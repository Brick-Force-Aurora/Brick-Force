{
  "folderName": "_Emulator",
  "folderPath": ".autodoc\\docs\\json\\Assembly-CSharp\\_Emulator",
  "url": "https://github.com/TieHaxJan/Brick-Force/.autodoc\\docs\\json\\Assembly-CSharp\\_Emulator",
  "files": [
    {
      "fileName": "Config.cs",
      "filePath": "Assembly-CSharp\\_Emulator\\Config.cs",
      "url": "https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\_Emulator\\Config.cs",
      "summary": "The code provided is a part of the Brick-Force project and is located in the `_Emulator` namespace. It defines a class called `Config` that is responsible for managing and loading/saving configuration settings for the project.\n\nThe `Config` class has several public properties that represent different configuration settings. These settings include the color of the crosshair, the hue of the crosshair color, whether to use USK textures, the axis ratio for camera movement, whether to allow only one client per IP, whether to block connections, whether to automatically clear dead clients, and the maximum number of connections.\n\nThe class also has a constructor that calls the `LoadConfigFromDisk` method to load the configuration settings from a CSV file located at the specified path. The `LoadConfigFromDisk` method uses a `CSVLoader` object to load the CSV file and then retrieves the values for each configuration setting from the loaded CSV data. It also applies some additional transformations to the loaded values, such as converting the crosshair color from RGB to HSV and calculating the crosshair hue.\n\nThe `Config` class also has a `SaveConfigToDisk` method that saves the current configuration settings to a CSV file located at the specified path. It uses the `CSVLoader` object to set the values for each configuration setting in the CSV data and then saves the CSV data to the file.\n\nAdditionally, the `Config` class has three methods: `ApplyAxisRatio`, `ApplyUskTextures`, and `ApplyCrosshairHue`. These methods are responsible for applying the changes made to the configuration settings. For example, the `ApplyAxisRatio` method adjusts the camera's ySpeed based on the axis ratio, the `ApplyUskTextures` method updates various build options based on the `uskTextures` setting, and the `ApplyCrosshairHue` method updates the crosshair color based on the `crosshairHue` setting.\n\nOverall, the `Config` class provides a way to manage and persist configuration settings for the Brick-Force project. It allows the project to load and save these settings from a CSV file and apply the changes made to the settings in the appropriate places.",
      "questions": "1. What is the purpose of the `Config` class?\n- The `Config` class is responsible for loading and saving configuration settings from a CSV file.\n\n2. What are the default values for the configuration settings?\n- The default values for the configuration settings are as follows:\n  - `crosshairColor` is set to `Color.green`\n  - `crosshairHue` is set to `90f`\n  - `uskTextures` is set to `false`\n  - `axisRatio` is set to `2.25f`\n  - `oneClientPerIP` is set to `true`\n  - `blockConnections` is set to `false`\n  - `autoClearDeadClients` is set to `false`\n  - `maxConnections` is set to `16`\n\n3. What is the purpose of the `ApplyAxisRatio()`, `ApplyUskTextures()`, and `ApplyCrosshairHue()` methods?\n- The `ApplyAxisRatio()` method adjusts the camera's ySpeed based on the axisRatio value.\n- The `ApplyUskTextures()` method updates various build options based on the uskTextures value.\n- The `ApplyCrosshairHue()` method updates the crosshairColor based on the crosshairHue value."
    },
    {
      "fileName": "Core.cs",
      "filePath": "Assembly-CSharp\\_Emulator\\Core.cs",
      "url": "https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\_Emulator\\Core.cs",
      "summary": "The code provided is a part of the Brick-Force project and is located in the `Brick-Force` file. The purpose of this code is to initialize the core components of the project and set up the build configuration.\n\nThe `Core` class is responsible for initializing the necessary components and setting up the build configuration. It has a public method called `Initialize()` which is called to start the initialization process. \n\nIn the `Initialize()` method, several components are instantiated and assigned to the `coreObject` GameObject. These components include `MainGUI`, `InventoryGUI`, `ConfigGUI`, `DebugConsole`, and `ServerEmulator`. These components are added as components to the `coreObject` using the `AddComponent<T>()` method. The `coreObject` is then marked as a DontDestroyOnLoad object using `UnityEngine.Object.DontDestroyOnLoad()` method, ensuring that it persists across scene changes.\n\nThe `Config` instance is created and assigned to the `Config.instance` variable. The `Config` class is not shown in the provided code, but it is likely responsible for storing and managing configuration settings for the project.\n\nThe `SetupBuildConfig()` method is a private method that sets up the build configuration. It sets `Application.runInBackground` to true, allowing the application to continue running even when it loses focus. It also sets `BuildOption.Instance.Props.UseP2pHolePunching` and `BuildOption.Instance.Props.isDuplicateExcuteAble` to true, which are likely specific build options for the project.\n\nOverall, this code initializes the core components of the Brick-Force project and sets up the build configuration. It ensures that the necessary components are instantiated and assigned to the `coreObject`, and it sets specific build options for the project. This code is likely called at the start of the project to set up the initial state and configuration.",
      "questions": "1. What is the purpose of the `Initialize()` method?\n- The `Initialize()` method is responsible for setting up various components and configurations for the Core object.\n\n2. What is the significance of the `coreObject` variable?\n- The `coreObject` variable is an instance of the GameObject class and is used to attach various components to it.\n\n3. What does the `SetupBuildConfig()` method do?\n- The `SetupBuildConfig()` method sets certain build options for the application, such as running in the background and enabling P2P hole punching."
    }
  ],
  "folders": [
    {
      "folderName": "GUI",
      "folderPath": ".autodoc\\docs\\json\\Assembly-CSharp\\_Emulator\\GUI",
      "url": "https://github.com/TieHaxJan/Brick-Force/.autodoc\\docs\\json\\Assembly-CSharp\\_Emulator\\GUI",
      "files": [
        {
          "fileName": "ConfigGUI.cs",
          "filePath": "Assembly-CSharp\\_Emulator\\GUI\\ConfigGUI.cs",
          "url": "https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\_Emulator\\GUI\\ConfigGUI.cs",
          "summary": "The code provided is a part of the Brick-Force project and is located in the `ConfigGUI` class. This class is responsible for creating and managing a graphical user interface (GUI) window that allows the user to configure various settings for the game.\n\nThe `ConfigGUI` class extends the `MonoBehaviour` class from the Unity engine, which means it can be attached to a game object in the scene and respond to events such as `Update` and `OnGUI`.\n\nThe `ConfigGUI` class has a few member variables. The `configGUIRect` variable is a `Rect` object that defines the position and size of the GUI window. The `hidden` variable is a boolean flag that determines whether the GUI window should be hidden or shown.\n\nThe `Update` method is called every frame and checks if the F7 key is pressed. If it is, the `hidden` flag is toggled, which hides or shows the GUI window accordingly. \n\nThe `OnGUI` method is called whenever the GUI needs to be rendered. If the `hidden` flag is false, the `GUILayout.Window` method is called to create a GUI window with the title \"Config\" and the ID 104. The `ConfigGUIWindow` method is then called to draw the contents of the GUI window.\n\nThe `ConfigGUIWindow` method contains various GUI elements such as buttons, labels, sliders, and toggle switches. These elements allow the user to save and load configurations, adjust the axis ratio and crosshair hue, and toggle various settings related to client connections and debugging.\n\nFor example, the code `Config.instance.axisRatio = GUILayout.HorizontalSlider(Config.instance.axisRatio, 1f, 2.25f);` creates a horizontal slider that allows the user to adjust the `axisRatio` property of the `Config` class. The current value of `axisRatio` is displayed as a label next to the slider.\n\nOverall, the `ConfigGUI` class provides a user-friendly way for players to customize their game settings. It is an important component of the larger Brick-Force project as it allows players to tailor their gameplay experience to their preferences.",
          "questions": "1. What is the purpose of the `ConfigGUI` class?\n- The `ConfigGUI` class is responsible for handling the GUI window for configuring various settings.\n\n2. What does the `Update` method do?\n- The `Update` method checks if the F7 key is pressed and toggles the `hidden` variable accordingly. It also applies the axis ratio and crosshair hue settings from the `Config` instance.\n\n3. What happens when the \"Save\" button is clicked in the GUI window?\n- When the \"Save\" button is clicked, the `SaveConfigToDisk` method of the `Config` instance is called to save the configuration to disk."
        },
        {
          "fileName": "DebugConsole.cs",
          "filePath": "Assembly-CSharp\\_Emulator\\GUI\\DebugConsole.cs",
          "url": "https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\_Emulator\\GUI\\DebugConsole.cs",
          "summary": "The code provided is for a DebugConsole class in the Brick-Force project. This class is responsible for displaying debug logs and messages in a console window within the game. \n\nThe DebugConsole class is a MonoBehaviour, meaning it can be attached to a GameObject in the Unity scene and will be updated and rendered automatically. It contains several variables and methods that control the behavior and appearance of the console.\n\nThe class defines a struct called Log, which represents a single log message. Each log message has a message string, a stackTrace string, and a LogType enum value. The LogType enum represents the type of log message, such as Log, Warning, Error, etc.\n\nThe class also defines a list of Log objects called logs, which stores all the log messages that have been received. There is a scrollPosition variable that keeps track of the current scroll position of the console window, and hidden and collapse variables that control the visibility and behavior of the console.\n\nThe OnEnable and OnDisable methods are Unity lifecycle methods that register and unregister a log callback function using the Application class. This callback function, HandleLog, is called whenever a new log message is received. The HandleLog function creates a new Log object with the message, stackTrace, and type parameters, and adds it to the logs list.\n\nThe Update method checks for user input to toggle the visibility of the console and to scroll through the log messages.\n\nThe OnGUI method is another Unity lifecycle method that is responsible for rendering the console window. If the console is not hidden, it uses the GUILayout.Window function to create a window with a unique ID and a title of \"Console\". Inside the window, it uses GUILayout.BeginScrollView and GUILayout.EndScrollView to create a scrollable area for the log messages. It then iterates over the logs list and displays each log message using GUILayout.Label. If the collapse variable is true, it skips displaying log messages that are the same as the previous one, to avoid repetition. Finally, it renders buttons for clearing the logs and toggling the collapse behavior.\n\nOverall, this DebugConsole class provides a way to display and manage debug logs and messages in a console window within the game. It can be used during development and testing to track and troubleshoot issues.",
          "questions": "1. What is the purpose of the `DebugConsole` class?\n- The `DebugConsole` class is responsible for displaying logs and stack traces in a console window in the Unity game engine.\n\n2. What is the significance of the `toggleKey` variable?\n- The `toggleKey` variable determines the key that can be pressed to show or hide the console window.\n\n3. How are log messages and stack traces stored and displayed in the console window?\n- Log messages and stack traces are stored in a list of `Log` structs and are displayed using the `GUILayout.Label` method."
        },
        {
          "fileName": "InventoryGUI.cs",
          "filePath": "Assembly-CSharp\\_Emulator\\GUI\\InventoryGUI.cs",
          "url": "https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\_Emulator\\GUI\\InventoryGUI.cs",
          "summary": "The code provided is a part of the Brick-Force project and is located in the `InventoryGUI` class. This class is responsible for displaying and managing the inventory GUI (Graphical User Interface) in the game.\n\nThe `InventoryGUI` class extends the `MonoBehaviour` class from the Unity engine, which allows it to interact with the game objects and events. It contains several private variables, such as `hidden`, `ranGUI`, `sortedItems`, and various `Rect` objects, which define the positions and sizes of GUI elements.\n\nThe `FitToScreen` method is responsible for adjusting the size of the GUI elements based on the screen size. It is called whenever the screen size changes.\n\nThe `Update` method checks if the F5 key is pressed and toggles the `hidden` variable accordingly. This allows the player to show or hide the inventory GUI by pressing the F5 key.\n\nThe `OnGUI` method is called every frame to draw the inventory GUI. It first checks if the inventory is available and the client is connected. If so, it proceeds to draw the GUI elements, such as windows, buttons, and text fields, using the Unity GUI functions.\n\nThe `IconGUIWindow` method is responsible for drawing the icons of the items in the inventory. It uses a scroll view to display a list of icons, which can be sorted and filtered based on the `sortText` variable. The icons can be clicked to add the corresponding item to the inventory.\n\nThe `InventoryGUIWindow` method is responsible for drawing the items in the inventory. It uses a scroll view to display a grid of item icons. The icons can be clicked to equip or unequip the corresponding item.\n\nOverall, this code provides the functionality to display and interact with the inventory GUI in the game. It allows the player to view, sort, and manage their inventory items. The code also includes methods to update, save, and load the inventory data.",
          "questions": "1. What is the purpose of the `FitToScreen()` method and when is it called?\n- The `FitToScreen()` method adjusts the size and position of GUI windows to fit the screen. It is called in the `OnGUI()` method.\n2. What is the significance of the `hidden` variable and how is it used?\n- The `hidden` variable is a boolean that determines whether the GUI windows should be displayed or not. It is used in the `OnGUI()` method to conditionally skip rendering the GUI if it is set to true.\n3. What is the purpose of the `ranGUI` variable and how is it used?\n- The `ranGUI` variable is a boolean that tracks whether the GUI has been rendered at least once. It is used in the `OnGUI()` method to ensure that certain operations are only performed once, such as sorting the items dictionary."
        },
        {
          "fileName": "MainGUI.cs",
          "filePath": "Assembly-CSharp\\_Emulator\\GUI\\MainGUI.cs",
          "url": "https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\_Emulator\\GUI\\MainGUI.cs",
          "summary": "The code provided is a part of the Brick-Force project and is located in the MainGUI.cs file. This code is responsible for managing the graphical user interface (GUI) of the game. It allows the player to interact with various setup and host options.\n\nThe MainGUI class is a MonoBehaviour class, which means it can be attached to a GameObject in the Unity game engine. It contains several public and private variables that control the visibility and position of GUI windows, as well as a custom message string.\n\nThe Update() method is called every frame and checks for specific key presses. If the F6 key is pressed, it toggles the visibility of the setup GUI window. If the F4 key is pressed, it toggles the visibility of the host GUI window. Additionally, the method calls the HandleReliableKillLog() method of the ClientExtension class.\n\nThe OnGUI() method is also called every frame and is responsible for rendering the GUI elements on the screen. If the setup GUI window is not hidden, it calls the GUILayout.Window() method to create a window with the title \"Setup\" and the specified dimensions. Inside the window, it displays a label for the host IP and a text field for the user to enter the IP address. It also provides two buttons: \"Host\" and \"Join\". Clicking the \"Host\" button hides the host GUI window, sets up the server using the ServerEmulator class, and loads the server using the ClientExtension class. Clicking the \"Join\" button also hides the host GUI window and loads the server.\n\nIf the host GUI window is not hidden and the server has been created, the method creates a host GUI window using the GUILayout.Window() method. Inside the window, it provides several buttons for different actions such as \"Shutdown\", \"Reset\", \"Clear Buffers\", and \"Send Custom Message\". It also displays a label for the connected clients and creates a button for each client in the ServerEmulator's clientList. Clicking a client button sends a disconnect message to the server.\n\nOverall, this code provides a user interface for setting up and managing a server in the Brick-Force game. It allows the player to host or join a server, perform server-related actions, and interact with connected clients.",
          "questions": "1. What is the purpose of the `Update()` method?\n- The `Update()` method is used to handle input from the user and perform actions based on that input.\n\n2. What is the purpose of the `OnGUI()` method?\n- The `OnGUI()` method is responsible for rendering the graphical user interface (GUI) elements on the screen.\n\n3. What does the `SendDisconnect()` method do?\n- The `SendDisconnect()` method is used to send a disconnect message to a specific client in the `clientList` of the `ServerEmulator` instance."
        }
      ],
      "folders": [],
      "summary": "The `GUI` folder in the `Assembly-CSharp\\_Emulator` directory of the Brick-Force project contains four C# files: `ConfigGUI.cs`, `DebugConsole.cs`, `InventoryGUI.cs`, and `MainGUI.cs`. Each file is responsible for a specific aspect of the game's graphical user interface (GUI).\n\n`ConfigGUI.cs` manages a GUI window for configuring game settings. It extends Unity's `MonoBehaviour` class, allowing it to be attached to a game object and respond to events. The class has methods for updating the GUI and rendering it, as well as a method for drawing the contents of the GUI window. For example, it uses `GUILayout.HorizontalSlider` to create a slider for adjusting the `axisRatio` property of the `Config` class.\n\n`DebugConsole.cs` displays debug logs and messages in a console window within the game. It also extends `MonoBehaviour` and defines a `Log` struct for log messages. The class registers a log callback function that is called whenever a new log message is received. The `OnGUI` method renders the console window and displays each log message.\n\n`InventoryGUI.cs` displays and manages the inventory GUI in the game. It adjusts the size of the GUI elements based on the screen size and allows the player to show or hide the inventory GUI. The class has methods for drawing the icons of the items in the inventory and the items themselves. It also includes methods for updating, saving, and loading the inventory data.\n\n`MainGUI.cs` manages the main GUI of the game, allowing the player to interact with various setup and host options. It checks for specific key presses to toggle the visibility of the setup and host GUI windows. The class creates a window for entering the host IP and provides buttons for hosting or joining a server. It also creates a host GUI window with buttons for different server-related actions.\n\nThese classes work together to provide a comprehensive and user-friendly interface for the Brick-Force game. They allow the player to configure settings, view debug logs, manage their inventory, and set up and manage a server.",
      "questions": ""
    },
    {
      "folderName": "Maps",
      "folderPath": ".autodoc\\docs\\json\\Assembly-CSharp\\_Emulator\\Maps",
      "url": "https://github.com/TieHaxJan/Brick-Force/.autodoc\\docs\\json\\Assembly-CSharp\\_Emulator\\Maps",
      "files": [
        {
          "fileName": "MapGenerator.cs",
          "filePath": "Assembly-CSharp\\_Emulator\\Maps\\MapGenerator.cs",
          "url": "https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\_Emulator\\Maps\\MapGenerator.cs",
          "summary": "The code provided is a part of the Brick-Force project and specifically focuses on the MapGenerator class. The purpose of this code is to generate maps for the game. \n\nThe MapGenerator class contains a nested class called Landscape, which represents a specific type of landscape for the map. Each Landscape object has properties such as bricks (an array of bytes representing different types of bricks), ratios (an array of floats representing the distribution of each brick type), size (the size of the map), and height (the height of the map). \n\nThe constructor of the Landscape class initializes the properties and also calculates the distribution array. The distribution array is used to determine the probability of selecting each brick type when generating the map. \n\nThe MapGenerator class itself is a singleton, meaning there can only be one instance of it. It has a private instance variable called landscapeTemplates, which is a dictionary that maps an integer key to a Landscape object. The keys represent different landscape templates that can be used to generate maps. The constructor of the MapGenerator class initializes the landscapeTemplates dictionary with predefined landscape templates.\n\nThe MapGenerator class also has a method called GetHashIdForTime, which takes a DateTime object as input and returns a unique hash ID based on the time. This method is used to generate a unique ID for each map based on the current time. The generated ID is then checked against existing map IDs to ensure uniqueness.\n\nThe MapGenerator class has a private method called GetNextTemplateByDistribution, which takes a Landscape object as input and returns the next brick type based on the distribution array of the landscape. This method is used to randomly select a brick type based on its probability of occurrence.\n\nThe GenerateInternal method is used to generate a map based on a given landscape and skybox index. It creates a UserMap object, sets its properties such as skybox index, map size, and center coordinates, and then iterates over each position in the map to add bricks using the AddBrickInst method. The AddBrickInst method takes parameters such as the brick type, position, and morphs (a list of integers representing additional properties of the brick).\n\nFinally, the Generate method is a public method that takes a landscape index and skybox index as input and returns a generated map based on the specified landscape and skybox. This method is the main entry point for generating maps in the Brick-Force project.\n\nOverall, the code provided is responsible for generating maps in the Brick-Force game based on predefined landscape templates and skybox indices. It uses various properties and methods to calculate the distribution of brick types and randomly select them when generating the map.",
          "questions": "1. What is the purpose of the Landscape class?\n- The Landscape class represents a specific configuration of bricks and their distribution in a map. It stores information about the bricks, ratios, size, and height of the landscape.\n\n2. What is the purpose of the MapGenerator instance variable?\n- The MapGenerator instance variable is used to create a single instance of the MapGenerator class. It allows access to the Generate and GetHashIdForTime methods.\n\n3. How does the GenerateInternal method generate a UserMap?\n- The GenerateInternal method generates a UserMap by iterating over the size and height of the landscape and calling the GetNextTemplateByDistribution method to determine the brick template for each position. It then adds the brick instance to the UserMap."
        }
      ],
      "folders": [],
      "summary": "The `MapGenerator.cs` file is a crucial component of the Brick-Force project, responsible for generating game maps. It contains the `MapGenerator` class, which is a singleton, ensuring only one instance of it exists. This class maintains a dictionary of landscape templates, with each template represented by a `Landscape` object. \n\nThe `Landscape` class encapsulates properties such as bricks, ratios, size, and height. The bricks are an array of bytes representing different types of bricks, and ratios are an array of floats representing the distribution of each brick type. The `Landscape` constructor initializes these properties and calculates the distribution array, which determines the probability of selecting each brick type when generating the map.\n\nThe `MapGenerator` class has a method `GetHashIdForTime(DateTime time)`, which generates a unique hash ID based on the current time. This ID is used to ensure the uniqueness of each generated map. \n\nThe class also contains a private method `GetNextTemplateByDistribution(Landscape landscape)`, which selects the next brick type based on the distribution array of the landscape. \n\nThe `GenerateInternal` method generates a map based on a given landscape and skybox index. It creates a `UserMap` object, sets its properties, and iterates over each position in the map to add bricks using the `AddBrickInst` method. \n\nThe `Generate` method is the main entry point for generating maps. It takes a landscape index and skybox index as input and returns a generated map based on the specified landscape and skybox. \n\nHere's an example of how the `Generate` method might be used:\n\n```csharp\nMapGenerator mapGenerator = MapGenerator.Instance;\nUserMap generatedMap = mapGenerator.Generate(landscapeIndex, skyboxIndex);\n```\n\nIn the larger project, this class interacts with other parts of the game that require map generation, such as game initialization or level changes. The generated maps are unique and based on predefined landscape templates and skybox indices, providing a diverse gaming experience.",
      "questions": ""
    }
  ],
  "summary": "The `Assembly-CSharp\\_Emulator` directory of the Brick-Force project contains key components for the game's configuration, core initialization, graphical user interface (GUI), and map generation.\n\nThe `Config.cs` file defines the `Config` class, which manages and persists configuration settings for the project. It loads and saves these settings from a CSV file and applies changes to the settings in the appropriate places. For instance, it adjusts the camera's ySpeed based on the axis ratio, updates build options based on the `uskTextures` setting, and updates the crosshair color based on the `crosshairHue` setting.\n\nThe `Core.cs` file initializes the core components of the project and sets up the build configuration. It instantiates and assigns necessary components to the `coreObject` GameObject, including `MainGUI`, `InventoryGUI`, `ConfigGUI`, `DebugConsole`, and `ServerEmulator`. It also sets specific build options for the project.\n\nThe `GUI` subfolder contains four files responsible for different aspects of the game's GUI. `ConfigGUI.cs` manages a GUI window for configuring game settings, `DebugConsole.cs` displays debug logs and messages in a console window, `InventoryGUI.cs` displays and manages the inventory GUI, and `MainGUI.cs` manages the main GUI, allowing the player to interact with various setup and host options.\n\nThe `Maps` subfolder contains the `MapGenerator.cs` file, which generates game maps. It maintains a dictionary of landscape templates and generates a map based on a given landscape and skybox index. The generated maps are unique and based on predefined landscape templates and skybox indices, providing a diverse gaming experience.\n\nHere's an example of how the `Generate` method might be used:\n\n```csharp\nMapGenerator mapGenerator = MapGenerator.Instance;\nUserMap generatedMap = mapGenerator.Generate(landscapeIndex, skyboxIndex);\n```\n\nIn the larger project, these components interact with each other and other parts of the game to provide a comprehensive and user-friendly interface, manage game settings, and generate diverse game maps.",
  "questions": ""
}