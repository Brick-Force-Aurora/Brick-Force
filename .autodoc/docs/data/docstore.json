[["0",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Accessory.cs)\n\nThe code provided is a class called \"Accessory\" that extends another class called \"Equip\". This class is a part of the larger Brick-Force project and is used to represent different types of accessories that can be equipped by characters in the game.\n\nThe \"Accessory\" class has a nested enum called \"CATEGORY\" which defines different categories of accessories that can be equipped. The categories include \"HELMET\", \"MASK\", \"BAG\", \"BOTTLE\", and \"ETC\". These categories are used to classify and organize the different types of accessories available in the game.\n\nThe \"cat\" variable is of type \"CATEGORY\" and is used to store the category of the accessory. This variable allows the game to determine the category of the accessory and perform specific actions or apply specific rules based on the category.\n\nFor example, if a character equips an accessory with the category \"HELMET\", the game may apply certain bonuses or effects related to head protection. On the other hand, if the accessory has the category \"BAG\", the game may allow the character to carry additional items or have increased inventory space.\n\nHere is an example of how this code may be used in the larger Brick-Force project:\n\n```csharp\nAccessory helmet = new Accessory();\nhelmet.cat = Accessory.CATEGORY.HELMET;\n\nAccessory bag = new Accessory();\nbag.cat = Accessory.CATEGORY.BAG;\n\n// Perform actions based on the category of the accessory\nif (helmet.cat == Accessory.CATEGORY.HELMET)\n{\n    // Apply head protection bonuses\n    // ...\n}\n\nif (bag.cat == Accessory.CATEGORY.BAG)\n{\n    // Increase inventory space\n    // ...\n}\n```\n\nIn summary, the \"Accessory\" class is used to represent different types of accessories in the Brick-Force game. The nested \"CATEGORY\" enum allows for categorizing and organizing the accessories, while the \"cat\" variable stores the category of a specific accessory instance. This code is essential for managing and applying specific rules or actions based on the category of the accessory.\n## Questions: \n 1. **What is the purpose of the `Accessory` class?**\nThe `Accessory` class is a subclass of the `Equip` class, but it is not clear what specific functionality or behavior it adds or modifies.\n\n2. **What is the purpose of the `CATEGORY` enum?**\nThe `CATEGORY` enum is used to define different categories of accessories, such as helmets, masks, bags, bottles, etc. It is unclear how this enum is used within the `Accessory` class or the wider project.\n\n3. **What is the significance of the `cat` variable?**\nThe `cat` variable is of the `CATEGORY` enum type, but it is not clear how or where it is used within the `Accessory` class or the wider project.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Accessory.md"}}],["1",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Accuracy.cs)\n\nThe code provided is a class called \"Accuracy\" that is used to handle accuracy calculations for a game. It contains various properties and methods to control and manipulate accuracy values.\n\nThe class has several public properties that represent different aspects of accuracy, such as accurateMin, accurateMax, inaccurateMin, inaccurateMax, accurateSpread, accurateCenter, inaccurateSpread, inaccurateCenter, and moveInaccuracyFactor. These properties are used to define the range and spread of accuracy values.\n\nThe class also has private fields for inaccurate and accurate, which are used to store the current inaccurate and accurate values.\n\nThe class has a public method called \"Init()\" that initializes the accurate and inaccurate values to their minimum values.\n\nThere are two public methods called \"MakeInaccurate()\" and \"MakeAccurate()\" that are used to adjust the accurate and inaccurate values based on certain conditions. \"MakeInaccurate()\" takes a boolean parameter called \"aimAccurateMore\" and increases the accurate and inaccurate values by their respective spreads. If \"aimAccurateMore\" is true, it adjusts the maximum values of accurate and inaccurate based on their minimum values. \"MakeAccurate()\" takes a boolean parameter called \"aimAccurate\" and decreases the accurate and inaccurate values based on their respective centers. If \"aimAccurate\" is false, it multiplies the minimum values of accurate and inaccurate by the moveInaccuracyFactor.\n\nThe class also has a public method called \"CalcDeflection()\" that calculates a deflection vector based on the accuracy values. It generates random values for f and f2, and a random value for num between 0 and 100. If num is less than the accuracy value, it generates random values for num2 and num3 between 0 and accurate/2. Otherwise, it generates random values for num2 and num3 between accurate/2 and inaccurate/2. It then multiplies num2 and num3 by the sign of f and f2 respectively. Finally, it calculates a factor based on the screen width, height, and camera field of view, and returns a Vector2 representing the deflection.\n\nOverall, this class is used to handle accuracy calculations for a game, allowing for adjustments to accuracy values and generating deflection vectors based on those values. It can be used in the larger project to determine the accuracy of player actions and calculate the resulting effects.\n## Questions: \n 1. What is the purpose of the `Accuracy` class?\n- The `Accuracy` class represents a set of properties and methods related to accuracy calculations in a game. \n\n2. What does the `Init()` method do?\n- The `Init()` method initializes the `accurate` and `inaccurate` variables to their respective minimum values.\n\n3. What does the `CalcDeflection()` method return?\n- The `CalcDeflection()` method returns a `Vector2` representing the calculated deflection based on random values and the accuracy settings.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Accuracy.md"}}],["2",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\AccusationDialog.cs)\n\nThe code provided is a class called \"AccusationDialog\" that extends another class called \"Dialog\". This class represents a dialog box that allows the user to make an accusation. \n\nThe class has several public variables that represent different UI elements such as image lists, label lists, text areas, and buttons. These variables are used to reference the corresponding UI elements in the Unity game engine.\n\nThe class overrides two methods from the base \"Dialog\" class: \"Start()\" and \"OnPopup()\". The \"Start()\" method sets the ID of the dialog and initializes some UI elements. The \"OnPopup()\" method calculates the position of the dialog box on the screen.\n\nThe class also has two overloaded versions of the \"InitDialog()\" method. The first version is called without any arguments and resets the UI elements to their default state. The second version is called with an array of strings representing user names and sets the user name combo box to display these names.\n\nThe most important method in this class is the \"DoDialog()\" method. This method is called to display and handle the user interaction with the dialog box. It first sets up the GUI skin and checks if the combo boxes for user names and reasons have been clicked. If they have been clicked, the GUI is disabled to prevent further interaction with the combo boxes. Then, it draws the UI elements such as image lists, label lists, text areas, buttons, and combo boxes. \n\nIf the \"OK\" button is clicked, the method checks if the user has entered a valid user name, a valid reason, and some text in the text area. If all these conditions are met, it sends an accusation request to the server using the entered information. If any of the conditions are not met, it displays an appropriate error message using a message box.\n\nIf the \"Exit\" button is clicked, the method returns true, indicating that the dialog should be closed.\n\nThe class also has three private helper methods: \"IsRightReason()\", \"IsRightName()\", and \"GetUserName()\". These methods are used to validate the user's input and retrieve the selected user name.\n\nOverall, this class represents a dialog box for making accusations in the game. It handles the user interaction, validates the input, and sends the accusation request to the server. It is likely used in the larger project to provide a way for players to report other players for misconduct or rule violations.\n## Questions: \n 1. What is the purpose of the `AccusationDialog` class?\n- The `AccusationDialog` class is a subclass of `Dialog` and represents a dialog box for accusing a player in the game.\n\n2. What are the functions `InitDialog()` and `InitDialog(string[] users)` used for?\n- The `InitDialog()` function resets the dialog box to its initial state with empty values, while `InitDialog(string[] users)` initializes the dialog box with a list of user names.\n\n3. What is the purpose of the `DoDialog()` function?\n- The `DoDialog()` function handles the logic for displaying and interacting with the dialog box, including checking for valid input and sending an accusation request to the server.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\AccusationDialog.md"}}],["3",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\AccusationMapDialog.cs)\n\nThe code provided is a class called \"AccusationMapDialog\" that extends the \"Dialog\" class. This class is used to create a dialog box for accusing a map in the larger Brick-Force project. \n\nThe class contains several public variables that are used to reference UI elements such as image lists, label lists, a map, a map name, a text area, and two buttons. These variables are assigned values in the \"InitDialog\" method, which is called when the dialog is initialized. \n\nThe \"Start\" method sets the ID of the dialog to a specific value from the \"DialogManager\" class. The \"OnPopup\" method sets the position and size of the dialog box based on the screen size. \n\nThe \"DoDialog\" method is the main method that is called to display and handle user interactions with the dialog box. It first sets the GUI skin and enables/disables GUI elements based on certain conditions. Then, it calls the \"Draw\" method on each UI element to display them on the screen. \n\nIf the \"ok\" button is clicked, the method checks if the selected reason from the combo box is valid and if the text input in the text area is not empty. If both conditions are met, it sends a request to the server to accuse the map with the selected reason and the input text. Otherwise, it displays an error message. \n\nIf the \"exit\" button is clicked, the method returns true, indicating that the dialog should be closed. \n\nThe \"IsRightReason\" method is a private helper method that checks if a valid reason is selected from the combo box. \n\nOverall, this code creates a dialog box for accusing a map in the Brick-Force project. It handles user interactions and sends requests to the server when necessary.\n## Questions: \n 1. What is the purpose of the `AccusationMapDialog` class?\n- The `AccusationMapDialog` class is a subclass of `Dialog` and represents a dialog box for accusing a map. \n\n2. What does the `InitDialog` method do?\n- The `InitDialog` method initializes the dialog by setting the `RegMap`, `mapName`, `reasonCombo`, and `textDetail` properties to their initial values.\n\n3. What does the `DoDialog` method do?\n- The `DoDialog` method handles the logic for drawing and interacting with the dialog box. It checks if the user has selected a valid reason and if the input text is not empty, and then sends an accusation request to the server.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\AccusationMapDialog.md"}}],["4",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ActiveItemBase.cs)\n\nThe code provided is a class called `ActiveItemBase` that inherits from the `MonoBehaviour` class in the Unity game engine. This class is likely a base class for other active items in the Brick-Force project.\n\nThe `ActiveItemBase` class has a protected integer variable called `useUserSeq`, which is used to store the sequence number of the user who is using the item. The class also has three methods: `UseItem`, `StartItem`, and `IsMyItem`.\n\nThe `UseItem` method takes an integer parameter called `seq`, which represents the sequence number of the user who is using the item. This method sets the `useUserSeq` variable to the value of `seq` and then calls the `StartItem` method.\n\nThe `StartItem` method is a virtual method, which means it can be overridden by derived classes. This method does not have any implementation in the `ActiveItemBase` class, so it can be customized in derived classes to define the specific behavior of the item when it is used.\n\nThe `IsMyItem` method returns a boolean value indicating whether the item belongs to the current user. It does this by comparing the `useUserSeq` variable with the sequence number of the current user obtained from the `MyInfoManager.Instance.Seq` property.\n\nOverall, this code provides a base class for active items in the Brick-Force project. It allows derived classes to define their own behavior when the item is used, and provides a method to check if the item belongs to the current user. This class can be used as a blueprint for creating different types of active items in the game, each with their own unique functionality. For example, a derived class could override the `StartItem` method to implement a weapon that shoots projectiles, or a power-up that increases the player's speed.\n## Questions: \n 1. What is the purpose of the `useUserSeq` variable and how is it used in the code?\n- The `useUserSeq` variable is used to store the sequence number of the user who is using the item. It is used in the `IsMyItem()` method to check if the item belongs to the current user.\n\n2. What is the purpose of the `StartItem()` method and how is it used?\n- The `StartItem()` method is a virtual method that can be overridden by derived classes. It is called after the `UseItem()` method and can be used to perform specific actions or behaviors related to the item.\n\n3. What is the purpose of the `IsMyItem()` method and what does it return?\n- The `IsMyItem()` method is used to check if the item belongs to the current user. It returns a boolean value indicating whether the item belongs to the current user or not.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ActiveItemBase.md"}}],["5",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ActiveItemData.cs)\n\nThe code provided defines a class called `ActiveItemData` that represents data for an active item in the Brick-Force project. This class is marked as `[Serializable]`, which means its instances can be converted to a serialized format (e.g., JSON or XML) for storage or transmission.\n\nThe `ActiveItemData` class has several properties and methods:\n\n- `itemType` is an integer that represents the type of the active item.\n- `icon` is a `Texture2D` object that represents the icon image for the active item.\n- `chance` is an integer that represents the chance of obtaining the active item.\n- `itemPrefap` is a `GameObject` that represents the 3D model or prefab of the active item.\n- `itemText` is a string that represents the text description of the active item.\n- `cooltime` is a float that represents the cooldown time for using the active item. A value of -1f indicates that the active item does not have a cooldown.\n\nThe class also has two methods:\n- `GetItemType()` returns the `itemType` value.\n- `SetItemType(int type)` sets the `itemType` value to the specified `type`.\n\nThis `ActiveItemData` class is likely used in the larger Brick-Force project to store and manage data for different active items. It provides a structured way to define and access properties of an active item, such as its type, icon, chance, and cooldown time. Other parts of the project can create instances of `ActiveItemData` and populate its properties with specific values for each active item.\n\nHere's an example of how this class could be used in the project:\n\n```csharp\nActiveItemData activeItem = new ActiveItemData();\nactiveItem.SetItemType(1);\nactiveItem.icon = Resources.Load<Texture2D>(\"item_icon\");\nactiveItem.chance = 5;\nactiveItem.itemPrefap = Resources.Load<GameObject>(\"item_prefab\");\nactiveItem.itemText = \"This is an example active item\";\nactiveItem.cooltime = 10f;\n\n// Accessing the properties\nint itemType = activeItem.GetItemType();\nTexture2D icon = activeItem.icon;\nint chance = activeItem.chance;\nGameObject itemPrefab = activeItem.itemPrefap;\nstring itemText = activeItem.itemText;\nfloat cooltime = activeItem.cooltime;\n```\n\nIn this example, an instance of `ActiveItemData` is created and its properties are set with specific values. The properties can then be accessed and used in other parts of the project as needed.\n## Questions: \n 1. **What is the purpose of the `Serializable` attribute on the `ActiveItemData` class?**\nThe `Serializable` attribute is used to indicate that the `ActiveItemData` class can be serialized, meaning its data can be converted into a format that can be stored or transmitted.\n\n2. **What does the `GetItemType` method do?**\nThe `GetItemType` method returns the value of the `itemType` field, which represents the type of the active item.\n\n3. **What is the purpose of the `SetItemType` method?**\nThe `SetItemType` method is used to set the value of the `itemType` field, allowing the developer to change the type of the active item.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ActiveItemData.md"}}],["6",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ActiveItemManager.cs)\n\nThe code provided is a part of the Brick-Force project and is contained in the file \"ActiveItemManager.cs\". This code is responsible for managing active items in the game. Active items are objects that can be collected and used by players to gain certain advantages or abilities.\n\nThe `ActiveItemManager` class is a MonoBehaviour that handles the creation, deletion, and usage of active items. It also manages the visual effects associated with active items.\n\nThe class has several public and private variables that store information about the active items. These variables include the GUI depth, the active item object, audio clips, effects, and various time-related variables.\n\nThe class also has a static instance property `Instance` that allows other classes to access the ActiveItemManager instance. This is implemented as a singleton pattern, ensuring that only one instance of the ActiveItemManager exists.\n\nThe `Awake()` method initializes some variables and sets up the itemIconEffect, which is responsible for displaying the active item icon on the screen.\n\nThe `Start()` method initializes the dicActiveItem dictionary, which stores the active items in the game.\n\nThe `Update()` method is called every frame and checks if a new active item needs to be created. If the maximum number of active items has not been reached, the method creates a new active item at a random position.\n\nThe `CreateActiveItem()` method creates a new active item at a random position and sends a network message to notify other players about the creation of the item.\n\nThe `IsValidPosition()` method checks if a given position is valid for placing an active item. It iterates through the dicActiveItem dictionary and checks the distance between the given position and the positions of existing active items. If the distance is less than a threshold value, the position is considered invalid.\n\nThe `EatItem()` method is called when a player collects an active item. It checks if the active item exists in the dicActiveItem dictionary and then proceeds to delete the item. If the player collecting the item is the master player, it also sends a network message to notify other players about the deletion of the item.\n\nThe `DeleteItem()` method deletes an active item from the game. It plays a sound effect, creates an itemGetEffect visual effect, and removes the item from the dicActiveItem dictionary. If the player collecting the item is the local player, it adds the item to the player's inventory and displays a message.\n\nThe `UseItem()` method is called when a player uses an active item. It instantiates the item's prefab and calls the UseItem method on the ActiveItemBase component attached to the prefab.\n\nThe `GetChoiceItemType()` method randomly selects an active item type based on their chances. Each active item has a chance value, and the method calculates the total chance value and selects a random number within that range. It then iterates through the active items and returns the index of the item whose chance range includes the random number.\n\nThe `ItemGetIconEffect()` method sets the texture image of the itemIconEffect to the icon of the active item and resets the effect.\n\nThe `OnGUI()` method is responsible for drawing the itemIconEffect on the screen.\n\nThe `GetActiveItemDictionary()` method returns the dicActiveItem dictionary, allowing other classes to access the active items.\n\nOverall, this code provides the functionality to manage active items in the game, including their creation, deletion, and usage. It also handles the visual effects associated with active items.\n## Questions: \n 1. What is the purpose of the `ActiveItemManager` class?\n- The `ActiveItemManager` class manages active items in the game, including their creation, deletion, and usage.\n\n2. What is the significance of the `activeItems` array?\n- The `activeItems` array stores data about different types of active items that can be created in the game.\n\n3. What is the purpose of the `CreateActiveItem` method?\n- The `CreateActiveItem` method is responsible for creating a new active item in the game at a random position.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ActiveItemManager.md"}}],["7",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ActiveItemTrigger.cs)\n\nThe code provided is a script called \"ActiveItemTrigger\" that is used in the Brick-Force project. This script is attached to a game object in the Unity game engine and is responsible for triggering an action when another game object collides with it.\n\nThe script has a public integer variable called \"seq\" which is used to store a sequence number. This variable can be set in the Unity editor or through code to determine the specific action to be triggered.\n\nThe script contains a private method called \"OnTriggerEnter\" which is automatically called by Unity when another game object with a collider component enters the trigger area of the game object this script is attached to. The method takes a parameter of type \"Collider\" which represents the collider component of the other game object.\n\nInside the \"OnTriggerEnter\" method, there is a conditional statement that checks if the current scene is not the \"MapEditor\" scene. If this condition is true, the code proceeds to the next step.\n\nThe code then attempts to get the \"LocalController\" component from the other game object using the \"GetComponent\" method. If the \"LocalController\" component is found, the code calls a method called \"EatItem\" on the \"ActiveItemManager\" instance, passing in the \"seq\" value and the sequence number from the \"MyInfoManager\" instance.\n\nIn summary, this script is used to trigger an action when another game object collides with the game object this script is attached to. The specific action to be triggered is determined by the \"seq\" value, and the \"EatItem\" method is called on the \"ActiveItemManager\" instance to perform the action. This script is likely used in the larger Brick-Force project to handle interactions between game objects and manage the consumption of active items.\n## Questions: \n 1. **Question:** What is the purpose of the `seq` variable?\n   - **Answer:** The `seq` variable is used as a parameter in the `EatItem` method of the `ActiveItemManager` class.\n\n2. **Question:** What is the significance of the `OnTriggerEnter` method?\n   - **Answer:** The `OnTriggerEnter` method is a Unity callback that is triggered when a collider enters the trigger zone of the game object. \n\n3. **Question:** What is the purpose of the `Application.loadedLevelName.Contains(\"MapEditor\")` condition?\n   - **Answer:** The condition checks if the current loaded level name contains the string \"MapEditor\". If it does not, the code inside the condition block will be executed.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ActiveItemTrigger.md"}}],["8",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ActRotatorExample.cs)\n\nThe code provided is a script for a game object in the Brick-Force project that rotates the object continuously at a specified speed. \n\nThe script is written in C# and uses the Unity game engine. It is attached to a game object in the scene and is executed every frame in the Update() method.\n\nThe script has a public float variable called \"speed\" that determines the rotation speed of the object. The [Range(1f, 100f)] attribute limits the possible values of the speed variable between 1 and 100. This allows the developer to adjust the rotation speed within a specific range in the Unity editor.\n\nIn the Update() method, the base.transform.Rotate() function is called to rotate the game object. The function takes three arguments: the rotation angles around the x, y, and z axes. In this case, the speed variable is multiplied by Time.deltaTime to ensure smooth rotation regardless of the frame rate.\n\nHere is an example of how this script can be used in the larger Brick-Force project:\n\n1. Attach the ActRotatorExample script to a game object in the scene.\n2. Adjust the speed variable in the Unity editor to set the desired rotation speed.\n3. Run the game and observe the game object rotating continuously at the specified speed.\n\nThis script can be used to add dynamic movement and animation to various objects in the game, such as rotating platforms, spinning obstacles, or animated characters. By adjusting the speed variable, developers can control the rotation speed of these objects to create different gameplay mechanics or visual effects.\n\nOverall, this script provides a simple and reusable way to rotate game objects in the Brick-Force project, enhancing the visual appeal and interactivity of the game.\n## Questions: \n 1. **What does the `[Range(1f, 100f)]` attribute do?**\nThe `[Range(1f, 100f)]` attribute sets the range of valid values for the `speed` variable to be between 1 and 100.\n\n2. **What does the `Update()` method do?**\nThe `Update()` method is a built-in Unity method that is called every frame. In this code, it rotates the transform of the game object based on the `speed` variable.\n\n3. **What does `Time.deltaTime` represent?**\n`Time.deltaTime` represents the time in seconds it took to complete the last frame. It is used here to make the rotation smooth and frame rate independent.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ActRotatorExample.md"}}],["9",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ActTesterGUI.cs)\n\nThe code provided is a script called \"ActTesterGUI\" that is used for testing and demonstrating the functionality of various anti-cheat measures in the Brick-Force project. \n\nThe script is attached to a GameObject in the Unity game engine and is responsible for creating a graphical user interface (GUI) that allows the user to interact with different anti-cheat features. \n\nThe script contains several private variables, including \"savesAlterationDetected\", \"savesLock\", and \"foreignSavesDetected\", which are used to track the state of the anti-cheat measures. \n\nThe script also contains references to several other scripts, such as \"ObscuredVector3Test\", \"ObscuredFloatTest\", \"ObscuredIntTest\", \"ObscuredStringTest\", and \"ObscuredPrefsTest\". These scripts likely contain the actual anti-cheat logic and are used to test different types of data (e.g., vectors, floats, ints, strings) for cheating attempts. \n\nThe \"Awake\" method is called when the script is initialized and is responsible for setting up event handlers for detecting alterations and foreign saves. It also finds an instance of the \"DetectorsUsageExample\" script, which is used to detect speed hacks and injections. \n\nThe \"OnGUI\" method is called every frame and is responsible for rendering the GUI elements. It creates a horizontal layout group and two vertical layout groups. The first vertical group contains buttons and labels for testing the anti-cheat measures related to memory cheating protection, such as obscured strings, ints, floats, and vectors. The second vertical group contains buttons and labels for testing the anti-cheat measures related to saves cheating protection using ObscuredPrefs. \n\nThe \"CenteredLabel\" method is a helper method that creates a centered label in the GUI. \n\nOverall, this script provides a user interface for testing and demonstrating the functionality of various anti-cheat measures in the Brick-Force project. It allows the user to interact with different types of data and see the effects of cheating attempts.\n## Questions: \n 1. **What is the purpose of the ObscuredTypes namespace?**\nThe ObscuredTypes namespace is likely used to provide additional security measures for sensitive data types, such as Vector3, float, int, and string, to prevent cheating or unauthorized access.\n\n2. **What is the purpose of the DetectorsUsageExample class and how is it related to the ActTesterGUI class?**\nThe DetectorsUsageExample class is likely used to detect cheating or unauthorized actions in the game. It is related to the ActTesterGUI class because the ActTesterGUI class displays the results of the cheating detection performed by the DetectorsUsageExample class.\n\n3. **What is the purpose of the Awake() method and what does it do?**\nThe Awake() method is called when the script instance is being loaded. In this code, it assigns the SavesAlterationDetected and ForeignSavesDetected methods to the ObscuredPrefs.onAlterationDetected and ObscuredPrefs.onPossibleForeignSavesDetected events respectively. It also finds an instance of the DetectorsUsageExample class and assigns it to the detectorsUsageExample variable.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ActTesterGUI.md"}}],["10",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\AddBanDialog.cs)\n\nThe code provided is a class called \"AddBanDialog\" that extends the \"Dialog\" class. This class represents a dialog box that allows the user to add a ban to a system. \n\nThe class has several member variables that define the position and size of various UI elements within the dialog box. These variables include \"maxId\" which represents the maximum length of the ban ID, \"banWannabe\" which stores the user input for the ban ID, \"crdTitle\" which represents the position of the title text, \"crdMessage\" which represents the position of the message text, \"crdBanTxtFld\" which represents the position and size of the ban ID text field, and \"crdAddBan\" which represents the position and size of the add ban button.\n\nThe class overrides several methods from the base \"Dialog\" class. The \"Start\" method sets the ID of the dialog box to a specific value. The \"OnPopup\" method calculates the position of the dialog box based on the screen size. The \"DoDialog\" method is the main method that handles the rendering and interaction of the dialog box. \n\nIn the \"DoDialog\" method, the method first sets the GUI skin to a specific skin. It then renders the title text using the \"LabelUtil.TextOut\" method, passing in the position, text, font style, and color. It then renders the message text using the \"LabelUtil.TextOut\" method, passing in the position, text, font style, and color. \n\nNext, the method renders a text field for the ban ID using the \"GUI.TextField\" method, passing in the position and size of the text field. The method also checks if the length of the ban ID exceeds the maximum length and reverts the ban ID to its previous value if it does.\n\nThe method then renders an \"Add Ban\" button using the \"GlobalVars.Instance.MyButton\" method, passing in the position, text, and style of the button. If the button is clicked, the method trims the ban ID, checks if it is not empty, and sends a request to add the ban using the \"CSNetManager.Instance.Sock.SendCS_ADD_BAN_BY_NICKNAME_REQ\" method. If the ban ID is empty, it displays a message box with an error message.\n\nThe method also renders a close button and checks if it is clicked or if the escape key is pressed to close the dialog box. It then sets the focus to the ban ID text field and handles input events.\n\nThe \"InitDialog\" method is a helper method that resets the ban ID to an empty string.\n\nIn the larger project, this class would be used to display a dialog box for adding a ban to the system. The user would enter the ban ID in the text field and click the \"Add Ban\" button to add the ban. The class handles the rendering of the dialog box and the interaction with the user.\n## Questions: \n 1. What is the purpose of the `AddBanDialog` class?\n- The `AddBanDialog` class is a subclass of `Dialog` and represents a dialog box for adding a ban. \n\n2. What is the significance of the `maxId` variable?\n- The `maxId` variable represents the maximum length of the banWannabe string. If the length of the banWannabe string exceeds `maxId`, it will be trimmed.\n\n3. What is the purpose of the `DoDialog` method?\n- The `DoDialog` method is responsible for rendering and handling user interactions with the dialog box. It returns a boolean value indicating whether the dialog should be closed or not.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\AddBanDialog.md"}}],["11",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\AddFriendDialog.cs)\n\nThe code provided is a class called \"AddFriendDialog\" that extends the \"Dialog\" class. This class represents a dialog box that allows the user to add a friend in the game. \n\nThe class has several member variables:\n- \"maxId\" is an integer that represents the maximum length of the friend's ID.\n- \"friendWannabe\" is a string that stores the inputted friend's ID.\n- \"crdMessage\" is a Vector2 that represents the position of the message text.\n- \"crdFriendTxtFld\" is a Rect that represents the position and size of the friend's ID text field.\n- \"crdAddFriend\" is a Rect that represents the position and size of the \"Add Friend\" button.\n\nThe class overrides several methods from the base \"Dialog\" class:\n- \"Start\" method sets the ID of the dialog to \"ADD_FRIEND\" using the \"DialogManager.DIALOG_INDEX\" enum.\n- \"OnPopup\" method sets the position of the dialog box to the center of the screen.\n- \"DoDialog\" method is the main method that handles the rendering and functionality of the dialog box. It returns a boolean value indicating whether the dialog box should be closed or not. \n  - The method first sets the GUI skin to a custom skin obtained from \"GUISkinFinder.Instance.GetGUISkin()\".\n  - It then renders the title of the dialog box using the \"LabelUtil.TextOut\" method.\n  - It renders a message text using the \"LabelUtil.TextOut\" method.\n  - It renders a text field for the user to input the friend's ID using the \"GUI.TextField\" method.\n  - It checks if the \"Add Friend\" button is clicked and sends a request to add the friend if the inputted ID is not empty.\n  - It renders a close button and checks if it is clicked or if the escape key is pressed to close the dialog box.\n  - It sets the focus on the friend's ID text field.\n  - It sets the GUI skin back to the original skin and returns the result.\n\nThe class also has a \"InitDialog\" method that initializes the \"friendWannabe\" variable to an empty string.\n\nThis class is likely used in the larger project to provide a user interface for adding friends in the game. It handles the rendering of the dialog box and the functionality of adding a friend by sending a request to the server.\n## Questions: \n 1. What is the purpose of the `AddFriendDialog` class?\n- The `AddFriendDialog` class is a subclass of the `Dialog` class and represents a dialog for adding a friend in the game.\n\n2. What is the significance of the `maxId` variable?\n- The `maxId` variable represents the maximum length of the friend's ID that can be entered in the text field.\n\n3. What is the purpose of the `InitDialog` method?\n- The `InitDialog` method initializes the `friendWannabe` variable to an empty string, resetting the dialog for adding a friend.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\AddFriendDialog.md"}}],["12",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\AfterImageEmitter.cs)\n\nThe code provided is for a class called \"AfterImageEmitter\" in the Brick-Force project. This class is responsible for creating and managing afterimages of a game object. \n\nThe class has several member variables:\n- `componentsToDel` is an array of strings that represents the names of the components to be removed from the afterimage object.\n- `minDistance` is a float that represents the minimum distance required for the game object to move before creating a new afterimage.\n- `lastPosition` is a Vector3 that stores the last position of the game object.\n- `afterImage` is a boolean that determines whether the afterimage should be shown or not.\n\nThe class has three methods:\n- `ShowAfterImage(bool show)` is a public method that sets the value of `afterImage` based on the input parameter. If `show` is true, it calls the `Shoot()` method to create a new afterimage.\n- `Shoot()` is a private method that creates a new afterimage game object by instantiating a copy of the current game object. It then removes the specified components from the afterimage object, adds a `FadeOutDestroyer` component, and updates the `lastPosition` variable.\n- `Update()` is a private method that is called every frame. If `afterImage` is true and the distance between the current position and the last position is greater than `minDistance`, it calls the `Shoot()` method to create a new afterimage.\n\nIn the larger project, this class can be used to create afterimages for game objects that move. The `ShowAfterImage()` method can be called to toggle the visibility of the afterimage, and the `minDistance` variable can be adjusted to control how often afterimages are created. The `componentsToDel` array can be used to specify which components should be removed from the afterimage object, allowing for customization of the afterimage appearance.\n## Questions: \n 1. What is the purpose of the `componentsToDel` array?\n- The `componentsToDel` array is used to store the names of components that should be removed from the instantiated game object in the `Shoot()` method.\n\n2. What does the `ShowAfterImage()` method do?\n- The `ShowAfterImage()` method sets the value of the `afterImage` variable and calls the `Shoot()` method if `afterImage` is true.\n\n3. What is the purpose of the `minDistance` variable?\n- The `minDistance` variable is used to determine the minimum distance required for the `Shoot()` method to be called in the `Update()` method.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\AfterImageEmitter.md"}}],["13",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Agb.cs)\n\nThe code provided is a basic script written in C# using the Unity game engine. It is a part of the larger Brick-Force project, which is a game development project. \n\nThe script is named \"Agb\" and is a MonoBehaviour class, which means it can be attached to a game object in the Unity editor. The purpose of this script is to provide a starting point for adding functionality to a game object in the Brick-Force project.\n\nThe script contains two methods: Start() and Update(). The Start() method is called once when the game object is first created or enabled, and the Update() method is called every frame of the game.\n\nThe Start() method is currently empty, meaning it does not contain any code. This method can be used to initialize variables, set up references to other objects, or perform any other necessary setup tasks when the game object is created.\n\nThe Update() method is also currently empty. This method can be used to update the state of the game object every frame. For example, it can be used to move the game object, check for user input, or update the game's physics simulation.\n\nHere is an example of how this script can be used in the larger Brick-Force project:\n\n1. Create a new game object in the Unity editor.\n2. Attach the \"Agb\" script to the game object.\n3. Implement the Start() method to initialize any necessary variables or references.\n4. Implement the Update() method to update the game object's state every frame.\n\nBy attaching the \"Agb\" script to a game object and implementing the Start() and Update() methods, developers can add custom functionality to the game object in the Brick-Force project. This script serves as a starting point for adding behavior to game objects and can be expanded upon to create more complex and interactive gameplay experiences.\n## Questions: \n 1. What is the purpose of the `Agb` class?\n- The purpose of the `Agb` class is not clear from the provided code. It would be helpful to know what functionality or behavior this class is intended to provide.\n\n2. Why are the `Start()` and `Update()` methods empty?\n- It is unclear why the `Start()` and `Update()` methods are empty. It would be useful to know if there is any specific functionality that is intended to be implemented in these methods.\n\n3. What is the significance of the `using UnityEngine;` statement?\n- The `using UnityEngine;` statement suggests that the code is using the Unity game engine. It would be helpful to know if there are any specific Unity-related features or components being utilized in this code.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Agb.md"}}],["14",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\aiBee.cs)\n\nThe code provided is a part of the Brick-Force project and is a script for an AI character called \"aiBee\". The purpose of this code is to change the texture of the AI character based on the team it belongs to.\n\nThe code starts by finding the \"Main\" game object in the scene and getting the \"Defense\" component attached to it. This component is responsible for storing the textures for the AI character. If the \"Defense\" component is found, the code proceeds to get the \"MonProperty\" component attached to the AI character itself.\n\nNext, the code tries to find the \"SkinnedMeshRenderer\" component attached to the AI character. This component is responsible for rendering the character's mesh. If the \"SkinnedMeshRenderer\" component is not found, an error message is logged.\n\nFinally, based on the team the AI character belongs to (determined by the \"bRedTeam\" property of the \"MonProperty\" component), the code sets the main texture of the character's material to either the \"texBeeRed\" or \"texBeeBlue\" texture from the \"Defense\" component.\n\nThis code can be used in the larger Brick-Force project to dynamically change the appearance of AI characters based on their team affiliation. For example, if the AI character belongs to the red team, its texture will be set to the \"texBeeRed\" texture, and if it belongs to the blue team, its texture will be set to the \"texBeeBlue\" texture.\n\nHere is an example of how this code can be used in the larger project:\n\n```csharp\naiBee aiCharacter = new aiBee();\naiCharacter.changeTexture();\n```\n\nThis will create an instance of the \"aiBee\" class and call the \"changeTexture\" method, which will change the texture of the AI character based on its team affiliation.\n## Questions: \n 1. What is the purpose of the `changeTexture()` method?\n- The `changeTexture()` method is responsible for changing the main texture of the SkinnedMeshRenderer component based on the team color of the AI character.\n\n2. What is the significance of the `Defense` component and how is it used in this code?\n- The `Defense` component is obtained from the \"Main\" GameObject and is used to access the `texBeeRed` and `texBeeBlue` textures, which are then applied to the SkinnedMeshRenderer component based on the team color.\n\n3. What happens if the SkinnedMeshRenderer component is not found?\n- If the SkinnedMeshRenderer component is not found, an error message is logged stating \"Fail to get skinned mesh renderer for flags\".","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\aiBee.md"}}],["15",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\aiBee2.cs)\n\nThe code provided is a part of the Brick-Force project and is a script for an AI character called \"aiBee2\". This script is responsible for changing the texture of the AI character based on the team it belongs to.\n\nThe script inherits from the \"MonAI\" class, which suggests that it is a part of a larger system for controlling AI characters in the game. The \"changeTexture\" method is an overridden method from the base class and is called to change the texture of the AI character.\n\nThe method starts by finding the \"Defense\" component attached to the \"Main\" game object using the \"GameObject.Find\" method. The \"Defense\" component is responsible for managing the defensive properties of the game. If the \"Defense\" component is found, the method proceeds to change the texture of the AI character.\n\nThe method then gets the \"MonProperty\" component attached to the same game object as the script. The \"MonProperty\" component likely contains information about the AI character, such as its team affiliation. The method also gets the \"SkinnedMeshRenderer\" component attached to the AI character or its child objects. The \"SkinnedMeshRenderer\" component is responsible for rendering the character's mesh with a texture.\n\nIf the \"SkinnedMeshRenderer\" component is not found, an error message is logged using the \"Debug.LogError\" method.\n\nFinally, based on the team affiliation stored in the \"MonProperty\" component, the method sets the main texture of the \"SkinnedMeshRenderer\" component to either \"texBee2Red\" or \"texBee2Blue\" from the \"Defense\" component. This changes the appearance of the AI character to match its team.\n\nThis script is likely used in the larger Brick-Force project to dynamically change the appearance of AI characters based on their team affiliation. It allows for visual distinction between different teams and enhances the overall gameplay experience.\n## Questions: \n 1. What is the purpose of the `changeTexture()` method?\n- The `changeTexture()` method is used to change the main texture of the SkinnedMeshRenderer component based on the team color of the AI character.\n\n2. What is the significance of the `Defense` and `MonProperty` components?\n- The `Defense` component is used to access the textures for the AI character's team colors, while the `MonProperty` component is used to check if the AI character belongs to the red team.\n\n3. What happens if the SkinnedMeshRenderer component is null?\n- If the SkinnedMeshRenderer component is null, an error message will be logged stating that it failed to get the skinned mesh renderer for flags.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\aiBee2.md"}}],["16",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\aiBomber.cs)\n\nThe code provided is a part of the Brick-Force project and is a script for an AI character called \"aiBomber\". This script is responsible for changing the texture of the AI character based on the team it belongs to.\n\nThe script inherits from the \"MonAI\" class, which suggests that it is a part of a larger system for controlling AI characters in the game. The \"changeTexture\" method is an overridden method from the base class, indicating that it is a specific behavior for the \"aiBomber\" character.\n\nThe method starts by finding the \"Defense\" component in the scene by searching for a GameObject named \"Main\". The \"Defense\" component is likely responsible for managing the defensive aspects of the game, such as team assignments and textures for different teams.\n\nIf the \"Defense\" component is found, the method proceeds to retrieve the \"MonProperty\" component from the current AI character. It then finds the \"SkinnedMeshRenderer\" component, which is responsible for rendering the character's mesh with a texture.\n\nIf the \"SkinnedMeshRenderer\" component is not found, an error message is logged. Otherwise, the method checks the team assignment of the AI character. If the character belongs to the red team, it sets the main texture of the \"SkinnedMeshRenderer\" to the \"texBomberRed\" texture from the \"Defense\" component. If the character belongs to the blue team, it sets the main texture to the \"texBomberBlue\" texture.\n\nThis code is likely used in the larger Brick-Force project to dynamically change the appearance of AI characters based on their team affiliation. It allows for visual distinction between different teams and enhances the overall gameplay experience.\n## Questions: \n 1. What is the purpose of the `changeTexture()` method?\n- The `changeTexture()` method is used to change the texture of the skinned mesh renderer based on the team color of the AI character.\n\n2. What is the role of the `Defense` component and how is it used in this code?\n- The `Defense` component is used to access the textures for the bomber character. It is retrieved using `GameObject.Find(\"Main\").GetComponent<Defense>()`.\n\n3. What happens if the skinned mesh renderer (`smr`) is null?\n- If `smr` is null, an error message is logged saying \"Fail to get skinned mesh renderer for flags\".","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\aiBomber.md"}}],["17",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\aiChampion.cs)\n\nThe code provided is a class called `aiChampion` that inherits from the `MonAI` class. The purpose of this class is to change the texture of a champion character in the game based on the team they belong to.\n\nThe `changeTexture` method is an overridden method from the `MonAI` class. It first finds the `Defense` component attached to the \"Main\" game object using `GameObject.Find` and `GetComponent`. If the `Defense` component is found, it proceeds to change the texture of the champion character.\n\nThe method then gets the `MonProperty` component attached to the current game object using `GetComponent<MonProperty>`. It also gets the `SkinnedMeshRenderer` component attached to any child game object using `GetComponentInChildren<SkinnedMeshRenderer>`.\n\nIf the `SkinnedMeshRenderer` component is null, it logs an error message using `Debug.LogError`. Otherwise, it checks the team of the champion character by accessing the `bRedTeam` property of the `Desc` property of the `component2` object.\n\nIf the champion character belongs to the red team, it sets the `mainTexture` property of the `renderer.material` of the `SkinnedMeshRenderer` to the `texChampionRed` texture from the `component` object. If the champion character belongs to the blue team, it sets the `mainTexture` property of the `renderer.material` of the `SkinnedMeshRenderer` to the `texChampionBlue` texture from the `component` object.\n\nIn the larger project, this code is likely used to dynamically change the appearance of champion characters based on the team they belong to. This could be used in a multiplayer game where players are divided into teams and each team has its own unique champion character. By changing the texture of the champion character, the game can visually differentiate between the teams and provide a more immersive experience for the players.\n\nExample usage:\n\n```csharp\naiChampion champion = new aiChampion();\nchampion.changeTexture();\n```\n\nThis code creates a new instance of the `aiChampion` class and calls the `changeTexture` method to change the texture of the champion character.\n## Questions: \n 1. What is the purpose of the `changeTexture()` method?\n- The `changeTexture()` method is responsible for changing the main texture of the SkinnedMeshRenderer component based on the team color of the AI character.\n\n2. What is the significance of the `Defense` and `MonProperty` components?\n- The `Defense` component is used to access the `texChampionRed` and `texChampionBlue` textures, while the `MonProperty` component is used to check if the AI character belongs to the red team.\n\n3. What happens if the SkinnedMeshRenderer component is null?\n- If the SkinnedMeshRenderer component is null, an error message will be logged stating that it failed to get the skinned mesh renderer for flags.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\aiChampion.md"}}],["18",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\aiFlash.cs)\n\nThe code provided is a class called `aiFlash` that extends the `MonAI` class. The purpose of this code is to define an AI behavior for a character in the Brick-Force project. \n\nIn the larger project, the `aiFlash` class would be used to create and control AI-controlled characters that exhibit specific behaviors and actions. The `MonAI` class likely provides a set of base functionality and methods that the `aiFlash` class can build upon and customize.\n\nBy extending the `MonAI` class, the `aiFlash` class inherits all the properties and methods of the `MonAI` class. This allows the `aiFlash` class to override and implement specific behaviors and actions for the AI-controlled character.\n\nFor example, the `aiFlash` class may override methods such as `OnStart()` or `OnUpdate()` to define what the AI-controlled character does when the game starts or during each game update. The class may also define additional methods or properties to handle specific actions or behaviors unique to the AI-controlled character.\n\nHere is an example of how the `aiFlash` class may be used in the larger project:\n\n```csharp\npublic class aiFlash : MonAI\n{\n    protected override void OnStart()\n    {\n        // Perform initialization tasks for the AI-controlled character\n        // For example, set the starting position, assign initial attributes, etc.\n    }\n\n    protected override void OnUpdate()\n    {\n        // Perform actions and behaviors for the AI-controlled character during each game update\n        // For example, move towards a target, attack enemies, avoid obstacles, etc.\n    }\n}\n\npublic class Game\n{\n    private aiFlash aiCharacter;\n\n    public void StartGame()\n    {\n        aiCharacter = new aiFlash();\n        aiCharacter.OnStart();\n    }\n\n    public void UpdateGame()\n    {\n        aiCharacter.OnUpdate();\n    }\n}\n```\n\nIn this example, the `aiFlash` class is instantiated and used within the `Game` class. The `StartGame()` method initializes the AI-controlled character, and the `UpdateGame()` method updates the character's actions and behaviors during each game update.\n\nOverall, the `aiFlash` class plays a crucial role in defining the AI behavior for a character in the Brick-Force project, allowing for dynamic and intelligent interactions between AI-controlled characters and the game environment.\n## Questions: \n 1. What is the purpose of the `aiFlash` class?\n- The `aiFlash` class is likely a subclass of the `MonAI` class, but without further information, it is unclear what specific functionality or behavior it adds or modifies.\n\n2. Are there any additional methods or properties defined in the `aiFlash` class?\n- The code provided only shows the class declaration, so it is unclear if there are any additional methods or properties defined within the `aiFlash` class.\n\n3. What is the relationship between the `aiFlash` class and the rest of the `Brick-Force` project?\n- Without more context, it is unclear how the `aiFlash` class fits into the overall structure and functionality of the `Brick-Force` project.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\aiFlash.md"}}],["19",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\aiHealer.cs)\n\nThe code provided is a class called `aiHealer` that extends the `MonAI` class. This class is responsible for managing the healing behavior of an AI character in the larger Brick-Force project.\n\nThe `aiHealer` class has several public variables that can be adjusted to customize the healing behavior. These variables include `healRange`, which determines the maximum distance at which the AI character can heal other characters, `incHp`, which represents the amount of health points that will be increased when healing, and `repeatTime`, which determines the time interval between each healing action.\n\nThe `aiHealer` class overrides two methods from the `MonAI` class: `ActiveHealerEff()` and `updateAreaHeal()`. \n\nThe `ActiveHealerEff()` method is responsible for activating the healing effect. It searches for a specific object named \"Dummy_mon_effect\" in the AI character's children objects and instantiates a copy of the `healerEff` object at the position and rotation of the found object. This method is likely called when the AI character is first spawned or when it needs to activate its healing ability.\n\nThe `updateAreaHeal()` method is responsible for performing the healing action. It first checks if the healing effect object (`effCopy`) exists. If it does, it searches for the \"Dummy_mon_effect\" object again and updates the position and rotation of the healing effect object to match the found object. \n\nNext, it checks if the AI character is the master character (controlled by the player). If it is, it increments the `dtHeal` variable by the time since the last frame. If `dtHeal` exceeds the `repeatTime` value, it performs the healing action.\n\nThe healing action involves sending a message to the `P2PManager` to notify other players of the healing action. It then searches for the \"Dummy_mon_effect\" object again and instantiates a new copy of the `healerEff` object at its position and rotation. \n\nFinally, it retrieves an array of all AI characters in the game and iterates over them. For each AI character within the `healRange`, it retrieves the corresponding `MonAI` class and calls its `ActiveHealEff()` method to activate the healing effect. It also increments the character's experience points (`Xp`) by the `incHp` value and sends a message to the `P2PManager` to notify other players of the updated health points.\n\nIn summary, the `aiHealer` class is responsible for managing the healing behavior of an AI character in the Brick-Force project. It activates and updates the healing effect object, performs the healing action at regular intervals, and notifies other players of the healing action and updated health points.\n## Questions: \n 1. What is the purpose of the `aiHealer` class?\n- The `aiHealer` class is responsible for healing other game objects within a certain range.\n\n2. What is the significance of the `healRange` variable?\n- The `healRange` variable determines the maximum distance at which the `aiHealer` can heal other game objects.\n\n3. What is the purpose of the `updateAreaHeal` method?\n- The `updateAreaHeal` method is responsible for updating the healing effect and healing nearby game objects within the specified range.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\aiHealer.md"}}],["20",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\aiHide.cs)\n\nThe code provided is a part of the Brick-Force project and is a script called `aiHide`. This script is responsible for managing the hiding behavior of an AI character in the game. \n\nThe `aiHide` script inherits from the `MonAI` class, which suggests that it is a part of a larger system that handles AI behavior in the game. \n\nThe script contains several variables and properties that control the hiding behavior. \n\n- `effHide` is a reference to a GameObject that represents the visual effect when the AI character hides.\n- `hideTime` is the duration in seconds for which the AI character remains hidden.\n- `deltaTimeHide` is a variable that keeps track of the time elapsed since the AI character started hiding.\n- `canApply` is a boolean flag that determines whether the hiding behavior can be applied to the AI character.\n- `isHide` is a boolean flag that indicates whether the AI character is currently hiding.\n\nThe script provides two public methods:\n\n1. `setHide(bool bSet)`: This method is responsible for toggling the hiding behavior of the AI character. If `bSet` is true, the AI character is set to hide. It instantiates the `effHide` GameObject, changes the color of the AI character's SkinnedMeshRenderers to make it appear hidden, and sets `isHide` to true. If `bSet` is false, the AI character is set to stop hiding. It restores the original color of the AI character's SkinnedMeshRenderers and sets `isHide` to false. Additionally, it sets `canApply` to false, preventing the hiding behavior from being applied again.\n\n2. `updateHide()`: This method is called in the update loop and is responsible for updating the hiding behavior if the AI character is currently hiding. It increments `deltaTimeHide` by the time elapsed since the last frame. If `deltaTimeHide` exceeds `hideTime`, it calls `setHide(false)` to stop the hiding behavior.\n\nOverall, this script allows the AI character to hide and unhide in the game. It provides methods to control the hiding behavior and updates the hiding state based on the elapsed time. This functionality can be used to create more dynamic and challenging AI behavior in the Brick-Force game.\n## Questions: \n 1. What is the purpose of the `aiHide` class and how is it used in the project?\n- The `aiHide` class appears to be a script for managing hiding behavior for an AI character in the game. It has methods for setting and updating the hide state of the character.\n\n2. What is the significance of the `effHide` variable and how is it used?\n- The `effHide` variable is a reference to a GameObject that represents an effect or visual representation of the hiding state. It is instantiated when the character is set to hide.\n\n3. What is the purpose of the `CanApply` property and how is it used?\n- The `CanApply` property is a boolean value that determines whether the hiding behavior can be applied to the character. It is used to control when the character can hide or stop hiding.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\aiHide.md"}}],["21",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\aiIntruder.cs)\n\nThe code provided is a part of the Brick-Force project and is a script for an AI intruder character. The purpose of this code is to change the texture of the AI intruder's model based on the team it belongs to.\n\nThe code starts by finding the \"Main\" game object in the scene and getting the Defense component attached to it. If the Defense component is found, the code proceeds to get the MonProperty component attached to the AI intruder object itself. It then gets the SkinnedMeshRenderer component attached to the AI intruder object or any of its child objects. If the SkinnedMeshRenderer component is not found, an error message is logged.\n\nNext, the code checks the value of the \"bRedTeam\" property in the MonProperty component. If it is true, the main texture of the SkinnedMeshRenderer component is set to the \"texIntruderRed\" texture from the Defense component. If it is false, the main texture is set to the \"texIntruderBlue\" texture from the Defense component.\n\nThis code is likely used in the larger Brick-Force project to dynamically change the appearance of AI intruder characters based on their team affiliation. By changing the texture of the AI intruder's model, the game can visually differentiate between different teams and provide a more immersive experience for the players.\n\nHere is an example of how this code might be used in the larger project:\n\n```csharp\n// Create an instance of the aiIntruder class\naiIntruder intruder = new aiIntruder();\n\n// Call the changeTexture method to change the texture of the AI intruder\nintruder.changeTexture();\n```\n\nOverall, this code plays a role in the visual representation of AI intruder characters in the Brick-Force project, allowing for team-based differentiation and enhancing the overall gameplay experience.\n## Questions: \n 1. What is the purpose of the `changeTexture()` method?\n- The `changeTexture()` method is used to change the main texture of the skinned mesh renderer component based on the team color of the AI intruder.\n\n2. What is the significance of the `Defense` component and how is it used in this code?\n- The `Defense` component is obtained from the \"Main\" game object and is used to access the `texIntruderRed` and `texIntruderBlue` textures, which are then applied to the skinned mesh renderer component based on the team color.\n\n3. What happens if the skinned mesh renderer component is not found?\n- If the skinned mesh renderer component is not found, an error message is logged stating \"Fail to get skinned mesh renderer for flags\".","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\aiIntruder.md"}}],["22",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Aim.cs)\n\nThe code provided is a script called \"Aim\" that is a part of the larger Brick-Force project. This script is responsible for handling the aiming functionality in the game. It determines the position and appearance of the crosshair on the screen based on the player's accuracy and weapon modifications.\n\nThe script contains several public properties that allow for customization of the crosshair appearance, such as the debugCrossHair, vCrossHair, and hCrossHair textures. These properties can be set in the Unity editor or through code.\n\nThe OnGUI method is called by Unity's GUI system and is responsible for drawing the crosshair on the screen. It first checks if the GUI is enabled and if the game is not in a modal state. If these conditions are met, it sets the GUI skin and depth, and then calls the DrawCrossHair method.\n\nThe DrawCrossHair method is responsible for calculating the position and size of the crosshair based on the player's accuracy and screen dimensions. It first calculates a factor based on the aspect ratio of the screen and the camera's field of view. It then calculates the position of the crosshair based on this factor and the screen dimensions. The method then draws the crosshair textures at the calculated positions using the TextureUtil.DrawTexture method.\n\nThe Start method is called when the script is first initialized. It calls the Modify method, sets the aiming flag to true, and initializes the accuracy values.\n\nThe Modify method is responsible for modifying the accuracy values based on the weapon being used. It retrieves the WeaponFunction component attached to the same game object and checks if it is not null. If it is not null, it retrieves the WpnMod object from the WeaponModifier singleton based on the weapon's ID. It then updates the accuracy values with the values from the retrieved WpnMod object. It also checks if the weapon has any upgrades and if so, it retrieves the upgrade value from the PimpManager singleton and adds it to the accuracy value.\n\nThe Update method is called every frame and calls the UpdateCrossEffect method.\n\nThe CalcDeflection method returns a Vector2 that represents the deflection of the aim based on the accuracy values.\n\nThe Inaccurate method makes the aim more inaccurate by calling the MakeInaccurate method of the accuracy object.\n\nThe Accurate method makes the aim more accurate by calling the MakeAccurate method of the accuracy object.\n\nThe SetAiming method sets the aiming flag to the provided value.\n\nThe SetShootEnermyEffect method sets the crossEffectTime variable to 0.3f, which is used to create a visual effect when shooting enemies.\n\nThe UpdateCrossEffect method is responsible for updating the crossEffectTime variable by subtracting the deltaTime from it.\n\nIn summary, this script handles the aiming functionality in the game by calculating the position and appearance of the crosshair based on the player's accuracy and weapon modifications. It also provides methods for making the aim more accurate or inaccurate, setting the aiming flag, and updating the crosshair effect.\n## Questions: \n 1. What is the purpose of the `Aim` class?\n- The `Aim` class is responsible for handling the aiming functionality in the game.\n\n2. What is the significance of the `accuracy` variable?\n- The `accuracy` variable is an instance of the `Accuracy` class, which is used to calculate and control the accuracy of the aiming.\n\n3. What is the purpose of the `Modify` method?\n- The `Modify` method is used to modify the accuracy values based on the weapon being used and its upgrades.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Aim.md"}}],["23",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\aiNormal.cs)\n\nThe code provided is a class called `aiNormal` that extends the `MonAI` class. \n\nThe purpose of this code is to define the behavior and characteristics of a normal AI in the Brick-Force project. The `aiNormal` class is likely used to create and control non-player characters (NPCs) that have basic AI functionality.\n\nBy extending the `MonAI` class, the `aiNormal` class inherits all the properties and methods defined in the `MonAI` class. This allows the `aiNormal` class to have access to common AI functionality and behavior that is shared among different types of NPCs in the game.\n\nThe `aiNormal` class can be used to define the specific behavior and actions of a normal AI character in the game. This could include things like movement patterns, interaction with the environment, and decision-making processes. \n\nHere is an example of how the `aiNormal` class could be used in the larger project:\n\n```java\naiNormal enemy = new aiNormal();\nenemy.setMovementPattern(MovementPattern.PATROL);\nenemy.setTarget(player);\nenemy.attack();\n```\n\nIn this example, a new instance of the `aiNormal` class is created and assigned to the `enemy` variable. The `setMovementPattern()` method is used to set the movement pattern of the enemy to a predefined `MovementPattern.PATROL`. The `setTarget()` method is used to set the target of the enemy to the `player` character. Finally, the `attack()` method is called to initiate an attack on the target.\n\nOverall, the `aiNormal` class plays a crucial role in defining the behavior and actions of normal AI characters in the Brick-Force project. It provides a way to create and control NPCs with basic AI functionality, allowing them to interact with the game environment and make decisions based on predefined behavior patterns.\n## Questions: \n 1. What is the purpose of the `aiNormal` class?\n- The `aiNormal` class is likely a subclass of the `MonAI` class, but without any code provided it is unclear what specific functionality or behavior it adds or modifies.\n\n2. Are there any methods or properties defined in the `aiNormal` class?\n- Without any code provided, it is not possible to determine if the `aiNormal` class has any methods or properties defined.\n\n3. What is the relationship between the `aiNormal` class and the `Brick-Force` project?\n- It is unclear from the code snippet alone how the `aiNormal` class is related to the `Brick-Force` project. More context or code would be needed to understand this relationship.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\aiNormal.md"}}],["24",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\aiSelfHeal.cs)\n\nThe code provided is a class called `aiSelfHeal` that extends the `MonAI` class. This class is responsible for implementing a self-healing behavior for an AI character in the Brick-Force project.\n\nThe class has several public variables that can be configured:\n- `incHp` is an integer that represents the amount of health points the AI character will gain when it heals itself. By default, it is set to 10.\n- `repeatTime` is a float that determines the time interval between each self-healing action. By default, it is set to 10 seconds.\n\nThe class also has private variables:\n- `dtHeal` is a float that keeps track of the time since the last self-healing action.\n- `bHeal` is a boolean that indicates whether the AI character is currently healing itself or not.\n\nThe class has a public property `IsHeal` that allows external code to get or set the value of `bHeal`.\n\nThe class overrides the `updateSelfHeal()` method from the `MonAI` class. This method is called periodically to update the self-healing behavior of the AI character. \n\nInside the `updateSelfHeal()` method, there is a check to ensure that the current AI character is the master character. If it is, the method proceeds with the self-healing logic.\n\nThe method increments the `dtHeal` variable by the time that has passed since the last frame. If `dtHeal` exceeds the `repeatTime`, the AI character performs the self-healing action.\n\nThe self-healing action consists of the following steps:\n1. Instantiate a healing effect object at the current position of the AI character.\n2. Reset `dtHeal` to 0.\n3. Increase the AI character's experience points (`monProp.Desc.Xp`) by the value of `incHp`.\n4. Check if the AI character's experience points exceed the maximum experience points (`monProp.Desc.max_xp`). If it does, set the experience points to the maximum value.\n5. Send a self-healing message to the P2PManager with the AI character's sequence number (`monProp.Desc.Seq`) and experience points (`monProp.Desc.Xp`).\n\nIn summary, this code implements a self-healing behavior for an AI character in the Brick-Force project. The AI character periodically heals itself, gaining a specified amount of health points, and updates its experience points accordingly. This behavior can be used to create more dynamic and resilient AI opponents in the game.\n## Questions: \n 1. What is the purpose of the `aiSelfHeal` class?\n- The `aiSelfHeal` class is responsible for managing the self-healing behavior of an AI character in the game.\n\n2. What does the `IsHeal` property do?\n- The `IsHeal` property is a getter and setter for a boolean variable that determines whether the AI character is currently healing or not.\n\n3. What does the `updateSelfHeal()` method do?\n- The `updateSelfHeal()` method is called to update the self-healing behavior of the AI character. It checks if the AI character is the master character, calculates the time since the last heal, and performs the healing action if enough time has passed.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\aiSelfHeal.md"}}],["25",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\AngelWingItem.cs)\n\nThe code provided is a class called \"AngelWingItem\" that inherits from the \"ActiveItemBase\" class. This class represents an item in the larger Brick-Force project that allows the player to enable and disable a wing effect on their character.\n\nThe class has several member variables:\n- \"ANGELWING_ITEM_TIME\" is a constant float that represents the duration of the wing effect.\n- \"deltaTime\" is a float that keeps track of the time elapsed since the wing effect was enabled.\n- \"itemEnable\" is a boolean that indicates whether the wing effect is currently enabled or disabled.\n- \"wingEffect\" is a reference to a GameObject that represents the visual effect of the wings.\n- \"firstPersonAttachBone\" and \"thirdPersonAttachBone\" are strings that specify the bone to which the wings should be attached in first-person and third-person views, respectively.\n- \"itemStartSound\" is an AudioClip that represents the sound played when the wing effect is started.\n\nThe class has several methods:\n- \"Awake()\" is an empty method that is called when the object is initialized.\n- \"Update()\" is a method that is called every frame. It checks if the wing effect is enabled and updates the \"deltaTime\" variable. If the elapsed time exceeds the duration of the wing effect, the \"enableWingItem()\" method is called with the \"enable\" parameter set to false.\n- \"StartItem()\" is a method that is called when the wing effect is started. It calls the \"enableWingItem()\" method with the \"enable\" parameter set to true, resets the \"deltaTime\" variable to 0, and plays the \"itemStartSound\" if the item belongs to the player.\n- \"enableWingItem(bool enable)\" is a method that enables or disables the wing effect based on the value of the \"enable\" parameter. If the item belongs to the player, it finds the player's GameObject and calls the \"enableWingEffect()\" method of the \"EquipCoordinator\" component attached to the player. If the item belongs to another player, it finds the corresponding GameObject and calls the \"enableWingEffect()\" method of the \"LookCoordinator\" component attached to that player.\n\nIn the larger Brick-Force project, this code is likely used to implement a gameplay mechanic where players can equip and activate angel wings for a limited time. The \"AngelWingItem\" class handles the logic for enabling and disabling the wing effect, as well as playing the associated sound effect. The class also interacts with other components, such as \"EquipCoordinator\" and \"LookCoordinator\", to enable the wing effect on the player's character or other players' characters.\n## Questions: \n 1. What is the purpose of the `Awake()` method?\n- The purpose of the `Awake()` method is not clear from the provided code. It is an empty method and does not contain any code.\n\n2. What is the significance of the `firstPersonAttachBone` and `thirdPersonAttachBone` variables?\n- The `firstPersonAttachBone` and `thirdPersonAttachBone` variables are strings that likely represent the names of bones or attachment points in a character model. They may be used to attach the wing effect to the character model in first-person and third-person views.\n\n3. What is the purpose of the `StartItem()` method?\n- The `StartItem()` method enables the wing item, sets the `deltaTime` to 0, and plays a sound effect if the item belongs to the player.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\AngelWingItem.md"}}],["26",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Angles.cs)\n\nThe code provided is a part of the Brick-Force project and it defines a class called \"Angles\". This class contains a single static method called \"ClampAngle\". \n\nThe purpose of the \"ClampAngle\" method is to restrict an input angle value within a specified range. It takes three parameters: \"angle\", \"min\", and \"max\". The \"angle\" parameter represents the input angle that needs to be clamped, while the \"min\" and \"max\" parameters define the lower and upper bounds of the allowed range.\n\nThe method first checks if the input angle is less than -360 degrees. If it is, the method adds 360 degrees to the angle to bring it within the range of -360 to 0 degrees. Similarly, if the angle is greater than 360 degrees, the method subtracts 360 degrees to bring it within the range of 0 to 360 degrees.\n\nAfter ensuring that the angle is within the -360 to 360 degree range, the method uses the Mathf.Clamp function to restrict the angle within the specified \"min\" and \"max\" range. The Mathf.Clamp function returns the input angle if it is within the range, otherwise it returns the closest value to the input angle that falls within the range.\n\nHere is an example usage of the \"ClampAngle\" method:\n\n```csharp\nfloat inputAngle = 400f;\nfloat minAngle = 0f;\nfloat maxAngle = 180f;\n\nfloat clampedAngle = Angles.ClampAngle(inputAngle, minAngle, maxAngle);\nDebug.Log(clampedAngle); // Output: 180\n```\n\nIn this example, the input angle is 400 degrees, which is outside the allowed range of 0 to 180 degrees. The \"ClampAngle\" method clamps the angle to the maximum allowed value of 180 degrees, and the resulting clamped angle is then logged to the console.\n## Questions: \n 1. **What does this code do?**\nThe code defines a class called \"Angles\" with a static method called \"ClampAngle\". This method takes in an angle value and two minimum and maximum values, and returns the angle value clamped between the minimum and maximum values.\n\n2. **What are the expected input and output of the \"ClampAngle\" method?**\nThe expected input for the \"ClampAngle\" method is a float angle value, and two float minimum and maximum values. The method returns a float value, which is the angle value clamped between the minimum and maximum values.\n\n3. **What is the purpose of the if statements in the \"ClampAngle\" method?**\nThe if statements check if the angle value is less than -360 or greater than 360, and if so, adjust the angle value to be within the range of -360 to 360. This ensures that the angle value is properly wrapped around within the valid range before being clamped between the minimum and maximum values.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Angles.md"}}],["27",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\AnimToIdle.cs)\n\nThe code provided is a script called \"AnimToIdle\" that is written in C# and is used in the Brick-Force project. This script is responsible for managing the animation state of a game object in the project.\n\nAt a high level, the purpose of this code is to ensure that the game object's animation transitions to the \"idle\" state when it is not currently playing the \"fire\" or \"idle\" animations. This is achieved by checking the current animation state in the Update() method and calling the CrossFade() method to transition to the \"idle\" animation if necessary.\n\nThe script starts by declaring a private variable called \"anim\" of type Animation. In the Start() method, it assigns the Animation component of the game object's child to the \"anim\" variable using the GetComponentInChildren<Animation>() method. If the \"anim\" variable is null, it logs an error message using the Debug.LogError() method.\n\nIn the Update() method, it checks if the current animation is not playing either the \"fire\" or \"idle\" animation using the IsPlaying() method. If both conditions are false, it calls the CrossFade() method on the \"anim\" variable to transition to the \"idle\" animation.\n\nHere is an example of how this script can be used in the larger project:\n\n1. Attach the \"AnimToIdle\" script to a game object in the scene that has an Animation component.\n2. Assign the appropriate animations (\"fire\" and \"idle\") to the Animation component.\n3. When the game object is not playing the \"fire\" or \"idle\" animations, the script will automatically transition it to the \"idle\" animation.\n\nThis script helps to manage the animation state of game objects in the Brick-Force project, ensuring smooth transitions between different animations and providing a more immersive gameplay experience.\n## Questions: \n 1. **What is the purpose of this script?**\n   This script appears to be responsible for transitioning an animation to the idle state when neither the \"fire\" nor the \"idle\" animations are currently playing.\n\n2. **What does the `GetComponentInChildren<Animation>()` method do?**\n   This method retrieves the first component of type `Animation` that is found in the children of the current game object.\n\n3. **Why is there a check for `anim == null` in the `Start()` method?**\n   This check is performed to ensure that the `anim` variable is not null, indicating that the `GetComponentInChildren<Animation>()` method was unable to find an `Animation` component in the children of the game object.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\AnimToIdle.md"}}],["28",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Aps.cs)\n\nThe code provided is a part of the Brick-Force project and is contained in a file called \"Aps.cs\". This file defines a class called \"Aps\" that inherits from the \"MonoBehaviour\" class provided by the Unity engine.\n\nThe purpose of this code is to manage and provide access to data related to the APS (Advanced Player Statistics) system in the game. The APS system categorizes players into different types (represented by the \"APS_TYPE\" enum) such as \"NONE\", \"CHINESE\", and \"KOREAN\". Each APS type has a corresponding set of data stored in an array of \"ApsData\" objects.\n\nThe class has a private static instance variable \"_instance\" and a public static property \"Instance\" that provides a way to access the singleton instance of the \"Aps\" class. The \"Instance\" property uses the Unity method \"Object.FindObjectOfType\" to find an existing instance of the \"Aps\" class in the scene. If no instance is found, it logs an error message.\n\nThe \"Awake\" method is called when the object is initialized and it uses the \"Object.DontDestroyOnLoad\" method to prevent the \"Aps\" object from being destroyed when a new scene is loaded.\n\nThe class provides several public methods to interact with the APS data. The \"SetLevel\" method takes an APS type and a level as parameters and sets the current APS type and level. It then returns a warning message from the corresponding \"ApsData\" object if the level is within the range of warnings.\n\nThe \"GetCurLevelIcon\" method returns a texture icon for the current APS type and level. It takes a boolean parameter \"flip\" which determines whether to return the normal icon or a flipped version of it.\n\nThe \"GetCurTooltip\" method returns the tooltip text for the current APS type and level. It uses the \"StringMgr.Instance.Get\" method to retrieve the localized tooltip text from a string manager.\n\nOverall, this code provides a centralized way to manage and access APS data in the game. It allows other parts of the project to retrieve information about APS types, levels, icons, and tooltips.\n## Questions: \n 1. **Question:** What is the purpose of the `ApsData` array and how is it used in this code?\n   - **Answer:** The `ApsData` array is used to store data related to different APS types. It is accessed to retrieve warnings, icons, and tooltips based on the current APS type and level.\n\n2. **Question:** What is the significance of the `APS_TYPE` enum and how is it used in this code?\n   - **Answer:** The `APS_TYPE` enum represents different types of APS. It is used to set the current APS type and retrieve data specific to that type, such as warnings, icons, and tooltips.\n\n3. **Question:** What is the purpose of the `SetLevel` method and how does it determine the warning message to return?\n   - **Answer:** The `SetLevel` method sets the current APS type and level, and returns a warning message based on the current APS type and level. It checks if the level is within the range of warnings available for the given APS type.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Aps.md"}}],["29",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ApsData.cs)\n\nThe code provided is a class called `ApsData` that is used to store data related to a game called Brick-Force. This class is marked as `[Serializable]`, which means that its instances can be converted to a format that can be stored or transmitted, such as JSON or binary.\n\nThe `ApsData` class has the following properties:\n\n- `name`: A string property that represents the name of the data.\n- `warnings`: An array of strings that stores any warnings associated with the data.\n- `icons`: An array of `Texture2D` objects that represents the icons associated with the data.\n- `flips`: An array of `Texture2D` objects that represents the flipped versions of the icons.\n- `tooltips`: An array of strings that stores tooltips associated with the data.\n\nThis class is likely used to store information about different game elements in Brick-Force, such as characters, weapons, or items. Each instance of `ApsData` would represent a specific element, with its name, warnings, icons, flips, and tooltips.\n\nFor example, if we have a character named \"Warrior\", we could create an instance of `ApsData` to store its information:\n\n```csharp\nApsData warriorData = new ApsData();\nwarriorData.name = \"Warrior\";\nwarriorData.warnings = new string[] { \"Low health\", \"Slow movement\" };\nwarriorData.icons = new Texture2D[] { warriorIcon1, warriorIcon2 };\nwarriorData.flips = new Texture2D[] { warriorFlip1, warriorFlip2 };\nwarriorData.tooltips = new string[] { \"Powerful melee attacks\", \"Heavy armor\" };\n```\n\nIn this example, `warriorData` would store the name \"Warrior\", the warnings \"Low health\" and \"Slow movement\", the icons for the warrior, the flipped versions of the icons, and the tooltips \"Powerful melee attacks\" and \"Heavy armor\".\n\nThis `ApsData` class provides a structured way to store and access data related to game elements in Brick-Force, making it easier to manage and manipulate the data within the larger project.\n## Questions: \n 1. **What is the purpose of the `ApsData` class?**\nThe `ApsData` class is used to store data related to a specific object in the Brick-Force game, such as its name, warnings, icons, flips, and tooltips.\n\n2. **What is the significance of the `[Serializable]` attribute?**\nThe `[Serializable]` attribute indicates that instances of the `ApsData` class can be serialized and deserialized, allowing them to be easily stored or transmitted as data.\n\n3. **What are the data types of the `warnings`, `icons`, `flips`, and `tooltips` fields?**\nThe `warnings`, `icons`, `flips`, and `tooltips` fields are all arrays of `string` and `Texture2D` data types, which suggests that they store textual and graphical information related to the object represented by the `ApsData` class.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ApsData.md"}}],["30",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ArmorTexture.cs)\n\nThe code provided is a part of the Brick-Force project and is responsible for managing the textures used for the armor gauges in the game. The `ArmorTexture` class is a MonoBehaviour, which means it can be attached to a GameObject in the Unity game engine.\n\nThe class has two public variables of type `Texture2D` named `hitGaugeBg` and `lifeGaugeBg`. These variables are used to store the textures for the background of the hit gauge and life gauge, respectively. By making these variables public, they can be easily accessed and assigned in the Unity editor or from other scripts.\n\nThe `Start()` and `Update()` methods are empty in this code, indicating that they do not contain any functionality. However, these methods are commonly used in Unity scripts to perform initialization tasks in the `Start()` method and update tasks in the `Update()` method. It is possible that the developer intended to add functionality to these methods later on.\n\nIn the larger project, this code would be used to manage the textures for the armor gauges. The `hitGaugeBg` texture could be used to display the background of a gauge that represents the amount of damage a player's armor has taken. The `lifeGaugeBg` texture could be used to display the background of a gauge that represents the player's remaining health.\n\nOther scripts or components in the project could access the `ArmorTexture` class to retrieve the textures for the armor gauges. For example, a script responsible for rendering the armor gauges on the player's HUD could use the `hitGaugeBg` and `lifeGaugeBg` textures to display the appropriate backgrounds.\n\nHere is an example of how the `ArmorTexture` class could be used in another script:\n\n```csharp\npublic class ArmorGaugeRenderer : MonoBehaviour\n{\n    public ArmorTexture armorTexture;\n\n    private void Start()\n    {\n        // Retrieve the textures for the armor gauges\n        Texture2D hitGaugeBg = armorTexture.hitGaugeBg;\n        Texture2D lifeGaugeBg = armorTexture.lifeGaugeBg;\n\n        // Use the textures to render the armor gauges\n        // ...\n    }\n}\n```\n\nIn this example, the `ArmorGaugeRenderer` script has a reference to an `ArmorTexture` object. It retrieves the textures for the armor gauges from the `ArmorTexture` object and uses them to render the gauges.\n## Questions: \n 1. **What is the purpose of the `ArmorTexture` class?**\nThe `ArmorTexture` class appears to be responsible for managing armor textures in the game, as it has variables for `hitGaugeBg` and `lifeGaugeBg` textures.\n\n2. **What are the types of `hitGaugeBg` and `lifeGaugeBg` variables?**\nThe types of `hitGaugeBg` and `lifeGaugeBg` variables are not explicitly mentioned in the code snippet, so it would be helpful to know their types to understand how they are used.\n\n3. **What functionality is expected to be implemented in the `Start()` and `Update()` methods?**\nThe `Start()` and `Update()` methods are currently empty, so it would be important to know what functionality is intended to be implemented in these methods to understand the behavior of the `ArmorTexture` class.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ArmorTexture.md"}}],["31",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\AssetBundleLoadManager.cs)\n\nThe code provided is for a class called `AssetBundleLoadManager`, which is a part of the larger Brick-Force project. The purpose of this class is to manage the loading and unloading of asset bundles in the game.\n\nThe class starts with an enumeration called `ASS_BUNDLE_TYPE`, which defines different types of asset bundles that can be loaded. These types include fonts, voices, brick materials, brick icons, item materials, item icons, item weaponbys, and a second type of voice.\n\nThe class also includes a nested class called `LoadedInfo`, which stores information about the loaded asset bundles. This information includes the type of asset bundle, the URL from which it was loaded, and the version of the asset bundle.\n\nThe class has several member variables, including a reference to the singleton instance of the class (`_instance`), a string variable for the resource server URL (`resourceServer`), a list of loaded asset bundles (`listLoaded`), a version number for the USK asset bundle (`usk_ver`), and a boolean variable for setting the font (`setfont`).\n\nThe class includes several methods for loading and getting asset bundles. The `getAssetBundle` method takes in the type of asset bundle, an assembly string, and a version number, and returns the corresponding asset bundle. The `load` method is used to load an asset bundle of a specific type, assembly string, and version number. It first checks if the resource server URL is empty and sets it if necessary. Then, it constructs the URL for the asset bundle based on the type and assembly string. It starts a coroutine called `downloadAB` to download the asset bundle and adds the loaded asset bundle information to the `listLoaded` list.\n\nThe `downloadAB` coroutine is responsible for downloading the asset bundle from the given URL and version number. It uses the `AssetBundleManager` class to download and get the asset bundle. Depending on the type of asset bundle, it performs different actions. For example, if the type is `VOICE`, it loads all audio clips from the asset bundle and adds them to the `VoiceManager` instance. If the type is `BRICK_MAT`, it loads all materials from the asset bundle and adds them to the `BrickManager` instance. After performing the necessary actions, it sets the corresponding boolean variable (`setfont`, `VoiceManager.bLoaded`, etc.) to true.\n\nThe `OnDestroy` method is called when the `AssetBundleLoadManager` instance is destroyed. It unloads all the loaded asset bundles using the `AssetBundleManager` class.\n\nIn summary, the `AssetBundleLoadManager` class is responsible for managing the loading and unloading of asset bundles in the Brick-Force game. It provides methods for loading and getting asset bundles of different types, and performs specific actions based on the type of asset bundle loaded.\n## Questions: \n 1. What is the purpose of the `AssetBundleLoadManager` class?\n- The `AssetBundleLoadManager` class is responsible for loading and managing asset bundles for different types of assets such as fonts, voices, brick materials, and item icons.\n\n2. How does the `AssetBundleLoadManager` class handle different types of asset bundles?\n- The `AssetBundleLoadManager` class uses an enum called `ASS_BUNDLE_TYPE` to specify the type of asset bundle to load. It then constructs the appropriate URL based on the asset type and uses the `AssetBundleManager` class to download and load the asset bundle.\n\n3. How does the `AssetBundleLoadManager` class handle the loaded asset bundles?\n- The `AssetBundleLoadManager` class keeps track of the loaded asset bundles using a list of `LoadedInfo` objects. When the `AssetBundleLoadManager` is destroyed, it unloads all the loaded asset bundles by calling the `Unload` method of the `AssetBundleManager` class.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\AssetBundleLoadManager.md"}}],["32",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\AssetBundleManager.cs)\n\nThe code provided is a static class called `AssetBundleManager` that manages asset bundles in the Brick-Force project. \n\nThe purpose of this class is to handle the downloading, caching, and unloading of asset bundles. Asset bundles are files that contain assets such as textures, models, and audio clips that are used in the game. \n\nThe class contains a dictionary called `dictAssetBundleRefs` that stores references to loaded asset bundles. The keys of the dictionary are generated by concatenating the URL and version number of the asset bundle. The values are instances of the `AssetBundleRef` class, which contains a reference to the actual asset bundle.\n\nThe `getAssetBundle` method is used to retrieve an asset bundle from the dictionary based on its URL and version number. If the asset bundle is found in the dictionary, it is returned. Otherwise, `null` is returned.\n\nThe `downloadAssetBundle` method is used to download an asset bundle from a given URL. It first checks if the asset bundle is already in the dictionary. If it is, the method returns immediately. Otherwise, it uses the `WWW` class to download the asset bundle file. If the downloaded file is empty, it tries to download the asset bundle from the URL. Once the asset bundle is downloaded, it is saved to disk using the `SaveAssetBundle` method. Finally, a new `AssetBundleRef` instance is created and added to the dictionary.\n\nThe `Unload` method is used to unload an asset bundle from memory. It takes the URL and version number of the asset bundle as parameters. If the asset bundle is found in the dictionary, it is unloaded and removed from the dictionary.\n\nThe `SaveAssetBundle` method is used to save an asset bundle to disk. It takes a byte array containing the asset bundle data and a file name as parameters. The method first determines the path where the asset bundle should be saved, which is the \"Resources\" folder in the project's data path. It then creates a file stream and a binary writer to write the asset bundle data to the file.\n\nOverall, this code provides a centralized way to manage asset bundles in the Brick-Force project. It allows for downloading, caching, and unloading of asset bundles, which are essential for efficient asset management in a game.\n## Questions: \n 1. **Question:** What is the purpose of the `AssetBundleManager` class?\n   - **Answer:** The `AssetBundleManager` class is responsible for managing asset bundles, including downloading, saving, and unloading them.\n\n2. **Question:** How does the `downloadAssetBundle` method handle existing asset bundles?\n   - **Answer:** If an asset bundle with the same key already exists in the `dictAssetBundleRefs` dictionary, the method returns null. Otherwise, it downloads the asset bundle from the provided URL and saves it.\n\n3. **Question:** Where are the downloaded asset bundles saved?\n   - **Answer:** The downloaded asset bundles are saved in the \"Resources\" folder located in the \"Assets\" directory of the project.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\AssetBundleManager.md"}}],["33",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\AssetBundleRef.cs)\n\nThe code provided defines a class called `AssetBundleRef` that represents a reference to an asset bundle in the Unity game engine. \n\nThe `AssetBundleRef` class has three public fields: `assetBundle`, `version`, and `url`. \n\nThe `assetBundle` field is of type `AssetBundle` and represents the actual asset bundle object that this reference points to. \n\nThe `version` field is of type `int` and represents the version number of the asset bundle. \n\nThe `url` field is of type `string` and represents the URL or file path of the asset bundle.\n\nThe class also has two constructors. The default constructor initializes the `url` field to an empty string and the `version` field to 0. The second constructor takes in a `string` parameter `strUrlIn` and an `int` parameter `intVersionIn` and assigns them to the `url` and `version` fields respectively.\n\nThis code is likely used in the larger Brick-Force project to manage and reference asset bundles. Asset bundles are a way to package and load game assets such as textures, models, and audio files in Unity. By using asset bundles, developers can dynamically load and unload assets at runtime, reducing the initial loading time of the game and allowing for more efficient memory usage.\n\nThe `AssetBundleRef` class provides a convenient way to store and pass around references to asset bundles. For example, it can be used to keep track of which asset bundle is currently loaded, its version, and its URL or file path. This information can then be used to load specific assets from the bundle when needed.\n\nHere's an example of how this class could be used in the larger project:\n\n```csharp\nAssetBundleRef bundleRef = new AssetBundleRef(\"https://example.com/assets.bundle\", 1);\n// Load the asset bundle using the URL and version\nbundleRef.assetBundle = AssetBundle.LoadFromFile(bundleRef.url);\n// Use the asset bundle to load a specific asset\nGameObject prefab = bundleRef.assetBundle.LoadAsset<GameObject>(\"PrefabName\");\n// Instantiate the loaded prefab\nInstantiate(prefab);\n```\n\nIn this example, an `AssetBundleRef` object is created with a URL and version number. The asset bundle is then loaded from the specified URL using the `LoadFromFile` method. Finally, a specific asset (in this case, a prefab) is loaded from the asset bundle and instantiated in the game.\n## Questions: \n 1. **What is the purpose of the AssetBundleRef class?**\nThe AssetBundleRef class is used to store information about an asset bundle, including the asset bundle itself, its version, and its URL.\n\n2. **What is the significance of the version and url variables?**\nThe version variable represents the version number of the asset bundle, which can be used to track changes or updates. The url variable stores the URL or location of the asset bundle.\n\n3. **What is the purpose of the two constructors in the AssetBundleRef class?**\nThe first constructor initializes the url variable with an empty string and the version variable with 0. The second constructor allows the url and version to be set during object creation.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\AssetBundleRef.md"}}],["34",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\AudioSourceModifier.cs)\n\nThe code provided is a script called `AudioSourceModifier` that is used to modify the audio settings of an `AudioSource` component in Unity. The purpose of this script is to control the volume and mute settings of the audio source based on the specified type (either SFX or BGM).\n\nThe script starts by defining an enumeration called `TYPE` with two possible values: `SFX` and `BGM`. This enumeration is used to determine the type of audio source that will be modified.\n\nThe script then declares several private variables, including an `AudioSource` object, a float variable to store the original volume of the audio source, and a `TYPE` variable to store the specified type.\n\nIn the `Start()` method, the script retrieves the `AudioSource` component attached to the same game object as the script. If an `AudioSource` component is found, the original volume is stored and the `Modify()` method is called.\n\nThe `OnChangeAudioSource()` method is not used in this script and can be ignored.\n\nThe `Modify()` method is the main logic of the script. It first initializes a boolean variable `flag` to false and a float variable `num` to 1. Then, based on the specified type, it retrieves the mute and volume settings from the player preferences using `PlayerPrefs.GetInt()` and `PlayerPrefs.GetFloat()` methods. If the type is `BGM`, it retrieves the settings for \"BgmMute\" and \"BgmVolume\". If the type is `SFX`, it retrieves the settings for \"SfxMute\" and \"SfxVolume\".\n\nNext, the script sets the `mute` property of the `AudioSource` component to the value of `flag`. If `flag` is true, the audio source will be muted. If `flag` is false, the script calculates the new volume by multiplying the original volume (`fOriginalVolume`) with `num` and sets the `volume` property of the `AudioSource` component to the new volume.\n\nFinally, the `Update()` method is empty and does not contain any logic.\n\nIn the larger project, this script can be used to control the audio settings of different audio sources. By attaching this script to game objects with `AudioSource` components, the volume and mute settings of the audio sources can be modified based on the specified type. For example, if the type is set to `BGM`, the script will retrieve the mute and volume settings for background music from the player preferences and apply them to the attached `AudioSource` component. Similarly, if the type is set to `SFX`, the script will retrieve the settings for sound effects and apply them accordingly. This allows for dynamic control of audio settings in the game.\n## Questions: \n 1. What is the purpose of the `AudioSourceModifier` class?\n- The `AudioSourceModifier` class is used to modify the volume and mute settings of an `AudioSource` component based on the specified `TYPE` (SFX or BGM).\n\n2. How does the `Modify()` method determine the volume and mute settings?\n- The `Modify()` method uses a switch statement to determine the `TYPE` and then retrieves the corresponding volume and mute settings from the `PlayerPrefs` storage.\n\n3. What is the purpose of the `OnChangeAudioSource()` method?\n- The purpose of the `OnChangeAudioSource()` method is not clear from the provided code. It is possible that this method is intended to be called when the `AudioSource` component is changed, but it is currently not being used.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\AudioSourceModifier.md"}}],["35",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\AutoFunction.cs)\n\nThe code provided is a class called `AutoFunction` that is used to create and manage timed function calls in the larger Brick-Force project. \n\nThe purpose of this code is to allow for the execution of a specified function at regular intervals for a specified duration of time. It provides a way to automate the execution of functions without the need for manual intervention.\n\nThe `AutoFunction` class has several properties and methods that enable this functionality. \n\n- The `functionPointer` property is a delegate that points to the function that will be executed at each interval. \n- The `endFunctionPointer` property is a delegate that points to a function that will be executed once the specified duration has elapsed. \n- The `endTime` property specifies the duration of time for which the function calls will be made. \n- The `updateTime` property specifies the interval at which the function calls will be made. \n\nThe `AutoFunction` class has several constructors that allow for different combinations of parameters to be passed in. \n\nThe `Update` method is the main method of the class. It is called at regular intervals and checks if the specified interval (`updateTime`) has elapsed. If it has, it calls the function specified by `functionPointer`. It also checks if the specified duration (`endTime`) has elapsed and returns `true` if it has. \n\nThe `EndFunctionCall` method is called once the specified duration has elapsed. It calls the function specified by `endFunctionPointer`. \n\nHere is an example of how this code could be used in the larger Brick-Force project:\n\n```csharp\n// Define a function that will be called at each interval\nbool MyFunction()\n{\n    // Do something\n    return false;\n}\n\n// Define a function that will be called once the duration has elapsed\nvoid EndFunction()\n{\n    // Do something\n}\n\n// Create an instance of AutoFunction with a duration of 5 seconds and an interval of 1 second\nAutoFunction autoFunction = new AutoFunction(MyFunction, 5f, 1f, EndFunction);\n\n// Update the AutoFunction instance in the game loop\nvoid Update()\n{\n    if (autoFunction.Update())\n    {\n        // The specified duration has elapsed, do something\n    }\n}\n\n// Call the EndFunction once the specified duration has elapsed\nvoid OnDestroy()\n{\n    autoFunction.EndFunctionCall();\n}\n```\n\nIn this example, the `MyFunction` will be called every 1 second for a duration of 5 seconds. Once the 5 seconds have elapsed, the `EndFunction` will be called. The `Update` method is called in the game loop to update the `AutoFunction` instance, and the `OnDestroy` method is called to ensure that the `EndFunction` is called when the object is destroyed.\n## Questions: \n 1. What is the purpose of the `AutoFunction` class?\n- The `AutoFunction` class is used to create timed function calls that can be updated and ended based on specified time intervals.\n\n2. What is the significance of the `FunctionPointer` type?\n- The `FunctionPointer` type is used to store a reference to a function that takes no arguments and returns a boolean value.\n\n3. How does the `Update` method determine when to call the `functionPointer` and when to return `true`?\n- The `Update` method uses the `updateTime` and `endTime` variables to track the elapsed time and determine when to call the `functionPointer` and when to return `true`.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\AutoFunction.md"}}],["36",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\AutoFunctionManager.cs)\n\nThe `AutoFunctionManager` class is responsible for managing a collection of `AutoFunction` objects. It provides methods to add, update, and delete these objects.\n\nThe `autoFunctionMap` variable is a dictionary that stores `AutoFunction` objects. The key is an integer hash code generated from the `AutoFunction` object, and the value is the `AutoFunction` object itself. This allows for efficient lookup and retrieval of `AutoFunction` objects.\n\nThe `AddAutoFunction` method adds an `AutoFunction` object to the `autoFunctionMap` dictionary. It takes an `AutoFunction` object as a parameter, generates a hash code for it, and adds it to the dictionary using the hash code as the key. It also performs a check to ensure that the number of `AutoFunction` objects in the dictionary does not exceed 100.\n\nThe `AddRepeatFunction` and `AddEndFunction` methods are convenience methods that create new `AutoFunction` objects and add them to the `autoFunctionMap` dictionary. They take different parameters to specify the behavior of the `AutoFunction` objects.\n\nThe `Update` method is called every frame and iterates through all the `AutoFunction` objects in the `autoFunctionMap` dictionary. It calls the `Update` method of each `AutoFunction` object, which updates its internal state and returns a boolean value indicating whether the `AutoFunction` has completed. If an `AutoFunction` has completed, its key is added to a list.\n\nAfter iterating through all the `AutoFunction` objects, the `Update` method checks if there are any completed `AutoFunction` objects in the list. If there are, it calls the `DeleteAutoFunction` method to remove them from the `autoFunctionMap` dictionary.\n\nThe `DeleteAutoFunction` method removes an `AutoFunction` object from the `autoFunctionMap` dictionary. It takes an integer key as a parameter and checks if the key exists in the dictionary. If it does, it calls the `EndFunctionCall` method of the `AutoFunction` object to perform any necessary cleanup, and then removes the key-value pair from the dictionary.\n\nThe `DeleteOnly` method is a convenience method that removes an `AutoFunction` object from the `autoFunctionMap` dictionary without calling the `EndFunctionCall` method.\n\nThe `DeleteAllAutoFunction` method clears the `autoFunctionMap` dictionary, effectively removing all `AutoFunction` objects from it.\n\nOverall, the `AutoFunctionManager` class provides a centralized way to manage and control the execution of `AutoFunction` objects in the larger project. It allows for adding, updating, and deleting `AutoFunction` objects, and ensures that the number of `AutoFunction` objects does not exceed a certain limit.\n## Questions: \n 1. What is the purpose of the `AutoFunctionManager` class?\n- The `AutoFunctionManager` class is responsible for managing a dictionary of `AutoFunction` objects.\n\n2. What is the purpose of the `AddAutoFunction` method?\n- The `AddAutoFunction` method adds an `AutoFunction` object to the `autoFunctionMap` dictionary and returns its hash code.\n\n3. What is the purpose of the `Update` method?\n- The `Update` method iterates through the `autoFunctionMap` dictionary and calls the `Update` method of each `AutoFunction` object. If an `AutoFunction` object returns true from its `Update` method, it is added to a list and then removed from the dictionary.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\AutoFunctionManager.md"}}],["37",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\AutoLogout.cs)\n\nThe code provided is a script called \"AutoLogout\" in the Brick-Force project. This script is responsible for handling the automatic logout functionality in the game. \n\nThe script starts by declaring a private Texture2D variable called \"bg\" which is used to store the background texture for the logout screen. It also declares private string variables called \"token\" and \"tokens\" which are used to store login tokens.\n\nThe Awake() method is empty and does not contain any code.\n\nThe Start() method calls the ResetSingletons() method of the BuildOption.Instance object. This method is responsible for resetting all the singleton instances in the game.\n\nThe Update() method is empty and does not contain any code.\n\nThe OnGUI() method is responsible for drawing the logout screen on the game's user interface. It sets the GUI skin to the one obtained from the GUISkinFinder.Instance object. It also disables the GUI if a modal dialog is currently being displayed. It then draws the background texture on the screen and displays a text label using the LabelUtil.TextOut() method.\n\nThe Relogin() method is called when the player needs to re-login after being automatically logged out. It takes a string parameter called \"parameters\" which contains the login information. The method first checks if the game is running in the \"Runup\" build option. If it is, it extracts the login tokens from the parameters using the CommandInterpreter.ExtractValueFromParameterByRunup() method. It then sets the AutoLogin property of the MyInfoManager.Instance object to \"RUNUP\" and creates a new SockTcp object for the CSNetManager.Instance.SwitchAfter property. It then opens a connection to the RoundRobinIp and RoundRobinPort using the Open() method of the CSNetManager.Instance.SwitchAfter object. If the connection is successful, it closes the current connection. If the game is not running in the \"Runup\" build option, it checks if the game is running in the \"Netmarble\" build option. If it is, it sets the AutoLogin property of the MyInfoManager.Instance object to \"NETMARBLE\" and performs the same connection logic as before. If the game is not running in either the \"Runup\" or \"Netmarble\" build options, it extracts the login token and site code from the parameters using the CommandInterpreter.ExtractValueFromParameter() method. It then sets the AutoLogin property of the MyInfoManager.Instance object to \"INFERNUM\" and performs the same connection logic as before. \n\nThe OnRoundRobin() method is responsible for opening a connection to the BfServer and BfPort using the Open() method of the CSNetManager.Instance.SwitchAfter object. If the connection is successful, it closes the current connection.\n\nThe OnServiceFail() method is empty and does not contain any code.\n\nThe OnSeed() method is responsible for sending the appropriate auto login request to the server based on the AutoLogin property of the MyInfoManager.Instance object. It sends the login token and build version information to the server using the SendCS_AUTO_LOGIN_REQ() method of the CSNetManager.Instance.Sock object.\n\nThe OnLoginFail() method is empty and does not contain any code.\n\nIn summary, this script handles the automatic logout functionality in the game. It provides methods for re-logging in the player after being automatically logged out and handles the connection logic with the server. The OnGUI() method is responsible for drawing the logout screen on the game's user interface. The Relogin() method is called when the player needs to re-login and it determines the appropriate login method based on the build options. The OnRoundRobin() method is responsible for opening a connection to the server. The OnSeed() method sends the auto login request to the server.\n## Questions: \n 1. What is the purpose of the `Relogin` method and how is it used?\n- The `Relogin` method is used to handle different login scenarios based on the value of `BuildOption.Instance.IsRunup` and `BuildOption.Instance.IsNetmarble`. It sets the `AutoLogin` property of `MyInfoManager.Instance` and opens a new `SockTcp` connection if necessary.\n\n2. What is the purpose of the `OnRoundRobin` method and when is it called?\n- The `OnRoundRobin` method is called to open a new `SockTcp` connection to the Brick-Force server specified by `CSNetManager.Instance.BfServer` and `CSNetManager.Instance.BfPort`. It is likely called when a round-robin connection is needed.\n\n3. What is the purpose of the `OnSeed` method and what actions does it perform?\n- The `OnSeed` method sends different types of login requests to the server based on the value of `MyInfoManager.Instance.AutoLogin`. It uses the `CSNetManager.Instance.Sock` object to send the requests with appropriate parameters.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\AutoLogout.md"}}],["38",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\AutoRotator.cs)\n\nThe code provided is for a class called \"AutoRotator\" in the Brick-Force project. This class is responsible for automatically rotating a game object in Unity. \n\nThe class has a public enum called \"ROTATE\" which defines three possible rotation states: LEFT, STOP, and RIGHT. The enum is used to control the rotation direction of the game object.\n\nThere is a public float variable called \"rotateSpeed\" which determines the speed at which the game object rotates. This value can be adjusted to control the rotation speed.\n\nThe class also has a public variable called \"rotate\" of type ROTATE. This variable is used to store the current rotation state of the game object. It can be set to either LEFT, STOP, or RIGHT using the \"Rotate\" method.\n\nThe class has a private boolean variable called \"stopOnStart\" which determines whether the rotation should be stopped when the game object starts. If this variable is set to true, the \"rotate\" variable is set to STOP in the Start method.\n\nThe Update method is called every frame and is responsible for actually rotating the game object. It multiplies the current rotation state (stored in the \"rotate\" variable) by the rotateSpeed and the Time.deltaTime to calculate the rotation amount. It then calls the Rotate method of the game object's transform to apply the rotation.\n\nHere is an example of how this class can be used in the larger project:\n\n```csharp\npublic class RotatingObject : MonoBehaviour\n{\n    private AutoRotator autoRotator;\n\n    private void Start()\n    {\n        autoRotator = GetComponent<AutoRotator>();\n    }\n\n    private void Update()\n    {\n        if (Input.GetKeyDown(KeyCode.LeftArrow))\n        {\n            autoRotator.Rotate(AutoRotator.ROTATE.LEFT);\n        }\n        else if (Input.GetKeyDown(KeyCode.RightArrow))\n        {\n            autoRotator.Rotate(AutoRotator.ROTATE.RIGHT);\n        }\n        else if (Input.GetKeyDown(KeyCode.Space))\n        {\n            autoRotator.Rotate(AutoRotator.ROTATE.STOP);\n        }\n    }\n}\n```\n\nIn this example, the \"RotatingObject\" class is attached to a game object in the scene. It retrieves the \"AutoRotator\" component from the same game object in the Start method. Then, in the Update method, it checks for key presses and calls the \"Rotate\" method of the \"AutoRotator\" component with the appropriate rotation state based on the key press. This allows the player to control the rotation of the game object using the arrow keys and stop the rotation using the space key.\n## Questions: \n 1. What does the `ROTATE` enum represent and how is it used in this code? \nThe `ROTATE` enum represents the different rotation states: LEFT, STOP, and RIGHT. It is used to determine the direction of rotation in the `Update()` method.\n\n2. What is the purpose of the `rotateSpeed` variable and how does it affect the rotation? \nThe `rotateSpeed` variable determines the speed at which the object rotates. It is multiplied by the `rotate` enum value in the `Update()` method to control the rotation speed.\n\n3. What is the significance of the `stopOnStart` variable and how does it affect the initial rotation state? \nThe `stopOnStart` variable determines whether the object should stop rotating when the script starts. If it is set to true, the `rotate` enum is set to STOP in the `Start()` method, causing the object to initially not rotate.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\AutoRotator.md"}}],["39",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BackConfirmDialog.cs)\n\nThe code provided is a class called \"BackConfirmDialog\" that extends the \"Dialog\" class. This class is used to create a dialog box that prompts the user to confirm if they want to go back to a previous scene or cancel an action. \n\nThe class has several private variables, including a RenderTexture called \"thumbnail\", a string called \"text\", a boolean called \"isEditor\", and a UserMapInfo object called \"umi\". These variables are used to store information about the dialog box and the current state of the game.\n\nThe class also has a public float variable called \"msgY\" and a Vector2 variable called \"sizeOk\". These variables are used to set the position and size of the dialog box elements.\n\nThe class has a public method called \"InitDialog\" that takes in a string parameter \"textMore\" and a boolean parameter \"bEditor\". This method is used to initialize the dialog box with the given text and editor state.\n\nThe class has a private method called \"BackToScene\" that is called when the user confirms the action. This method performs several actions, including clearing the vote, leaving the current squad, shutting down the P2PManager, and loading a new scene.\n\nThe class also has a private method called \"GetCopyRight\" that checks if the current room type is a map editor and retrieves the user map info. This method returns a boolean value indicating if the user map info was successfully retrieved.\n\nThe class has a private method called \"ThumbnailToPNG\" that converts the thumbnail image to a PNG byte array. This method uses the RenderTexture and Texture2D classes to read the pixels from the thumbnail and encode them as a PNG.\n\nThe class overrides the \"DoDialog\" method from the base \"Dialog\" class. This method is responsible for rendering the dialog box and handling user input. The method uses the LabelUtil class to display text on the screen and the GlobalVars class to handle button clicks and key presses. The method also calls the \"GetCopyRight\" and \"ThumbnailToPNG\" methods when necessary.\n\nIn summary, the \"BackConfirmDialog\" class is used to create a dialog box that prompts the user to confirm if they want to go back to a previous scene or cancel an action. The class handles rendering the dialog box and handling user input. It also performs various actions when the user confirms the action, such as clearing the vote and loading a new scene.\n## Questions: \n 1. What is the purpose of the `BackConfirmDialog` class?\n- The `BackConfirmDialog` class is a subclass of the `Dialog` class and is used to display a confirmation dialog when the user wants to go back to a previous scene.\n\n2. What is the significance of the `thumbnail` variable?\n- The `thumbnail` variable is a `RenderTexture` object that is used to store a thumbnail image.\n\n3. What is the purpose of the `DoDialog` method?\n- The `DoDialog` method is responsible for rendering the dialog on the screen and handling user interactions with the dialog. It returns a boolean value indicating whether the dialog should be closed or not.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BackConfirmDialog.md"}}],["40",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Banner.cs)\n\nThe code provided is a class called \"Banner\" that represents a banner object in the larger Brick-Force project. The purpose of this class is to store information about a banner, such as its row, image path, action type, and action parameter. It also includes properties for accessing and modifying these values.\n\nThe class has private fields for the row, image path, action type, action parameter, texture, and a WWW object. These fields are used to store the corresponding values for a banner object.\n\nThe class also includes public properties for each of these fields. These properties provide a way to get and set the values of the fields. For example, the \"Row\" property allows getting and setting the value of the \"row\" field. This encapsulation ensures that the values can be accessed and modified in a controlled manner.\n\nThe class also includes a constructor that takes in the row, image path, action type, and action parameter as parameters. This constructor initializes the corresponding fields with the provided values. The \"bnnr\" and \"cdn\" fields are set to null initially.\n\nThis class can be used in the larger Brick-Force project to create and manage banner objects. For example, it can be used to create a list of banners that are displayed in the game. Each banner object can have its own row, image path, action type, and action parameter. The texture and WWW object can be used to load and display the banner image from a remote server.\n\nHere is an example of how this class can be used:\n\n```csharp\nBanner banner = new Banner(1, \"path/to/image.png\", 2, \"param\");\nbanner.Bnnr = LoadTextureFromURL(banner.ImagePath);\n```\n\nIn this example, a new banner object is created with the provided values. The \"Bnnr\" property is then used to load the texture from the image path and assign it to the banner object.\n\nOverall, this class provides a way to store and manage information about banners in the Brick-Force project. It encapsulates the data and provides properties for accessing and modifying it.\n## Questions: \n 1. **What is the purpose of the `Banner` class?**\nThe `Banner` class represents a banner object and contains properties and methods related to the banner.\n\n2. **What is the significance of the `Texture2D` and `WWW` types in this code?**\nThe `Texture2D` type is used to store the banner image, while the `WWW` type is used to handle web requests for the banner image.\n\n3. **What is the purpose of the constructor in the `Banner` class?**\nThe constructor initializes the properties of the `Banner` object with the provided values and sets the `bnnr` and `cdn` properties to null.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Banner.md"}}],["41",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BannerManager.cs)\n\nThe `BannerManager` class in the Brick-Force project is responsible for managing and displaying banner ads. It contains methods for adding ads, retrieving ads, and clearing the ads.\n\nThe class has a private field `ads` which is a `SortedDictionary<int, Banner>`. This dictionary stores the ads, with the row number as the key and a `Banner` object as the value. The `Banner` class represents an individual ad and contains properties for the image path, action type, action parameter, banner texture, and a reference to the CDN (Content Delivery Network) object.\n\nThe class also has a private static field `_instance` and a public static property `Instance`. This follows the Singleton design pattern and ensures that there is only one instance of the `BannerManager` class throughout the project. The `Instance` property returns the singleton instance of the `BannerManager` class.\n\nThe `Awake` method is called when the `BannerManager` object is created. It initializes the `ads` dictionary and ensures that the object is not destroyed when a new scene is loaded.\n\nThe `Clear` method clears all the ads from the `ads` dictionary.\n\nThe `AddAd` method is used to add a new ad to the `ads` dictionary. It takes parameters for the row number, image path, action type, and action parameter. If an ad with the same row number already exists in the dictionary, the existing ad is updated with the new values. The method then calls the `GetBanner` method to retrieve the updated banner object and starts a coroutine `LoadBannerTexture` to load the banner texture asynchronously.\n\nThe `GetBnnr` method returns the banner texture for a given row number. It checks if the row number exists in the `ads` dictionary and returns the banner texture if it exists.\n\nThe `GetBanner` method returns the `Banner` object for a given row number. It checks if the row number exists in the `ads` dictionary and returns the `Banner` object if it exists.\n\nThe `Count` method returns the number of ads in the `ads` dictionary.\n\nThe `Start` and `Update` methods are empty and not used in this class.\n\nThe `LoadBannerTexture` method is a coroutine that loads the banner texture from a URL. It takes a `Banner` object as a parameter. It constructs the URL using the image path from the `Banner` object and starts a `WWW` request to download the image. It then creates a new `Texture2D` object with a size of 128x128 and loads the image data into it. If the image fails to load, the `Texture2D` object is set to null. Otherwise, the texture is applied and the `WWW` object is disposed.\n\nOverall, the `BannerManager` class provides functionality for managing and displaying banner ads in the Brick-Force project. It allows for adding, retrieving, and clearing ads, as well as loading the banner textures asynchronously.\n## Questions: \n 1. What is the purpose of the `BannerManager` class?\n- The `BannerManager` class is responsible for managing banners in the game.\n\n2. What is the purpose of the `ads` variable?\n- The `ads` variable is a SortedDictionary that stores banners, with the key being the row number and the value being a `Banner` object.\n\n3. What is the purpose of the `LoadBannerTexture` coroutine?\n- The `LoadBannerTexture` coroutine is responsible for loading the banner texture from a URL and assigning it to the `Bnnr` property of a `Banner` object.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BannerManager.md"}}],["42",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BannerViewer.cs)\n\nThe code provided is a class called \"BannerViewer\" that is used to display and manage banners in a lobby scene. The purpose of this code is to handle the rendering and interaction of banners within the lobby.\n\nThe class has several private variables, including a default texture for the banner, a fade texture, a reference to the main lobby object, and various timing variables. It also has a public method called \"Start\" that initializes the class by setting the fade texture and banner ID.\n\nThe class has a method called \"SetupMain\" that takes a reference to the main lobby object and sets it to the \"main\" variable. This method is likely used to establish a connection between the banner viewer and the main lobby.\n\nThe main functionality of the class is implemented in the \"OnGUI\" method. This method is responsible for rendering the banners and handling user interaction. It first checks if the banner ID is less than 0, and if so, it renders the default banner texture using the \"TextureUtil.DrawTexture\" method.\n\nIf the banner ID is greater than or equal to 0, it retrieves the banner texture from the \"BannerManager\" class using the \"GetBnnr\" method. If the retrieved texture is null, it uses the default banner texture. It then renders the banner texture using the \"TextureUtil.DrawTexture\" method.\n\nThe method also checks if the fade texture is not null. If it is not null, it applies a fade effect to the banner by changing the GUI color and rendering the fade texture using the \"TextureUtil.DrawTexture\" method.\n\nThe method then creates an array of strings with the same length as the number of banners in the \"BannerManager\" class. It sets each element of the array to an empty string. It then uses the \"GUI.SelectionGrid\" method to create a selection grid for the banners, allowing the user to switch between different banners. If the user selects a different banner, the \"OnChangeBanner\" method is called.\n\nThe method also checks if the user clicks on the banner using the \"GlobalVars.Instance.MyButton\" method. If the user clicks on the banner, it retrieves the corresponding banner object from the \"BannerManager\" class and performs an action based on the banner's action type. The possible actions include opening a URL, opening the shop tree, buying an item, or sending a request to a server.\n\nThe \"Update\" method is responsible for updating the fade effect and automatically switching banners after a certain amount of time. It checks if the fade texture is not null and updates the fade effect by incrementing the \"deltaFade\" variable. If the \"deltaFade\" variable exceeds a certain threshold, the fade texture is set to null.\n\nThe method also checks if there are any banners in the \"BannerManager\" class. If there are, it checks if the mouse is outside the banner area. If it is, it increments the \"deltaTimeChangeBanner\" variable and checks if it exceeds a certain threshold. If it does, it switches to the next banner by incrementing the banner ID and calling the \"OnChangeBanner\" method.\n\nIn summary, the \"BannerViewer\" class is responsible for rendering and managing banners in a lobby scene. It allows the user to switch between different banners and perform actions based on the selected banner. It also includes a fade effect for the banners and automatically switches banners after a certain amount of time.\n## Questions: \n 1. What is the purpose of the `BannerViewer` class?\n- The `BannerViewer` class is responsible for displaying banners in the game's lobby.\n\n2. What is the significance of the `id` variable?\n- The `id` variable represents the index of the currently displayed banner.\n\n3. What actions can be performed when clicking on a banner?\n- Clicking on a banner can perform various actions depending on the `ActionType` of the banner, such as opening a URL, opening the shop tree, buying an item, or sending a request to the server.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BannerViewer.md"}}],["43",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BattleGuideDialog.cs)\n\nThe code provided is a class called `BattleGuideDialog` that extends the `Dialog` class. This class is used to create a dialog box that provides instructions or guidance to the player during a battle in the larger Brick-Force project.\n\nThe `BattleGuideDialog` class has several public fields that are used to reference UI elements within the dialog box, such as `imgList`, `labelList`, `reloadText`, `mouseText`, `speedUpText`, `toggle`, and `ok`. These fields are assigned values in the Unity editor or through code.\n\nThe `Start()` method sets the `id` field of the dialog to a specific value from an enum called `DIALOG_INDEX`. This is likely used to identify and manage different types of dialogs within the project.\n\nThe `OnPopup()` method calculates the position and size of the dialog box based on the screen size and the size of the dialog itself.\n\nThe `InitDialog()` method initializes the text of the `reloadText` and `speedUpText` labels based on the key bindings for the \"reload\" and \"forward\" actions. It uses the `custom_inputs` and `StringMgr` classes to retrieve the appropriate key bindings and format the text accordingly.\n\nThe `DoDialog()` method is the main method that is called to display and interact with the dialog box. It first sets the GUI skin to a specific skin obtained from the `GUISkinFinder` class. Then, it calls the `Draw()` method on the `imgList`, `labelList`, `reloadText`, `mouseText`, `toggle`, and `ok` UI elements to draw them on the screen. If a certain build option is enabled (`BuildOption.Instance.Props.useDefaultDash`), it also draws the `speedUpText` label.\n\nIf the `ok` button is clicked, the method checks if the `DontShowThisMessageAgain` property is true. If it is, it saves the \"donot_battle_guide\" option in the `MyInfoManager` class. Finally, the method checks if there are any active pop-up menus and consumes any input events if there are none.\n\nThe `BattleGuideDialog` class provides a way to display a dialog box with instructions or guidance during a battle in the Brick-Force project. It allows the player to interact with the dialog and potentially save their preferences for future battles.\n## Questions: \n 1. What is the purpose of the `BattleGuideDialog` class?\n- The `BattleGuideDialog` class is a subclass of `Dialog` and represents a dialog box for a battle guide.\n\n2. What is the purpose of the `InitDialog()` method?\n- The `InitDialog()` method initializes the dialog by setting the text of the `reloadText` and `speedUpText` labels based on custom inputs.\n\n3. What does the `DoDialog()` method do?\n- The `DoDialog()` method handles the drawing and interaction of the dialog elements, such as drawing the images, labels, and toggles, and checking for button clicks. It also saves the user's preference for not showing the message again if the \"ok\" button is clicked.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BattleGuideDialog.md"}}],["44",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BattleTutor.cs)\n\nThe `BattleTutor` class is a script that is part of the larger Brick-Force project. This script is responsible for managing the tutorial mode in the game. \n\nThe `Start()` method is called when the script is first initialized. It sets up various global variables and initializes the tutorial map. It also finds the `TutoInput` component attached to the \"Main\" game object.\n\nThe `InitializeFirstPerson()` method is called to initialize the first-person perspective for the player. It sets up the usable items for the player and spawns the player character at the appropriate location.\n\nThe `OnDisable()` method is called when the script is disabled. It checks if the game is still loading a level and performs cleanup tasks such as clearing the brick manager, disabling the palette manager, and resetting certain global variables.\n\nThe `OnGUI()` method is responsible for rendering the graphical user interface (GUI) elements for the tutorial mode. It displays a help box with a specific text and an icon. It also calls the `drawInputs()` method of the `TutoInput` component to render any tutorial-specific input prompts.\n\nThe `Update()` method is called every frame. It updates the state of the game, checks for user input, and performs various actions. It locks the cursor to the screen if certain conditions are met. It also checks if the tutorial map has been loaded and initializes the first-person perspective if it hasn't been done already. It also checks for button presses to open the main menu or the help window.\n\nThe `OnNoticeCenter()` method is a callback method that is called when a notice is received from the game's notice center. It adds the received message to the system inform instance.\n\nOverall, this script manages the tutorial mode in the game by setting up the tutorial map, initializing the player character, rendering the tutorial GUI elements, and handling user input. It is an essential part of the Brick-Force project as it provides a guided learning experience for new players.\n## Questions: \n 1. What is the purpose of the `InitializeFirstPerson()` method?\n- The `InitializeFirstPerson()` method is responsible for initializing the first-person perspective of the player character, including equipping usable items and spawning the character in the game world.\n\n2. What does the `OnGUI()` method do?\n- The `OnGUI()` method is responsible for rendering the graphical user interface (GUI) elements on the screen, including a help box and an icon.\n\n3. What is the purpose of the `OnNoticeCenter()` method?\n- The `OnNoticeCenter()` method is called when a notice is received from the game's notice center, and it adds the received message to the system inform message center.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BattleTutor.md"}}],["45",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BfCommand.cs)\n\nThe code provided defines a class called `BfCommand` that represents a command in the Brick-Force project. The purpose of this class is to encapsulate a command along with its arguments, allowing for easy manipulation and passing of commands within the project.\n\nThe class has three private fields: `cmd`, `arg1`, and `arg2`. `cmd` is of type `BF_COMMAND`, an enumeration that represents different types of commands. The `BF_COMMAND` enumeration includes values such as `WHISPER_CMD`, `CAMERA_CMD`, `GUI_CMD`, etc., each representing a specific command type. `arg1` and `arg2` are of type `string` and represent the arguments associated with the command.\n\nThe class provides public properties to access the private fields: `Cmd`, `Arg1`, and `Arg2`. These properties are read-only and allow external code to retrieve the values of the private fields.\n\nThe class also has a constructor that takes in three parameters: `_cmd`, `_arg1`, and `_arg2`. These parameters are used to initialize the private fields of the class. This constructor allows for the creation of a `BfCommand` object with the specified command type and arguments.\n\nThis `BfCommand` class can be used in the larger Brick-Force project to represent and handle different commands. For example, it can be used to create a command object for a whisper command with the sender and receiver as arguments:\n\n```csharp\nBfCommand whisperCommand = new BfCommand(BF_COMMAND.WHISPER_CMD, \"sender\", \"receiver\");\n```\n\nThe `BfCommand` object can then be passed to other parts of the project that handle commands, allowing them to easily access the command type and arguments.\n\nOverall, this code provides a simple and reusable way to represent and manipulate commands in the Brick-Force project.\n## Questions: \n 1. What is the purpose of the `BF_COMMAND` enum? \n- The `BF_COMMAND` enum is used to define different types of commands that can be executed in the Brick-Force project.\n\n2. What are the possible values for the `BF_COMMAND` enum? \n- The possible values for the `BF_COMMAND` enum are `NONE`, `WHISPER_CMD`, `CAMERA_CMD`, `GUI_CMD`, `GOD_CMD`, `GHOST_CMD`, `SPEED_CMD`, `STRAIGHT_MOVEMENT_CMD`, `INVISIBLE_CMD`, `MUTE_CMD`, and `BAN_CMD`.\n\n3. What is the purpose of the `BfCommand` class and its constructor? \n- The `BfCommand` class is used to represent a command in the Brick-Force project. The constructor is used to initialize the command, along with its two arguments.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BfCommand.md"}}],["46",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BfScript.cs)\n\nThe code provided is a class called `BfScript` that represents a script in the Brick-Force project. This class is responsible for storing and manipulating information about a script, including its alias, whether it should be enabled on awake, whether it should be visible on awake, and a list of script commands.\n\nThe `BfScript` class has several properties that allow access to its private fields. The `Alias` property gets and sets the value of the `alias` field. The `EnableOnAwake` property gets and sets the value of the `enableOnAwake` field. The `VisibleOnAwake` property gets and sets the value of the `visibleOnAwake` field. The `CmdList` property returns the `cmdList` field.\n\nThe class has a constructor that takes in the alias, enableOnAwake, visibleOnAwake, and cmdList as parameters. It initializes the `alias`, `enableOnAwake`, and `visibleOnAwake` fields with the provided values. It also initializes the `cmdList` field as a new empty list. It then splits the `_cmdList` parameter into an array of strings using the `ScriptCmd.CmdDelimeters` as the delimiter. It iterates over the array and creates a new `ScriptCmd` object for each element using the `ScriptCmdFactory.Create` method. It adds each created `ScriptCmd` object to the `cmdList` field.\n\nThe `BfScript` class also has a method called `GetCommandString` that returns a string representation of the script's commands. It iterates over the `cmdList` field and calls the `GetDescription` method on each `ScriptCmd` object to get its description. It concatenates the descriptions together with the `ScriptCmd.CmdDelimeters[0]` delimiter between them and returns the resulting string.\n\nOverall, this code provides a way to create and manage scripts in the Brick-Force project. It allows for the storage of script information and provides methods to retrieve and manipulate that information. This class can be used in the larger project to handle scripts and their commands. For example, it can be used to create and store different scripts, enable or disable scripts on awake, and retrieve the string representation of a script's commands.\n## Questions: \n 1. What is the purpose of the `BfScript` class?\n- The `BfScript` class represents a script in the Brick-Force project and contains properties and methods related to the script.\n\n2. What is the purpose of the `CmdList` property?\n- The `CmdList` property is a list of `ScriptCmd` objects, which represents the commands in the script.\n\n3. What does the `GetCommandString` method do?\n- The `GetCommandString` method returns a string that represents the description of each command in the `CmdList`, separated by a delimiter.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BfScript.md"}}],["47",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BF_PeeMOVE.cs)\n\nThe code provided defines a struct called `BF_PeeMOVE` which represents a data structure for storing information related to a movement action in the Brick-Force project. \n\nThe struct has three properties: `cc`, `isDead`, and `isRegularSend`. \n\nThe `cc` property is a byte that represents the movement command. It uses a bitwise AND operation with the value `0x3F` to extract the lower 6 bits of the `bitvector1` field. The `get` accessor returns the extracted value, while the `set` accessor updates the `bitvector1` field by performing a bitwise OR operation with the provided value.\n\nThe `isDead` property is a boolean that indicates whether the movement action results in the character's death. It uses a bitwise AND operation with the value `0x40` to check the 7th bit of the `bitvector1` field. The `get` accessor divides the result by 64 and compares it to 1 to determine if the character is dead. The `set` accessor updates the `bitvector1` field by performing a bitwise OR operation with the appropriate value based on the provided boolean value.\n\nThe `isRegularSend` property is a boolean that indicates whether the movement action is a regular send. It uses a bitwise AND operation with the value `0x80` to check the 8th bit of the `bitvector1` field. The `get` accessor divides the result by 128 and compares it to 1 to determine if it is a regular send. The `set` accessor updates the `bitvector1` field by performing a bitwise OR operation with the appropriate value based on the provided boolean value.\n\nThis struct is likely used in the larger Brick-Force project to store and manipulate movement-related data for characters or objects. It provides a compact way to store multiple properties in a single byte field, using bitwise operations to extract and update specific bits. This can be useful for optimizing memory usage and improving performance in scenarios where a large number of movement actions need to be processed. \n\nExample usage:\n\n```csharp\nBF_PeeMOVE move = new BF_PeeMOVE();\nmove.cc = 10; // Set the movement command to 10\nmove.isDead = true; // Set the character as dead\nmove.isRegularSend = false; // Set the movement as not a regular send\n\nConsole.WriteLine(move.cc); // Output: 10\nConsole.WriteLine(move.isDead); // Output: True\nConsole.WriteLine(move.isRegularSend); // Output: False\n```\n## Questions: \n 1. What is the purpose of the `bitvector1` field in the `BF_PeeMOVE` struct?\n- The `bitvector1` field is used to store multiple boolean flags in a single byte.\n\n2. How does the `cc` property work?\n- The `cc` property returns the lower 6 bits of `bitvector1`, effectively extracting a specific subset of flags.\n\n3. What is the purpose of the `isDead` property?\n- The `isDead` property is used to get or set the flag that indicates whether the object is dead.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BF_PeeMOVE.md"}}],["48",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BF_PeerCurMax.cs)\n\nThe code provided defines a struct called `BF_PeerCurMax`. This struct has two public properties: `cur` and `max`. \n\nThe `cur` property is a getter and setter that operates on a bitvector called `bitvector1`. The getter returns the value of `bitvector1` after applying a bitwise AND operation with the hexadecimal value `0x3FF`. This operation effectively extracts the 10 least significant bits of `bitvector1`. The setter performs a bitwise OR operation between the input value and `bitvector1`, effectively setting the 10 least significant bits of `bitvector1` to the input value.\n\nThe `max` property is similar to the `cur` property, but with a different bitmask and scaling factor. The getter applies a bitwise AND operation with the hexadecimal value `0xFFC00` to `bitvector1`, effectively extracting the 10 bits between the 11th and 21st least significant bits. This value is then divided by 1024 to obtain the final result. The setter performs a multiplication of the input value by 1024 and then performs a bitwise OR operation with `bitvector1`, effectively setting the 10 bits between the 11th and 21st least significant bits of `bitvector1` to the scaled input value.\n\nThis struct seems to be used to store and manipulate two values, `cur` and `max`, which are represented as bitfields within a single 32-bit unsigned integer (`bitvector1`). The purpose of this struct is not clear from the provided code alone, but it could potentially be used to represent and manipulate current and maximum values in a game or simulation context. For example, it could be used to store and update the current and maximum health of a character in a game.\n## Questions: \n 1. What is the purpose of the `bitvector1` field in the `BF_PeerCurMax` struct?\n- The `bitvector1` field is used to store a bit vector that represents the current and maximum values.\n\n2. How is the `cur` property calculated and what does it represent?\n- The `cur` property is calculated by performing a bitwise AND operation between `bitvector1` and `0x3FF`, and it represents the current value.\n\n3. How is the `max` property calculated and what does it represent?\n- The `max` property is calculated by performing a bitwise AND operation between `bitvector1` and `0xFFC00`, dividing the result by 1024, and it represents the maximum value.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BF_PeerCurMax.md"}}],["49",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BF_PeerFIRE.cs)\n\nThe code provided defines a struct called `BF_PeerFIRE`. This struct has two public properties: `slot` and `ammoId`. \n\nThe `slot` property is a ushort (unsigned short) that represents a slot number. The getter of the `slot` property returns the lower 4 bits of the `bitvector1` field, which is a bit vector represented by another ushort. The setter of the `slot` property sets the lower 4 bits of the `bitvector1` field to the specified value.\n\nThe `ammoId` property is also a ushort that represents an ammo ID. The getter of the `ammoId` property returns the upper 12 bits of the `bitvector1` field, which are obtained by performing a bitwise AND operation with 0xFFF0 and then dividing the result by 16. The setter of the `ammoId` property sets the upper 12 bits of the `bitvector1` field to the specified value multiplied by 16.\n\nThe purpose of this code is to provide a convenient way to access and manipulate the `slot` and `ammoId` properties of a `BF_PeerFIRE` object. This struct may be used in the larger Brick-Force project to represent a peer's firing information, such as the slot number and ammo ID of a weapon they are using. By encapsulating these properties within a struct, the code provides a simple and efficient way to store and retrieve this information.\n\nHere is an example of how this code may be used in the larger project:\n\n```csharp\nBF_PeerFIRE peerFire = new BF_PeerFIRE();\npeerFire.slot = 3;\npeerFire.ammoId = 256;\n\nConsole.WriteLine($\"Slot: {peerFire.slot}\"); // Output: Slot: 3\nConsole.WriteLine($\"Ammo ID: {peerFire.ammoId}\"); // Output: Ammo ID: 256\n```\n\nIn this example, a `BF_PeerFIRE` object is created and its `slot` and `ammoId` properties are set. The values of these properties are then printed to the console.\n## Questions: \n 1. **What is the purpose of the `BF_PeerFIRE` struct?**\nThe `BF_PeerFIRE` struct appears to represent a peer's firing information, including the slot and ammo ID.\n\n2. **What does the `slot` property do?**\nThe `slot` property returns the lower 4 bits of the `bitvector1` field, representing the slot number.\n\n3. **What does the `ammoId` property do?**\nThe `ammoId` property returns the upper 12 bits of the `bitvector1` field, divided by 16, representing the ammo ID.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BF_PeerFIRE.md"}}],["50",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BF_PeerHITBRICKMAN_NEW.cs)\n\nThe code provided defines a struct called `BF_PeerHITBRICKMAN_NEW`. This struct is used to store information about a hit on a brickman in the Brick-Force project. \n\nThe struct has several properties: `slot`, `ammoId`, `damage`, `hitpart`, and `lucky`. Each property has a getter and a setter method that manipulate a bitvector called `bitvector1`. \n\nThe `slot` property represents the slot number of the brickman that was hit. It uses a bitwise AND operation to extract the 3 least significant bits from `bitvector1`. The setter method uses a bitwise OR operation to set the value of `slot` in `bitvector1`.\n\nThe `ammoId` property represents the ID of the ammunition used for the hit. It uses a bitwise AND operation to extract the 9 bits starting from the 4th least significant bit from `bitvector1`. The getter method then divides the extracted value by 8 to get the actual `ammoId`. The setter method multiplies the input value by 8 and uses a bitwise OR operation to set the value of `ammoId` in `bitvector1`.\n\nThe `damage` property represents the amount of damage caused by the hit. It uses a bitwise AND operation to extract the 20 bits starting from the 13th least significant bit from `bitvector1`. The getter method then divides the extracted value by 4096 to get the actual `damage`. The setter method multiplies the input value by 4096 and uses a bitwise OR operation to set the value of `damage` in `bitvector1`.\n\nThe `hitpart` property represents the part of the brickman that was hit. It uses a bitwise AND operation to extract the 3 bits starting from the 29th least significant bit from `bitvector1`. The getter method then divides the extracted value by 268435456 to get the actual `hitpart`. The setter method multiplies the input value by 268435456 and uses a bitwise OR operation to set the value of `hitpart` in `bitvector1`.\n\nThe `lucky` property represents whether the hit was lucky or not. It uses a bitwise AND operation to extract the most significant bit from `bitvector1`. The getter method then converts the extracted value to an unsigned integer by dividing it by 2147483648. The setter method multiplies the input value by -2147483648 and uses a bitwise OR operation to set the value of `lucky` in `bitvector1`.\n\nOverall, this struct provides a way to store and manipulate information about a hit on a brickman in the Brick-Force project. It allows for easy access and modification of the various properties related to the hit.\n## Questions: \n 1. What is the purpose of the `bitvector1` field in the `BF_PeerHITBRICKMAN_NEW` struct?\n- The `bitvector1` field is used to store multiple bit flags that represent different properties of the `BF_PeerHITBRICKMAN_NEW` struct.\n\n2. How is the `slot` property calculated and what does it represent?\n- The `slot` property is calculated by performing a bitwise AND operation between `bitvector1` and 7. It represents the slot number of the brick.\n\n3. What is the purpose of the `lucky` property and how is it calculated?\n- The `lucky` property represents a boolean value indicating whether the hit was lucky or not. It is calculated by performing a bitwise AND operation between `bitvector1` and -2147483648, and then dividing the result by 2147483648.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BF_PeerHITBRICKMAN_NEW.md"}}],["51",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BF_PeerHP.cs)\n\nThe code provided defines a struct called `BF_PeerHP` which represents the health and armor of a peer in the Brick-Force project. The struct has three properties: `hp`, `armor`, and `maxArmor`.\n\nThe `hp` property represents the current health of the peer. It uses a bitwise AND operation (`&`) with a hexadecimal value `0x3FF` to extract the lower 10 bits of the `bitvector1` field. This ensures that the returned value is within the range of 0 to 1023.\n\nThe `armor` property represents the current armor of the peer. It also uses a bitwise AND operation with a hexadecimal value `0xFFC00` to extract the middle 10 bits of the `bitvector1` field. The extracted value is then divided by 1024 to get the actual armor value. This ensures that the returned value is within the range of 0 to 1023.\n\nThe `maxArmor` property represents the maximum armor capacity of the peer. It uses a bitwise AND operation with a negative hexadecimal value `-1048576` to extract the upper 10 bits of the `bitvector1` field. The extracted value is then divided by 1048576 to get the actual maximum armor value. This ensures that the returned value is within the range of 0 to 1023.\n\nThe `set` accessors for all three properties update the `bitvector1` field by performing bitwise OR operations (`|`) with the provided value. This allows the properties to be set individually without affecting the other properties.\n\nThis struct can be used in the larger Brick-Force project to represent the health and armor of peers in the game. It provides a convenient way to store and manipulate these values using bitwise operations. For example, a game engine could use this struct to update the health and armor of a peer during gameplay:\n\n```csharp\nBF_PeerHP peerHP = new BF_PeerHP();\npeerHP.hp = 500; // Set the health of the peer to 500\npeerHP.armor = 750; // Set the armor of the peer to 750\npeerHP.maxArmor = 1000; // Set the maximum armor capacity of the peer to 1000\n\nConsole.WriteLine(peerHP.hp); // Output: 500\nConsole.WriteLine(peerHP.armor); // Output: 750\nConsole.WriteLine(peerHP.maxArmor); // Output: 1000\n```\n\nOverall, this code provides a compact and efficient way to represent and manipulate the health and armor values of peers in the Brick-Force project.\n## Questions: \n 1. What does the `bitvector1` variable represent and how is it used in the code?\n- The `bitvector1` variable is used to store multiple values related to the `BF_PeerHP` struct. It is used in the getter and setter methods of the `hp`, `armor`, and `maxArmor` properties to manipulate and retrieve specific bits of the `bitvector1` value.\n\n2. What is the purpose of the `hp`, `armor`, and `maxArmor` properties?\n- The `hp` property returns the value of the first 10 bits of `bitvector1`, representing the hit points of a peer. The `armor` property returns the value of the next 10 bits of `bitvector1`, representing the armor of a peer. The `maxArmor` property returns the value of the remaining bits of `bitvector1`, representing the maximum armor of a peer.\n\n3. How are the values of `hp`, `armor`, and `maxArmor` set and retrieved?\n- The values of `hp`, `armor`, and `maxArmor` are set and retrieved using the getter and setter methods defined in the code. The getter methods use bitwise operations to extract specific bits from `bitvector1`, while the setter methods use bitwise operations to modify specific bits of `bitvector1`.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BF_PeerHP.md"}}],["52",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BF_PeerINITIATE.cs)\n\nThe code provided defines a struct called `BF_PeerINITIATE`. This struct represents a peer in the Brick-Force project. \n\nThe struct has several properties that provide access to different attributes of the peer. \n\nThe `cc` property represents the peer's cc (character class) value. It is a 7-bit value obtained by performing a bitwise AND operation between the `bitvector1` field and the hexadecimal value `0x7F`. The `cc` property also has a setter that updates the `bitvector1` field by performing a bitwise OR operation between the current value of `bitvector1` and the new value of `cc`.\n\nThe `curWeaponType` property represents the peer's current weapon type. It is a 7-bit value obtained by performing a bitwise AND operation between the `bitvector1` field and the hexadecimal value `0x1F80`, and then dividing the result by 128. The `curWeaponType` property also has a setter that updates the `bitvector1` field by performing a bitwise OR operation between the current value of `bitvector1` and the new value of `curWeaponType` multiplied by 128.\n\nThe `empty` property represents whether the peer is empty or not. It is a boolean value obtained by performing a bitwise AND operation between the `bitvector1` field and the hexadecimal value `0x2000`, and then dividing the result by 8192. The `empty` property also has a setter that updates the `bitvector1` field by performing a bitwise OR operation between the current value of `bitvector1` and the new value of `empty` multiplied by 8192.\n\nThe `dead` property represents whether the peer is dead or not. It is a boolean value obtained by performing a bitwise AND operation between the `bitvector1` field and the hexadecimal value `0x4000`, and then dividing the result by 16384. The `dead` property also has a setter that updates the `bitvector1` field by performing a bitwise OR operation between the current value of `bitvector1` and the new value of `dead` multiplied by 16384.\n\nThe `invisibility` property represents whether the peer is invisible or not. It is a boolean value obtained by performing a bitwise AND operation between the `bitvector1` field and the hexadecimal value `0x8000`, and then dividing the result by 32768. The `invisibility` property also has a setter that updates the `bitvector1` field by performing a bitwise OR operation between the current value of `bitvector1` and the new value of `invisibility` multiplied by 32768.\n\nOverall, this code provides a way to access and modify different attributes of a peer in the Brick-Force project using a single struct. This struct can be used in the larger project to represent and manipulate peers in various scenarios, such as updating their character class, weapon type, and status (empty, dead, invisible).\n## Questions: \n 1. What is the purpose of the `bitvector1` field in the `BF_PeerINITIATE` struct?\n- The `bitvector1` field is used to store multiple boolean flags that represent different properties of a peer.\n\n2. How is the `cc` property calculated and what does it represent?\n- The `cc` property is calculated by performing a bitwise AND operation between `bitvector1` and `0x7F`. It represents a value related to the peer.\n\n3. How are the `curWeaponType`, `empty`, `dead`, and `invisibility` properties calculated and what do they represent?\n- These properties are calculated by performing bitwise operations on `bitvector1` and specific bit masks. They represent different boolean flags indicating the state of the peer's weapon type, emptiness, death, and invisibility.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BF_PeerINITIATE.md"}}],["53",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BF_PeerSHOOT.cs)\n\nThe code provided defines a struct called `BF_PeerSHOOT` which represents a shooting event in the Brick-Force project. This struct contains three properties: `lucky`, `hitpart`, and `damage`.\n\nThe `lucky` property is a boolean value that indicates whether the shooting event was lucky or not. It is implemented using a bitwise operation on the `bitvector1` field. The `bitvector1` field is a 16-bit unsigned integer that stores various bit flags related to the shooting event. The least significant bit of `bitvector1` is used to represent the `lucky` property. If the least significant bit is set to 1, the `lucky` property is true; otherwise, it is false.\n\nThe `hitpart` property represents the part of the target that was hit during the shooting event. It is implemented using another bitwise operation on the `bitvector1` field. The 4th, 5th, and 6th bits of `bitvector1` are used to represent the `hitpart` property. These bits are extracted from `bitvector1` and divided by 2 to get the actual value of `hitpart`.\n\nThe `damage` property represents the amount of damage caused by the shooting event. It is also implemented using a bitwise operation on the `bitvector1` field. The 5th to 16th bits of `bitvector1` are used to represent the `damage` property. These bits are extracted from `bitvector1` and divided by 16 to get the actual value of `damage`.\n\nThis struct is likely used in the larger Brick-Force project to represent shooting events and store relevant information about each event. It provides a convenient way to access and manipulate the properties of a shooting event using bitwise operations on a single integer field. For example, the `lucky` property can be used to determine if a shooting event was lucky or not, and the `damage` property can be used to calculate the amount of damage caused by the event.\n\nHere is an example of how this struct could be used in the larger project:\n\n```csharp\nBF_PeerSHOOT shootingEvent = new BF_PeerSHOOT();\nshootingEvent.lucky = true;\nshootingEvent.hitpart = 3;\nshootingEvent.damage = 80;\n\nConsole.WriteLine($\"Lucky: {shootingEvent.lucky}\");\nConsole.WriteLine($\"Hit Part: {shootingEvent.hitpart}\");\nConsole.WriteLine($\"Damage: {shootingEvent.damage}\");\n```\n\nOutput:\n```\nLucky: True\nHit Part: 1\nDamage: 5\n```\n\nIn this example, a shooting event is created and its properties are set. The `lucky` property is set to true, indicating that the shooting event was lucky. The `hitpart` property is set to 3, indicating that the third part of the target was hit. The `damage` property is set to 80, indicating that 80 units of damage were caused by the shooting event. The values of these properties are then printed to the console.\n## Questions: \n 1. What does the `bitvector1` variable represent and how is it used in this code? \n- The `bitvector1` variable is a ushort that is used to store multiple boolean values in its bits. It is used to store information about the `lucky`, `hitpart`, and `damage` properties.\n\n2. How is the `lucky` property implemented and what does it represent? \n- The `lucky` property is implemented as a boolean property that represents whether the peer is lucky or not. It is determined by the least significant bit of the `bitvector1` variable.\n\n3. How are the `hitpart` and `damage` properties implemented and what do they represent? \n- The `hitpart` and `damage` properties are implemented as integer properties that represent the hit part and damage values respectively. They are calculated based on specific bits of the `bitvector1` variable.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BF_PeerSHOOT.md"}}],["54",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BF_PEER_HIT_BRICKMAN.cs)\n\nThe code provided defines a struct called `BF_PEER_HIT_BRICKMAN`. This struct represents a hit on a brickman in the Brick-Force project. It contains three properties: `lucky`, `part`, and `curammo`.\n\nThe `lucky` property is a boolean value that indicates whether the hit was lucky or not. It is implemented using a bitvector. The least significant bit of the `bitvector1` field is used to store the value of `lucky`. When the `lucky` property is accessed, the code checks the value of the least significant bit and returns `true` if it is 1, and `false` otherwise. When the `lucky` property is set, the code sets the least significant bit of `bitvector1` to 1 if the value is `true`, and 0 otherwise.\n\nThe `part` property represents the part of the brickman that was hit. It is also implemented using the `bitvector1` field. The 5 bits starting from the second least significant bit of `bitvector1` are used to store the value of `part`. When the `part` property is accessed, the code extracts these 5 bits, divides the resulting value by 2, and returns the integer result. When the `part` property is set, the code multiplies the value by 2 and sets the corresponding bits in `bitvector1`.\n\nThe `curammo` property represents the current amount of ammunition. It is also implemented using the `bitvector1` field. The 11 bits starting from the sixth least significant bit of `bitvector1` are used to store the value of `curammo`. When the `curammo` property is accessed, the code extracts these 11 bits, divides the resulting value by 32, and returns the integer result. When the `curammo` property is set, the code multiplies the value by 32 and sets the corresponding bits in `bitvector1`.\n\nThis struct is likely used in the larger Brick-Force project to represent hits on brickmen and store information about the hit, such as whether it was lucky, which part of the brickman was hit, and the current amount of ammunition. It provides a compact way to store this information using a bitvector, which can be useful for efficient memory usage and serialization.\n## Questions: \n 1. What does the `bitvector1` variable represent and how is it used in this code? \n- The `bitvector1` variable is a ushort that is used to store multiple boolean values in its bits. It is used to store different properties of a brickman.\n\n2. What is the purpose of the `lucky` property and how is it calculated? \n- The `lucky` property represents whether the brickman is lucky or not. It is calculated by checking the least significant bit of `bitvector1` and returning true if it is 1, otherwise false.\n\n3. How are the `part` and `curammo` properties calculated and what do they represent? \n- The `part` property represents the part of the brickman and is calculated by extracting bits 1-5 from `bitvector1` and dividing the result by 2. The `curammo` property represents the current ammo of the brickman and is calculated by extracting bits 6-15 from `bitvector1` and dividing the result by 32.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BF_PEER_HIT_BRICKMAN.md"}}],["55",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\bgmPlayer.cs)\n\nThe code provided is a script for a background music player in the Brick-Force project. This script is attached to a GameObject in the Unity game engine and is responsible for playing background music in the game.\n\nThe script starts by declaring an array of AudioClips called \"bgm\", which will hold the different background music tracks that can be played. It also defines two variables, \"minDelay\" and \"maxDelay\", which determine the minimum and maximum delay times between playing different tracks.\n\nIn the Start() method, the Play() method is called to start playing the background music. \n\nThe Play() method first checks if the GameObject has an AudioSource component attached to it and if the \"bgm\" array is not empty. If these conditions are met, the method proceeds to select a random AudioClip from the \"bgm\" array and assigns it to the AudioSource component. It also sets the delayTime variable to a random value between \"minDelay\" and \"maxDelay\". Finally, it calls the Play() method on the AudioSource component to start playing the selected background music track.\n\nIn the Update() method, it checks if the AudioSource component is not playing any audio. If this condition is true, it increments the deltaTime variable by the time that has passed since the last frame. If the deltaTime exceeds the delayTime, it calls the Play() method again to play a new random background music track.\n\nThis script allows for dynamic and random selection of background music tracks, with a customizable delay between each track. It can be used in the larger Brick-Force project to provide a more immersive and varied audio experience for the players.\n## Questions: \n 1. What is the purpose of the `bgmPlayer` class?\n- The `bgmPlayer` class is responsible for playing background music (bgm) in the game.\n\n2. How is the delay time for playing the next bgm determined?\n- The delay time is randomly generated between the `minDelay` and `maxDelay` values.\n\n3. What happens if there is no `AudioSource` component attached to the game object or if the `bgm` array is empty?\n- If there is no `AudioSource` component or if the `bgm` array is empty, the `Play()` method will not be executed and no bgm will be played.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\bgmPlayer.md"}}],["56",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BitField.cs)\n\nThe code provided defines a class called `BitField` that contains two static methods: `AddToBitfield` and `ReadFromBitfield`. The purpose of this class is to manipulate a bitfield, which is a data structure that represents a sequence of bits.\n\nThe `AddToBitfield` method takes three parameters: `ref int bitfield`, `int bitCount`, and `int value`. It adds the `value` to the `bitfield` by shifting the `bitfield` to the left by `bitCount` positions and then performing a bitwise OR operation with the `value`. This effectively appends the `value` to the rightmost `bitCount` bits of the `bitfield`. The `bitfield` parameter is passed by reference, meaning that any changes made to it inside the method will be reflected outside of the method.\n\nHere is an example usage of the `AddToBitfield` method:\n\n```csharp\nint bitfield = 0b1010; // Initial bitfield value\nint bitCount = 2; // Number of bits to add\nint value = 0b11; // Value to add\n\nBitField.AddToBitfield(ref bitfield, bitCount, value);\n\nConsole.WriteLine(Convert.ToString(bitfield, 2)); // Output: 101011\n```\n\nThe `ReadFromBitfield` method takes two parameters: `ref int bitfield` and `int bitCount`. It reads the rightmost `bitCount` bits from the `bitfield` by performing a bitwise AND operation with a mask that consists of `bitCount` ones. It then shifts the `bitfield` to the right by `bitCount` positions. The method returns the extracted bits as an integer. Similar to `AddToBitfield`, the `bitfield` parameter is passed by reference.\n\nHere is an example usage of the `ReadFromBitfield` method:\n\n```csharp\nint bitfield = 0b101011; // Bitfield value\nint bitCount = 2; // Number of bits to read\n\nint extractedBits = BitField.ReadFromBitfield(ref bitfield, bitCount);\n\nConsole.WriteLine(Convert.ToString(extractedBits, 2)); // Output: 11\nConsole.WriteLine(Convert.ToString(bitfield, 2)); // Output: 1010\n```\n\nIn the larger project, this `BitField` class can be used to efficiently store and retrieve values that can be represented as a sequence of bits. It provides a way to manipulate individual bits within a larger bitfield, which can be useful in various scenarios such as encoding and decoding data, implementing custom data structures, or optimizing memory usage.\n## Questions: \n 1. **What is the purpose of the BitField class?**\nThe BitField class appears to be a utility class for manipulating and reading values from a bitfield.\n\n2. **What does the AddToBitfield method do?**\nThe AddToBitfield method adds a value to the bitfield by shifting the existing bits and then OR-ing the value.\n\n3. **What does the ReadFromBitfield method do?**\nThe ReadFromBitfield method reads a value from the bitfield by performing a bitwise AND operation with a mask and then shifting the bitfield.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BitField.md"}}],["57",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BlackHole.cs)\n\nThe code provided is a script for a BlackHole object in the Brick-Force project. This script is responsible for creating and managing a black hole in the game world.\n\nThe script contains several public and private variables. The public variables include `objBlackhole`, which is a reference to the black hole game object, and `fxOn`, which is a reference to a visual effect that is played when the black hole is activated. The private variables include `posOn`, which stores the position of the black hole, and `users`, which is an array of Vector3 positions representing the positions of users around the black hole.\n\nThe script provides several methods for interacting with the black hole. The `placeTo` method is used to place the black hole at a specified position. It instantiates the `objBlackhole` game object at the given position and sets `posOn` to the same position. It then calls the `makeUserPositions` method to calculate the positions of the users around the black hole.\n\nThe `On` method is used to activate the black hole. It instantiates the `fxOn` visual effect at the `posOn` position.\n\nThe `makeUserPositions` method calculates the positions of the users around the black hole. It takes the black hole position as a parameter and initializes the `users` array with 8 Vector3 positions. It then modifies the positions based on the black hole position to create a circular pattern of users around the black hole.\n\nThe `gotoPos` method is used to retrieve the position of a user based on their ID. It takes an ID as a parameter and returns the corresponding position from the `users` array.\n\nOverall, this script provides functionality for creating and managing a black hole in the game world. It allows for placing the black hole at a specified position, activating it, and retrieving the positions of users around the black hole. This script can be used in the larger Brick-Force project to add black hole mechanics to the game. For example, it could be used to create a level where players have to navigate around black holes to reach their objectives.\n## Questions: \n 1. What does the `placeTo` method do and how is it used?\n- The `placeTo` method instantiates a black hole object at a given position and updates the `posOn` variable. It is likely used to place the black hole in the game world.\n\n2. What is the purpose of the `makeUserPositions` method?\n- The `makeUserPositions` method calculates and sets the positions of users around the black hole. It is likely used to position other game objects or characters relative to the black hole.\n\n3. How is the `gotoPos` method used and what does it return?\n- The `gotoPos` method takes an integer `id` as input and returns the corresponding position from the `users` array. It is likely used to retrieve the position of a specific user based on their ID.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BlackHole.md"}}],["58",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BlackHoleItem.cs)\n\nThe code provided is a class called \"BlackHoleItem\" that inherits from the \"ActiveItemBase\" class. This class represents an item in the game called \"Black Hole\". \n\nThe purpose of this code is to define the behavior of the \"Black Hole\" item when it is used by a player. The \"StartItem\" method is called when the item is activated. \n\nThe code first finds the \"BlackHole\" component in the scene by searching for a GameObject named \"Main\". If the component is found, the \"On\" method of the \"BlackHole\" component is called. This suggests that the \"BlackHole\" component is responsible for the visual and gameplay effects of the black hole in the game.\n\nNext, the code checks if the player using the item is not the same as the player who activated it. If this condition is true, the code performs several actions. \n\nFirst, it finds the GameObject representing the player using the item by searching for a GameObject named \"Me\". If the GameObject is found, it gets the \"LocalController\" component attached to it. If the \"LocalController\" component is found, it checks if the player is not dead, not in the process of respawning, and the black hole is not already activated for the player. If these conditions are met, it calls the \"sparcleFXOn\" method of the \"LocalController\" component. This suggests that the \"sparcleFXOn\" method is responsible for activating visual effects on the player when the black hole is used.\n\nThen, it finds the GameObject representing the player using the item again and gets the \"BlackholeScreenFX\" component attached to it. If the component is found, it calls the \"Reset\" method of the \"BlackholeScreenFX\" component, passing in the \"useUserSeq\" value. This suggests that the \"Reset\" method is responsible for resetting the visual effects of the black hole screen.\n\nFinally, it gets the \"BrickManDesc\" object associated with the player using the item by calling the \"GetDesc\" method of the \"BrickManManager\" class, passing in the \"useUserSeq\" value. If the \"BrickManDesc\" object is found, it shows a system message with a formatted string that includes the nickname of the player. This suggests that the \"ShowMessage\" method of the \"SystemMsgManager\" class is responsible for displaying system messages in the game.\n\nIn summary, this code defines the behavior of the \"Black Hole\" item when it is used by a player. It activates the black hole visual and gameplay effects, triggers visual effects on the player, resets the black hole screen effects, and shows a system message with the nickname of the player using the item.\n## Questions: \n 1. What is the purpose of the `BlackHoleItem` class and how is it used in the project?\n- The `BlackHoleItem` class is a subclass of `ActiveItemBase` and it overrides the `StartItem()` method. It seems to be responsible for activating a black hole in the game, but more context is needed to understand its exact purpose and usage.\n\n2. What is the significance of the `MyInfoManager.Instance.Seq` variable and how does it relate to the `useUserSeq` variable?\n- The code checks if `MyInfoManager.Instance.Seq` is not equal to `useUserSeq` before executing certain actions. Understanding the purpose and relationship between these variables would provide insight into the conditions under which those actions are performed.\n\n3. What is the purpose of the `BlackholeScreenFX` component and how does it interact with the `BlackHole` component?\n- The code finds a `BlackholeScreenFX` component on the \"Me\" game object and calls its `Reset()` method with the `useUserSeq` parameter. Understanding the relationship between `BlackholeScreenFX` and `BlackHole` components would clarify their roles and how they work together in the game.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BlackHoleItem.md"}}],["59",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BlackholeScreenFX.cs)\n\nThe code provided is a script for a BlackholeScreenFX class in the Brick-Force project. This class is responsible for creating a visual effect on the screen when a black hole is activated in the game. \n\nThe class has several public and private variables that are used to control the behavior of the effect. The \"guiDepth\" variable determines the layer at which the GUI elements will be rendered. The \"shieldFx\" variable is a texture that will be used for the effect. The \"clrFrom\" and \"clrTo\" variables define the starting and ending colors of the effect. The \"sndStart\" and \"sndEnd\" variables are audio clips that will be played when the effect starts and ends.\n\nThe class also has a private variable called \"localController\" which is used to reference the LocalController component attached to the same game object. The \"VerifyLocalController\" method is used to check if the \"localController\" variable is null and if so, it assigns the LocalController component to it.\n\nThe \"Start\" method is called when the script is first initialized and it calls the \"VerifyLocalController\" method.\n\nThe \"OnGUI\" method is called every frame and it is responsible for rendering the GUI elements for the effect. It sets the GUI skin and depth, and then calculates the current color of the effect based on the \"deltaTime\" variable. It then sets the GUI color to this calculated color.\n\nThe \"Reset\" method is called when the black hole effect needs to be reset. It resets the \"deltaTime\" variable, sets the \"showFx\" variable to true, plays the \"sndStart\" audio clip, and enables a screen brightness effect.\n\nThe \"Update\" method is called every frame and it is responsible for updating the state of the effect. It increments the \"deltaTime\" variable by the time since the last frame, and if the \"deltaTime\" exceeds a certain threshold (3 seconds in this case), it stops the effect. It also checks if the \"localController\" is not null and if the effect is still being shown. If these conditions are met, it sends a network message to activate the black hole effect, updates the position of the \"localController\" based on the black hole's position, and plays the \"sndEnd\" audio clip if the current user is the one who activated the black hole.\n\nIn summary, this code is responsible for creating and managing the visual and audio effects of a black hole in the game. It handles rendering the effect on the screen, playing audio clips, and updating the game state when the black hole is activated.\n## Questions: \n 1. What is the purpose of the `BlackholeScreenFX` class?\n- The `BlackholeScreenFX` class is responsible for displaying a visual effect on the screen when a black hole is activated in the game.\n\n2. What is the significance of the `shieldFx` variable?\n- The `shieldFx` variable is a Texture2D object that is likely used to display a shield effect during the black hole activation.\n\n3. What is the purpose of the `Reset` method?\n- The `Reset` method is called to reset the state of the `BlackholeScreenFX` object and initiate the black hole activation sequence.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BlackholeScreenFX.md"}}],["60",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BlastModeConfig.cs)\n\nThe code provided is a class called \"BlastModeConfig\" that is used in the larger Brick-Force project. This class is responsible for configuring and displaying the settings and options for a specific game mode called \"Blast Mode\". \n\nThe class contains various properties and methods that handle the graphical user interface (GUI) elements and logic for displaying and interacting with the Blast Mode configuration. \n\nThe class has a number of private fields that store the positions, sizes, and textures for various GUI elements such as thumbnails, buttons, and labels. These fields are used to position and draw the GUI elements on the screen. \n\nThe \"Start\" method is empty and does not have any functionality. It is likely intended to be used for initialization purposes, but it is not currently implemented. \n\nThe \"OnGUI\" method is responsible for drawing the Blast Mode configuration GUI. It first checks if a thumbnail texture is available for the current game map. If a thumbnail is available, it is drawn on the screen. Additionally, if the map was registered on the current day, a \"new map\" icon is displayed. Depending on the map's tag mask, different icons may be displayed to indicate special attributes of the map (e.g., glory, medal, gold ribbon). If the map is flagged as an abuse map, an \"abuse\" icon is displayed. The method also displays the map's alias and game mode type. \n\nThe \"DoOption\" method is responsible for displaying various options and settings related to the Blast Mode configuration. It displays the round goal, weapon options, break-in option, item drop option, and team balance option. The values for these options are retrieved from the \"room\" object passed as a parameter to the method. \n\nThe \"ShowTooltip\" method is responsible for displaying a tooltip message when the user hovers over a GUI element. The tooltip message is drawn on the screen at the position of the mouse cursor. \n\nOverall, the \"BlastModeConfig\" class provides the functionality to configure and display the Blast Mode settings and options in the Brick-Force project. It handles the GUI elements and logic for displaying the map thumbnail, map attributes, and various configuration options.\n## Questions: \n 1. What is the purpose of the `Start()` method in the `BlastModeConfig` class?\n- The purpose of the `Start()` method is not clear from the provided code. It seems to be an empty method that does not have any functionality.\n\n2. What is the significance of the `isRoom` variable in the `BlastModeConfig` class?\n- The `isRoom` variable is a boolean that determines whether the current context is a room. It is used in the `DoOption()` method to conditionally display certain options based on whether it is a room or not.\n\n3. What is the purpose of the `ShowTooltip()` method in the `BlastModeConfig` class?\n- The `ShowTooltip()` method is responsible for displaying a tooltip message on the GUI. It takes the tooltip message as input and renders it on the screen using the provided coordinates and style.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BlastModeConfig.md"}}],["61",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BlastTarget.cs)\n\nThe code provided is a class called `BlastTarget` that is a part of the larger Brick-Force project. This class is responsible for defining a target object that can be blasted in the game. \n\nThe class has a private integer variable called `spot`, which represents the spot or position of the target. It also has a public property called `Spot` that allows other classes to access and modify the value of `spot`. The property has a getter and a setter, which provide read and write access to the `spot` variable.\n\nThe `Start()` and `Update()` methods are empty and do not contain any code. These methods are commonly used in Unity game development to perform initialization tasks and update the state of objects respectively. In this case, they are left empty, indicating that there are no specific initialization or update tasks required for the `BlastTarget` object.\n\nThis class can be used in the larger Brick-Force project to create and manage targets that can be blasted by the player. Other classes can access the `Spot` property to get or set the position of the target. For example, a player's weapon class may use the `BlastTarget` class to determine the position of the target and apply damage to it when the player shoots.\n\nHere is an example of how the `BlastTarget` class can be used in another class:\n\n```csharp\npublic class Weapon : MonoBehaviour\n{\n    private BlastTarget target;\n\n    private void Start()\n    {\n        target = new BlastTarget();\n        target.Spot = 5;\n    }\n\n    private void Update()\n    {\n        if (Input.GetKeyDown(KeyCode.Space))\n        {\n            // Get the position of the target\n            int targetSpot = target.Spot;\n\n            // Apply damage to the target\n            ApplyDamage(targetSpot);\n        }\n    }\n\n    private void ApplyDamage(int spot)\n    {\n        // Apply damage to the target at the specified spot\n        // ...\n    }\n}\n```\n\nIn this example, the `Weapon` class creates a new instance of the `BlastTarget` class and sets its `Spot` property to 5. When the player presses the space key, the `Update()` method retrieves the position of the target from the `Spot` property and applies damage to it using the `ApplyDamage()` method.\n## Questions: \n 1. **What is the purpose of the `BlastTarget` class?**\nThe `BlastTarget` class appears to be a script attached to a game object in a Unity project. It likely has some functionality related to a blast effect or targeting system.\n\n2. **What is the significance of the `Spot` property?**\nThe `Spot` property is an integer that has both a getter and a setter. It is not clear from the provided code what the purpose or use of this property is.\n\n3. **What functionality is expected in the `Start` and `Update` methods?**\nThe `Start` and `Update` methods are empty in the provided code. It is unclear what functionality is intended to be implemented in these methods.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BlastTarget.md"}}],["62",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BlickTexture.cs)\n\nThe code provided is a class called \"BlickTexture\" that is used in the larger Brick-Force project. This class is responsible for managing the behavior and rendering of a texture in the game.\n\nThe class has several private variables, including \"ux\" and \"uy\" which represent the x and y coordinates of the texture, \"isActive\" which indicates whether the texture is active or not, \"deltaTime\" which keeps track of the time passed since the texture became active, \"blickTime\" which determines the duration of the blinking effect, \"view\" which controls whether the texture is currently visible or not, and \"viewText\" which controls whether the texture's text is visible or not.\n\nThe class also has two public properties, \"IsActive\" and \"ViewText\", which allow external code to get and set the values of \"isActive\" and \"viewText\" respectively.\n\nThe class provides several methods for drawing and updating the texture. The \"Draw\" method takes in the x and y coordinates of the texture, as well as the actual texture image, and draws the texture on the screen if it is active and currently visible. The \"DrawReaminText\" method is similar to the \"Draw\" method, but it also takes in a \"remain\" parameter which represents the remaining time for the texture to be active. It draws the texture's text below the texture image if it is active and the text is set to be visible.\n\nThe \"Update\" method is called every frame and updates the state of the texture. If the texture is active, it increments the \"deltaTime\" variable by the time passed since the last frame. If the \"deltaTime\" exceeds the \"blickTime\" value, it resets the \"deltaTime\" and toggles the \"view\" variable, which controls the visibility of the texture.\n\nOverall, this class provides functionality for managing and rendering a texture in the game, including the ability to toggle its visibility, draw the texture on the screen, and update its state for blinking effects.\n## Questions: \n 1. What is the purpose of the `IsActive` property and how is it used?\n- The `IsActive` property is used to determine if the `BlickTexture` object is active or not. It is used to control the visibility of the texture when drawing.\n\n2. What is the purpose of the `ViewText` property and how is it used?\n- The `ViewText` property is used to determine if the text associated with the `BlickTexture` object should be displayed or not. It is used to control the visibility of the text when drawing.\n\n3. What is the purpose of the `Update` method and how does it work?\n- The `Update` method is used to update the state of the `BlickTexture` object. It increments the `deltaTime` variable with the time that has passed since the last frame and toggles the `view` variable based on the `blickTime` value. This allows for the blinking effect of the texture.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BlickTexture.md"}}],["63",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BloodMark.cs)\n\nThe code provided is for a class called \"BloodMark\" in the Brick-Force project. This class is responsible for creating and managing a blood mark effect on the screen. \n\nThe class has several private variables: \n- \"bloodMark\" is a Texture2D object that represents the blood mark image.\n- \"pos\" is a Vector2 object that represents the position of the blood mark on the screen.\n- \"bloodColor\" is a Color object that represents the current color of the blood mark.\n- \"toColor\" is a Color object that represents the target color of the blood mark.\n- \"scale\" is a float value that represents the scale factor of the blood mark.\n\nThe class has a public property \"IsAlive\" which returns a boolean value indicating whether the blood mark is still visible or not. It checks if the alpha value of the blood color is greater than 0.01f.\n\nThe class has a constructor that takes in a Texture2D object for the blood mark image, two Color objects for the initial and target colors of the blood mark, and a float value for the scale factor. In the constructor, the provided values are assigned to the corresponding variables. Additionally, the position of the blood mark is calculated randomly within a quarter of the screen size.\n\nThe class has two methods: \"Update()\" and \"Draw()\". \n- The \"Update()\" method is responsible for updating the color of the blood mark over time. It uses the Color.Lerp() function to gradually change the blood color from the initial color to the target color based on the Time.deltaTime value.\n- The \"Draw()\" method is responsible for drawing the blood mark on the screen. It temporarily modifies the GUI color to match the blood color, calculates the width and height of the blood mark based on the scale factor, and then uses the TextureUtil.DrawTexture() function to draw the blood mark image on the screen at the specified position and size.\n\nOverall, this class provides a way to create and manage a blood mark effect in the Brick-Force project. It allows for customization of the blood mark image, initial and target colors, and scale factor. The \"Update()\" method can be called in the game's update loop to animate the blood mark, and the \"Draw()\" method can be called in the game's draw loop to render the blood mark on the screen.\n## Questions: \n 1. What does the `IsAlive` property do and how is it determined? \nThe `IsAlive` property returns a boolean value indicating whether the blood mark is still visible. It is determined by checking if the alpha value of the `bloodColor` is greater than 0.01f.\n\n2. What does the `Update` method do? \nThe `Update` method updates the `bloodColor` by gradually interpolating it towards the `toColor` over time using `Color.Lerp`.\n\n3. What does the `Draw` method do? \nThe `Draw` method draws the blood mark on the screen using the `bloodMark` texture, `bloodColor`, and `scale`. It uses `TextureUtil.DrawTexture` to draw the texture at the specified position and size.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BloodMark.md"}}],["64",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BndConfig.cs)\n\nThe code provided is a class called \"BndConfig\" that is part of the Brick-Force project. This class is responsible for managing the configuration and display of a room in the game. \n\nThe class contains various properties and methods that handle the configuration and display of the room. \n\nThe properties include:\n- \"nonavailable\": a Texture2D object that represents the thumbnail image of the room. \n- \"crdFrame\": a Rect object that represents the frame of the room. \n- \"crdThumbnail\": a Rect object that represents the thumbnail image of the room. \n- \"crdAlias\": a Vector2 object that represents the position of the room's alias. \n- \"crdMode\": a Vector2 object that represents the position of the room's mode. \n- \"crdConfigBtn\": a Rect object that represents the position of the room's configuration button. \n- \"crdOptionLT\": a Vector2 object that represents the position of the room's options. \n- \"crdLine\": a Rect object that represents the position of the room's dividing line. \n- \"optionLX\": a float value that represents the x-coordinate of the room's options. \n- \"optionRX\": a float value that represents the x-coordinate of the room's options. \n- \"diff_y\": a float value that represents the difference in y-coordinate between the room's options. \n- \"crdBox\": a Vector2 object that represents the size of the room's options box. \n- \"diff_y2\": a float value that represents the difference in y-coordinate between the room's options. \n- \"tooltipMessage\": a string that represents the tooltip message to be displayed. \n- \"clrValue\": a Color object that represents the color of the room's value. \n- \"weaponOptions\": an array of strings that represents the available weapon options for the room. \n- \"isRoom\": a boolean value that indicates whether the room is a valid room. \n\nThe methods include:\n- \"Start()\": a method that is called when the room starts. \n- \"OnGUI()\": a method that handles the graphical user interface (GUI) of the room. It displays the room's thumbnail, alias, mode, options, and configuration button. It also handles the display of tooltips. \n- \"DoOption(Room room)\": a method that handles the display of the room's options. It displays the build phase time, shoot phase time, repeat time, kill count, weapon option, break-in option, team balance option, and use build gun option. \n- \"ShowTooltip(int id)\": a method that displays the tooltip message. \n\nOverall, this code manages the configuration and display of a room in the Brick-Force game. It handles the GUI elements and options of the room, and provides methods for updating and displaying the room's information.\n## Questions: \n 1. What is the purpose of the `BndConfig` class?\n- The `BndConfig` class is used to store and manage various configuration settings and data related to a room in the game.\n\n2. What is the significance of the `Start` method in the `BndConfig` class?\n- The `Start` method does not have any implementation in the given code and appears to be unused. A smart developer might wonder why it is included in the class.\n\n3. What is the purpose of the `DoOption` method in the `BndConfig` class?\n- The `DoOption` method is responsible for displaying and setting various options related to a room, such as build phase time, shoot phase time, kill count, weapon options, and more.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BndConfig.md"}}],["65",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BNDGuideDialog.cs)\n\nThe code provided is a class called `BNDGuideDialog` that extends the `Dialog` class. This class is used to create a dialog box with various UI elements such as image lists, label lists, toggles, and buttons. The purpose of this code is to handle the functionality and behavior of the dialog box in the larger Brick-Force project.\n\nThe `BNDGuideDialog` class has several public variables that represent different UI elements, such as `imgList`, `labelList`, `toggle`, and `ok`. These variables are used to reference and manipulate the UI elements within the dialog box.\n\nThe `DontShowThisMessageAgain` property is a boolean value that is determined by the state of the `toggle` UI element. If the toggle is checked, the property will return `true`, indicating that the user does not want to see the message again.\n\nThe `Start()` method is an override of the `Start()` method from the base `Dialog` class. It sets the `id` of the dialog box to a specific value from the `DialogManager.DIALOG_INDEX` enum.\n\nThe `OnPopup()` method is another override method that is called when the dialog box is displayed. It calculates the position of the dialog box based on the screen size and sets the `rc` (rect) variable accordingly.\n\nThe `InitDialog()` method is empty and does not have any functionality. It can be used to initialize the dialog box if needed.\n\nThe `DoDialog()` method is the main method that handles the rendering and interaction of the dialog box. It first sets the GUI skin to a specific skin obtained from `GUISkinFinder.Instance.GetGUISkin()`. Then, it calls the `Draw()` method on the UI elements (`imgList`, `labelList`, `toggle`, and `ok`) to render them on the screen. It also checks if the `ok` button is clicked and if the `DontShowThisMessageAgain` property is `true`. If both conditions are met, it saves the user's preference using `MyInfoManager.Instance.SaveDonotCommonMask()` method. Finally, it checks if there is no other popup menu open and calls `WindowUtil.EatEvent()` to prevent any further input events from being processed. The GUI skin is then reset to its original value, and the method returns a boolean value indicating whether the dialog box should be closed (`true`) or not (`false`).\n\nIn the larger Brick-Force project, this code can be used to create and manage dialog boxes that display messages or options to the user. The UI elements can be customized and the behavior of the dialog box can be modified by extending this class and overriding its methods.\n## Questions: \n 1. What is the purpose of the `BNDGuideDialog` class?\n- The `BNDGuideDialog` class is a subclass of the `Dialog` class and represents a specific type of dialog in the Brick-Force project.\n\n2. What are the `imgList`, `labelList`, `toggle`, and `ok` variables used for?\n- These variables are used to store references to UI elements (such as image lists, label lists, toggles, and buttons) that are used in the dialog.\n\n3. What does the `DoDialog` method do?\n- The `DoDialog` method is responsible for drawing the UI elements, handling user interactions, and returning a boolean value indicating whether the dialog should be closed or not.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BNDGuideDialog.md"}}],["66",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BndMatch.cs)\n\nThe code provided is a script for the Brick-Force project. This script is called \"BndMatch\" and is responsible for managing various aspects of the game during a match.\n\nAt a high level, this script handles the initialization and management of the game's match. It includes functions for setting up the game environment, resetting game status, handling player input, and updating game state.\n\nThe script contains several private variables that store references to other game objects and components. These variables include references to a wall object, a wall component, a battle chat component, a local controller component, a radar component, a timer component, and an equip coordinator component. These references are used to interact with and control various aspects of the game.\n\nThe script also includes several public variables that can be set in the Unity editor. These variables include textures for battle and build icons, as well as a vector for positioning the weapon icon.\n\nThe script includes several properties that provide access to certain game states. For example, the \"IsBuildPhase\" property returns a boolean value indicating whether the game is currently in the build phase. The \"IsBuilderMode\" property returns a boolean value indicating whether the player is in builder mode. The \"AmIUsingBuildGun\" property returns a boolean value indicating whether the player is currently using a build gun.\n\nThe script contains several private methods that handle various aspects of the game. These methods include functions for initializing the first-person perspective, resetting the status of the game's wall, handling the player's return to the spawner, handling the completion of the game's loading process, and handling the start of the game.\n\nThe script also includes several Unity lifecycle methods, such as \"Awake\", \"OnDisable\", \"OnGUI\", and \"Update\". These methods are called automatically by the Unity engine at specific points during the game's execution. For example, the \"Awake\" method is called when the script is first loaded, while the \"Update\" method is called every frame.\n\nIn summary, this script is an essential component of the Brick-Force project as it manages various aspects of the game's match, including initialization, game state management, and player input handling. It interacts with other game objects and components to control the game's behavior and provide a seamless gaming experience.\n## Questions: \n 1. What is the purpose of the `InitializeFirstPerson()` method?\n- The `InitializeFirstPerson()` method is responsible for initializing the `EquipCoordinator` and `LocalController` components for the player character.\n\n2. What does the `ResetBndStatus(bool wallRightNow)` method do?\n- The `ResetBndStatus(bool wallRightNow)` method resets the status of the BndMatch, including showing or hiding the BndWall, resetting the weapons, and showing or hiding the team spawners.\n\n3. What is the purpose of the `OnLoadComplete()` method?\n- The `OnLoadComplete()` method is called when the loading of the game is complete. It loads the train, resets the BndStatus, spawns the player character, and shows the BNDGuideDialog if necessary.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BndMatch.md"}}],["67",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BndMatchScore.cs)\n\nThe `BndMatchScore` class is a MonoBehaviour script that is used to display the scores and other information related to a match in the Brick-Force game. \n\nThe purpose of this code is to handle the display of the match scores, the background image, and the fonts used to display the scores. It also handles the flickering effect for the team scores.\n\nThe class has several public variables that can be set in the Unity editor or through code. These variables include the GUI depth, which determines the rendering order of the GUI elements, the fonts used for the red and blue team scores, the font used for the goal count, and the background image for the score display.\n\nThe class also has private variables that store the actual scores for the red and blue teams, as well as the offset for the palette when using the build gun. There are also Rect and Vector2 variables that define the positions and sizes of the score display elements.\n\nThe `Start` method initializes the variables and sends a score request to the server if the player is currently breaking into a match.\n\nThe `VerifyBndMatch` method checks if the `bndMatch` variable is null and assigns it the `BndMatch` component if it is.\n\nThe `OnTeamScore` method is called when the team scores are updated. It updates the red and blue team scores and sets the scale of the fonts to 2 to create a visual effect.\n\nThe `OnGUI` method is responsible for rendering the GUI elements. It checks if the GUI is enabled and retrieves the GUI skin. It then sets the GUI depth and enables or disables the GUI based on whether a modal dialog is open. It creates a group for the score display using the background image and draws the flickering effect for the team scores. It then prints the red and blue team scores and the goal count using the specified fonts and positions. Finally, it resets the GUI skin and enables the GUI.\n\nThe `Update` method is responsible for updating the flickering effect for the team scores.\n\nOverall, this code provides the functionality to display the match scores and related information in the Brick-Force game. It is likely used in the larger project to provide a visual representation of the current match progress to the players.\n## Questions: \n 1. What is the purpose of the `BndMatchScore` class?\n- The `BndMatchScore` class is responsible for displaying the scores and other UI elements related to a match in the game.\n\n2. What is the significance of the `redTeamScore` and `blueTeamScore` variables?\n- These variables store the current scores of the red and blue teams in the match.\n\n3. What is the purpose of the `VerifyBndMatch` method?\n- The `VerifyBndMatch` method is used to ensure that the `bndMatch` variable is not null and is properly initialized before using it in other methods.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BndMatchScore.md"}}],["68",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BndTimer.cs)\n\nThe `BndTimer` class is a script that manages the countdown timer for the game phases in the Brick-Force project. It is responsible for displaying the timer on the screen, updating the timer, and shifting between the build and battle phases.\n\nThe class has several private variables that store information about the timer and its appearance, such as the GUI depth, the position and size of the timer rectangle, the background texture, and references to other components like the radar and local controller.\n\nThe class also has public properties and methods that allow other classes to access and modify the timer properties. For example, the `IsBuildPhase` property allows other classes to check if the current phase is the build phase or the battle phase. The `RemainRepeat` property returns the number of times the timer will repeat.\n\nThe class has several static methods that are used to pack and unpack the timer options. The `PackTimerOption` method takes the build phase time, battle phase time, and repeat count as input and returns a packed integer value. The `BuildPhaseTime` and `BattlePhaseTime` methods extract the build and battle phase times from the packed timer option. The `Repeat` method extracts the repeat count from the packed timer option.\n\nThe `ResetTimer` method is used to reset the timer based on the current phase and time limit. It sets the remaining time to the build phase time if the current phase is the battle phase, and vice versa.\n\nThe `ShiftPhase` method is used to shift between the build and battle phases. It decreases the repeat count if shifting to the build phase, and updates the remaining time based on the new phase and time limit.\n\nThe `Start` method is called when the script is initialized. It initializes the radar, sets the initial phase to the build phase, and sets the remaining time and repeat count based on the time limit.\n\nThe `VerifyRadar` method is used to check if the radar component is available and assigns it if it is not.\n\nThe `OnGUI` method is responsible for drawing the timer on the screen. It uses the GUI functions provided by Unity to draw the timer background and the remaining time text.\n\nThe `Update` method is called every frame and updates the timer. It checks if the local player is the master player, if the local player is controllable, and if the brick manager is loaded. If all conditions are met, it updates the timer by decreasing the remaining time, sending network messages, and shifting phases if necessary.\n\nThe `OnPlayTime` and `OnTimer` methods are event handlers that are called when the play time and remaining time are received from the network. They update the play time and remaining time if the received values are greater or smaller than the current values, respectively.\n\nIn summary, the `BndTimer` class manages the countdown timer for the game phases in the Brick-Force project. It handles the display, update, and shifting of the timer between the build and battle phases. Other classes can access and modify the timer properties through public properties and methods.\n## Questions: \n 1. What is the purpose of the `BndTimer` class?\n- The `BndTimer` class is responsible for managing the timer functionality in the game.\n\n2. What is the significance of the `isBuildPhase` variable?\n- The `isBuildPhase` variable determines whether the game is currently in the build phase or the battle phase.\n\n3. What is the purpose of the `ShiftPhase` method?\n- The `ShiftPhase` method is used to shift the game phase between the build phase and the battle phase.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BndTimer.md"}}],["69",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BndWall.cs)\n\nThe `BndWall` class is a script that controls the hiding and showing of a wall object in the Brick-Force project. The purpose of this script is to provide functionality for hiding and showing the wall with a smooth animation.\n\nThe script contains several private variables, including `deltaTime`, `hideTime`, `showTime`, `hiding`, `showing`, `scaleShow`, and `scaleHide`. These variables are used to keep track of the time, animation durations, and the current state of the wall.\n\nThe `Start` method is called when the script is initialized. It sets the initial values for the `hiding` and `showing` variables, and calculates the `scaleHide` value based on the initial scale of the wall. It also adjusts the positions of the `probeTop` and `probeBottom` game objects.\n\nThe `Hiding` and `Showing` methods are responsible for animating the hiding and showing of the wall. They are called in the `Update` method. Inside these methods, the script checks if the wall is currently hiding or showing, and then updates the scale of the wall gradually over time using `Vector3.Lerp`. When the animation is complete, the script disables or enables the `MeshCollider` components of the wall and adjusts the positions of the `probeTop` and `probeBottom` game objects.\n\nThe `Hide` and `Show` methods are public methods that can be called from other scripts to initiate the hiding or showing of the wall. They take a boolean parameter `rightNow`, which determines whether the animation should start immediately or not. If `rightNow` is true, the `deltaTime` variable is set to the corresponding animation duration, otherwise it is set to 0. The `hiding` or `showing` variable is then set to true, which triggers the animation in the `Hiding` or `Showing` methods.\n\nOverall, this script provides a way to hide and show a wall object in the Brick-Force project with smooth animations. It can be used to create dynamic and interactive environments where walls can be hidden or shown based on certain conditions or player actions.\n## Questions: \n 1. What is the purpose of the `Hiding()` and `Showing()` methods?\n- The `Hiding()` and `Showing()` methods are responsible for animating the hiding and showing of the object respectively. They update the scale of the object and enable/disable the MeshColliders accordingly.\n\n2. What is the significance of the `probeTop` and `probeBottom` arrays?\n- The `probeTop` and `probeBottom` arrays contain references to game objects that are used to position the top and bottom probes of the object. These probes are repositioned based on the scale of the object.\n\n3. What is the purpose of the `Hide()` and `Show()` methods?\n- The `Hide()` and `Show()` methods are used to initiate the hiding and showing of the object. They set the `deltaTime` variable to the appropriate value and set the `hiding` or `showing` flag to true, triggering the corresponding animation in the `Update()` method.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BndWall.md"}}],["70",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BombFuction.cs)\n\nThe code provided is a script for the BombFunction class in the Brick-Force project. This class is responsible for handling the functionality of the bomb weapon in the game. \n\nThe class contains several public variables for textures used in the game, such as crosshairs and gauges. It also has a private variable called \"explosionMatch\" of type ExplosionMatch, which is a reference to the ExplosionMatch component attached to the \"Main\" game object. \n\nThe class has a property called \"IsInstalling\" which returns the value of the private variable \"installing\". This property is used to check if the bomb is currently being installed.\n\nThe class has several private methods that handle different aspects of the bomb functionality. The \"EnsureVisibility\" method checks if the bomb installer is the same as the player's sequence number and hides the bomb if it is. The \"VerifyExplosionMatch\" method finds the ExplosionMatch component if it hasn't been assigned yet. The \"Reset\" method restarts the bomb installation process if it has been drawn. The \"SetDrawn\" method sets the drawn state of the bomb and restarts the installation process if it has been drawn. The \"Restart\" method resets the bomb installation variables and sends a message to the P2PManager to stop the bomb installation. The \"DrawCrossHair\" method draws the crosshair textures on the screen. The \"DrawInstallingGauge\" method draws the installation gauge on the screen. The \"OnGUI\" method is responsible for drawing the GUI elements on the screen. The \"CanInstall\" method checks if the bomb can be installed based on certain conditions. The \"Start\" method is called when the script is first initialized and resets the bomb. The \"VerifyCameraAll\" method checks if the required camera components are present. The \"GetInstallTarget\" method checks if the bomb can be installed at the current target position. The \"Show\" and \"Hide\" methods enable and disable the mesh renderers of the bomb, respectively. The \"Clear\" method resets the bomb. The \"Update\" method is called every frame and handles the bomb installation process. \n\nOverall, this code provides the functionality for installing and using the bomb weapon in the game. It handles the drawing of GUI elements, checking if the bomb can be installed, and sending messages to other components to control the bomb installation process.\n## Questions: \n **Question 1:** What is the purpose of the `EnsureVisibility()` method?\n- The `EnsureVisibility()` method is responsible for determining whether the bomb should be hidden or shown based on the current state of the game.\n\n**Question 2:** What does the `VerifyCameraAll()` method do?\n- The `VerifyCameraAll()` method checks if the camera and other related components are not null, indicating that they have been properly initialized.\n\n**Question 3:** What is the purpose of the `GetInstallTarget(out RaycastHit hit)` method?\n- The `GetInstallTarget(out RaycastHit hit)` method determines if the player is aiming at a valid target for installing the bomb and returns the result in the `hit` parameter.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BombFuction.md"}}],["71",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\bombInfo.cs)\n\nThe code provided defines a class called `bombInfo`. This class is used to store information about a bomb in the larger Brick-Force project. \n\nThe `bombInfo` class has three members: `bombId`, `isMyTeam`, and a method called `reset()`. \n\nThe `bombId` member is an integer that represents the unique identifier of the bomb. The `isMyTeam` member is a boolean that indicates whether the bomb belongs to the player's team or not. \n\nThe `reset()` method is used to reset the values of the `bombId` and `isMyTeam` members to their default values. In this case, the default value for `bombId` is -1 and the default value for `isMyTeam` is false. \n\nThis class can be used in the larger Brick-Force project to keep track of bombs and their ownership. For example, when a bomb is placed in the game, an instance of the `bombInfo` class can be created and its members can be set accordingly. \n\nHere is an example of how this class can be used:\n\n```csharp\nbombInfo bomb = new bombInfo();\nbomb.bombId = 1;\nbomb.isMyTeam = true;\n\n// ... some code ...\n\nbomb.reset();\n```\n\nIn this example, a new instance of the `bombInfo` class is created and assigned to the `bomb` variable. The `bombId` member is set to 1 and the `isMyTeam` member is set to true. Later in the code, the `reset()` method is called on the `bomb` object, which resets the values of `bombId` and `isMyTeam` to their default values (-1 and false, respectively).\n## Questions: \n 1. **What is the purpose of the `bombInfo` class?**\nThe `bombInfo` class appears to be a data structure that holds information about a bomb, including its ID and whether it belongs to the player's team.\n\n2. **What does the `reset()` method do?**\nThe `reset()` method sets the `bombId` to -1 and `isMyTeam` to false, effectively resetting the bomb information to its default state.\n\n3. **Are there any other properties or methods in the `bombInfo` class?**\nBased on the given code, it is not clear if there are any other properties or methods in the `bombInfo` class. Further examination of the codebase or documentation would be needed to determine this.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\bombInfo.md"}}],["72",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BombsCall.cs)\n\nThe code provided is a part of the Brick-Force project and is contained within the \"BombsCall\" class. This class extends the \"ActiveItemBase\" class and is responsible for handling the creation and explosion of bombs in the game.\n\nThe class has several public variables that can be set to customize the behavior of the bombs. These variables include \"bombsCallTime\" (the time at which the bombs are called), \"explosionTime\" (the time at which the bombs explode), \"explosionRadius\" (the radius of the bomb explosion), \"bombCreateYPosition\" (the Y position at which the bombs are created), \"bombExplosionExceptHigher\" (the Y position above which the bomb explosion does not affect), \"bombExplosionExceptLower\" (the Y position below which the bomb explosion does not affect), and various game objects and audio clips used for the bomb effects and sounds.\n\nThe class has a list of \"explosionPosition\" which stores the positions where the bombs will explode. The \"currentTime\" variable keeps track of the current time in the game. The \"createBomb\" and \"explosion\" boolean variables are used to control the creation and explosion of bombs.\n\nThe \"Awake\" method initializes the \"currentTime\" variable to 0. The \"Update\" method is called every frame and updates the \"currentTime\" variable. If the \"createBomb\" boolean is false and the \"bombsCallTime\" is less than the \"currentTime\", the \"createBomb\" boolean is set to true and the \"BombsCreate\" method is called. Similarly, if the \"explosion\" boolean is false and the \"explosionTime\" is less than the \"currentTime\", the \"explosion\" boolean is set to true and the \"CreateExplosion\" method is called for each position in the \"explosionPosition\" list. After the explosions are created, the \"explosionPosition\" list is cleared.\n\nThe \"StartItem\" method is called when the bomb item is started. It plays the \"sndBombsCall\" audio clip.\n\nThe \"BombsCreate\" method is responsible for creating the bombs. It first plays the \"sndBombsFalling\" audio clip. Then, it creates a bomb at the position of the player (\"Me\") if the \"useUserSeq\" is not equal to the current player's sequence. It then retrieves a dictionary of brick men from the \"BrickManManager\" and creates a bomb for each brick man in the dictionary, excluding the player.\n\nThe \"CreateBomb\" method is called to create a bomb at a given position. It instantiates the \"targetEffect\" game object at the given position and adds the position to the \"explosionPosition\" list. It then increases the Y position of the given position by the \"bombCreateYPosition\" and instantiates the \"bombEffect\" game object at the new position.\n\nThe \"CreateExplosion\" method is called to create an explosion at a given position. If the player is below level 12, it instantiates the \"explosionEffect11\" game object at the given position. Otherwise, it instantiates the \"explosionEffect\" game object. It then checks if the player is within the explosion radius of the given position. If so, it checks if the Y position of the given position is within the range of the player's Y position excluding the \"bombExplosionExceptHigher\" and \"bombExplosionExceptLower\" values. If the player is within the range, it retrieves the \"LocalController\" component of the player and calls the \"GetHitBungeeBomb\" method to apply damage to the player.\n\nIn summary, this code handles the creation and explosion of bombs in the game. It provides methods to create bombs at specific positions and create explosions at those positions. It also includes functionality to play audio clips for bomb calls, bomb falling, and bomb explosions. This code is likely used in the larger Brick-Force project to add gameplay elements involving bombs and explosions.\n## Questions: \n 1. What is the purpose of the `Awake()` method?\n- The `Awake()` method is used to initialize the `currentTime` variable to 0.\n\n2. What is the purpose of the `StartItem()` method?\n- The `StartItem()` method is used to play the `sndBombsCall` audio clip when the item is started.\n\n3. What is the purpose of the `CreateExplosion()` method?\n- The `CreateExplosion()` method is used to create an explosion effect at a given position and check if any player is within the explosion radius to apply damage.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BombsCall.md"}}],["73",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BootstrapMain.cs)\n\nThe `BootstrapMain` class is a script that is responsible for initializing and setting up the game when it starts. It is a part of the larger Brick-Force project.\n\nThe `Awake` method is called when the script is first loaded. It starts the injection detection process using the `InjectionDetector.StartDetection` method. If an injection is detected, it logs a message and calls the `HardExit` method from the `BuildOption` class.\n\nThe `Start` method is called after the `Awake` method. It initializes the `once` variable to false.\n\nThe `OnGUI` method is responsible for drawing the loading screen and logo on the screen. It uses the `GUISkinFinder` class to get the GUI skin and sets it as the current GUI skin. It then calculates the position of the loading image and logo based on the screen size and draws them using the `TextureUtil.DrawTexture` method. It also checks if the font is ready and if so, it displays the \"Loading Bricks...\" text using the `LabelUtil.TextOut` method.\n\nThe `Init` method is a coroutine that is responsible for initializing the game settings. It retrieves the screen width, height, and full-screen mode from the player preferences. If the width or height is less than the minimum screen width or height, it sets them to the minimum values. It then checks if the width and height are equal to or greater than the maximum screen resolution and sets the full-screen mode accordingly. Finally, it sets the screen resolution using the `Screen.SetResolution` method and waits for a frame to complete.\n\nThe `Update` method is called every frame. It checks if the font is ready and if the game scene is loaded. If both conditions are met and the `once` variable is false, it sets `once` to true and starts loading the game data by calling the `Load` method from the `StringMgr` and `WordFilter` classes. It also starts the `Init` coroutine.\n\nThe `LateUpdate` method is called after all other updates have been processed. It checks if the setup is complete and if the \"LoadBrick\" scene can be loaded. If both conditions are met, it loads the \"LoadBrick\" scene using the `Application.LoadLevel` method.\n\nIn summary, the `BootstrapMain` script is responsible for initializing the game and setting up the initial game settings. It detects injections, displays the loading screen and logo, and loads the game data and scene. It is an essential part of the Brick-Force project as it ensures that the game starts correctly and all necessary resources are loaded.\n## Questions: \n 1. What is the purpose of the `Awake()` method?\n- The `Awake()` method is used to start the detection of code injection and disable eating key press on text field focus.\n\n2. What is the purpose of the `Init()` method and what does it do?\n- The `Init()` method is a coroutine that sets the screen resolution and quality level based on player preferences and system capabilities.\n\n3. What is the purpose of the `LateUpdate()` method and when does it execute?\n- The `LateUpdate()` method is executed after all other `Update()` methods and it checks if the setup is complete and if the level \"LoadBrick\" can be loaded, then it loads the level.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BootstrapMain.md"}}],["74",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BossUiInfo.cs)\n\nThe code provided defines a class called `BossUiInfo` that is used to store information about a boss character in the Brick-Force project. The class has four public properties: `msg`, `tex2d`, `name`, and `dmg`.\n\nThe `msg` property is of type `string` and is used to store a message or description about the boss character. This could be used to display information about the boss to the player, such as its abilities or weaknesses.\n\nThe `tex2d` property is of type `Texture2D` and is used to store a texture image that represents the boss character. This could be used to display a visual representation of the boss in the game's user interface.\n\nThe `name` property is of type `string` and is used to store the name of the boss character. This could be used to display the boss's name in the game's user interface or in other parts of the game where the boss is referenced.\n\nThe `dmg` property is of type `int` and is used to store the damage value of the boss character. This could be used to determine how much damage the boss can inflict on the player or other game entities.\n\nOverall, this code provides a way to store and access information about a boss character in the Brick-Force project. This information can be used to display relevant details about the boss to the player and to determine the boss's capabilities in the game. Here is an example of how this class could be used:\n\n```csharp\nBossUiInfo bossInfo = new BossUiInfo();\nbossInfo.msg = \"This boss is immune to fire attacks.\";\nbossInfo.tex2d = Resources.Load<Texture2D>(\"BossTexture\");\nbossInfo.name = \"Fire King\";\nbossInfo.dmg = 50;\n\n// Display boss information to the player\nDebug.Log(\"Boss Name: \" + bossInfo.name);\nDebug.Log(\"Boss Message: \" + bossInfo.msg);\nDebug.Log(\"Boss Damage: \" + bossInfo.dmg);\n\n// Display boss texture in the game's user interface\nbossImage.texture = bossInfo.tex2d;\n```\n## Questions: \n 1. **What is the purpose of the `BossUiInfo` class?**\nThe `BossUiInfo` class is likely used to store information related to a boss character's UI, such as a message, a texture, a name, and damage.\n\n2. **What type of data does the `msg` variable store?**\nThe `msg` variable is likely used to store a string message related to the boss character's UI.\n\n3. **What is the purpose of the `tex2d` variable?**\nThe `tex2d` variable is likely used to store a 2D texture related to the boss character's UI.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BossUiInfo.md"}}],["75",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BreakTrigger.cs)\n\nThe code provided is a class called \"BreakTrigger\" that inherits from a class called \"Trigger\". The purpose of this code is to define a trigger that will execute a script when a certain condition is met. \n\nThe class has a private method called \"OnBreak\" which is called when the trigger is activated. Inside this method, there is an if statement that checks two conditions. The first condition checks if the current loaded level name does not contain the string \"MapEditor\". The second condition checks if the base class (Trigger) is enabled. If both conditions are true, the method \"RunScript()\" is called.\n\nThe purpose of this code is to provide a way to execute a script when a break event occurs, but only under certain conditions. The condition of the loaded level name not containing \"MapEditor\" suggests that this trigger is intended to be used in a game environment, where the script should only run if the current level is not the map editor. The condition of the base class being enabled suggests that this trigger can be enabled or disabled, allowing for more control over when the script should run.\n\nHere is an example of how this code might be used in the larger project:\n\n```csharp\npublic class MyLevel : MonoBehaviour\n{\n    public BreakTrigger breakTrigger;\n\n    private void Start()\n    {\n        // Enable the break trigger\n        breakTrigger.enabled = true;\n    }\n\n    private void Update()\n    {\n        // Check if the break trigger script should run\n        if (Input.GetKeyDown(KeyCode.Space))\n        {\n            breakTrigger.OnBreak();\n        }\n    }\n}\n```\n\nIn this example, the \"MyLevel\" class has a reference to a \"BreakTrigger\" instance called \"breakTrigger\". In the \"Start\" method, the break trigger is enabled. Then, in the \"Update\" method, the break trigger's \"OnBreak\" method is called when the space key is pressed. This will execute the script associated with the break trigger, but only if the current level is not the map editor and the trigger is enabled.\n## Questions: \n 1. **What is the purpose of the `BreakTrigger` class?**\nThe `BreakTrigger` class is a subclass of the `Trigger` class and it likely represents a trigger that is activated when something is broken in the game.\n\n2. **What does the `OnBreak()` method do?**\nThe `OnBreak()` method checks if the current loaded level is not the \"MapEditor\" level and if the `BreakTrigger` component is enabled, and if both conditions are true, it calls the `RunScript()` method.\n\n3. **What is the significance of the `Application.loadedLevelName.Contains(\"MapEditor\")` condition?**\nThe `Application.loadedLevelName.Contains(\"MapEditor\")` condition checks if the current loaded level contains the string \"MapEditor\". If it does, the `OnBreak()` method will not execute the `RunScript()` method.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BreakTrigger.md"}}],["76",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Brick.cs)\n\nThe code provided is a class called \"Brick\" that represents a brick object in the Brick-Force project. The purpose of this class is to define the properties and behaviors of a brick object, such as its name, alias, comment, appearance, functionality, and various other attributes.\n\nThe class contains several enums that define different aspects of a brick, such as its direction (DIR), function (FUNCTION), category (CATEGORY), spawner type (SPAWNER_TYPE), and replace check (REPLACE_CHECK). These enums are used to categorize and identify different types of bricks in the game.\n\nThe class also contains various properties and fields that store information about the brick, such as its name, sequence number, alias, comment, game object representation, materials, textures, and audio clips. These properties and fields are used to define the visual and audio aspects of the brick.\n\nThe class includes several methods that provide functionality related to the brick object. For example, the \"IsTutor\" method checks if the current level is a tutorial level and if the brick is only available in tutorial levels. The \"UseAbleSeason\" method checks if the current season in the game is compatible with the brick's season. The \"UseAbleGameMode\" method checks if the current game mode is compatible with the brick's game mode dependency. These methods are used to determine if the brick can be used in the current game context.\n\nThe class also includes methods for checking if the brick is climbable or shootable, getting random step sounds, bullet marks, and bullet impacts, converting coordinates to brick coordinates, determining if chunk optimization is needed, getting the spawner type of the brick, instantiating a brick object in the game world, and getting the index of the brick.\n\nOverall, this class provides a blueprint for defining and manipulating brick objects in the Brick-Force project. It is used to create and manage different types of bricks with various properties and behaviors, allowing for a diverse and customizable gameplay experience.\n## Questions: \n **Question 1:** What is the purpose of the `Brick` class?\n    \n**Answer:** The `Brick` class represents a brick object in the game and contains various properties and methods related to the brick.\n\n**Question 2:** What are the different categories of bricks that can be created?\n    \n**Answer:** The different categories of bricks that can be created are `GENERAL`, `COLORBOX`, `ACCESSORY`, and `FUNCTIONAL`.\n\n**Question 3:** What is the purpose of the `Instantiate` method in the `Brick` class?\n    \n**Answer:** The `Instantiate` method is used to create an instance of the brick object in the game world, based on the provided code, position, and rotation.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Brick.md"}}],["77",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BrickBoomItem.cs)\n\nThe code provided is a class called `BrickBoomItem` that inherits from the `ActiveItemBase` class. This class is part of the larger Brick-Force project and is responsible for equipping a \"Brick Boom\" item to a player character.\n\nThe `Awake()` and `Update()` methods are empty and do not contain any code. These methods are commonly used in Unity game development to handle initialization and update logic respectively. In this case, they are not being used.\n\nThe main functionality of this class is implemented in the `StartItem()` method. This method overrides the `StartItem()` method from the base class.\n\nThe `StartItem()` method first checks if the current instance of `BrickBoomItem` is associated with the player character controlled by the local user. This is done by calling the `IsMyItem()` method. If the item belongs to the local user, it equips the \"Brick Boom\" item to the player character by finding the game object with the name \"Me\" and getting the `LocalController` component attached to it. If the `LocalController` component exists, the `EquipBrickBoom()` method is called on it.\n\nIf the item does not belong to the local user, it retrieves the game object associated with the `useUserSeq` value from the `BrickManManager` instance. If the game object exists, it gets the `LookCoordinator` component attached to it. If the `LookCoordinator` component exists, the `EquipBrickBoom()` method is called on it.\n\nIn summary, this code is responsible for equipping the \"Brick Boom\" item to either the local user's player character or another player character based on the ownership of the item. It demonstrates how to find and interact with game objects and their components in the Unity game engine.\n## Questions: \n 1. What is the purpose of the `Awake()` and `Update()` methods in the `BrickBoomItem` class?\n- The smart developer might ask why these methods are empty and if they need to be implemented for any specific functionality.\n\n2. What is the purpose of the `StartItem()` method and how is it being used?\n- The smart developer might ask for clarification on how the `StartItem()` method is being called and what it does when it is called.\n\n3. What is the significance of the `IsMyItem()` method and how does it determine the behavior of the code?\n- The smart developer might ask how the `IsMyItem()` method is implemented and what conditions it checks in order to determine the execution path of the code.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BrickBoomItem.md"}}],["78",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BrickChunk.cs)\n\nThe `BrickChunk` class is a script that is used to manage a chunk of bricks in the larger Brick-Force project. It is attached to a game object in the Unity game engine and provides functionality for adding bricks to the chunk and merging them together.\n\nThe `Init` method is used to initialize the chunk with a material and a maximum number of children (bricks). It sets the material of the chunk's `MeshRenderer` component to the provided material and updates the `maxChildren` variable.\n\nThe `AddBrick` method is used to add a brick to the chunk. It first checks if the chunk has reached its maximum number of children. If it has, it returns false indicating that the brick cannot be added. Otherwise, it sets the brick's parent to the chunk's transform and if the `merge` parameter is true, it calls the `Merge` method.\n\nThe `GetMeshFiltersInBricks` method is a helper method that returns an array of `MeshFilter` components found in the child bricks of the chunk. It filters out any `MeshFilter` components that are on the \"BulletMark\" layer.\n\nThe `Merge` method is called when bricks are added to the chunk and the `merge` parameter is true. It first clears the mesh of the chunk's `MeshFilter` component. It then gets an array of `MeshFilter` components from the child bricks using the `GetMeshFiltersInBricks` method. If there are any `MeshFilter` components, it sets the material of the chunk's `MeshRenderer` component to the material of the first `MeshFilter` component. It then creates an array of `CombineInstance` objects to store the meshes and transforms of the child bricks. It loops through the `MeshFilter` components, excluding the chunk's own `MeshFilter`, and adds their shared mesh and local-to-world matrix to the `CombineInstance` array. It also sets the child bricks to be inactive. Finally, it combines the meshes in the `CombineInstance` array into the chunk's `MeshFilter` component, sets the chunk to be active, and updates the mesh collider of the chunk.\n\nOverall, this code provides functionality for managing and merging bricks in a chunk. It allows for the creation of complex structures by combining multiple bricks into a single mesh.\n## Questions: \n 1. What does the `Init` method do and how is it used?\n- The `Init` method initializes the BrickChunk with a specified material and maximum number of children. It sets the material of the MeshRenderer component and updates the maxChildren variable.\n\n2. What does the `AddBrick` method do and what does the `merge` parameter do?\n- The `AddBrick` method adds a brick GameObject as a child of the BrickChunk. If the number of children exceeds the maxChildren limit, it returns false. If the `merge` parameter is true, it calls the `Merge` method.\n\n3. What does the `Merge` method do and how does it work?\n- The `Merge` method combines the meshes of the child bricks into a single mesh. It sets the material of the BrickChunk to the material of the first child brick, combines the meshes using CombineInstance, and updates the MeshCollider with the combined mesh.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BrickChunk.md"}}],["79",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BrickCollisionTest.cs)\n\nThe code provided is a part of the Brick-Force project and is contained within the `BrickCollisionTest` class. This class is responsible for handling collisions between bricks in the game. \n\nThe `BrickCollisionTest` class has two private variables: `seq` and `index`. These variables are used to store the sequence and index values of the brick. \n\nThe class also has two public properties: `Seq` and `Index`. These properties allow other classes to set the values of `seq` and `index` respectively. \n\nThe main functionality of this class is implemented in the `OnTriggerEnter` method. This method is called when a collision occurs with a trigger collider attached to the game object. In this case, the method is triggered when a collision occurs with the brick. \n\nInside the `OnTriggerEnter` method, the code first checks if the collided object has a `LocalController` component attached to it. If it does, it retrieves the `LocalController` component using the `GetComponent` method. \n\nIf the `LocalController` component is not null, it calls the `OnTrampoline` method of the `LocalController` component, passing in the value of `seq` as an argument. This suggests that the collision with the brick triggers some action related to a trampoline in the game. \n\nAdditionally, the code also calls the `AnimationPlay` method of the `BrickManager` class, passing in the values of `index`, `seq`, and \"fire\" as arguments. This suggests that the collision with the brick triggers a specific animation related to the brick. \n\nIn summary, the `BrickCollisionTest` class handles collisions between bricks in the game. It triggers actions related to a trampoline and plays animations using the `LocalController` and `BrickManager` classes respectively. This code is likely a part of a larger project that involves building and interacting with bricks in a game environment.\n## Questions: \n 1. **What is the purpose of the `BrickCollisionTest` class?**\nThe purpose of the `BrickCollisionTest` class is to handle collisions with other objects and perform certain actions based on the collision.\n\n2. **What is the significance of the `Seq` and `Index` properties?**\nThe `Seq` and `Index` properties are used to set the values of the `seq` and `index` variables respectively. These variables are likely used in other parts of the code to determine specific behavior or actions.\n\n3. **What does the `OnTriggerEnter` method do?**\nThe `OnTriggerEnter` method is called when a collision occurs with a trigger collider. In this code, it checks if the collided object has a `LocalController` component and if so, it calls the `OnTrampoline` method of that component and the `AnimationPlay` method of the `BrickManager` instance.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BrickCollisionTest.md"}}],["80",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BrickCreator.cs)\n\nThe `BrickCreator` class is responsible for creating and managing bricks in the larger Brick-Force project. \n\nThe class has several private variables, including `seq`, `brick`, `rot`, `newBrick`, `deltaTime`, `cube`, and `boxCollider`. These variables are used to store information about the brick being created and its properties.\n\nThe `Start()` method is called when the object is first created. It initializes the `newBrick` variable by calling the `GetBrick()` method from the `BrickManager` class. If the `newBrick` is null, an error message is logged. The method then sets the rotation of the object based on the `rot` value. It finds the `Cube` child object and sets its position and scale based on the `center` and `size` values fetched from the `BrickManager`. It also sets the `targetScale` of the `UniformedScaler` component attached to the `Cube` object. Finally, it sets the size and center of the `boxCollider` attached to the object.\n\nThe `Update()` method is called every frame. It increments the `deltaTime` variable by the time since the last frame. If the `deltaTime` is greater than the `delayTime`, the method checks if the `boxCollider` is not null. If it is not null, it destroys the `boxCollider`. It then checks if the new brick is empty at the current position. If it is empty, it removes the brick creator from the `BrickManager`, adds the brick to the `BrickManager`, and destroys the object. If the new brick is not empty, it checks if the current player is the master player. If they are, it checks if the brick is invalid (not empty). If it is invalid, it logs an error message, sends a request to delete the brick, and destroys the object. If the current player is not the master player, it checks if the brick is invalid. If it is invalid, it logs an error message and destroys the object.\n\nOverall, this code is responsible for creating bricks, setting their properties, and managing their placement in the game world. It ensures that bricks are only created and placed if they are valid and not overlapping with other bricks.\n## Questions: \n 1. What is the purpose of the `BrickCreator` class?\n- The `BrickCreator` class is responsible for creating and managing bricks in the game.\n\n2. What does the `Start()` method do?\n- The `Start()` method initializes the `BrickCreator` by setting up the brick's properties and components.\n\n3. What is the purpose of the `Update()` method?\n- The `Update()` method is called every frame and handles the logic for destroying and adding bricks based on certain conditions.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BrickCreator.md"}}],["81",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BrickForce.cs)\n\nThe code provided is a static class called `BrickForce` that contains a single method called `Restart()`. This method is responsible for restarting the Brick-Force application.\n\nThe `Restart()` method first creates a new instance of the `ProcessStartInfo` class, which is used to specify the start-up information for a new process. \n\nNext, it checks the version of the operating system using the `Environment.OSVersion.Version.Major` property. If the major version is greater than or equal to 6, it sets the `Verb` property of the `ProcessStartInfo` object to \"runas\". This indicates that the process should be run with elevated privileges, typically requiring administrator access. This is done to ensure that the application is restarted with the necessary permissions.\n\nThe `CreateNoWindow` property of the `ProcessStartInfo` object is set to `false`, which means that a new window will be created when the process is started. \n\nThe `FileName` property is set to \"BrickForce.exe\", indicating that the application to be restarted is named \"BrickForce.exe\".\n\nThe `UseShellExecute`, `RedirectStandardError`, `RedirectStandardInput`, and `RedirectStandardOutput` properties are all set to `false`, indicating that the process should not use the operating system shell to execute, and that no error, input, or output streams should be redirected.\n\nFinally, the `Process.Start()` method is called with the `ProcessStartInfo` object as a parameter. This starts a new process with the specified start-up information.\n\nIf an exception occurs during the process of restarting the application, the exception message is logged as an error using `UnityEngine.Debug.LogError()`.\n\nIn the larger project, this code can be used to provide a way for the user to restart the Brick-Force application. For example, it can be called when the user selects a \"Restart\" button in the game's settings menu. By restarting the application, any changes or updates made to the game can take effect without the user having to manually close and reopen the application.\n## Questions: \n 1. What is the purpose of the `Restart` method?\n- The `Restart` method is used to restart the BrickForce application.\n\n2. Why is the `Verb` property set to \"runas\" if the operating system version is greater than or equal to 6?\n- The `Verb` property is set to \"runas\" to run the process with administrator privileges if the operating system version is Windows Vista or later.\n\n3. What happens if an exception is thrown during the execution of the `Restart` method?\n- If an exception is thrown, the error message is logged using `UnityEngine.Debug.LogError`.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BrickForce.md"}}],["82",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BrickInst.cs)\n\nThe code provided is a class called `BrickInst` that represents a brick instance in the Brick-Force project. This class is used to store information about a specific brick, such as its position, rotation, and associated script.\n\nThe class has several public properties and a constructor. The properties include `Seq`, which represents the sequence number of the brick instance; `Template`, which represents the template of the brick; `PosX`, `PosY`, and `PosZ`, which represent the X, Y, and Z coordinates of the brick's position; `Code`, which represents a code associated with the brick; `Rot`, which represents the rotation of the brick; `BrickForceScript`, which represents the script associated with the brick; and `pathcnt`, which represents the count of paths associated with the brick.\n\nThe constructor takes in several parameters, including `seq`, `template`, `x`, `y`, `z`, `code`, and `rot`, and initializes the corresponding properties of the class.\n\nThe class also has a method called `UpdateScript`, which takes in parameters `alias`, `enableOnAwake`, `visibleOnAwake`, and `commands`. This method creates a new instance of the `BfScript` class, passing in the provided parameters, and assigns it to the `BrickForceScript` property of the `BrickInst` class.\n\nThis `BrickInst` class is likely used in the larger Brick-Force project to represent individual bricks and store their properties and associated scripts. It provides a convenient way to create and update brick instances with the necessary information. For example, in the larger project, there may be a system that allows users to create and customize bricks, and this class would be used to store and manage the data for each individual brick instance.\n\nHere is an example of how the `BrickInst` class could be used in the larger project:\n\n```csharp\n// Create a new brick instance\nBrickInst brick = new BrickInst(1, 2, 3, 4, 5, 6, 7);\n\n// Update the script of the brick instance\nbrick.UpdateScript(\"myAlias\", true, false, \"print('Hello, world!')\");\n```\n\nIn this example, a new `BrickInst` object is created with the provided parameters. Then, the `UpdateScript` method is called to update the script of the brick instance with the provided values.\n## Questions: \n 1. What is the purpose of the `BrickInst` class?\n- The `BrickInst` class represents a brick instance and stores information about its position, rotation, and associated script.\n\n2. What is the significance of the `UpdateScript` method?\n- The `UpdateScript` method allows for updating the script associated with the brick instance by creating a new `BfScript` object with the provided parameters.\n\n3. What is the purpose of the `pathcnt` variable?\n- The `pathcnt` variable is used to store the number of paths associated with the brick instance.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BrickInst.md"}}],["83",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BrickManDesc.cs)\n\nThe code provided is a class called `BrickManDesc` that represents a player in the game. It contains various properties and methods related to the player's status, equipment, statistics, and gameplay functionality.\n\nThe `BrickManDesc` class has several properties that store information about the player, such as their nickname, equipment, health points (hp), armor, experience points (xp), rank, and various statistics like kills, deaths, assists, and mission progress. It also has properties related to the player's clan affiliation and average ping time.\n\nThe class includes methods to change the player's weapon and drop weapon, reset game-related statistics, equip and unequip items, and check if the player is considered hostile in the current game mode. There is also a method to compare two `BrickManDesc` objects based on their score and kills.\n\nThe purpose of this class is to provide a data structure to store and manage player information during gameplay. It is likely used in the larger project to keep track of player data, update player statistics, and handle player interactions and gameplay mechanics.\n\nHere is an example of how this class could be used in the larger project:\n\n```csharp\n// Create a new instance of BrickManDesc for a player\nBrickManDesc player = new BrickManDesc(1, \"Player1\", new string[]{\"weapon1\", \"weapon2\"}, 1, 100, 1, \"Clan1\", 1, 10, new string[]{\"weapon1\", \"weapon2\"}, new string[]{\"dropItem1\", \"dropItem2\"});\n\n// Change the player's weapon\nplayer.ChangeWeapon(\"weapon3\");\n\n// Equip a new item\nplayer.Equip(\"item1\");\n\n// Check if the player is hostile\nbool isHostile = player.IsHostile();\n\n// Compare two players based on their score and kills\nint comparisonResult = player.Compare(otherPlayer);\n```\n\nIn summary, the `BrickManDesc` class is a representation of a player in the game, providing properties and methods to manage player information, statistics, and gameplay functionality. It is an essential component of the larger Brick-Force project, allowing for player data management and gameplay mechanics.\n## Questions: \n 1. **What is the purpose of the `BrickManDesc` class?**\nThe `BrickManDesc` class represents a player in the game and stores various attributes and statistics about the player.\n\n2. **What is the significance of the `STATUS` enum?**\nThe `STATUS` enum represents the different states that a player can be in, such as waiting, ready, loading, playing, etc.\n\n3. **What is the purpose of the `ChangeWeapon` and `ChangeDropWeapon` methods?**\nThe `ChangeWeapon` and `ChangeDropWeapon` methods are used to change the player's equipped weapon and dropped weapon, respectively. They validate the new weapon code and update the corresponding arrays in the `BrickManDesc` class.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BrickManDesc.md"}}],["84",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BrickNumber.cs)\n\nThe code provided is a part of the Brick-Force project and is contained within the `BrickNumber` class. This class is responsible for displaying the number of bricks in the game's user interface (UI). \n\nThe `OnGUI` method is called by Unity's GUI system to render the UI elements. Within this method, there are several GUI operations that are performed to display the brick count. \n\nFirst, the method checks if the GUI is enabled and if the BrickManager is loaded. If both conditions are met, the GUI skin is set to the one obtained from the GUISkinFinder, the GUI depth is set to the specified value, and the GUI is enabled if there are no modal dialogs present. \n\nNext, a GUI group is created using the `GUI.BeginGroup` method. This group defines a rectangular area on the screen where the UI elements will be rendered. The position and size of the group are calculated based on the screen width and the `crdSize` vector.\n\nInside the GUI group, several UI elements are created using the `GUI.Box` and `LabelUtil.TextOut` methods. These elements include two boxes to display the brick count and special brick count, as well as labels for the brick and unit names. The positions and sizes of these elements are calculated based on the `crdSize` and `crdCountBox` vectors.\n\nFinally, the GUI group is closed using the `GUI.EndGroup` method, and the GUI is enabled again.\n\nOverall, this code is responsible for rendering the brick count UI in the game. It retrieves the necessary information from the BrickManager and StringMgr classes and uses the GUI system provided by Unity to display the UI elements on the screen. This code is likely used in the larger project to provide players with a visual representation of the number of bricks they have in the game.\n## Questions: \n 1. What is the purpose of the `OnGUI()` method?\n- The `OnGUI()` method is responsible for rendering the graphical user interface (GUI) elements on the screen.\n\n2. What does the `guiDepth` variable represent?\n- The `guiDepth` variable determines the layer at which the GUI elements will be rendered.\n\n3. What is the significance of the `crdSize` and `crdCountBox` variables?\n- The `crdSize` variable represents the size of the GUI group, while the `crdCountBox` variable represents the size of the GUI box used to display the count of bricks.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BrickNumber.md"}}],["85",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BrickProperty.cs)\n\nThe code provided is a class called \"BrickProperty\" that is a part of the larger Brick-Force project. This class is responsible for managing the properties and behavior of a brick object in the game.\n\nThe class has several private variables: \"seq\", \"chunk\", \"index\", \"hitPoint\", and \"visible_t\". These variables store information about the brick's sequence number, chunk number, index, hit points, and visibility status respectively.\n\nThe class also has several public properties: \"Seq\", \"Chunk\", \"Index\", \"HitPoint\", and \"Visible_t\". These properties provide access to the private variables, allowing other classes to read and modify the values. For example, the \"Seq\" property allows other classes to get and set the value of the \"seq\" variable.\n\nThe class also has a public method called \"Hit\", which takes an integer parameter \"AtkPow\". This method is called when the brick is hit by an attack. It first retrieves the brick object associated with the index value from the BrickManager. If the brick is destructible and has a function of type \"SCRIPT\", it checks if there is a \"Trigger\" component attached to the brick. If the \"Trigger\" component is not found or is disabled, the method returns without further action.\n\nIf the brick has hit points greater than 0, the method subtracts the attack power from the hit points. If the hit points become less than or equal to 0 and the brick has a function of type \"SCRIPT\", the method broadcasts the \"OnBreak\" message to all scripts attached to the brick. If the current scene name contains \"Tutor\", the BrickManager destroys the brick associated with the sequence number.\n\nIn summary, this code manages the properties and behavior of a brick object in the game. It provides access to the brick's sequence number, chunk number, index, hit points, and visibility status. It also handles the logic for when the brick is hit, triggering events and potentially destroying the brick. This class is likely used in conjunction with other classes and scripts to create the gameplay mechanics involving bricks in the Brick-Force project.\n## Questions: \n 1. What is the purpose of the `Hit` method?\n- The `Hit` method is used to handle the logic for when a brick is hit by an attack. It checks if the brick is destructible and reduces its hit points accordingly.\n\n2. What is the significance of the `seq` variable?\n- The `seq` variable represents the sequence number of the brick. It is used to identify and manage individual bricks within the game.\n\n3. What is the purpose of the `Visible_t` property?\n- The `Visible_t` property is used to determine if the brick is visible or not. It can be used to control the visibility of the brick in the game.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BrickProperty.md"}}],["86",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Briefing4Bnd.cs)\n\nThe `Briefing4Bnd` class is a script that is part of the Brick-Force project. It is responsible for managing the briefing screen in the game. The purpose of this code is to handle the user interface and functionality of the briefing screen, allowing players to interact with various elements such as the chat, equipment, shop, and messenger.\n\nThe code starts by declaring several variables, including references to various game objects and textures used in the briefing screen. It also defines the positions and sizes of different UI elements on the screen.\n\nThe `Start` method is called when the script is first initialized. It sets up the initial state of the briefing screen by calling various methods to initialize different components such as the lobby chat, mirror, equipment frame, shop frame, and messenger. It also sets the mirror type to \"simple\" and sends a network request to resume the room if the player is the room master.\n\nThe `DrawCurrentChannel` method is responsible for displaying the name of the current channel on the screen.\n\nThe `OnGUI` method is called every frame to handle the rendering of the UI elements on the screen. It first sets up the GUI skin and enables or disables certain UI elements based on the current state of the game. It then draws various UI elements such as buttons, labels, and textures based on the current step of the briefing screen. The method also handles button clicks and toggles the messenger view on or off.\n\nThe `Update` method is called every frame to update the state of the briefing screen. It updates various components such as the lobby chat, messenger, mirror, channel label, equipment frame, shop frame, and briefing panel. It also checks if a certain amount of time has passed and if the player has been exiled from their clan.\n\nThe `OnClanExiled` method is called when the player has been exiled from their clan. It displays a message to the player and performs some cleanup by closing dialogs and sending network requests to leave the squad and clear the squad manager.\n\nOverall, this code manages the briefing screen in the Brick-Force game, allowing players to interact with various elements and providing a smooth user experience.\n## Questions: \n 1. What is the purpose of the `Start()` method in this code?\nThe `Start()` method is used to initialize various components and variables when the game starts.\n\n2. What is the purpose of the `OnGUI()` method in this code?\nThe `OnGUI()` method is responsible for rendering the user interface elements on the screen.\n\n3. What is the purpose of the `Update()` method in this code?\nThe `Update()` method is used to update various components and variables every frame.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Briefing4Bnd.md"}}],["87",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Briefing4Capture.cs)\n\nThe code provided is a script for the Briefing4Capture class in the Brick-Force project. This class is responsible for managing the briefing screen before a team match in the game. \n\nThe code starts by declaring several variables, including textures, other scripts, and GUI coordinates. It also initializes some variables and sets up the audio source. \n\nThe Start() method is called when the script is first initialized. It calls various methods to start the lobby tools, briefing panel, lobby chat, mirror, equipment frame, shop frame, CTF mode configuration, messenger, channel label, player list frame, and the BrickManManager. It also checks if the current player is the room master and sends a request to resume the room if they are. \n\nThe DrawCurrentChannel() method is responsible for drawing the current channel name on the screen. \n\nThe OnGUI() method is called every frame to handle the graphical user interface. It sets up the GUI skin and draws various GUI elements, such as buttons, labels, and textures. It also handles button clicks and performs different actions based on the current GUI step. For example, if the GUI step is 0, it handles the close button click, draws the channel label, mirror, CTF configuration, lobby chat, player list frame, briefing panel, my equipment button, shop button, and messenger button. If the GUI step is 1 or 2, it handles the close button click, draws the mirror, equipment frame or shop frame, and handles the chat view. \n\nThe Update() method is called every frame and updates various components, such as the lobby chat, messenger, mirror, lobby tools, channel label, equipment frame, shop frame, and briefing panel. It also checks if a certain amount of time has passed and if the player has been exiled from their clan. \n\nThe OnClanExiled() method is called when the player has been exiled from their clan. It displays a message and performs various actions, such as closing dialogs and loading the lobby scene. \n\nThe End() method is called when the script is disabled. \n\nThe OnDisable() method is called when the script is disabled. \n\nThe OnKillLog() method is called when a kill log is received. \n\nThe OnChat() method is called when a chat message is received. \n\nIn summary, this script manages the briefing screen before a team match in the game. It handles the GUI, updates various components, and performs actions based on user input. It also handles events such as receiving kill logs and chat messages.\n## Questions: \n 1. What is the purpose of the `Start()` method?\n- The `Start()` method is responsible for initializing various components and setting up the initial state of the game.\n\n2. What is the significance of the `guiStep` variable?\n- The `guiStep` variable is used to determine which part of the GUI should be displayed and updated. It is used to control the flow of the user interface.\n\n3. What is the purpose of the `OnGUI()` method?\n- The `OnGUI()` method is responsible for rendering and handling user input for the graphical user interface (GUI) elements of the game. It is called every frame to update the GUI.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Briefing4Capture.md"}}],["88",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Briefing4Defense.cs)\n\nThe code provided is a script for the Briefing4Defense class in the Brick-Force project. This class is responsible for managing the user interface and functionality of the briefing screen for the defense mode in the game.\n\nThe class contains various public variables that reference other scripts and assets used in the briefing screen, such as textures, lobby tools, lobby chat, mirror, equipment frame, shop frame, messenger, channel label, defense mode configuration, briefing panel, and player list frame.\n\nThe Start() method is called when the script is initialized. It performs several initialization tasks, such as setting up event listeners, setting the GUI step to 0, initializing the messenger, lobby tools, lobby chat, mirror, equipment frame, shop frame, channel label, defense mode configuration, player list frame, and setting the mirror type to simple. It also checks if the current player is the room master and sends a request to resume the room if they are.\n\nThe OnClanExiled() method is called when the player is exiled from their clan. It displays a message box with the appropriate message.\n\nThe OnGUI() method is responsible for rendering the user interface elements on the screen. It uses the Unity GUI system to draw various buttons, labels, and textures. The method checks the current GUI step and renders different elements based on the step. It also handles button clicks and performs actions accordingly, such as opening the equipment frame or shop frame, toggling the messenger, and closing the briefing screen.\n\nThe Update() method is called every frame and is responsible for updating the various components of the briefing screen, such as the lobby chat, messenger, mirror, lobby tools, channel label, equipment frame, shop frame, and briefing panel.\n\nThe OnChat() method is called when a chat message is received. It enqueues the chat message to be displayed in the lobby chat.\n\nOverall, this script manages the user interface and functionality of the briefing screen for the defense mode in the game. It handles rendering the UI elements, handling button clicks, updating components, and displaying chat messages. It is an essential part of the larger Brick-Force project as it provides the user with the necessary tools and information to prepare for the defense mode gameplay.\n## Questions: \n 1. What is the purpose of the `Start()` method in this code?\n- The `Start()` method is responsible for initializing various components and sending network requests to set up the game lobby.\n\n2. What is the significance of the `guiStep` variable in the `OnGUI()` method?\n- The `guiStep` variable is used to determine which part of the user interface should be displayed and interacted with. It controls the flow of the GUI.\n\n3. What is the purpose of the `OnChat()` method?\n- The `OnChat()` method is called when a new chat message is received. It enqueues the chat message to be displayed in the lobby chat.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Briefing4Defense.md"}}],["89",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Briefing4Explosion.cs)\n\nThe code provided is a script for the Brick-Force project. This script is called \"Briefing4Explosion\" and is written in C# using the Unity game engine.\n\nThe purpose of this script is to handle the user interface and functionality of the briefing screen for a team match in the game. The briefing screen is where players can prepare for the upcoming match by selecting equipment, chatting with teammates, and accessing various game features.\n\nThe script contains several public variables that reference other scripts and game objects, such as textures, lobby tools, lobby chat, mirror, blast mode configuration, player list frame, equipment frame, shop frame, messenger, briefing panel, and channel label. These variables are used to access and interact with the corresponding components in the game.\n\nThe script also contains private variables for storing GUI coordinates, GUI step, and messenger status. These variables are used for positioning and controlling the user interface elements on the briefing screen.\n\nThe Start() method is called when the script is first initialized. It initializes various components and sets the initial values for variables. It also sends network requests to retrieve data related to the player's squad and room.\n\nThe DrawCurrentChannel() method is responsible for displaying the current channel name on the screen.\n\nThe OnGUI() method is called every frame to handle the rendering and interaction of the user interface elements. It uses Unity's GUI system to draw buttons, labels, and other UI elements. It also handles button clicks and updates the state of the UI based on user input.\n\nThe Update() method is called every frame to update the state of the UI elements and handle any necessary logic. It updates components such as lobby chat, messenger, mirror, lobby tools, channel label, equipment frame, shop frame, and briefing panel. It also checks for certain conditions, such as if the player has been exiled from their clan, and takes appropriate actions.\n\nThe OnClanExiled() method is called when the player has been exiled from their clan. It displays a message to the player and performs necessary actions, such as closing dialogs and loading the lobby scene.\n\nOverall, this script is an important part of the Brick-Force project as it handles the functionality and user interface of the briefing screen for team matches. It allows players to prepare for matches by selecting equipment, chatting with teammates, and accessing various game features.\n## Questions: \n 1. What is the purpose of the `Start()` method in this code?\nThe `Start()` method is used to initialize various components and variables when the script is first started.\n\n2. What does the `OnGUI()` method do?\nThe `OnGUI()` method is responsible for rendering the user interface elements on the screen, such as buttons and labels.\n\n3. What is the significance of the `guiStep` variable?\nThe `guiStep` variable is used to determine which section of the user interface should be displayed and updated.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Briefing4Explosion.md"}}],["90",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Briefing4IndividualMatch.cs)\n\nThe code provided is a script for the Briefing4IndividualMatch class in the Brick-Force project. This class is responsible for managing the user interface and functionality of the individual match briefing screen. \n\nThe code starts by declaring several public variables, including textures, tools, chat, mirror, equipment, shop, messenger, player list, briefing panel, individual match configuration, and channel label. These variables are used to reference various UI elements and components that are needed for the briefing screen.\n\nThe code also declares several private variables, including rectangles and vectors that define the positions and sizes of various UI elements on the screen. These variables are used for positioning and sizing the UI elements correctly.\n\nThe Start() method is called when the script is first initialized. It initializes various components and sets up the initial state of the briefing screen. It calls the Start() method of the lobby chat, mirror, equipment, shop, messenger, individual match configuration, channel label, player list, and mirror components. It also sets the mirror type to \"SIMPLE\" and sends a network request to resume the room if the player is the room master.\n\nThe OnClanExiled() method is called when the player is exiled from their clan. It displays a message box with the appropriate message.\n\nThe OnGUI() method is called every frame to update and draw the UI elements on the screen. It begins by setting up the GUI skin and enabling or disabling GUI elements based on the current state of the game. It then draws various UI elements, such as buttons, labels, and textures, using the positions and sizes defined in the private variables. The method also handles button clicks and performs the appropriate actions based on the current state of the game.\n\nThe Update() method is called every frame to update the state of the UI elements and components. It calls the Update() method of the lobby chat, messenger, mirror, lobby tools, channel label, equipment, shop, and briefing panel components.\n\nThe End() method is called when the script is about to be destroyed. It is currently empty and does not perform any actions.\n\nThe OnDisable() method is called when the script is disabled. It is currently empty and does not perform any actions.\n\nThe OnKillLog() method is called when a kill log is received. It is currently empty and does not perform any actions.\n\nThe OnChat() method is called when a chat message is received. It enqueues the chat message to be displayed in the lobby chat.\n\nIn summary, this code manages the user interface and functionality of the individual match briefing screen in the Brick-Force project. It initializes and updates various UI elements and components, handles button clicks and user input, and displays messages and chat logs. It is an essential part of the larger project as it provides the interface for players to interact with the game and prepare for individual matches.\n## Questions: \n 1. What is the purpose of the `Start()` method?\n- The `Start()` method is used to initialize various components and send network requests when the briefing screen for an individual match is loaded.\n\n2. What is the purpose of the `OnGUI()` method?\n- The `OnGUI()` method is responsible for rendering the user interface elements on the briefing screen for an individual match, such as buttons, labels, and textures.\n\n3. What is the purpose of the `Update()` method?\n- The `Update()` method is used to update various components and handle user input on the briefing screen for an individual match, such as updating the lobby chat, messenger, and equipment frame.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Briefing4IndividualMatch.md"}}],["91",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BriefingPanel4Defense.cs)\n\nThe code provided is a class called `BriefingPanel4Defense` that is used in the larger Brick-Force project. This class is responsible for managing the user interface and functionality of a briefing panel for the defense team in a game room.\n\nThe class contains several private variables of type `Rect` that define the coordinates and dimensions of various buttons on the panel. These buttons include a start button (`crdStartBtn`) and a change team button (`crdChangeLeftBtn`).\n\nThe `Start()` method is empty and does not contain any code.\n\nThe `OnGUI()` method is responsible for rendering the user interface elements on the screen. It first checks if the player's slot in the game room is greater than or equal to 0. If it is, it proceeds to render the UI elements.\n\nInside the method, it checks if the player is the master of the room. If they are, it sets a boolean flag to true. It then retrieves the current room from the `RoomManager` and checks if the room is not null and its status is set to \"playing\". If these conditions are met, it renders the start button with the label \"START\" and an associated icon. Clicking on this button triggers a series of checks and actions, such as checking if the rendezvous point has been completed, if the player has a weapon limited by star rate, and if the application is not currently loading a level. If all these conditions are met, it sets a flag `BreakingInto` to true and sends a network request to break into the game.\n\nThe method also renders the change team button, which triggers a network request to change the team if clicked.\n\nIf the player is not the master of the room, it renders a different set of UI elements. It checks if the battle is starting and sets a string key accordingly. It then renders the start button with the label \"START\" or \"CANCEL\" depending on the battle status. Clicking on this button triggers similar checks and actions as before, but with some variations based on the battle status.\n\nThe method also renders a \"RANDOM_INVITE\" button that triggers a network request to send a random invite if clicked. There is a check to ensure that the random invite can only be sent after a certain time interval has passed.\n\nIf the player is not in the defense team, it renders a different set of UI elements. It renders the change team button and triggers a network request to change the team if clicked. It also renders a \"READY\" button if the player's status is not set to 1 (indicating that they are ready). Clicking on this button triggers similar checks and actions as before, but with some variations based on the player's status.\n\nThe `Update()` method is responsible for updating the `inviteAfter` variable by adding the elapsed time since the last frame. This variable is used to track the time interval for sending random invites.\n\nIn summary, this class manages the user interface and functionality of a briefing panel for the defense team in a game room. It renders different UI elements and triggers network requests based on the player's role and status in the room.\n## Questions: \n 1. What is the purpose of the `Start()` method in the `BriefingPanel4Defense` class?\n- The purpose of the `Start()` method is not clear from the given code. It seems to be an empty method that does not have any functionality.\n\n2. What is the significance of the `inviteAfter` variable and how is it used?\n- The `inviteAfter` variable is used to track the time elapsed since the last invitation was sent. It is incremented in the `Update()` method using `Time.deltaTime` and is used in the code to determine when to send a random invite.\n\n3. What is the purpose of the `OnGUI()` method and what functionality does it provide?\n- The `OnGUI()` method is responsible for rendering the graphical user interface (GUI) elements on the screen. It contains conditional statements and button actions based on the current state of the game room and the player's status.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BriefingPanel4Defense.md"}}],["92",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BriefingPanel4Individual.cs)\n\nThe code provided is a class called `BriefingPanel4Individual` that is used to handle the user interface (UI) for a briefing panel in the larger Brick-Force project. The purpose of this code is to display different UI elements and handle user interactions based on the current state of the game.\n\nThe `OnGUI` method is responsible for rendering the UI elements on the screen. It first checks if the player's slot is valid (`MyInfoManager.Instance.Slot >= 0`). If it is, it sets the GUI skin and checks if the player is the master of the current room (`RoomManager.Instance.Master == MyInfoManager.Instance.Seq`). \n\nIf the player is the master and the room is in the playing state, a \"START\" button is displayed. When this button is clicked, it performs several checks before taking action. It checks if the room can be broken into (`!room.isBreakInto`), if the rendezvous point has been completed (`!P2PManager.Instance.RendezvousPointed`), if the player has a weapon limited by star rate (`MyInfoManager.Instance.HaveWeaponLimitedByStarRate()`), and if the level is not currently loading (`!Application.isLoadingLevel`). If all these conditions are met, it sets the `BreakingInto` flag to true and sends a `CS_BREAK_INTO_REQ` message.\n\nIf the player is the master and the room is not in the playing state, a \"START\" or \"CANCEL\" button is displayed based on the `battleStarting` flag. When this button is clicked, it performs similar checks as before and sends a `CS_START_REQ` message with the appropriate parameters.\n\nIf the player is not the master and their status is not 1, a \"READY\" button is displayed. When this button is clicked, it performs similar checks as before and sends a `CS_SET_STATUS_REQ` message with the status set to 1.\n\nIf none of the above conditions are met, a \"ROOM_STATUS_WAITING\" button is displayed. When this button is clicked, it sends a `CS_SET_STATUS_REQ` message with the status set to 0.\n\nThe `Update` method is responsible for updating the `inviteAfter` variable, which keeps track of the time since the last invitation was sent. It increments the `inviteAfter` variable by the time since the last frame (`Time.deltaTime`).\n\nOverall, this code provides the functionality to display and handle user interactions with the briefing panel UI in the Brick-Force game.\n## Questions: \n 1. What is the purpose of the `Start()` method in the `BriefingPanel4Individual` class?\n- The purpose of the `Start()` method is not clear from the given code. It appears to be an empty method and does not have any functionality implemented.\n\n2. What is the significance of the `inviteAfter` variable and how is it used in the code?\n- The `inviteAfter` variable is used to track the time elapsed since the last invite was sent. It is incremented in the `Update()` method using `Time.deltaTime`. It is used in the code to determine if a random invite can be sent.\n\n3. What is the purpose of the `OnGUI()` method in the `BriefingPanel4Individual` class?\n- The `OnGUI()` method is responsible for rendering the graphical user interface (GUI) elements based on certain conditions and user interactions. It handles different scenarios based on the current room status and the player's role.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BriefingPanel4Individual.md"}}],["93",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BriefingPanel4TeamMatch.cs)\n\nThe code provided is a class called \"BriefingPanel4TeamMatch\" that is used in the larger Brick-Force project. This class is responsible for displaying and handling the user interface for the briefing panel in a team match scenario.\n\nThe class contains several Rect variables that define the position and size of various buttons on the panel. These variables are used to position the buttons correctly on the screen.\n\nThe class also has a constant variable RANDOM_INVITE_RESEND_TIME, which is set to 3 seconds. This variable is used to determine the time interval between random invite requests.\n\nThe class has several methods, including Start(), OnGUI(), and Update(). The Start() method is empty and does not contain any code. The Update() method is responsible for updating the inviteAfter variable by adding the deltaTime value to it.\n\nThe main method of interest is the OnGUI() method. This method is called every frame and is responsible for rendering the user interface elements on the screen. The method first checks if the player's slot is greater than or equal to 0. If it is, it proceeds to render the UI elements.\n\nThe method then checks if the player is the master of the room. If they are, it sets a flag to true. It then retrieves the current room and checks if it is not null and if its status is set to \"PLAYING\". If these conditions are met, it renders the \"START\" button and the \"Change Team\" button.\n\nIf the player is not the master of the room, it checks if the current channel mode is not equal to 4 (indicating it is not a clan team match). If this condition is met, it renders the \"Change Team\" button and the \"Random Invite\" button.\n\nIf the current channel mode is equal to 4 (indicating it is a clan team match), it checks if the clan team match success is equal to -1. If it is, it renders the \"Change Team\" button and the \"Match\" button. If the clan team match success is not equal to -1, it only renders the \"Match\" button.\n\nIf the player's status is not equal to 1 (indicating they are not ready), it renders the \"Ready\" button. If the player's status is equal to 1, it renders the \"Waiting\" button.\n\nOverall, this class is responsible for rendering the briefing panel for a team match scenario and handling the button clicks for various actions such as starting the match, changing teams, and sending random invites. It is an important component of the larger Brick-Force project as it provides the user interface for team matches.\n## Questions: \n 1. What is the purpose of the `Start()` method in the `BriefingPanel4TeamMatch` class?\n- The purpose of the `Start()` method is not clear from the code provided. It appears to be an empty method that does not have any functionality.\n\n2. What is the significance of the `inviteAfter` variable and how is it used?\n- The `inviteAfter` variable is used to track the time since the last invite was sent. It is incremented in the `Update()` method using `Time.deltaTime`. It is used in the `OnGUI()` method to determine if a random invite can be sent.\n\n3. What is the purpose of the `BtnAction` method referenced in the `GlobalVars.Instance.MyButton3()` calls?\n- The purpose of the `BtnAction` method is not clear from the code provided. It is likely a method that handles the button click event, but its implementation is not shown in the provided code.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BriefingPanel4TeamMatch.md"}}],["94",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Buff.cs)\n\nThe code provided is a script for a class called \"Buff\" in the Brick-Force project. This class is responsible for managing and displaying a buff icon on the game's Heads-Up Display (HUD). The buff icon is displayed as a button with a tooltip that provides additional information about the buff.\n\nThe class has several fields and methods that control the behavior of the buff icon. The \"guiDepth\" field determines the layer on which the GUI element will be rendered. The \"offset\" field specifies the position of the buff icon relative to the top-left corner of the screen. The \"flip\" field is a boolean flag that determines whether the buff icon should be flipped horizontally. The \"deltaTime\" field keeps track of the time elapsed since the last flip of the buff icon.\n\nThe \"Start\" method initializes the \"flip\" and \"deltaTime\" fields to their default values.\n\nThe \"OnGUI\" method is called every frame to render the GUI elements. It first checks if the GUI is enabled by checking the \"isGuiOn\" flag in the \"MyInfoManager\" class. If GUI is enabled, it sets the GUI skin and depth, and enables GUI interaction if there is no active modal dialog. It then retrieves the current tooltip and level icon from the \"Aps\" class and renders the buff icon button using the retrieved icon and tooltip. If there is a tooltip and it is not empty, it calculates the size of the tooltip text and renders a box with the tooltip text at the current mouse position.\n\nThe \"Update\" method is called every frame to update the state of the buff icon. It increments the \"deltaTime\" field by the time elapsed since the last frame. If the \"flip\" flag is true, it checks if enough time has passed (0.3 seconds) to flip the buff icon back to its original state. If the \"flip\" flag is false, it checks if enough time has passed (1 second) to flip the buff icon horizontally.\n\nOverall, this code manages the rendering and behavior of a buff icon on the game's HUD. It handles the display of the buff icon, tooltip, and flipping animation. The class can be used in the larger project to create and manage various buffs that can be applied to the player or other game entities.\n## Questions: \n 1. What is the purpose of the `Buff` class?\n- The `Buff` class is responsible for handling the graphical user interface (GUI) for displaying a buff in the game.\n\n2. What is the significance of the `guiDepth` variable?\n- The `guiDepth` variable determines the layer at which the GUI elements associated with the `Buff` class will be rendered.\n\n3. What is the purpose of the `flip` and `deltaTime` variables?\n- The `flip` variable is used to alternate between two states, and the `deltaTime` variable is used to keep track of the time elapsed since the last state change. These variables are used to control the animation of the buff icon.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Buff.md"}}],["95",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BuffDesc.cs)\n\nThe code provided is a class called `BuffDesc` that is used to define and store information about different buffs in the Brick-Force project. \n\nThe class is marked with the `[Serializable]` attribute, which means that instances of this class can be serialized and deserialized, allowing them to be saved to and loaded from disk or sent over a network. This is useful for saving and sharing buff information between different parts of the project.\n\nThe class has an enum called `WHY`, which defines different reasons for a buff to be applied. These reasons include \"ITEM\", \"PREMIUM\", \"APS\", \"GM\", \"CHANNEL\", and \"PC_BANG\". This enum can be used to categorize buffs and determine the reason for a buff being applied.\n\nThe class also has two fields: `icon` and `tooltip`. The `icon` field is of type `Texture2D` and is used to store the icon image for the buff. The `tooltip` field is of type `string` and is used to store a description or additional information about the buff.\n\nThis class can be used in the larger Brick-Force project to define and store information about different buffs. For example, a `BuffDesc` instance can be created for each buff in the game, with the `icon` field set to the corresponding icon image and the `tooltip` field set to a description of the buff. These `BuffDesc` instances can then be used by other parts of the project to display buff information to the player, determine the reason for a buff being applied, or perform other operations related to buffs.\n\nHere is an example of how this class could be used in the project:\n\n```csharp\nBuffDesc buff = new BuffDesc();\nbuff.icon = Resources.Load<Texture2D>(\"BuffIcons/Health\");\nbuff.tooltip = \"Increases player's health by 50%\";\n\n// Use the buff information\nDisplayBuffIcon(buff.icon);\nDisplayBuffTooltip(buff.tooltip);\n```\n\nIn this example, a `BuffDesc` instance is created and its `icon` and `tooltip` fields are set. The `icon` field is set to a `Texture2D` loaded from a resource file, and the `tooltip` field is set to a description of the buff. The `DisplayBuffIcon` and `DisplayBuffTooltip` functions can then be called to display the buff icon and tooltip to the player.\n## Questions: \n 1. **What is the purpose of the `BuffDesc` class?**\nThe `BuffDesc` class appears to be a data structure for describing buffs in the game, as it contains fields for an icon and tooltip.\n\n2. **What is the purpose of the `WHY` enum inside the `BuffDesc` class?**\nThe `WHY` enum inside the `BuffDesc` class is likely used to categorize the reasons for a buff, such as being related to an item, premium status, APS, GM, channel, or PC_BANG.\n\n3. **What is the purpose of the `Serializable` attribute above the `BuffDesc` class?**\nThe `Serializable` attribute indicates that instances of the `BuffDesc` class can be serialized and deserialized, which means they can be converted into a format that can be stored or transmitted and then reconstructed back into an object.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BuffDesc.md"}}],["96",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BuffManager.cs)\n\nThe `BuffManager` class is responsible for managing buffs in the Brick-Force project. Buffs are temporary enhancements or bonuses that can be applied to players or objects in the game. This class provides methods for adding, retrieving, and manipulating buffs.\n\nThe class contains several constants, such as `BF_NON_NMCAFE_USER` and `BF_NMCAFE_USER_CHECKIN`, which are used as identifiers for different types of buffs.\n\nThe class also contains an array of `BuffDesc` objects, which represent the descriptions of each buff, and an array of `Texture2D` objects, which represent the icons associated with each buff.\n\nThe `BuffManager` class is implemented as a singleton, meaning that there can only be one instance of it in the game. The `Instance` property provides access to this instance.\n\nThe class provides methods for retrieving the icons associated with specific buffs, such as `getPointUpTex()`, `getXpUpTex()`, and `getLuckUpTex()`. These methods return the corresponding `Texture2D` object from the `icons` array.\n\nThe `Add()` method is used to add a new buff to the manager. It takes an index, a name, and a `TBuff` object as parameters. The method checks if the buff already exists in the manager's dictionaries (`dic` and `dicByName`) and adds it if it doesn't.\n\nThe `ToWhyArray()` method is used to convert a bitmask into an array of `BuffDesc` objects. It takes a bitmask as a parameter and iterates over each bit, checking if it is set in the bitmask. If the bit is set and certain conditions are met, the corresponding `BuffDesc` object is added to a list, which is then converted to an array and returned.\n\nThe `Get()` methods are used to retrieve a `TBuff` object by its index or name from the manager's dictionaries.\n\nThe `Awake()` method is called when the `BuffManager` object is created. It initializes the dictionaries and ensures that the object is not destroyed when a new scene is loaded.\n\nThe `Load()` method is used to load the buffs from a file. It checks if the game is running in a web player or a local file system and calls the appropriate method to load the buffs.\n\nThe `LoadFromLocalFileSystem()` method loads the buffs from a local file system. It checks if the necessary directories and files exist, and if not, it logs an error. It then uses a `CSVLoader` object to load the buffs from a CSV file and calls the `Parse()` method to parse the loaded data.\n\nThe `LoadAllFromWWW()` method loads the buffs from a web server. It creates a `WWW` object to download the buffs file, reads the downloaded data using a `BinaryReader`, and uses a `CSVLoader` object to parse the data.\n\nThe `Parse()` method is called to parse the loaded data. It iterates over each row in the CSV file and reads the values for each column. It then creates a new `TBuff` object with the parsed values and adds it to the manager using the `Add()` method.\n\nThe `IsChannelBuff()` method checks if there are any buffs applied to the current game channel. It checks if the experience bonus or the force points bonus of the channel is non-zero and returns `true` if either of them is non-zero.\n\nThe `GetBuffDesc()` method retrieves the `BuffDesc` object for a specific buff type. It takes a `BuffDesc.WHY` enum value as a parameter and returns the corresponding `BuffDesc` object from the `why` array.\n\nThe `IsPCBangBuff()` method checks if the current game is a PC bang buff. It checks if the `netCafeCode` variable is equal to 1 and returns `true` if it is.\n\nOverall, the `BuffManager` class provides functionality for managing buffs in the Brick-Force project. It allows for adding, retrieving, and manipulating buffs, as well as loading them from a file or a web server.\n## Questions: \n **Question 1:** What is the purpose of the `BuffManager` class?\n- The `BuffManager` class is responsible for managing buffs in the game.\n\n**Question 2:** How are buffs loaded in the game?\n- Buffs can be loaded either from a local file system or from a web server, depending on the platform.\n\n**Question 3:** What is the significance of the `isLoaded` variable?\n- The `isLoaded` variable indicates whether the buffs have been successfully loaded and are ready to be used in the game.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BuffManager.md"}}],["97",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BuildNDestroyModeDesc.cs)\n\nThe code provided is a simple class called `BuildNDestroyModeDesc`. This class has a single public boolean variable called `buildPhase`. \n\nThe purpose of this class is to store information about the current phase of the \"Build and Destroy\" mode in the Brick-Force project. The `buildPhase` variable is used to determine whether the game is currently in the build phase or the destroy phase.\n\nIn the build phase, players are able to construct structures using various bricks and materials. They can place bricks, create structures, and design their own environments. This phase is typically time-limited, allowing players to build within a specific timeframe.\n\nIn the destroy phase, players are given the opportunity to destroy the structures created by other players. They can use weapons or tools to demolish the structures and gain points or rewards. This phase is also time-limited, allowing players to destroy as much as they can within the given time.\n\nBy using the `BuildNDestroyModeDesc` class, the game can keep track of the current phase and determine the appropriate actions and rules for the players. For example, during the build phase, players may have access to specific tools and bricks for construction, while during the destroy phase, they may have access to weapons for demolition.\n\nHere is an example of how this class could be used in the larger project:\n\n```csharp\nBuildNDestroyModeDesc modeDesc = new BuildNDestroyModeDesc();\nmodeDesc.buildPhase = true;\n\nif (modeDesc.buildPhase)\n{\n    // Perform actions specific to the build phase\n    // Allow players to construct structures\n}\nelse\n{\n    // Perform actions specific to the destroy phase\n    // Allow players to destroy structures\n}\n```\n\nIn this example, the `buildPhase` variable is used to determine which actions should be performed based on the current phase of the game. If `buildPhase` is true, the code will execute actions related to the build phase. If `buildPhase` is false, the code will execute actions related to the destroy phase.\n\nOverall, the `BuildNDestroyModeDesc` class provides a simple way to store and retrieve information about the current phase of the \"Build and Destroy\" mode in the Brick-Force project.\n## Questions: \n 1. **What is the purpose of the `BuildNDestroyModeDesc` class?**\nThe `BuildNDestroyModeDesc` class appears to be a description or configuration class for a specific game mode in the Brick-Force project. It likely contains properties or methods related to the build and destroy phase of the game mode.\n\n2. **What does the `buildPhase` property represent?**\nThe `buildPhase` property is a boolean variable that likely indicates whether the game mode is currently in the build phase or not. It could be used to control the behavior or flow of the game mode.\n\n3. **Are there any other properties or methods in the `BuildNDestroyModeDesc` class?**\nBased on the provided code, it is not clear if there are any other properties or methods in the `BuildNDestroyModeDesc` class. It would be helpful to review the rest of the code or documentation to determine if there are any additional components to this class.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BuildNDestroyModeDesc.md"}}],["98",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BuildOption.cs)\n\nThe `BuildOption` class in the Brick-Force project is responsible for managing various build options and configurations for the game. It contains several enums that define different options and settings for the game, such as XP mode, voice language, country filter, target server, season, and random box type.\n\nThe `target` variable represents the target server for the game, which can be set to different values from the `TARGET` enum. The `properties` array holds a list of `Property` objects, which contain specific properties and settings for each target server.\n\nThe class also has several boolean properties that determine certain conditions based on the target server. For example, the `IsRunup` property returns true if the target server is either the RUNUP_LIVE or RUNUP_LOCAL server. Similarly, the `MustAutoLogin` property returns true if the target server is the RUNUP_LIVE server.\n\nThe `Props` property returns the `Property` object corresponding to the current target server.\n\nThe `Instance` property is a singleton instance of the `BuildOption` class, ensuring that only one instance of the class exists at a time.\n\nThe class also contains several methods for managing the game, such as `AllowBuildGunInDestroyPhase`, which returns a boolean value indicating whether building guns is allowed during the destroy phase of the game.\n\nThe `Awake` method is called when the game object is initialized and sets up the necessary configurations. The `Update` method is empty and does not perform any actions.\n\nThe `Exit` method is responsible for quitting the game or loading the login scene based on the auto-login status. The `HardExit` method forcefully quits the game.\n\nThe `ResetSingletons` method clears various managers and resets the game state.\n\nThe `OnApplicationQuit` method is called when the application is about to quit and starts a new process for the FunPortal application if the target server is a Runup server.\n\nThe `IsDuplicateExcute` method checks if there is already an instance of the game running by creating a mutex and returning a boolean value indicating whether the game is a duplicate execution.\n\nThe `IsWindowsPlayerOrEditor` method checks if the application is running on a Windows player or editor.\n\nThe `OpenURL` method opens a URL in the default web browser.\n\nThe `TokensParameter` method returns a string containing tokens for the Infernum server, including the user ID and nickname.\n\nOverall, the `BuildOption` class provides a centralized location for managing various build options and configurations for the Brick-Force game. It allows for easy customization and adaptation of the game based on different target servers and settings.\n## Questions: \n 1. **What is the purpose of the `BuildOption` class?**\nThe `BuildOption` class is used to store various options and settings related to the build of the game.\n\n2. **What is the significance of the `TARGET` enum?**\nThe `TARGET` enum represents different target servers or platforms that the game can be built for.\n\n3. **What is the purpose of the `Props` property?**\nThe `Props` property returns the `Property` object associated with the current target server or platform.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BuildOption.md"}}],["99",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BuildTool.cs)\n\nThe code provided is a class called `BuildTool` that extends the `EditorTool` class. It is a part of the larger Brick-Force project and is used as a tool for building within the game.\n\nThe `BuildTool` class has a constructor that takes in an instance of `EditorToolScript` and `BattleChat` as parameters. It calls the constructor of the parent class `EditorTool` with the `ets` parameter and sets the `_battleChat` field to the provided `_battleChat` parameter.\n\nThe `BuildTool` class also overrides the `Update()` method from the parent class. This method is responsible for updating the state of the tool and determining if it should be active or not.\n\nIn the `Update()` method, it first checks if the `battleChat` is not currently active (not chatting) and if a specific button (specified by `editorToolScript.inputKey`) is pressed using the `custom_inputs.Instance.GetButtonDown()` method. If both conditions are true, it sets the `active` field to `true` and returns `true`.\n\nIf the conditions are not met, it returns `false`, indicating that the tool should not be active.\n\nThis code is likely used in the larger Brick-Force project to handle the logic for activating the build tool when the specified button is pressed and the player is not currently chatting. The `BuildTool` class may be instantiated and used in other parts of the project to enable the building functionality for the player. For example, it could be used in a user interface component to handle the button press event and activate the build tool accordingly.\n\nExample usage:\n\n```csharp\nEditorToolScript ets = new EditorToolScript();\nBattleChat battleChat = new BattleChat();\nBuildTool buildTool = new BuildTool(ets, battleChat);\n\nif (buildTool.Update())\n{\n    // Build tool is active, perform building logic\n}\nelse\n{\n    // Build tool is not active\n}\n```\n## Questions: \n 1. **What is the purpose of the `BuildTool` class?**\nThe `BuildTool` class is a subclass of `EditorTool` and is used for handling building functionality in the game.\n\n2. **What is the significance of the `BattleChat` parameter in the constructor?**\nThe `BattleChat` parameter is used to initialize a `BattleChat` object, which is likely used for handling chat functionality during battles.\n\n3. **What does the `Update` method do?**\nThe `Update` method checks if the player is not currently chatting and if a specific button is pressed, then it sets the `active` flag to true and returns true. Otherwise, it returns false.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BuildTool.md"}}],["100",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Bullet.cs)\n\nThe code provided is for a class called \"Bullet\" in the Brick-Force project. This class is responsible for controlling the behavior of a bullet object in the game. \n\nThe Bullet class has several private variables, including \"speed\", \"orgPosition\", \"orgDirection\", \"prevPosition\", and \"hit\". These variables are used to store information about the bullet's speed, original position, original direction, previous position, and whether the bullet has hit something.\n\nThe class also has several public properties for accessing and modifying these private variables. For example, the \"Speed\" property allows other classes to get and set the value of the \"speed\" variable.\n\nThe Awake() method is empty and does not contain any code.\n\nThe Start() method is called when the bullet object is first created. It sets the original direction of the bullet to be the forward direction of the object, and sets the original and previous positions to be the current position of the object. It then moves the bullet 10 units forward in its original direction. Finally, it sets the \"hit\" variable to false.\n\nThe LineTest() method is a helper method that performs a linecast from the previous position of the bullet to its current position. It checks if the line intersects with any objects on the \"Chunk\" or \"BoxMan\" layers. If there is an intersection, it returns true and stores information about the hit in the \"hitInfo\" parameter.\n\nThe Update() method is called every frame. It first checks if the bullet has hit something or if it has traveled a distance greater than 1000 units from its original position. If either of these conditions is true, it destroys the bullet object. Otherwise, it calls the LineTest() method to check for any intersections. If there is an intersection, it moves the bullet to the point of intersection and sets the \"hit\" variable to true. If there is no intersection, it calculates the new position of the bullet based on its speed and original direction, and moves the bullet accordingly.\n\nIn summary, the Bullet class controls the behavior of a bullet object in the game. It moves the bullet forward in its original direction, checks for intersections with other objects, and destroys the bullet if it hits something or travels too far. This class is likely used in the larger project to handle shooting mechanics and collisions with other objects.\n## Questions: \n 1. What is the purpose of the `LineTest` method?\n- The `LineTest` method is used to check if there is a collision between the bullet's previous position and its current position with objects on the \"Chunk\" and \"BoxMan\" layers.\n\n2. What does the `hit` variable represent and how is it used?\n- The `hit` variable is a boolean flag that indicates whether the bullet has collided with an object. It is used to determine whether the bullet should be destroyed or if its position should be updated.\n\n3. What is the significance of the `orgPosition` and `orgDirection` variables?\n- The `orgPosition` variable stores the original position of the bullet when it was instantiated, while the `orgDirection` variable stores the original direction of the bullet. These variables are used for distance calculations and to reset the bullet's position if it exceeds a certain distance.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Bullet.md"}}],["101",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BulletMark.cs)\n\nThe code provided is for a class called \"BulletMark\" in the Brick-Force project. This class is responsible for generating a decal on a mesh object when a bullet hits it. The decal is a texture that is applied to the surface of the mesh to simulate a bullet mark.\n\nThe main method in this class is the \"GenerateDecal\" method. This method takes in three parameters: a Texture2D object representing the bullet mark texture, a GameObject representing the mesh object that was hit by the bullet, and a GameObject representing the parent object that the decal should be attached to.\n\nInside the \"GenerateDecal\" method, the code first rotates the decal randomly around the z-axis to give it a more realistic appearance. Then, it initializes the \"lifeTime\" variable to 0 and increments a static counter variable called \"dCount\" in the \"Decal\" class.\n\nNext, it gets the \"Decal\" component attached to the current game object and sets its \"affectedObjects\" array to contain the mesh object that was hit. It also sets the \"decalMode\" to 0, indicating that the decal should be applied directly to the mesh surface. The \"pushDistance\" is set to 0.009f, which determines how far the decal is pushed away from the mesh surface.\n\nA new material is created using the decal material from the \"Decal\" component, and the bullet mark texture is assigned to the \"mainTexture\" property of the material. Finally, the decal is calculated and its parent is set to the provided parent object.\n\nThe \"Update\" method is called every frame and updates the \"lifeTime\" variable by adding the time since the last frame. If the \"lifeTime\" exceeds the \"lengthOfLife\" value (which is set to 10 seconds by default), the game object is destroyed and the \"dCount\" variable is decremented.\n\nOverall, this code allows for the generation of bullet mark decals on mesh objects in the Brick-Force project. It provides a way to visually represent bullet impacts on surfaces and adds realism to the game environment.\n## Questions: \n 1. What is the purpose of the `GenerateDecal` method and how is it used?\n- The `GenerateDecal` method is used to generate a decal on a given mesh object. It takes in a texture, a mesh object, and a parent object as parameters and applies the decal to the mesh object.\n\n2. What does the `Update` method do?\n- The `Update` method is called every frame and updates the `lifeTime` variable by adding the time since the last frame. If the `lifeTime` exceeds the `lengthOfLife` value, it destroys the game object and decrements the `dCount` variable of the `Decal` class.\n\n3. What is the purpose of the `Decal` component and how is it used?\n- The `Decal` component is used to apply decals to objects in the game. In this code, it is used to set the affected objects, decal mode, push distance, decal material, and calculate the decal.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BulletMark.md"}}],["102",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BundleDatas.cs)\n\nThe code provided is a class called `BundleDatas` that is a part of the Brick-Force project. This class is responsible for managing and storing various data related to items and bricks in the game.\n\nThe class has several boolean variables such as `saveItemMaterial`, `saveItemIcon`, `saveItemWeaponby`, `saveBrickMaterial`, and `saveBrickIcon`. These variables determine whether or not to save specific types of data. For example, if `saveItemMaterial` is set to true, it means that the item materials should be saved.\n\nThe class also has arrays of materials and textures such as `itemMaterials`, `itemIcons`, `itemWeaponby`, `brickMaterials`, and `brickIcons`. These arrays store the actual data for the items and bricks.\n\nThe `copyAll()` method is currently empty and does not have any functionality. It is likely that this method would be implemented in the future to copy all the data from one instance of `BundleDatas` to another.\n\nIn the larger project, this class would be used to manage and store the data for items and bricks. Other parts of the project, such as the inventory system or the level editor, would interact with this class to access and modify the data.\n\nFor example, if the inventory system needs to display the icons of all the items, it would access the `itemIcons` array in the `BundleDatas` class. Similarly, if the level editor needs to change the material of a brick, it would access the `brickMaterials` array.\n\nOverall, the `BundleDatas` class plays a crucial role in managing and storing the data for items and bricks in the Brick-Force project. It provides a centralized location for accessing and modifying this data, making it easier to maintain and update the game.\n## Questions: \n 1. **What is the purpose of the `copyAll()` method?**\nThe `copyAll()` method is defined in the code, but it is empty. A smart developer might wonder what functionality or logic is intended to be implemented in this method.\n\n2. **What are the possible values for the boolean variables `saveItemMaterial`, `saveItemIcon`, `saveItemWeaponby`, `saveBrickMaterial`, and `saveBrickIcon`?**\nThe code declares several boolean variables, but it is not clear what values these variables can take. A smart developer might want to know the possible values in order to understand the behavior of the code.\n\n3. **What is the purpose of the arrays `itemMaterials`, `itemIcons`, `itemWeaponby`, `brickMaterials`, and `brickIcons`?**\nThe code declares several arrays, but it is not clear what data these arrays hold or how they are used. A smart developer might want to know the purpose of these arrays in order to understand their role in the code.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BundleDatas.md"}}],["103",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BundleDesc.cs)\n\nThe code provided is a class called `BundleDesc` that is part of the Brick-Force project. This class is responsible for managing a collection of `BundleUnit` objects. \n\nThe `BundleDesc` class has a private field called `items`, which is a list of `BundleUnit` objects. This list is initialized in the constructor of the class using the `List<BundleUnit>` constructor. \n\nThe `Pack` method is used to add a new `BundleUnit` object to the `items` list. It takes two parameters: `tItem` of type `TItem` and `opt` of type `int`. The method first checks if there is already a `BundleUnit` object in the `items` list with the same `tItem.code` value as the `tItem` parameter. If there is, the method simply returns without making any changes. If there isn't, a new `BundleUnit` object is created using the `tItem` and `opt` parameters, and it is added to the `items` list using the `Add` method.\n\nThe `Unpack` method is used to retrieve all the `BundleUnit` objects from the `items` list. It returns an array of `BundleUnit` objects by calling the `ToArray` method on the `items` list.\n\nThis code can be used in the larger Brick-Force project to manage bundles of items. The `Pack` method allows for adding new items to a bundle, while ensuring that duplicate items are not added. The `Unpack` method allows for retrieving all the items in a bundle. \n\nHere is an example of how this code can be used:\n\n```csharp\nBundleDesc bundle = new BundleDesc();\n\nTItem item1 = new TItem(\"item1\", 1);\nbundle.Pack(item1, 2);\n\nTItem item2 = new TItem(\"item2\", 3);\nbundle.Pack(item2, 4);\n\nBundleUnit[] unpackedItems = bundle.Unpack();\nforeach (BundleUnit unit in unpackedItems)\n{\n    Console.WriteLine($\"Item: {unit.tItem.code}, Option: {unit.opt}\");\n}\n```\n\nOutput:\n```\nItem: item1, Option: 2\nItem: item2, Option: 4\n```\n\nIn this example, we create a new `BundleDesc` object and add two `TItem` objects to it using the `Pack` method. We then retrieve all the items from the bundle using the `Unpack` method and print out their codes and options.\n## Questions: \n 1. What is the purpose of the `Pack` method?\n- The `Pack` method is used to add a new `BundleUnit` to the `items` list if it does not already exist.\n\n2. What is the purpose of the `Unpack` method?\n- The `Unpack` method is used to retrieve all the `BundleUnit` objects stored in the `items` list as an array.\n\n3. What is the type of `TItem` and where is it defined?\n- The type of `TItem` is not defined in the given code snippet. It is likely defined in another part of the codebase or in an external library.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BundleDesc.md"}}],["104",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BundleManager.cs)\n\nThe `BundleManager` class is responsible for managing bundles of items in the Brick-Force project. It provides methods for packing and unpacking items into bundles, as well as loading and clearing the bundle data.\n\nThe class has a private dictionary `dic` that stores the bundle data. Each bundle is represented by a `BundleDesc` object, which contains information about the items packed in the bundle. The `dic` dictionary uses the bundle name as the key and the `BundleDesc` object as the value.\n\nThe `BundleManager` class is implemented as a singleton, meaning that there can only be one instance of it in the project. The `Instance` property provides access to the singleton instance.\n\nThe `Unpack` method takes a bundle name as input and returns an array of `BundleUnit` objects, which represent the unpacked items in the bundle. It checks if the bundle exists in the `dic` dictionary and calls the `Unpack` method of the corresponding `BundleDesc` object to retrieve the unpacked items.\n\nThe `Pack` method takes a bundle name, item code, and an option as input. It converts the bundle and item codes to lowercase and retrieves the `TItem` object corresponding to the item code from the `TItemManager` class. If the `TItem` object exists, it checks if the bundle already exists in the `dic` dictionary. If not, it adds a new `BundleDesc` object to the dictionary. It then calls the `Pack` method of the `BundleDesc` object to pack the item into the bundle.\n\nThe `Clear` method clears the `dic` dictionary, removing all bundle data.\n\nThe `Remove` method takes a bundle name as input and removes the corresponding `BundleDesc` object from the `dic` dictionary.\n\nThe `Awake` method is called when the `BundleManager` object is created. It sets the `dic` dictionary to a new instance of `Dictionary<string, BundleDesc>` and ensures that the object is not destroyed when a new scene is loaded.\n\nThe `LoadFromWWW` method is a coroutine that loads bundle data from a remote server using the `WWW` class. It constructs the URL for the bundle data file and creates a `WWW` object to download the file. It then reads the downloaded data using a `MemoryStream` and a `BinaryReader`, and passes it to a `CSVLoader` object to parse the data. If the data is successfully parsed, it calls the `ParseData` method to populate the `dic` dictionary with the bundle data.\n\nThe `LoadFromLocalFileSystem` method loads bundle data from the local file system. It constructs the path to the bundle data file and checks if the file exists. If the file does not exist, it returns false. Otherwise, it creates a `CSVLoader` object and attempts to load the data from the file. If the data cannot be loaded, it returns false. If the data is successfully loaded, it checks the platform and saves the data in a secured format if the platform is the Windows editor or if the secured save fails. It then calls the `ParseData` method to populate the `dic` dictionary with the bundle data.\n\nThe `ParseData` method takes a `CSVLoader` object as input and iterates over each row in the data. It reads the bundle name, item code, and option from the data and converts the item code to lowercase. It then calls the `Pack` method to pack the item into the bundle.\n\nThe `Load` method is called to load the bundle data. It first clears the `dic` dictionary. It then checks the project's build options to determine if the shop text should be loaded. If the shop text should not be loaded and the application is not running in the editor, it sets the `isLoaded` flag to true. If the application is a web player, it starts the `LoadFromWWW` coroutine. Otherwise, it calls the `LoadFromLocalFileSystem` method.\n## Questions: \n 1. What is the purpose of the `BundleManager` class?\n- The `BundleManager` class is responsible for managing bundles and their contents.\n\n2. What is the purpose of the `Unpack` method?\n- The `Unpack` method is used to retrieve the contents of a specific bundle.\n\n3. How does the `Load` method determine whether to load data from a local file system or from a web server?\n- The `Load` method checks the `loadShopTxt` property and the application platform to determine whether to load data from a local file system or from a web server.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BundleManager.md"}}],["105",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BundleUnit.cs)\n\nThe code provided defines a class called `BundleUnit`. This class has two public variables: `tItem` of type `TItem` and `opt` of type `int`. The class also has a constructor that takes two parameters: `_item` of type `TItem` and `_opt` of type `int`. \n\nThe purpose of this code is to create a bundle unit that represents an item (`tItem`) and an option (`opt`). It is likely that this class is used in the larger Brick-Force project to handle bundles of items with associated options. \n\nFor example, let's say the Brick-Force project is a game where players can purchase bundles of in-game items. Each bundle may have different options, such as different colors or sizes for the items. The `BundleUnit` class can be used to represent each bundle, with `tItem` representing the item and `opt` representing the chosen option for that item.\n\nHere is an example usage of the `BundleUnit` class:\n\n```java\n// Create a new item\nTItem item = new TItem(\"Sword\");\n\n// Create a new bundle unit with the item and option\nBundleUnit bundle = new BundleUnit(item, 2);\n\n// Access the item and option\nSystem.out.println(bundle.tItem.getName()); // Output: Sword\nSystem.out.println(bundle.opt); // Output: 2\n```\n\nIn this example, we create a new `TItem` object representing a sword and pass it along with the option `2` to the `BundleUnit` constructor. We can then access the item's name (`Sword`) through the `tItem` variable and the option (`2`) through the `opt` variable.\n\nOverall, the `BundleUnit` class provides a way to bundle an item with an associated option, which can be useful in managing and representing bundles of items in the larger Brick-Force project.\n## Questions: \n 1. **What is the purpose of the `BundleUnit` class?**\nThe `BundleUnit` class appears to represent a bundle unit, containing a `tItem` object and an `opt` integer value. The purpose of this class is not explicitly stated in the code, so a developer might want to know what this class is used for in the context of the project.\n\n2. **What is the significance of the `TItem` type?**\nThe code references a `TItem` type in the declaration of the `tItem` variable. A smart developer might wonder what this type represents and how it is related to the overall functionality of the code.\n\n3. **What does the `opt` variable represent and how is it used?**\nThe `opt` variable is an integer value, but its purpose is not clear from the code. A developer might want to know what this variable represents and how it is used within the `BundleUnit` class or in other parts of the codebase.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BundleUnit.md"}}],["106",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BungeeGuideDialog.cs)\n\nThe code provided is a class called `BungeeGuideDialog` that extends the `Dialog` class. This class is used to create a dialog box with various UI elements such as image lists, label lists, toggles, and buttons. The purpose of this code is to handle the functionality and behavior of the dialog box in the larger project.\n\nThe `BungeeGuideDialog` class has several public variables that represent different UI elements. These variables include `imgList`, `labelList`, `toggle`, and `ok`. These variables are used to reference and manipulate the UI elements within the dialog box.\n\nThe `DontShowThisMessageAgain` property is a boolean property that returns the value of the `toggle` UI element. It is used to determine whether the user has selected the option to not show the message again.\n\nThe `Start` method is an overridden method from the `Dialog` class. It sets the `id` property of the dialog to a specific value from the `DialogManager.DIALOG_INDEX` enum.\n\nThe `OnPopup` method is another overridden method from the `Dialog` class. It sets the position and size of the dialog box based on the screen size.\n\nThe `InitDialog` method is empty and does not have any functionality. It can be used to initialize the dialog box if needed.\n\nThe `DoDialog` method is the main method that handles the rendering and interaction of the dialog box. It first sets the GUI skin to a specific skin obtained from `GUISkinFinder.Instance.GetGUISkin()`. Then, it calls the `Draw` method on the `imgList`, `labelList`, `toggle`, and `ok` UI elements to render them on the screen. It checks if the `ok` button is clicked and if the `DontShowThisMessageAgain` property is true. If both conditions are met, it saves the user's preference using `MyInfoManager.Instance.SaveDonotCommonMask` method. Finally, it checks if there is no other popup menu open and calls `WindowUtil.EatEvent()` to prevent any further events from being processed. It then restores the original GUI skin and returns the result.\n\nOverall, this code provides the functionality to create and handle a dialog box with various UI elements. It allows the user to interact with the dialog box and save their preferences. This code can be used in the larger project to display informative messages or prompts to the user and handle their responses.\n## Questions: \n 1. What is the purpose of the `BungeeGuideDialog` class?\n- The `BungeeGuideDialog` class is a subclass of the `Dialog` class and represents a dialog box in the game. It contains various UI elements such as image lists, label lists, toggle, and buttons.\n\n2. What is the significance of the `DontShowThisMessageAgain` property?\n- The `DontShowThisMessageAgain` property is a boolean property that returns the value of the `toggle` UI element. It determines whether the user has selected the option to not show the message again.\n\n3. What is the purpose of the `DoDialog` method?\n- The `DoDialog` method is responsible for drawing the UI elements of the dialog box and handling user interactions. It returns a boolean value indicating whether the dialog box should be closed or not.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BungeeGuideDialog.md"}}],["107",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BungeeMatch.cs)\n\nThe code provided is a part of the Brick-Force project and is contained within the `BungeeMatch` class. The purpose of this code is to handle various game mechanics and functionalities related to a specific game mode called \"BungeeMatch\". \n\nThe `BungeeMatch` class inherits from the `MonoBehaviour` class, which is a base class provided by Unity for creating scripts that can be attached to game objects. This allows the code to interact with the game engine and respond to various events and updates.\n\nThe code starts with the declaration of several private variables, such as `guiDepth`, `deltaTime`, `delayLoad`, `battleChat`, `localController`, `bLoaded`, and `listEffectivePoint`. These variables are used to store information and manage the state of the game.\n\nThe `Start()` method is called when the game starts and is responsible for initializing various game elements and components. It calls several methods from the `GlobalVars` class to clear dropped weapons, apply audio sources, switch off flashbangs, and reset the fever state. It also initializes the first-person perspective, sets up the battle chat, and calls the `OnStart()` method of the `BrickManManager` class.\n\nThe `Awake()` method is empty and does not contain any code.\n\nThe `StartLoad()` method is called to start loading the game resources. It calls the `SendCS_CACHE_BRICK_REQ()` method of the `CSNetManager` class to send a request for caching brick data.\n\nThe `OnGUI()` method is responsible for rendering the graphical user interface (GUI) elements on the screen. It checks if the game has been loaded (`bLoaded`) and if the GUI is enabled (`MyInfoManager.Instance.isGuiOn`). If both conditions are true, it sets up the GUI skin, depth, and enables GUI interaction. It then iterates over the `listEffectivePoint` and renders a label at the screen position of each effective point.\n\nThe `InitializeFirstPerson()` method is called to initialize the first-person perspective. It finds the game object with the name \"Me\" and retrieves the `EquipCoordinator` and `LocalController` components attached to it. It then initializes the `EquipCoordinator` with a list of usable items.\n\nThe `OnLoadComplete()` method is called when the game loading is complete. It calls the `Load()` method of the `TrainManager` class to load the train data, spawns the player character at a random spawn position, sets the loaded flag (`bLoaded`) to true, and shows the bungee guide dialog if it has not been disabled.\n\nThe `ResetGameStuff()` method is called to reset various game-related data and components. It calls the `ResetGameStuff()` method of the `MyInfoManager` class to reset game-related information, unloads the train data using the `UnLoad()` method of the `TrainManager` class, and performs other necessary cleanup tasks.\n\nThe `OnDisable()` method is called when the script is disabled. It checks if the application is still loading a level and performs cleanup tasks such as resetting game-related data, clearing the brick manager, and resetting the fever state.\n\nThe `Update()` method is called every frame and is responsible for handling various game updates and events. It checks if the game is currently showing a connecting screen and sets the `Screen.lockCursor` property accordingly. It also checks if the game is still loading and delays the loading process for a certain amount of time. It handles input events for opening the main menu and closing the map edit authority dialog. It also updates the list of effective points and removes points that have exceeded a certain time limit.\n\nThe `OnEffectivePoint()` method is called to add an effective point to the list. It takes a position and a distance as parameters and creates an `EffectivePoint` object with the position and a color based on the distance. The `EffectivePoint` object is then added to the `listEffectivePoint`.\n\nOverall, this code handles various game mechanics and functionalities related to the \"BungeeMatch\" game mode. It initializes game elements, handles GUI rendering, manages game loading, updates game state, and handles effective points in the game.\n## Questions: \n 1. What is the purpose of the `StartLoad()` method?\n- The `StartLoad()` method is responsible for initializing and loading the necessary resources for the game.\n\n2. What is the significance of the `OnLoadComplete()` method?\n- The `OnLoadComplete()` method is called when the game finishes loading. It performs additional setup and initialization tasks.\n\n3. What does the `OnEffectivePoint()` method do?\n- The `OnEffectivePoint()` method is called to add an effective point to the game. It takes in a position and distance parameter and adds the effective point to a list for rendering.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BungeeMatch.md"}}],["108",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BungeeMatchScore.cs)\n\nThe code provided is a part of the Brick-Force project and is a script called \"BungeeMatchScore\". This script is responsible for displaying the score and goal information for a bungee match in the game. \n\nThe script uses various variables and components to achieve its purpose. Here is a breakdown of the important elements:\n\n- `guiDepth` is an enum variable that determines the layer depth of the GUI elements. It is set to the HUD layer by default.\n- `scoreFont` and `goalFont` are ImageFont objects that define the font style and size for displaying the score and goal information.\n- `scoreBg` is a Texture2D object that represents the background image for the score display.\n- `size` is a Vector2 object that determines the size of the score display.\n- `crdScore` and `crdGoal` are Vector2 objects that define the coordinates for displaying the score and goal information.\n- `score` is an integer variable that stores the current score.\n\nThe script contains several methods that are used to update and display the score information. \n\n- The `Start()` method initializes the score to 0 and sends a score request if the player is breaking into the game.\n- The `OnBungeeScore()` method is called when the score is updated. It sets the scale of the score font and updates the score value.\n- The `OnGUI()` method is responsible for rendering the GUI elements on the screen. It checks if the GUI is enabled and then sets the GUI skin, depth, and group for the score display. It also draws the score background image, prints the score and goal information using the defined fonts and coordinates, and resets the GUI skin.\n- The `Update()` method is empty and does not contain any code.\n\nOverall, this script is an essential part of the Brick-Force project as it handles the display of the score and goal information for a bungee match. It uses various components and methods to render the GUI elements on the screen and update the score based on the game events.\n## Questions: \n 1. What is the purpose of the `OnBungeeScore` method?\n- The `OnBungeeScore` method is responsible for updating the score font and setting the score value based on the total number of kills.\n\n2. What is the significance of the `guiDepth` variable?\n- The `guiDepth` variable determines the depth at which the GUI elements will be rendered. It is of type `GUIDepth.LAYER` and its value affects the rendering order of GUI elements.\n\n3. What is the purpose of the `Update` method?\n- The `Update` method is currently empty and does not contain any code. It is likely that this method is intended to be used for updating the state of the object or performing other actions that need to be executed every frame.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BungeeMatchScore.md"}}],["109",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BungeeMatchSituation.cs)\n\nThe code provided is a part of the Brick-Force project and is contained within the `BungeeMatchSituation` class. The purpose of this code is to display a match situation UI in the game. \n\nThe code contains various variables that define the positions and sizes of different UI elements, such as boxes, labels, and textures. These variables are used to position and style the UI elements in the `OnGUI` method.\n\nThe `OnGUI` method is responsible for rendering the match situation UI. It first checks if the UI should be displayed based on the game state and user input. If the UI should be displayed, it proceeds to render the UI elements using the `GUI` class and various utility classes such as `LabelUtil` and `TextureUtil`.\n\nThe UI elements include a frame, a room title, a green box, a result text box, an indicator icon, and a grid of player information. The player information grid is populated with data from the `BrickManManager` and `MyInfoManager` classes. Each player's information is displayed in a row, including their clan mark, badge, nickname, score, and ping. The player's own information is highlighted with a different style.\n\nThe `GridOut` method is responsible for rendering each row of player information in the grid. It takes in various parameters such as clan mark, XP, rank, nickname, kill count, assist count, death count, score, average ping, status, and whether the player is dead or not. It uses the `LabelUtil` class to display the information in the appropriate style and color.\n\nThe `VerifyLocalController` method is used to find and assign the `LocalController` component to the `localController` variable if it is not already assigned. This component is used to determine if the player is dead or not.\n\nThe `Start` and `Update` methods are empty and do not contain any code.\n\nOverall, this code is responsible for rendering the match situation UI in the game, displaying player information in a grid format. It uses various utility classes and methods to position and style the UI elements and retrieve player data.\n## Questions: \n 1. What is the purpose of the `VerifyLocalController()` method?\n- The `VerifyLocalController()` method is used to check if the `localController` variable is null and if so, it finds the GameObject with the name \"Me\" and assigns its `LocalController` component to the `localController` variable.\n\n2. What does the `GridOut()` method do?\n- The `GridOut()` method is responsible for displaying information about a player in a grid format. It takes in various parameters such as clan mark, XP, rank, nickname, kill count, death count, score, average ping, status, and whether the player is dead or not, and displays this information using the `LabelUtil.TextOut()` method.\n\n3. What is the purpose of the `on` variable and how is it updated?\n- The `on` variable is used to determine whether the GUI should be displayed or not. It is updated in the `Update()` method based on the state of the `DialogManager.Instance.IsModal` and the result of the `custom_inputs.Instance.GetButton(\"K_SITUATION\")` method.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BungeeMatchSituation.md"}}],["110",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BungeeModeConfig.cs)\n\nThe code provided is a class called `BungeeModeConfig` that is used in the larger Brick-Force project. This class is responsible for configuring and displaying the settings and options for the Bungee game mode in the game.\n\nThe `BungeeModeConfig` class contains various properties and methods that handle the graphical user interface (GUI) elements and logic for displaying and interacting with the Bungee game mode settings.\n\nThe `OnGUI` method is the main entry point for rendering the GUI elements. It first checks if a thumbnail image is available for the current game map. If a thumbnail is available, it is displayed on the GUI. Additionally, if the map was registered on the current day, a \"new map\" icon is displayed. Depending on the map's tag mask, different icons are displayed to indicate special attributes of the map, such as glory, medals, or gold ribbons. If the map is flagged as an abuse map, an \"abuse\" icon is displayed.\n\nThe method also displays the alias of the current room and the game mode type. It then calls the `DoOption` method to display additional options for the Bungee game mode, such as the time limit and the number of kills required to win. Finally, if the user is the master of the room, a configuration button is displayed, which opens a dialog to change the room configuration.\n\nThe `DoOption` method is responsible for displaying the time limit and kill count options for the Bungee game mode. It calculates the positions of the GUI elements based on predefined coordinates and uses the `LabelUtil` class to render the text labels and `GUI.Box` to render the background boxes.\n\nThe `ShowTooltip` method is called when the user hovers over a GUI element and displays a tooltip with additional information about the element.\n\nOverall, the `BungeeModeConfig` class provides the necessary functionality to configure and display the settings and options for the Bungee game mode in the Brick-Force project.\n## Questions: \n 1. What is the purpose of the `OnGUI()` method?\n- The `OnGUI()` method is responsible for rendering the graphical user interface for the Brick-Force game. It displays various textures and labels based on the current state of the game.\n\n2. What does the `DoOption()` method do?\n- The `DoOption()` method is used to display and update the options related to the current room in the game. It sets the time limit, bungee count, and break into options based on the values stored in the `Room` object.\n\n3. What is the purpose of the `ShowTooltip()` method?\n- The `ShowTooltip()` method is used to display a tooltip message when the user hovers over certain elements in the graphical user interface. It renders the tooltip message as a label with a yellow color.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BungeeModeConfig.md"}}],["111",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BungeeTool.cs)\n\nThe code provided is a class called \"BungeeTool\" that is part of the larger Brick-Force project. This class represents a tool that can be used in the game. \n\nThe purpose of this class is to manage the functionality of the BungeeTool, including its cooldown time, usage, and resetting of its state. \n\nThe class has several properties and methods that allow for the management of the BungeeTool. \n\nThe \"coolTimeInst\" property represents the cooldown time of the tool. It is initially set to -1, indicating that the tool is not on cooldown. \n\nThe \"itemIcon\" property is of type \"UIImage\" and represents the icon image associated with the tool. \n\nThe \"desc\" property is of type \"ActiveItemData\" and represents the data associated with the tool. \n\nThe \"uiEffect\" property is of type \"UIChangeColor\" and represents the UI effect associated with the tool. \n\nThe \"deltaTime\" property is a float that keeps track of the time since the tool was last used. \n\nThe \"useItem\" property is a boolean that indicates whether the tool is currently being used. \n\nThe \"CoolTime\" property is a getter that returns the remaining cooldown time of the tool. It checks if the tool has a description and if the current time is greater than or equal to the cooldown time. If so, it returns an empty string. Otherwise, it calculates the remaining cooldown time and returns it as a string. \n\nThe \"Update\" method updates the deltaTime and the uiEffect. It also checks if the tool is being used and if it is usable. If so, it calls the \"ResetSlot\" method. \n\nThe \"UseAble\" method checks if the tool has a description and if the current time is greater than the cooldown time. If so, it returns true, indicating that the tool can be used. \n\nThe \"StartCoolTime\" method resets the deltaTime to 0, sets the useItem flag to true, and checks if the tool has a cooldown time of -1. If so, it calls the \"ResetSlot\" method. \n\nThe \"Use\" method calls the \"UseItem\" method of the ActiveItemManager and the \"SendPEER_USE_ACTIVE_ITEM\" method of the P2PManager. It then calls the \"StartCoolTime\" method and resets the uiEffect. \n\nThe \"AddActiveItem\" method checks if the tool already has a description. If not, it sets the description to the provided item, sets the deltaTime to 10000, sets the useItem flag to false, sets the itemIcon to the item's icon, resets the uiEffect, and returns true. Otherwise, it returns false. \n\nThe \"GetActiveItem\" method returns the description of the tool. \n\nThe \"ResetSlot\" method resets the description, cooldown time, deltaTime, useItem flag, and itemIcon to their initial values.\n## Questions: \n 1. What is the purpose of the `BungeeTool` class?\n- The `BungeeTool` class appears to be a tool for managing active items in the game. It has methods for updating the cooldown time, using the item, adding an active item, and resetting the item slot.\n\n2. What is the significance of the `CoolTime` property?\n- The `CoolTime` property returns the remaining cooldown time for the active item. If the cooldown time is not set or the cooldown time has not yet passed, it returns an empty string. Otherwise, it returns the remaining time in seconds.\n\n3. What is the purpose of the `uiEffect` variable and its associated methods?\n- The `uiEffect` variable is likely used for visual effects related to the active item. The `Update()` method updates the UI effect, and the `Reset()` method resets the UI effect.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BungeeTool.md"}}],["112",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BungeeTools.cs)\n\nThe code provided is a class called \"BungeeTools\" that is a part of the larger Brick-Force project. This class is responsible for managing and controlling the bungee tools in the game. \n\nThe class contains several constants, such as RESERVE_SLOT, ITEM_SLOT, ITEM_USE, and ITEM_CHANGE, which are used as indices for various operations related to the bungee tools. \n\nThe class also has an array of strings called \"input\" that stores the names of the input keys for the bungee tools. These input keys are used to trigger specific actions related to the bungee tools. \n\nThe class has a reference to the \"BungeeTool\" class, which represents an individual bungee tool. The \"tools\" array stores instances of the \"BungeeTool\" class. \n\nThe class also has references to various UI elements, such as \"itemBackground\" and \"keyTextBackground\", which are used to display the bungee tools and their associated key bindings on the screen. \n\nThe class has a method called \"StartCoolTime()\" that starts the cooldown time for all the bungee tools. This method iterates over the \"tools\" array and calls the \"StartCoolTime()\" method on each individual bungee tool. \n\nThe class also has an \"OnGUI()\" method that is responsible for rendering the bungee tools and their associated UI elements on the screen. This method is called by the Unity engine during the GUI rendering phase. \n\nThe class has an \"Update()\" method that is called by the Unity engine every frame. This method is responsible for updating the state of the bungee tools and handling user input related to the bungee tools. \n\nThe class has several other helper methods, such as \"VerifyLocalController()\", \"AddActiveItem()\", and \"ResetAllSlot()\", which are used for various operations related to the bungee tools. \n\nOverall, the \"BungeeTools\" class is an important component of the Brick-Force project as it manages and controls the bungee tools in the game. It handles user input, updates the state of the bungee tools, and renders the bungee tools on the screen.\n## Questions: \n 1. What is the purpose of the `BungeeTools` class?\n- The `BungeeTools` class is responsible for managing bungee tools in the game.\n\n2. What is the significance of the `tools` array?\n- The `tools` array holds instances of the `BungeeTool` class, which represents individual bungee tools in the game.\n\n3. What is the purpose of the `StartCoolTime` method?\n- The `StartCoolTime` method is used to start the cooldown time for all the bungee tools in the `tools` array.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BungeeTools.md"}}],["113",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\BuyConfirmDialog.cs)\n\nThe code provided is a class called BuyConfirmDialog, which is a subclass of the Dialog class. This class is used to display a confirmation dialog for purchasing an item in the game. \n\nThe BuyConfirmDialog class has several member variables that store information about the item being purchased, such as the type of currency used for the purchase (buyHow), the selected option for the item (selected), and whether the item is equipped (wasEquip). It also has variables for storing textures used in the dialog, such as fpIcon and bpIcon.\n\nThe class has several Rect variables that define the positions and sizes of various UI elements in the dialog, such as the title, close button, outline, money icon, toggle button, and buy button.\n\nThe ShowGood() method is responsible for displaying the details of the item being purchased. It uses the GUI.Box() method to draw a box with a fade blue style, and then uses the TextureUtil.DrawTexture() method to draw the item's icon. It also displays the item's name, remaining quantity, and price.\n\nThe Start() method sets the id of the dialog to a specific value.\n\nThe OnPopup() method sets the position of the dialog based on the screen size.\n\nThe DoDialog() method is responsible for handling user input and updating the dialog. It uses various GUI methods to display text labels, buttons, and checkboxes. It also checks if the user has enough currency to make the purchase and displays an error message if not.\n\nThe InitDialog() methods are used to initialize the dialog with the necessary information about the item being purchased. They also check if the user has enough currency to make the purchase and set the cantBuy variable accordingly.\n\nIn summary, the BuyConfirmDialog class is used to display a confirmation dialog for purchasing an item in the game. It allows the user to select options for the item, such as the quantity and whether to equip it. It also checks if the user has enough currency to make the purchase and displays an error message if not. The class provides methods for initializing the dialog with the necessary information about the item and updating the dialog based on user input.\n## Questions: \n 1. What is the purpose of the `BuyConfirmDialog` class?\n- The `BuyConfirmDialog` class is a subclass of the `Dialog` class and is used to display a confirmation dialog for purchasing items in the game.\n\n2. What are the variables `fpIcon` and `bpIcon` used for?\n- The `fpIcon` and `bpIcon` variables are Texture2D objects that are used to store icons for different types of currency in the game (general points and brick points).\n\n3. What is the purpose of the `InitDialog` methods?\n- The `InitDialog` methods are used to initialize the `BuyConfirmDialog` with the necessary information for displaying the confirmation dialog, such as the selected item, the purchase method, and any additional confirmation messages.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\BuyConfirmDialog.md"}}],["114",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\CaptureTheFlagMatchScore.cs)\n\nThe code provided is a part of the Brick-Force project and is responsible for managing the score display in a Capture the Flag match. \n\nThe `CaptureTheFlagMatchScore` class extends the `MonoBehaviour` class from the Unity engine, indicating that it is a script that can be attached to a game object in the Unity editor. \n\nThe class has several public variables that can be set in the Unity editor, including `guiDepth`, `redScoreFont`, `blueScoreFont`, `goalFont`, and `scoreBg`. These variables determine the appearance and positioning of the score display on the screen. \n\nThe class also has private variables `redTeamScore` and `blueTeamScore` that store the current scores for the red and blue teams, respectively. \n\nThe `Start` method is called when the script is first initialized. It sets the initial scores to 0 and checks if the player is currently breaking into the game. If the player is breaking into the game, it sends a request to the server to get the current score. \n\nThe `OnTeamScore` method is called when the server sends an update about the team scores. It updates the local score variables and adjusts the scale of the score fonts to make them appear larger. \n\nThe `OnGUI` method is responsible for rendering the score display on the screen. It checks if the GUI is enabled and if there are any active modal dialogs. If the GUI is enabled and there are no active modal dialogs, it sets the GUI skin, depth, and group for rendering the score display. It then draws the score background texture, prints the red and blue team scores using the respective fonts, and applies a flickering effect to the font of the player's team. \n\nThe `Update` method is called every frame and updates the flickering effect for the red and blue team fonts. \n\nOverall, this code manages the display of the score in a Capture the Flag match, including updating the scores, rendering the score display on the screen, and applying a flickering effect to the font of the player's team.\n## Questions: \n 1. What is the purpose of the `CaptureTheFlagMatchScore` class?\n- The `CaptureTheFlagMatchScore` class is responsible for managing the score display for a Capture the Flag match.\n\n2. What is the significance of the `redTeamScore` and `blueTeamScore` variables?\n- The `redTeamScore` and `blueTeamScore` variables store the current scores for the red and blue teams respectively.\n\n3. What is the purpose of the `OnGUI` method?\n- The `OnGUI` method is responsible for rendering the score display on the screen using GUI elements.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\CaptureTheFlagMatchScore.md"}}],["115",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ChangeIntroDialog.cs)\n\nThe code provided is a class called `ChangeIntroDialog` that extends the `Dialog` class. This class is responsible for displaying a dialog box that allows the user to change the intro text for a clan in the game. \n\nThe class has several member variables that define the layout and appearance of the dialog box. These include a texture for an icon, the maximum number of characters allowed for the intro text, and the coordinates for the icon, intro text, and OK button within the dialog box. \n\nThe `Start()` method sets the `id` of the dialog to a specific value, which is used to identify this dialog in the `DialogManager`. \n\nThe `OnPopup()` method calculates the position of the dialog box based on the screen size and sets the `rc` variable to the calculated position. \n\nThe `InitDialog()` method initializes the `intro` variable to an empty string. \n\nThe `DoTitle()` method displays the title of the dialog box using the `LabelUtil.TextOut()` method. \n\nThe `DoIntro()` method displays a text area where the user can enter the intro text. The entered text is stored in the `intro` variable. \n\nThe `CheckInput()` method checks the entered text for any bad words using the `WordFilter` class. If any bad words are detected, a message box is displayed and the method returns false. Otherwise, it returns true. \n\nThe `DoDialog()` method is the main method that is called to display the dialog box and handle user input. It sets the GUI skin, calls the `DoTitle()` and `DoIntro()` methods to display the title and intro text, and checks if the OK button is pressed. If the OK button is pressed and the input is valid (no bad words), it sends a network request to change the clan intro text and returns true. \n\nThe method also checks if the close button or the escape key is pressed, and returns true in those cases as well. \n\nFinally, the method checks if there are any active popups and calls `WindowUtil.EatEvent()` to prevent any further input events from being processed. It then restores the original GUI skin and returns the result.\n## Questions: \n 1. What is the purpose of the `ChangeIntroDialog` class?\n- The `ChangeIntroDialog` class is a subclass of the `Dialog` class and is used to handle the dialog for changing the intro in the game.\n\n2. What is the significance of the `maxIntro` variable?\n- The `maxIntro` variable determines the maximum number of characters allowed in the intro text.\n\n3. What does the `DoDialog` method do?\n- The `DoDialog` method is responsible for rendering and handling user interactions with the dialog. It returns a boolean value indicating whether the dialog was successfully completed or not.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ChangeIntroDialog.md"}}],["116",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ChangeLangDialog.cs)\n\nThe code provided is a class called `ChangeLangDialog` that extends the `Dialog` class. This class is responsible for creating a dialog box that allows the user to change the language in the game. \n\nThe class has several member variables including `languages`, `langTex`, `crdButtonSize`, `crdLeftTop`, `crdRightBottom`, and `offset`. \n\nThe `languages` variable is an array of `LANG_OPT` enums, which represents the supported languages in the game. The `langTex` variable is an array of `Texture2D` objects, which represents the icons for each language. \n\nThe `crdButtonSize` variable is a `Vector2` that represents the size of each language button. The `crdLeftTop` and `crdRightBottom` variables are `Vector2` objects that represent the position of the top-left and bottom-right corners of the dialog box, respectively. The `offset` variable represents the vertical spacing between each language button. \n\nThe `Start` method sets the `id` of the dialog box to `CHANGE_LANG`. \n\nThe `OnPopup` method is empty and does not have any functionality. \n\nThe `InitDialog` method initializes the dialog box by creating the `languages` and `langTex` arrays based on the supported languages in the game. It also calculates the size and position of the dialog box based on the number of languages and the size of the language buttons. \n\nThe `DoDialog` method is responsible for rendering the dialog box and handling user input. It first sets the GUI skin to the appropriate skin for the game. It then renders the title of the dialog box using the `LabelUtil.TextOut` method. \n\nNext, it iterates over each language button and renders them using the `GUI.Button` method. If a language button is clicked, it sets the `flag` variable to true and updates the selected language in the `LangOptManager` class. It also triggers other actions such as changing the GUI skin, loading assets, and changing the voice based on the selected language. \n\nFinally, it resets the GUI skin and checks if the dialog box is not a popup. If it is not a popup, it consumes the event to prevent further processing. \n\nIn summary, this code creates a dialog box that allows the user to change the language in the game. It renders the language buttons and handles user input to update the selected language and trigger other actions based on the selected language.\n## Questions: \n 1. What is the purpose of the `ChangeLangDialog` class?\n- The `ChangeLangDialog` class is a subclass of `Dialog` and represents a dialog box for changing the language in the game.\n\n2. What does the `InitDialog` method do?\n- The `InitDialog` method initializes the dialog by setting the supported languages and their corresponding textures, calculating the size of the dialog box, and setting its position.\n\n3. What happens when a language button is clicked in the `DoDialog` method?\n- When a language button is clicked, the `DoDialog` method sets the selected language as the current language, updates the GUI skin for the new language, loads the appropriate assets, and changes the voice based on the selected language.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ChangeLangDialog.md"}}],["117",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ChangeNickDialog.cs)\n\nThe code provided is a class called \"ChangeNickDialog\" that extends the \"Dialog\" class. This class is responsible for creating a dialog box that allows the user to change their nickname. \n\nThe class contains several private variables that define the position and size of various GUI elements within the dialog box. These variables include the position and size of the nickname input field, the \"Check Availability\" button, the \"Cancel\" button, and a comment label. \n\nThe class also has public variables for the maximum length of the nickname and the current nickname. \n\nThe class overrides the \"Start\" and \"OnPopup\" methods from the base \"Dialog\" class. The \"Start\" method sets the ID of the dialog, and the \"OnPopup\" method sets the position of the dialog box based on the screen size. \n\nThe class has a public method called \"InitDialog\" that resets the nickname to an empty string. \n\nThe class has a private method called \"CheckInput\" that validates the nickname input. It trims any leading or trailing whitespace from the nickname and checks its length. If the nickname is empty or too short, an error message is displayed. \n\nThe class has a public method called \"SetNickNameAvailability\" that sets the availability of the nickname and the available name. \n\nThe class has a private method called \"DoNickName\" that handles the GUI elements of the dialog box. It displays the nickname input field, removes any special characters from the nickname (if the build option is set to \"Axeso5\"), and checks the availability of the nickname when the \"Change\" button is clicked. It also displays a comment label with a message based on the availability of the nickname. \n\nThe class has a private method called \"RemoveSpecialCharacters\" that removes any special characters from the input string. \n\nThe class overrides the \"DoDialog\" method from the base \"Dialog\" class. This method handles the rendering of the dialog box. It calls the \"DoNickName\" method to display the GUI elements, and it checks if the \"Cancel\" button or the close button is clicked to close the dialog box. \n\nIn summary, this code defines a dialog box for changing the user's nickname. It handles the rendering of the dialog box and the validation of the nickname input. It also checks the availability of the nickname and displays a message accordingly. This class can be used in the larger project to provide a user interface for changing nicknames.\n## Questions: \n 1. What is the purpose of the `InitDialog()` method?\n- The `InitDialog()` method is used to reset the `nickName` variable to an empty string.\n\n2. What does the `DoNickName()` method do?\n- The `DoNickName()` method is responsible for displaying and handling the user input for the nickname. It also checks the availability of the nickname and performs some string manipulations.\n\n3. What is the purpose of the `RemoveSpecialCharacters()` method?\n- The `RemoveSpecialCharacters()` method removes any special characters from the input string and returns the modified string.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ChangeNickDialog.md"}}],["118",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ChangeNoticeDialog.cs)\n\nThe code provided is a class called `ChangeNoticeDialog` that extends the `Dialog` class. This class represents a dialog box that allows the user to change a notice for a clan. The purpose of this code is to handle the functionality and behavior of the dialog box.\n\nThe `ChangeNoticeDialog` class has several member variables and methods that are used to define and control the dialog box. \n\nThe `maxNotice` variable is an integer that represents the maximum number of characters allowed in the notice text. The `crdNotice` variable is a `Rect` object that defines the position and size of the notice text area within the dialog box. The `crdOk` variable is another `Rect` object that defines the position and size of the \"OK\" button within the dialog box. The `notice` variable is a string that holds the text entered by the user in the notice text area.\n\nThe `Start` method is an override of the `Start` method from the `Dialog` class. It sets the `id` variable of the dialog to a specific value from an enum called `DIALOG_INDEX`.\n\nThe `OnPopup` method is another override of a method from the `Dialog` class. It sets the `rc` variable to a `Rect` object that represents the position and size of the dialog box on the screen.\n\nThe `InitDialog` method is used to initialize the `notice` variable to an empty string.\n\nThe `DoTitle` method is responsible for rendering the title of the dialog box. It uses the `LabelUtil.TextOut` method to display the title text at a specific position on the screen.\n\nThe `DoNotice` method is responsible for rendering the notice text area. It uses the `GUI.TextArea` method to display a text area at a specific position and size on the screen. The user can enter text in this area.\n\nThe `CheckBadword` method checks if the notice text contains any bad words. It calls a method from a `WordFilter` class to perform the check. If any bad words are detected, a message box is displayed and the method returns false. Otherwise, it returns true.\n\nThe `DoDialog` method is the main method that handles the rendering and functionality of the dialog box. It sets the GUI skin, calls the `DoTitle` and `DoNotice` methods to render the title and notice text area, and checks if the \"OK\" button is pressed. If the button is pressed and the `CheckBadword` method returns true, a network request is made to change the clan notice. The method also checks if the close button or the escape key is pressed to close the dialog box. Finally, it restores the GUI skin and returns the result.\n\nIn the larger project, this code would be used to create and display a dialog box that allows the user to change the notice for a clan. The dialog box would be rendered on the screen and the user can enter text in the notice text area. The code also handles checking for bad words and making a network request to change the clan notice.\n## Questions: \n 1. What is the purpose of the `ChangeNoticeDialog` class?\n- The `ChangeNoticeDialog` class is a subclass of `Dialog` and is used to display a dialog box for changing a notice.\n\n2. What is the significance of the `maxNotice` variable?\n- The `maxNotice` variable determines the maximum number of characters allowed in the notice text.\n\n3. What does the `CheckBadword` method do?\n- The `CheckBadword` method checks if the notice text contains any bad words and displays a message if it does.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ChangeNoticeDialog.md"}}],["119",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Channel.cs)\n\nThe `Channel` class represents a channel in the Brick-Force project. A channel is a virtual space where players can interact and play the game. The class has various properties and methods that provide information about the channel and allow for comparisons and checks.\n\nThe class has several private fields, including `id`, `mode`, `name`, `ip`, `port`, `userCount`, `maxUserCount`, `country`, `minLvRank`, `maxLvRank`, `xpBonus`, `fpBonus`, and `limitStarRate`. These fields store information about the channel, such as its unique identifier, mode, name, IP address, port number, user count, maximum user count, country, level rank limits, experience bonus, force points bonus, and limit star rate.\n\nThe class also has several public properties that provide read-only access to some of the private fields, such as `Id`, `Mode`, `Name`, `Ip`, `Port`, and others. These properties allow other parts of the code to retrieve information about the channel without modifying it.\n\nThe class has a constructor that takes in parameters to initialize the private fields of the class. This constructor allows for the creation of a new channel object with the specified properties.\n\nThe class has several methods that provide additional functionality. The `GetMapHint` method returns a hint for the channel based on its mode. It uses a switch statement to determine the appropriate hint based on the channel's mode and returns the corresponding string.\n\nThe `Compare` method compares the current channel with another channel based on their modes and IDs. It returns an integer value indicating the result of the comparison.\n\nThe `IsUseAbleLevel` method checks if a given level rank is within the minimum and maximum level rank limits of the channel. It returns a boolean value indicating whether the level rank is usable in the channel.\n\nOverall, the `Channel` class provides a representation of a channel in the Brick-Force project and allows for accessing and manipulating its properties and performing comparisons and checks. It can be used in the larger project to manage and interact with channels, such as displaying channel information, filtering channels based on certain criteria, and determining if a player's level rank is suitable for a particular channel.\n## Questions: \n 1. What is the purpose of the `Channel` class?\n- The `Channel` class represents a channel in the Brick-Force game and contains various properties and methods related to the channel.\n\n2. What is the significance of the `MODE` enum?\n- The `MODE` enum represents the different modes of a channel, such as \"NEWBIE\", \"BATTLE\", \"MAPEDIT\", and \"CLAN\".\n\n3. What is the purpose of the `Compare` method?\n- The `Compare` method is used to compare two `Channel` objects based on their mode and id, and returns an integer value indicating their relative order.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Channel.md"}}],["120",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ChannelLabel.cs)\n\nThe code provided is a class called `ChannelLabel` that is marked with the `[Serializable]` attribute. This attribute indicates that objects of this class can be converted into a format that can be stored or transmitted, such as binary or XML.\n\nThe `ChannelLabel` class has three methods: `OnGUI()`, `Start()`, and `Update()`. These methods are commonly used in game development with the Unity engine.\n\nThe `OnGUI()` method is typically used to draw GUI elements on the screen. This method is called every frame and is responsible for rendering any user interface elements that need to be displayed. It is often used to create buttons, labels, and other interactive elements.\n\nThe `Start()` method is called when the object is first created or initialized. It is commonly used to set up initial values or perform any necessary setup tasks before the object is used. In the context of a game, this method might be used to initialize variables, load resources, or set the initial state of the game.\n\nThe `Update()` method is called every frame and is used to update the state of the object. This method is commonly used to handle user input, update the position or behavior of game objects, and perform any necessary calculations or logic. In the context of a game, this method might be used to move characters, detect collisions, or update the game's physics simulation.\n\nOverall, this code represents a class that can be used to create and manage GUI elements in a game or application. It provides methods for rendering GUI elements, initializing objects, and updating the state of the object. This class can be used as a building block in the larger project to create and manage the user interface. For example, it could be used to create buttons, labels, or other interactive elements that the player can interact with.\n## Questions: \n 1. **What is the purpose of the ChannelLabel class?**\nThe smart developer might want to know what functionality or role the ChannelLabel class serves within the Brick-Force project.\n\n2. **What is the purpose of the OnGUI() method?**\nThe smart developer might want to understand what actions or operations are performed within the OnGUI() method and when it is called.\n\n3. **What is the purpose of the Start() and Update() methods?**\nThe smart developer might want to know what actions or operations are performed within the Start() and Update() methods and when they are called.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ChannelLabel.md"}}],["121",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ChannelManager.cs)\n\nThe `ChannelManager` class is responsible for managing the channels in the Brick-Force project. It keeps track of the current channel, login channel, and other channel-related information. \n\nThe class has several properties, including `CurChannelId`, `LoginChannelId`, `CurChannel`, and `Tk2FpMultiple`, which provide access to the current channel ID, login channel ID, current channel object, and a multiplier for in-game currency, respectively. \n\nThe class also has a static property `Instance` that returns the singleton instance of the `ChannelManager` class. This allows other classes to access the `ChannelManager` instance without creating a new one.\n\nThe `ChannelManager` class provides several methods for retrieving the best channel for different purposes. These methods include `GetTutorialableChannel()`, `GetBestPlayChannel()`, `GetBestBuildChannel()`, and `GetBestClanChannel()`. These methods iterate over the channels in the `channelDictionary` and select the best channel based on various criteria such as user count, mode, and level rank. \n\nThe class also provides methods for updating and retrieving channel information. The `UpdateAlways()` method is used to update the information of a channel, such as user count and maximum user count. The `ToArraySortedByMode()`, `ToArray()`, and `ToArray(int mode, int country)` methods return an array of channels sorted by mode or filtered by mode and country.\n\nThe `ChannelManager` class also includes methods for checking if there is an error and retrieving the last error message. The `IsLastError()` method returns true if there is an error, and the `GetBestChannelLastError()` method returns the last error message.\n\nThe `Update()` method is called every frame and is responsible for refreshing the channel list if the game is in the \"ChangeChannel\" scene.\n\nOverall, the `ChannelManager` class is an important component of the Brick-Force project as it manages the channels and provides methods for selecting the best channel for different purposes. It also handles updating and retrieving channel information and checking for errors.\n## Questions: \n 1. What is the purpose of the `ChannelManager` class?\n- The `ChannelManager` class is responsible for managing channels in the game.\n\n2. What is the significance of the `curChannelId` and `loginChannelId` variables?\n- The `curChannelId` variable represents the current channel ID, while the `loginChannelId` variable represents the channel ID that the player logged in to.\n\n3. What is the purpose of the `GetBestPlayChannel()` method?\n- The `GetBestPlayChannel()` method returns the best channel for playing the game based on the player's status (newbie or not).","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ChannelManager.md"}}],["122",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ChannelUserManager.cs)\n\nThe `ChannelUserManager` class is responsible for managing the users in a channel. It keeps track of the users in a dictionary, where the key is the user's sequence number and the value is an instance of the `NameCard` class.\n\nThe `ChannelUserManager` class is a singleton, meaning that there can only be one instance of it in the project. The singleton pattern is implemented using a static property `Instance` and a private static field `_instance`. The `Instance` property ensures that there is only one instance of the `ChannelUserManager` class and provides a way to access that instance from other parts of the project.\n\nThe `Awake` method is called when the `ChannelUserManager` object is created. It initializes the dictionary `dic` and ensures that the object is not destroyed when a new scene is loaded using `Object.DontDestroyOnLoad(this)`.\n\nThe `Refresh` method is called periodically to refresh the user list. It checks if enough time has passed since the last refresh and if so, sends a request to the server to get the updated list of users in the channel.\n\nThe `AddUser` method is used to add a new user to the dictionary. If the user with the given sequence number does not exist in the dictionary, a new `NameCard` object is created and added to the dictionary. If the user already exists in the dictionary, the `Lv`, `Rank`, and `SvrId` properties of the existing `NameCard` object are updated.\n\nThe `Clear` method is used to clear the dictionary and reset the `deltaTime` variable.\n\nThe `DelUser` method is used to remove a user from the dictionary based on their sequence number.\n\nThe `GetUser` method is used to retrieve a `NameCard` object from the dictionary based on the user's sequence number.\n\nThe `ContainsUser` method is used to check if a user with the given sequence number exists in the dictionary.\n\nThe `ToArray` method is used to convert the dictionary of `NameCard` objects into an array of `NameCard` objects.\n\nOverall, the `ChannelUserManager` class provides a way to manage and manipulate the users in a channel. It allows for adding, removing, and retrieving user information, as well as refreshing the user list from the server. This class is likely used in conjunction with other classes and components in the larger project to display and interact with the users in the channel.\n## Questions: \n 1. What is the purpose of the `ChannelUserManager` class?\n- The `ChannelUserManager` class is responsible for managing a dictionary of `NameCard` objects, which represent users in a channel.\n\n2. What is the significance of the `Instance` property?\n- The `Instance` property is a singleton pattern implementation that ensures there is only one instance of the `ChannelUserManager` class throughout the application.\n\n3. What does the `Refresh` method do?\n- The `Refresh` method updates the `deltaTime` variable and sends a request to the `CSNetManager` to retrieve the player list for the current channel if the `deltaTime` exceeds 3 seconds.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ChannelUserManager.md"}}],["123",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ChatLogManager.cs)\n\nThe code provided is for a class called `ChatLogManager` in the Brick-Force project. This class is responsible for managing the chat log functionality within the game. \n\nThe `ChatLogManager` class has several public and private variables. The `maxCopynpaste` variable determines the maximum number of times a message can be copied and pasted before a penalty is applied. The `penaltyTime` variable determines the duration of the penalty for copying and pasting messages. The `coolTime` variable determines the duration after which the chat log is cleared.\n\nThe class also has a private `Queue<string>` variable called `latestChat` to store the latest chat messages. The `penalty` variable is a boolean flag that indicates whether a penalty is currently active. The `deltaTime` variable keeps track of the time passed since the penalty was applied. The `loggingTime` variable keeps track of the time passed since the last chat message was logged.\n\nThe class has a static property called `Instance` which provides a singleton instance of the `ChatLogManager` class. The `Start` method initializes the `latestChat` queue. The `Awake` method ensures that the `ChatLogManager` object is not destroyed when a new scene is loaded.\n\nThe `Log` method is used to log a new chat message. It checks if a penalty is currently active and returns false if it is. It then checks if the message has been copied and pasted more than the allowed number of times. If it has, a penalty is applied, the `latestChat` queue is cleared, and a warning message is displayed. Otherwise, the message is added to the `latestChat` queue and if the queue exceeds the maximum size, the oldest message is removed.\n\nThe `Update` method is called every frame. If a penalty is active, it updates the `deltaTime` variable and if the penalty duration has passed, it clears the penalty. The `loggingTime` variable is also updated and if it exceeds the `coolTime`, the `latestChat` queue is cleared.\n\nOverall, the `ChatLogManager` class provides functionality for logging chat messages, applying penalties for excessive copying and pasting, and clearing the chat log after a certain duration. This class can be used in the larger project to manage the chat log system and enforce chat rules.\n## Questions: \n 1. What is the purpose of the `ChatLogManager` class?\n- The `ChatLogManager` class is responsible for managing a chat log, including logging messages, enforcing penalties for excessive copying and pasting, and clearing the log after a certain amount of time.\n\n2. What is the significance of the `maxCopynpaste` variable?\n- The `maxCopynpaste` variable determines the maximum number of times a message can be copied and pasted before a penalty is enforced.\n\n3. What is the purpose of the `penalty` variable and how is it used?\n- The `penalty` variable is a boolean flag that indicates whether a penalty is currently being enforced. It is used to prevent logging messages and clear the chat log when a penalty is active.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ChatLogManager.md"}}],["124",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ChatSelectBtns.cs)\n\nThe `ChatSelectBtns` class is responsible for managing the chat modes in the Brick-Force project. It provides functionality to switch between different chat modes, such as general chat, clan chat, and team chat. \n\nThe class has several private variables, including `crdCombo`, which represents the position and size of the chat mode selection box, `chatModes`, which is an array of strings representing the different chat modes, `cbox`, which is an instance of the `ComboBox` class used for displaying the chat mode selection box, `IsBattle`, a boolean flag indicating whether the chat mode is for a battle or not, `selected`, an integer representing the index of the currently selected chat mode, `chatView`, a boolean flag indicating whether the chat view is enabled or not, and `chatMode`, an enum representing the current chat mode.\n\nThe class has several public methods, including `chatModeLobby()` and `chatModeBattle()`, which set the `IsBattle` flag and populate the `chatModes` array with the appropriate chat mode strings based on the current input keys. The `OnGUI()` method is responsible for rendering the chat mode selection box and handling user input to change the selected chat mode. The `changeChildIdx()` method is used to change the selected item index of the `cbox` instance based on the provided chat type. The `rcBox()` methods are used to update the position of the chat mode selection box. The `VerifyChatView()` method is responsible for checking the current chat view state in the game and updating the `chatView` flag accordingly. The `changeParentChatMode()` method is used to update the chat mode in the parent chat components based on the current selected chat mode. The `Update()` method is responsible for calling the `VerifyChatView()` method to update the chat view state.\n\nOverall, this class provides the functionality to switch between different chat modes in the Brick-Force project. It is used to manage the chat view and update the chat mode in the parent chat components based on the user's selection.\n## Questions: \n 1. What is the purpose of the `ChatSelectBtns` class?\n- The `ChatSelectBtns` class is responsible for managing the chat modes and displaying them in a dropdown menu.\n\n2. What is the significance of the `chatView` variable?\n- The `chatView` variable determines whether the chat view is enabled or disabled.\n\n3. What is the purpose of the `changeParentChatMode` method?\n- The `changeParentChatMode` method is used to update the chat mode in various components of the game based on the selected chat mode in the dropdown menu.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ChatSelectBtns.md"}}],["125",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ChatText.cs)\n\nThe code provided is a class called `ChatText` that is used to represent a chat message in a game called Brick-Force. The purpose of this class is to store and manage the properties and behavior of a chat message, such as the type of chat, the speaker, the message content, and the colors of the text and outline.\n\nThe class has several properties, including `textColor`, `outlineColor`, `seq`, `speaker`, `sChatType`, `message`, `chatType`, `lapTime`, `isGm`, and `getsrvnick`. These properties are used to store information about the chat message, such as the colors of the text and outline, the sequence number, the speaker's name, the chat type, the message content, and other related data.\n\nThe class also has several methods, including a constructor, `FullMessage`, `IsAlive`, `setTextAlpha`, `setOutTextAlpha`, `Filtered`, and `Update`. These methods are used to perform various operations on the chat message, such as constructing the full message string, checking if the message is still alive, setting the alpha value of the text and outline colors, filtering the message based on the selected tab, and updating the chat message over time.\n\nThe `ChatText` class is likely used in the larger Brick-Force project to handle and display chat messages in the game. It provides a way to store and manage chat message data, as well as perform operations on the messages, such as filtering and updating their appearance. This class can be used by other components or systems in the game to handle chat functionality, such as displaying messages in the chat window, filtering messages based on user preferences, and managing the lifespan of chat messages.\n\nHere is an example of how the `ChatText` class can be used in the larger project:\n\n```csharp\n// Create a new chat message\nChatText chatMessage = new ChatText(ChatText.CHAT_TYPE.NORMAL, 1, \"Player1\", \"Hello, world!\");\n\n// Get the full message string\nstring fullMessage = chatMessage.FullMessage;\n\n// Check if the message is still alive\nbool isAlive = chatMessage.IsAlive;\n\n// Set the alpha value of the text color\nchatMessage.setTextAlpha(0.5f);\n\n// Set the alpha value of the outline color\nchatMessage.setOutTextAlpha(0.8f);\n\n// Filter the message based on the selected tab\nbool filtered = chatMessage.Filtered(1);\n\n// Update the chat message over time\nchatMessage.Update();\n```\n\nOverall, the `ChatText` class provides a way to represent and manage chat messages in the Brick-Force game, allowing for the display and manipulation of chat message data in the game's chat system.\n## Questions: \n 1. What is the purpose of the `ChatText` class?\n- The `ChatText` class is used to represent a chat message in the game. It stores information such as the type of chat, the speaker, and the message content.\n\n2. How is the chat message displayed in the game?\n- The `FullMessage` property returns a formatted string that includes the chat type, speaker, and message content. The formatting varies depending on the chat type.\n\n3. How does the chat message fade out over time?\n- The `Update` method is called every frame and updates the transparency of the text and outline colors based on the elapsed time. After 14 seconds, the text and outline colors gradually fade out until they become completely transparent.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ChatText.md"}}],["126",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\CheckBrickDead.cs)\n\nThe purpose of this code is to check if a brick object in the game is still active or has been destroyed. This code is part of a larger project called Brick-Force, which likely involves a game where players can build structures using bricks.\n\nThe `CheckBrickDead` class is a MonoBehaviour that is attached to a game object in the scene. It has a private integer variable `idBrick` initialized to -1, which represents the ID of the brick object it is checking. The `brickID` property provides access to this variable, allowing other classes to get or set its value.\n\nThe `Update` method is called every frame by Unity's game engine. Within this method, the code checks if `idBrick` is greater than or equal to 0. If it is, it means that a brick object has been assigned to `idBrick`. The code then calls a method `GetBrickObject` from the `BrickManager` class, passing in `idBrick` as an argument. This method is likely responsible for retrieving the actual game object associated with the given brick ID.\n\nIf `brickObject` is null, it means that the brick object has been destroyed or is no longer active in the game. In this case, the code destroys the game object to remove it from the scene using `Object.Destroy(base.gameObject)`. The `base` keyword refers to the MonoBehaviour component attached to the game object that this script is attached to.\n\nThis code is useful in the larger Brick-Force project because it allows the game to keep track of and remove destroyed or inactive brick objects. It ensures that the game remains in a consistent state and prevents any potential issues that may arise from interacting with non-existent objects.\n\nExample usage:\n```csharp\nCheckBrickDead brickChecker = gameObject.AddComponent<CheckBrickDead>();\nbrickChecker.brickID = 5; // Assign brick ID to check\n```\n\nIn this example, a `CheckBrickDead` component is added to a game object, and the `brickID` property is set to 5. This will cause the `Update` method to check if the brick object with ID 5 is still active, and if not, it will be destroyed.\n## Questions: \n 1. What is the purpose of the `brickID` property?\n- The `brickID` property is used to get and set the ID of a brick.\n\n2. What is the significance of the `Update()` method?\n- The `Update()` method is called every frame and is used to check if the brick with the specified ID still exists. If it doesn't, the game object associated with this script is destroyed.\n\n3. What is the role of `BrickManager.Instance.GetBrickObject(idBrick)`?\n- `BrickManager.Instance.GetBrickObject(idBrick)` is used to retrieve the game object associated with the brick ID.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\CheckBrickDead.md"}}],["127",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\CheckMonDead.cs)\n\nThe code provided is a part of the Brick-Force project and is contained within a file called \"CheckMonDead\". This code is written in C# and utilizes the Unity game engine.\n\nThe purpose of this code is to check if a specific monster (referred to as \"Mon\") is dead or no longer exists in the game. It does this by checking the ID of the monster and retrieving its description from the \"MonManager\" class. If the description is null, it means that the monster no longer exists, and the code destroys the game object associated with this script.\n\nThe code begins by declaring a private integer variable called \"idMon\" and initializing it with a value of -1. This variable is used to store the ID of the monster being checked.\n\nNext, there is a public property called \"MonID\" which provides access to the \"idMon\" variable. The \"get\" accessor returns the value of \"idMon\", and the \"set\" accessor allows the value of \"idMon\" to be modified.\n\nThe \"Update\" method is a built-in Unity method that is called once per frame. Within this method, the code checks if the \"idMon\" variable is greater than or equal to 0. If it is, it retrieves the description of the monster using the \"GetDesc\" method from the \"MonManager\" class. If the description is null, it means that the monster no longer exists, and the code destroys the game object associated with this script using the \"Destroy\" method from the \"Object\" class.\n\nThis code can be used in the larger Brick-Force project to handle the logic for checking if a monster is dead or no longer exists. It can be attached to a game object in the scene that represents a monster, and when the monster is killed or removed from the game, the associated game object will be destroyed. This code provides a way to clean up any remaining references to monsters that are no longer present in the game, preventing memory leaks and improving performance.\n## Questions: \n 1. What is the purpose of the `MonID` property?\n- The `MonID` property is used to get and set the value of the `idMon` private variable.\n\n2. What is the significance of the `Update` method?\n- The `Update` method is called every frame and it checks if the `idMon` is greater than or equal to 0. If it is, it retrieves the `MonDesc` object associated with that `idMon` from the `MonManager` and if it is null, it destroys the game object.\n\n3. What is the role of the `MonManager` class?\n- The `MonManager` class is responsible for managing and providing access to `MonDesc` objects based on their IDs.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\CheckMonDead.md"}}],["128",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Clan.cs)\n\nThe code provided is a class called \"Clan\" that represents a clan in the Brick-Force project. The purpose of this class is to store and manage information about a clan, such as its name, members, win/loss records, rank, match points, and other details.\n\nThe class has several private variables, including \"seq\" (sequence), \"mark\" (a mark or identifier), \"name\" (the name of the clan), \"clanMaster\" (the username of the clan's master), and various counters for win, draw, and loss counts. There are also variables for the number of members, rank, rank change, match points, and various other details.\n\nThe class has public properties for accessing and modifying these variables. For example, the \"Name\" property allows getting and setting the name of the clan. The \"Seq\" property is a read-only property that returns the sequence of the clan.\n\nThe class also has several methods that provide functionality related to the clan. For example, the \"RecordString\" method returns a string representation of the win, draw, and loss counts. The \"MemberCountString\" method returns a string representation of the number of members in the clan. The \"RankString\" method returns a string representation of the rank of the clan. The \"MatchPointString\" method returns a string representation of the match points of the clan. The \"CeateDateString\" method returns a string representation of the creation date of the clan. The \"GoldSilverBronzeString\" method returns a string representation of the gold, silver, and bronze counts of the clan.\n\nThe class also has a \"Compare\" method that compares the rank of the current clan with another clan and returns a value indicating the comparison result.\n\nOverall, this class provides a way to store and manage information about a clan in the Brick-Force project. It allows accessing and modifying various details of the clan and provides methods for retrieving string representations of certain details. This class can be used in the larger project to create and manage clans, track their statistics, and perform comparisons between clans based on their ranks.\n## Questions: \n 1. What is the purpose of the `Clan` class?\n- The `Clan` class represents a clan in the Brick-Force project and contains various properties and methods related to the clan.\n\n2. What are the different status levels that a clan member can have?\n- The different status levels that a clan member can have are `NO_MEMBER`, `MEMBER`, `STAFF`, and `MASTER`.\n\n3. What is the purpose of the `Compare` method?\n- The `Compare` method is used to compare two `Clan` objects based on their ranks. It returns 1 if the rank of the current `Clan` object is greater than or equal to the rank of the argument `Clan` object, otherwise it returns -1.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Clan.md"}}],["129",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ClanApplicant.cs)\n\nThe code provided is a class called `ClanApplicant` that represents an applicant for a clan in the larger Brick-Force project. \n\nThe class has several private variables: `name`, `seq`, `day`, `month`, and `year`. These variables are used to store information about the applicant's name and date of application. \n\nThe class also has public properties for each of these variables: `Name` and `Seq`. These properties allow other parts of the code to access and modify the values of these variables. \n\nThe class has a constructor that takes in the applicant's sequence number, name, and date of application as parameters. This constructor is used to create a new instance of the `ClanApplicant` class with the provided values. \n\nThe class also has a public method called `GetDateToString()`. This method returns a string representation of the applicant's date of application in the format \"year.month.day\". The method achieves this by converting the integer values of `year`, `month`, and `day` to strings and concatenating them with periods in between. \n\nOverall, this code provides a way to create and store information about clan applicants in the Brick-Force project. The `ClanApplicant` class allows for the creation of new applicant objects with their respective sequence number, name, and date of application. The `GetDateToString()` method provides a way to retrieve the date of application in a specific format. \n\nExample usage of this code could be as follows:\n\n```csharp\nClanApplicant applicant = new ClanApplicant(1, \"John Doe\", 2022, 10, 15);\nConsole.WriteLine(applicant.Name); // Output: John Doe\nConsole.WriteLine(applicant.GetDateToString()); // Output: 2022.10.15\napplicant.Seq = 2;\nConsole.WriteLine(applicant.Seq); // Output: 2\n```\n## Questions: \n 1. What is the purpose of the `ClanApplicant` class?\n- The `ClanApplicant` class represents an applicant for a clan in the Brick-Force project.\n\n2. What are the properties of the `ClanApplicant` class?\n- The `ClanApplicant` class has properties for `Name` (string) and `Seq` (int).\n\n3. What does the `GetDateToString` method do?\n- The `GetDateToString` method returns a string representation of the date stored in the `year`, `month`, and `day` variables in the format \"year.month.day\".","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ClanApplicant.md"}}],["130",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ClanConfirmDialog.cs)\n\nThe code provided is a class called \"ClanConfirmDialog\" that extends the \"Dialog\" class. This class represents a dialog box that is used in the larger Brick-Force project to confirm various actions related to a clan.\n\nThe class has several public and private variables that store information about the dialog, such as the icon to display, the position and size of different UI elements, and the type of action to confirm. The \"CLAN_CONFIRM_WHAT\" enum defines the different types of actions that can be confirmed, including destroying a clan, kicking a clan member, leaving a clan, and delegating the clan master.\n\nThe class overrides the \"Start\" and \"OnPopup\" methods from the base \"Dialog\" class. The \"Start\" method sets the ID of the dialog, and the \"OnPopup\" method sets the position of the dialog on the screen.\n\nThe class also has a method called \"InitDialog\" that is used to initialize the dialog with the specific action to confirm, the target sequence, target name, and object name.\n\nThe main functionality of the class is implemented in the \"DoDialog\" method. This method displays the dialog UI elements, including a title, a comment box, and an OK button. The content of the comment box and the action performed when the OK button is clicked depend on the type of action to confirm.\n\nFor example, if the action is to destroy a clan, the comment box displays a confirmation message and the OK button sends a request to the server to destroy the clan. Similarly, for other actions like kicking a clan member, leaving a clan, or delegating the clan master, the comment box and the OK button perform the corresponding actions.\n\nThe method also handles the close button and the escape key press to close the dialog.\n\nOverall, this class represents a dialog box used in the Brick-Force project to confirm various actions related to a clan. It provides a reusable component that can be easily integrated into the larger project to handle clan-related actions.\n## Questions: \n 1. What is the purpose of the `ClanConfirmDialog` class?\n- The `ClanConfirmDialog` class is a subclass of the `Dialog` class and is used to display a dialog box for confirming clan-related actions.\n\n2. What is the purpose of the `CLAN_CONFIRM_WHAT` enum?\n- The `CLAN_CONFIRM_WHAT` enum is used to define different types of clan-related actions that can be confirmed, such as destroying a clan, kicking a clan member, leaving a clan, or delegating the master role.\n\n3. What is the purpose of the `InitDialog` method?\n- The `InitDialog` method is used to initialize the dialog with the specific details of the clan-related action being confirmed, such as the action type, target sequence, target name, and object name.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ClanConfirmDialog.md"}}],["131",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ClanMarkManager.cs)\n\nThe `ClanMarkManager` class in the `Brick-Force` project is responsible for managing clan marks, which are visual representations used to identify different clans in the game. \n\nThe class contains several arrays and variables that store different textures and colors used for clan marks. These include `bg` (background textures), `amblum` (amblum textures), `colorTable` (color values), and `colorPanel` (color textures). \n\nThe class also includes several methods that convert between different representations of clan marks. \n\nThe `IndexToMark` method takes in indices for the background, color, and amblum and combines them into a single integer value that represents the clan mark. \n\nThe `MarkToBg`, `MarkToColor`, and `MarkToAmblum` methods extract the background, color, and amblum indices from a given clan mark. \n\nThe `GetBg`, `GetColor`, and `GetAmblum` methods retrieve the corresponding textures for a given clan mark. \n\nThe `GetColorValue` method returns the color value associated with a given clan mark. \n\nThe `GetBgByIndex`, `GetAmblumByIndex`, `GetColorByIndex`, and `GetColorValueByIndex` methods retrieve the textures and color values based on their respective indices. \n\nThe `Awake`, `Start`, and `Update` methods are empty and do not contain any code. \n\nOverall, the `ClanMarkManager` class provides a centralized way to manage and retrieve clan marks and their associated textures and colors. It can be used by other classes in the project to display and manipulate clan marks for different clans. For example, it could be used in a UI component to allow players to select and customize their clan mark.\n## Questions: \n 1. What is the purpose of the `ClanMarkManager` class?\n- The `ClanMarkManager` class is responsible for managing clan marks, including their backgrounds, colors, and emblems.\n\n2. How does the `IndexToMark` method work?\n- The `IndexToMark` method takes in indices for the background, color, and emblem and combines them into a single integer value.\n\n3. What is the purpose of the `Awake`, `Start`, and `Update` methods?\n- The `Awake` method ensures that the `ClanMarkManager` object is not destroyed when a new scene is loaded, while the `Start` and `Update` methods are currently empty and do not have any functionality.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ClanMarkManager.md"}}],["132",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ClanMatchRounding.cs)\n\nThe `ClanMatchRounding` class is responsible for handling the countdown and round restart functionality in the Brick-Force project. It is a MonoBehaviour script that is attached to a GameObject in the Unity game engine.\n\nThe purpose of this code is to manage the countdown and restart of rounds in a clan match. It provides functionality for displaying the countdown digits on the screen, handling the round restart process, and managing various game-related components.\n\nThe code includes several private variables, such as `count`, `rounding`, and `step`, which are used to keep track of the current state of the round restart process. The `count` variable represents the current countdown digit, while `rounding` indicates whether a round restart is in progress. The `step` variable represents the current step in the round restart process.\n\nThe code also includes public properties, such as `Count` and `Rounding`, which allow other classes to access and modify the `count` and `rounding` variables, respectively.\n\nThe `Start` method is called when the script is first initialized. It sets the initial values of the `rounding` and `showRoundMessage` variables and calls the `VerifyLocalController` method.\n\nThe `VerifyLocalController` method is responsible for finding and assigning the `LocalController` and `EquipCoordinator` components from the `me` GameObject. These components are used later in the code for various game-related operations.\n\nThe code includes several event handler methods, such as `OnRoundEnd`, `OnClanMatchHalfTime`, `OnGetBack2Spawner`, `OnMatchRestartCount`, and `OnMatchRestarted`. These methods are called in response to specific events in the game, such as the end of a round or the halfway point in a clan match. They perform various actions, such as resetting variables, canceling actions, and playing audio.\n\nThe `Update` method is called every frame and is responsible for updating the countdown and round restart process. It checks if a round restart is in progress (`rounding` is true) and updates the `preWaitTime` variable. If the current player is the master of the room, it also updates the `deltaTime` variable and performs different actions based on the current `step`.\n\nThe `OnGUI` method is responsible for rendering the countdown digits and round restart messages on the screen. It is only called when a round restart is in progress and the GUI is enabled. It uses the Unity GUI system to draw the countdown digits and round restart messages at the appropriate positions on the screen.\n\nIn summary, the `ClanMatchRounding` class manages the countdown and round restart functionality in the Brick-Force project. It handles the display of countdown digits, the execution of round restart actions, and the rendering of relevant messages on the screen. It interacts with other game-related components and responds to specific events in the game.\n## Questions: \n 1. What is the purpose of the `ClanMatchRounding` class?\n- The `ClanMatchRounding` class is responsible for handling the countdown and round restart logic in a clan match.\n2. What is the significance of the `STEP` enum?\n- The `STEP` enum is used to track the current step in the round restart process, with possible values of `WAIT` and `CHANGED`.\n3. What is the purpose of the `VerifyLocalController` method?\n- The `VerifyLocalController` method is used to find and assign the `LocalController` and `EquipCoordinator` components to the `me` GameObject.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ClanMatchRounding.md"}}],["133",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ClanMemberCard.cs)\n\nThe code provided is a class called `ClanMemberCard` that extends another class called `NameCard`. This class represents a card for a clan member in the larger Brick-Force project. \n\nThe `ClanMemberCard` class has several private variables: `clanLv`, `clanRoyalty`, and `clanPoint`. These variables store information about the clan member's level, royalty, and points. \n\nThe class also has public properties for each of these variables (`ClanLv`, `ClanRoyalty`, and `ClanPoint`) that allow access to their values. These properties have both a getter and a setter, allowing other parts of the project to read and modify these values as needed. \n\nThe class has a constructor that takes in several parameters, including the clan member's sequence number, nickname, level, rank, clan level, clan royalty, and clan points. The constructor sets the values of the private variables using the provided parameters. \n\nThe class also has a method called `Compare` that takes in another `ClanMemberCard` object, a `CLANSORT` enum value, and a boolean indicating whether the comparison should be in ascending or descending order. This method compares the current `ClanMemberCard` object with the provided object based on the specified sorting criteria. The method returns an integer value indicating the result of the comparison. \n\nThe `Compare` method uses a switch statement to determine which sorting criteria to use. It compares the values of the corresponding variables (`clanPoint`, `Nickname`, `clanLv`, and `IsConnected`) and assigns the result to the `num` variable. If the `ascending` parameter is `false`, the `num` value is negated. Finally, the method returns the `num` value. \n\nOverall, this code provides a class that represents a clan member card in the Brick-Force project. It allows for storing and accessing information about the clan member's level, royalty, and points. The `Compare` method allows for comparing two `ClanMemberCard` objects based on different sorting criteria.\n## Questions: \n 1. What is the purpose of the `ClanMemberCard` class and how does it relate to the `NameCard` class? \n- The `ClanMemberCard` class is a subclass of the `NameCard` class. It adds additional properties and methods specific to clan members.\n\n2. What is the purpose of the `Compare` method and how is it used? \n- The `Compare` method is used to compare two `ClanMemberCard` objects based on a specified sorting criteria (`CLANSORT`). It returns an integer value indicating the comparison result.\n\n3. What are the possible values for the `CLANSORT` enum and how do they affect the comparison in the `Compare` method? \n- The possible values for the `CLANSORT` enum are `POINT`, `NAME`, `LV`, and `CNNT`. They determine which property of the `ClanMemberCard` objects is used for comparison in the `switch` statement of the `Compare` method.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ClanMemberCard.md"}}],["134",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ClanMemberListFrame.cs)\n\nThe code provided is a class called `ClanMemberListFrame` that is used to display a list of clan members in a graphical user interface (GUI) in the game Brick-Force. \n\nThe class contains several private variables that define the positions and sizes of various GUI elements, such as the outline of the clan member list, the label for the clan members, and the user list. These variables are used to position and size the GUI elements correctly on the screen.\n\nThe class also has a `Start` method that initializes the `onceASecond` variable to 0. This variable is used to keep track of the time elapsed since the last update.\n\nThe `Update` method is called every frame and increments the `onceASecond` variable by the time elapsed since the last frame. If `onceASecond` is greater than 1, it resets the variable to 0 and sends a network request to the server to get the latest information about the clan members.\n\nThe `OnGUI` method is responsible for rendering the GUI elements on the screen. It first draws a box outline and a label for the clan members. It then retrieves an array of `NameCard` objects representing the clan members from the `MyInfoManager` class. It creates an empty string array with the same length as the `NameCard` array.\n\nNext, it creates a scrollable view for the user list using the `GUI.BeginScrollView` method. It sets the size of the scrollable view based on the number of clan members and the size of each element. It also sets the current selection index for the user list.\n\nInside the scrollable view, it iterates over each clan member and calls the `aPlayer` method to render the badge and nickname for each clan member. The `aPlayer` method takes a `NameCard` object and the current y position as parameters, and returns the updated y position for the next clan member.\n\nFinally, it ends the scrollable view using the `GUI.EndScrollView` method.\n\nOverall, this code is responsible for rendering a list of clan members in the game's GUI and updating the list periodically by sending a network request to the server. It uses various GUI elements and positions them correctly on the screen.\n## Questions: \n 1. What is the purpose of the `Start()` method?\n- The `Start()` method initializes the `onceASecond` variable to 0.\n\n2. What does the `Update()` method do?\n- The `Update()` method increments the `onceASecond` variable by the time since the last frame and sends a network request if `onceASecond` is greater than 1.\n\n3. What is the purpose of the `OnGUI()` method?\n- The `OnGUI()` method is responsible for rendering the graphical user interface (GUI) elements for displaying clan member information.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ClanMemberListFrame.md"}}],["135",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ClanReq.cs)\n\nThe code provided is a class called `ClanReq` that represents a clan request in the Brick-Force project. This class is used to store and manipulate information about a clan request, such as the name of the clan, the sequence number, the clan mark, the clan master, the rank, win/loss/draw counts, number of members, and various other attributes.\n\nThe class has several properties that allow access to these attributes. For example, the `Name` property allows getting and setting the name of the clan, the `Seq` property allows getting and setting the sequence number, and so on. These properties provide a way to encapsulate the data and control how it is accessed and modified.\n\nThe class also has a constructor that takes in all the necessary attributes to create a `ClanReq` object. This constructor initializes the object with the provided values.\n\nAdditionally, the class has several methods that provide functionality to convert the attributes into strings. For example, the `GetDateToString` method returns a string representation of the date attributes (year, month, and day) in the format \"yyyy.mm.dd\". The `RecordString` method returns a string representation of the win/loss/draw counts in the format \"winCount-drawCount-loseCount\". The `MemberCountString` method returns a string representation of the number of members. The `RankString` method returns a string representation of the rank, or \"-\" if the rank is less than 0. The `GoldSilverBronzeString` method returns a string representation of the gold, silver, and bronze attributes in the format \"gold/silver/bronze\".\n\nOverall, this `ClanReq` class provides a way to store and manipulate information about a clan request in the Brick-Force project. It encapsulates the data and provides methods to convert the attributes into strings for display or further processing. This class can be used in the larger project to manage and handle clan requests. For example, it can be used to create new clan requests, retrieve information about existing clan requests, or display information about clan requests in the user interface.\n## Questions: \n 1. What is the purpose of the `ClanReq` class?\n- The `ClanReq` class is used to store information about a clan, such as its name, rank, win/loss/draw counts, member count, and other details.\n\n2. What are the different properties of the `ClanReq` class and what do they represent?\n- The properties of the `ClanReq` class include `Name`, `Seq`, `Mark`, `ClanMaster`, `Rank`, `WinCount`, `DrawCount`, `LoseCount`, `NoMember`, `Gold`, `Silver`, `Bronze`, `Day`, `Month`, and `Year`. These properties represent various attributes of a clan, such as its name, sequence number, mark, clan master, rank, win/loss/draw counts, member count, and date.\n\n3. What are the different methods in the `ClanReq` class and what do they do?\n- The `ClanReq` class has several methods including `GetDateToString()`, `RecordString()`, `MemberCountString()`, `RankString()`, and `GoldSilverBronzeString()`. These methods are used to convert the date to a string format, generate a string representation of the win/loss/draw counts, member count, rank, and gold/silver/bronze counts respectively.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ClanReq.md"}}],["136",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\CLANSORT.cs)\n\nThe code provided is an enumeration called `CLANSORT`. An enumeration is a set of named values that represent a set of possible options or choices. In this case, `CLANSORT` represents the different sorting options for clans in the larger Brick-Force project.\n\nThe `CLANSORT` enumeration has four possible values: `POINT`, `NAME`, `LV`, and `CNNT`. Each value represents a different sorting option for clans. \n\n- `POINT` represents sorting by points. This could be used to sort clans based on their performance or achievements in the game.\n- `NAME` represents sorting by name. This could be used to sort clans alphabetically by their names.\n- `LV` represents sorting by level. This could be used to sort clans based on their level or rank in the game.\n- `CNNT` represents sorting by connection. This could be used to sort clans based on their online presence or activity.\n\nThe `CLANSORT` enumeration allows the code in the larger Brick-Force project to easily specify the desired sorting option for clans. For example, if the project needs to display a leaderboard of clans sorted by points, it can use the `POINT` value from the `CLANSORT` enumeration.\n\nHere's an example of how this enumeration could be used in the larger project:\n\n```java\nCLANSORT sortingOption = CLANSORT.POINT;\nList<Clan> clans = getClansFromDatabase();\nsortClans(clans, sortingOption);\ndisplayClans(clans);\n```\n\nIn this example, the `sortingOption` variable is set to `CLANSORT.POINT`, indicating that the clans should be sorted by points. The `getClansFromDatabase()` function retrieves a list of clans from a database. The `sortClans()` function then sorts the clans based on the specified sorting option. Finally, the `displayClans()` function displays the sorted clans to the user.\n\nOverall, the `CLANSORT` enumeration provides a convenient way for the code in the Brick-Force project to specify and handle different sorting options for clans.\n## Questions: \n 1. What is the purpose of this enum? \n- This enum is used to define the sorting options for clans in the Brick-Force project. \n\n2. What do the values 0, 1, 2, and 4 represent in this enum? \n- The values represent different sorting criteria for clans: 0 represents sorting by points, 1 represents sorting by name, 2 represents sorting by level, and 4 represents sorting by connection.\n\n3. Are there any other sorting options available for clans in the Brick-Force project? \n- No, these four options (points, name, level, and connection) are the only sorting options available for clans in the Brick-Force project.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\CLANSORT.md"}}],["137",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\clipNameManager.cs)\n\nThe code provided is a class called `clipNameManager` that manages a list of clip names. \n\nThe `clipNameManager` class has the following methods:\n\n1. `Alloc()`: This method initializes the `clipNames` ArrayList. It creates a new instance of the ArrayList and assigns it to the `clipNames` variable.\n\n2. `Add(string clipName)`: This method adds a new clip name to the `clipNames` ArrayList. It takes a string parameter `clipName` and uses the `Add()` method of the ArrayList to add the clip name to the list.\n\n3. `Find(string findName)`: This method checks if a given clip name exists in the `clipNames` ArrayList. It takes a string parameter `findName` and uses the `Contains()` method of the ArrayList to check if the clip name is present in the list. If the clip name is found, the method returns `true`, otherwise it returns `false`.\n\nThe purpose of this code is to provide a way to manage a collection of clip names. It allows for adding new clip names to the collection and checking if a specific clip name exists in the collection.\n\nThis code can be used in the larger Brick-Force project to handle and organize various clip names used in the game. For example, it can be used to keep track of all the available animation clips for different characters or objects in the game. The `Alloc()` method can be called at the start of the game to initialize the clip name manager, and then the `Add()` method can be used to add new clip names as they are created. The `Find()` method can be used to check if a specific clip name is already in use before adding a new one.\n\nHere is an example of how this code can be used:\n\n```csharp\nclipNameManager manager = new clipNameManager();\nmanager.Alloc();\n\nmanager.Add(\"clip1\");\nmanager.Add(\"clip2\");\nmanager.Add(\"clip3\");\n\nbool clipExists = manager.Find(\"clip2\");\n// clipExists will be true\n\nbool nonExistentClipExists = manager.Find(\"clip4\");\n// nonExistentClipExists will be false\n```\n\nIn this example, a new `clipNameManager` instance is created and initialized using the `Alloc()` method. Three clip names are then added to the manager using the `Add()` method. Finally, the `Find()` method is used to check if a specific clip name exists in the manager.\n## Questions: \n 1. **What is the purpose of the `clipNameManager` class?**\nThe `clipNameManager` class is responsible for managing a list of clip names.\n\n2. **What does the `Alloc` method do?**\nThe `Alloc` method initializes the `clipNames` ArrayList.\n\n3. **Why does the `Find` method return a boolean value?**\nThe `Find` method returns a boolean value to indicate whether a given clip name is present in the `clipNames` ArrayList.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\clipNameManager.md"}}],["138",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\CMPlayer.cs)\n\nThe code provided defines a class called `CMPlayer` which represents a player in the Brick-Force project. This class has several private fields to store information about the player, including their experience points (`xp`), rank, nickname, number of kills, number of assists, number of deaths, and score. \n\nThe class also has several public properties that allow access to these private fields. The `Xp` property returns the player's experience points, the `Rank` property returns the player's rank, the `Nickname` property returns the player's nickname, the `Record` property returns a string representation of the player's kill/assist/death record, and the `Score` property returns the player's score.\n\nThe class also has a constructor that takes in parameters for each of these fields and initializes them. This allows for the creation of a `CMPlayer` object with the specified values for each field.\n\nThis code is likely used in the larger Brick-Force project to represent and manage player data. It provides a way to create player objects with their respective attributes and retrieve information about the players, such as their experience points, rank, nickname, record, and score. \n\nHere is an example of how this code might be used in the larger project:\n\n```csharp\n// Create a new CMPlayer object for a player named \"John\" with the following attributes\nCMPlayer player = new CMPlayer(1000, 5, \"John\", 50, 20, 10, 500);\n\n// Retrieve and print the player's nickname\nConsole.WriteLine(player.Nickname); // Output: John\n\n// Retrieve and print the player's record\nConsole.WriteLine(player.Record); // Output: 50/20/10\n\n// Retrieve and print the player's score\nConsole.WriteLine(player.Score); // Output: 500\n```\n\nOverall, this code provides a way to represent and manage player data in the Brick-Force project, allowing for easy access to player attributes and information.\n## Questions: \n 1. What is the purpose of the CMPlayer class?\n- The CMPlayer class is used to represent a player in the Brick-Force game and store their XP, rank, nickname, kill count, assist count, death count, and score.\n\n2. What is the significance of the Xp, Rank, Nickname, Record, and Score properties?\n- The Xp, Rank, Nickname, Record, and Score properties provide read-only access to the corresponding private fields in the CMPlayer class.\n\n3. What does the Record property return?\n- The Record property returns a string representation of the player's kill count, assist count, and death count in the format \"kill/assist/death\".","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\CMPlayer.md"}}],["139",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\CMR.cs)\n\nThe code provided is a class called `CMR` that represents a Clan Match Result in the Brick-Force project. This class is responsible for storing and providing information about a specific clan match.\n\nThe class has several private fields that store various information about the clan match, such as the match ID (`clanMatch`), the map ID (`map`), the type of match (`kind`), the number of players in the match (`playerCount`), the enemy mark (`enemyMark`), the name of the enemy clan (`enemy`), the kill count (`killCount`), the death count (`deathCount`), the result of the match (`result`), the score of the match (`score`), the goal of the match (`goal`), and the date of the match (`year`, `month`, `date`).\n\nThe class also has two lists of `CMPlayer` objects, `ourPlayers` and `enemyPlayers`, which store information about the players in the match. The `CMPlayer` class is not provided in the code snippet, but it can be assumed that it represents a player in the clan match and stores information such as experience points, rank, nickname, kill count, assist count, death count, and score.\n\nThe class provides several getter methods for accessing the stored information, such as `GetKindString()` which returns a string representation of the match type and player count, `GetResultString()` which returns a string representation of the match result and kill/death count, `GetMiniResultString()` which returns a string representation of the kill/death count, and `GetDateString()` which returns a string representation of the match date.\n\nThe class also provides a method `AddPlayer()` for adding a player to either the `ourPlayers` or `enemyPlayers` list based on their clan. This method takes in various parameters representing the player's information and creates a new `CMPlayer` object to store that information.\n\nAdditionally, the class provides two methods `GetOurPlayersArray()` and `GetEnemyPlayersArray()` which return arrays of `CMPlayer` objects representing the players in the match. These methods convert the `ourPlayers` and `enemyPlayers` lists to arrays using the `ToArray()` method.\n\nOverall, this `CMR` class is a data structure that represents a clan match result and provides methods for accessing and manipulating the stored information. It can be used in the larger Brick-Force project to store and retrieve information about clan matches, such as the match details, player information, and match results.\n## Questions: \n 1. What is the purpose of the `CMR` class?\n- The `CMR` class represents a clan match result and provides methods to retrieve information about the match and its players.\n\n2. What is the significance of the `PlayerList` property?\n- The `PlayerList` property is a boolean value that indicates whether the list of players has been populated. It can be used to check if the player list needs to be retrieved or not.\n\n3. How are players added to the `ourPlayers` and `enemyPlayers` lists?\n- Players are added to the `ourPlayers` and `enemyPlayers` lists using the `AddPlayer` method, which takes in various player attributes such as clan, xp, rank, nickname, kill, assist, death, and score.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\CMR.md"}}],["140",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\CodeStage.AntiCheat.Detectors\\InjectionDetector.cs)\n\nThe code provided is a part of the Brick-Force project and is responsible for detecting code injection in the game. The InjectionDetector class is a MonoBehaviour that can be attached to a GameObject in the Unity scene. \n\nThe purpose of this code is to monitor the game for any unauthorized code injection attempts. It does this by checking the assemblies that are currently loaded in the game and comparing them to a list of allowed assemblies. If an assembly is found that is not in the allowed list, it triggers the onInjectionDetected callback and takes appropriate action.\n\nThe code starts by defining a private class called AllowedAssembly, which represents an assembly that is allowed to be loaded in the game. It has two properties: name, which is the name of the assembly, and hashes, which is an array of integer hashes representing the assembly.\n\nThe InjectionDetector class has several public properties and methods that can be used to control its behavior. The autoDispose property determines whether the InjectionDetector GameObject should be automatically destroyed when an injection is detected. The keepAlive property determines whether the InjectionDetector should be kept alive when a new level is loaded. The onInjectionDetected property is a callback that is triggered when an injection is detected.\n\nThe code also defines a static instance of the InjectionDetector class, which can be accessed through the Instance property. This ensures that there is only one instance of the InjectionDetector in the game.\n\nThe code provides methods for starting and stopping the detection process. The StartDetection method starts the detection process by checking the currently loaded assemblies and comparing them to the allowed assemblies. If an unauthorized assembly is found, it triggers the onInjectionDetected callback. The StopMonitoring method stops the detection process by removing the event handler for new assembly loads.\n\nThe code also includes several private methods that are used internally. The Awake method checks if there is already an instance of the InjectionDetector and destroys itself if there is. It also checks if the InjectionDetector is placed correctly in the scene. The OnLevelWasLoaded method is called when a new level is loaded and disposes of the InjectionDetector if the keepAlive property is set to false. The OnDisable method stops the detection process when the InjectionDetector is disabled. The OnApplicationQuit method disposes of the InjectionDetector when the application is quit.\n\nThe LoadAndParseAllowedAssemblies method is responsible for loading and parsing the allowed assemblies from a text asset. It reads the text asset as a binary stream and decrypts the values using the ObscuredString.EncryptDecrypt method. It then splits the values into an array and creates an AllowedAssembly object for each value. The GetAssemblyHash method calculates a hash value for an assembly based on its name and public key token. The PublicKeyTokenToString method converts a byte array representing the public key token to a string.\n\nIn summary, the InjectionDetector class is a component that can be attached to a GameObject in the Unity scene to detect code injection attempts in the game. It monitors the currently loaded assemblies and compares them to a list of allowed assemblies. If an unauthorized assembly is found, it triggers a callback and takes appropriate action.\n## Questions: \n 1. What is the purpose of the `InjectionDetector` class?\n- The `InjectionDetector` class is used to detect injection of unauthorized assemblies into the project.\n\n2. How does the `InjectionDetector` class determine if an assembly is allowed or not?\n- The `InjectionDetector` class checks the name and hash of the loaded assembly against a list of allowed assemblies and their corresponding hashes.\n\n3. What happens when an injection is detected?\n- When an injection is detected, the `InjectionDetected` method is called, which triggers the `onInjectionDetected` callback if it is not null. If `autoDispose` is true, the `Dispose` method is called to destroy the `InjectionDetector` instance. Otherwise, the `StopMonitoringInternal` method is called to stop the detection process.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\CodeStage.AntiCheat.Detectors\\InjectionDetector.md"}}],["141",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\CodeStage.AntiCheat.Detectors\\SpeedHackDetector.cs)\n\nThe code provided is a part of the Brick-Force project and is a script for detecting speed hacks in the game. The purpose of this code is to monitor the player's movement speed and detect if they are using any speed hacks or cheats.\n\nThe `SpeedHackDetector` class is a MonoBehaviour script that is attached to a game object in the scene. It contains various properties and methods for detecting speed hacks.\n\nThe `Instance` property is a singleton instance of the `SpeedHackDetector` class. It ensures that only one instance of the detector exists in the scene. If an instance does not exist, it creates a new game object with the `SpeedHackDetector` component attached.\n\nThe `Dispose` method is used to dispose of the `SpeedHackDetector` instance. It stops the monitoring process, destroys the game object, and sets the instance to null.\n\nThe `Awake` method is called when the script is initialized. It checks if the `SpeedHackDetector` is placed correctly in the scene. If not, it displays a warning message and destroys the script.\n\nThe `OnLevelWasLoaded` method is called when a new level is loaded. If the `keepAlive` property is set to false, it disposes of the `SpeedHackDetector` instance.\n\nThe `OnDisable` method is called when the script is disabled. It stops the monitoring process.\n\nThe `OnApplicationQuit` method is called when the application is about to quit. It disposes of the `SpeedHackDetector` instance.\n\nThe `StartDetection` method is used to start the speed hack detection process. It takes a callback function, a check interval, and the maximum number of false positives as parameters. It sets the callback function, check interval, and maximum false positives properties of the `SpeedHackDetector` instance. It also sets the start time and starts a repeating timer that calls the `OnTimer` method.\n\nThe `StopMonitoring` method is used to stop the speed hack detection process. It cancels the repeating timer and sets the callback function to null.\n\nThe `OnTimer` method is called by the repeating timer. It calculates the current time and checks if the player's movement speed exceeds a threshold value. If it does, it increments the error count and displays a warning message. If the error count exceeds the maximum false positives, it calls the callback function and disposes of the `SpeedHackDetector` instance.\n\nOverall, this code provides a way to detect speed hacks in the game and take appropriate actions when a speed hack is detected. It can be used as a part of a larger anti-cheat system in the Brick-Force project to ensure fair gameplay.\n## Questions: \n 1. What does this code do?\n   - This code is a Speed Hack Detector component in the Brick-Force project that detects if a player is using a speed hack cheat in the game.\n\n2. How does the Speed Hack Detector work?\n   - The Speed Hack Detector calculates the difference between the current time and the time when the game started, and compares it to the difference between the current system tick count and the tick count when the game started. If the difference exceeds a threshold of 5000000, it considers it a speed hack detection.\n\n3. How can the Speed Hack Detector be used in the project?\n   - The Speed Hack Detector can be used by calling the `StartDetection` method with a callback function to be executed when a speed hack is detected. The detection interval and maximum allowed false positives can also be specified. The detector can be stopped using the `StopMonitoring` method.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\CodeStage.AntiCheat.Detectors\\SpeedHackDetector.md"}}],["142",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/.autodoc\\docs\\json\\Assembly-CSharp\\CodeStage.AntiCheat.Detectors)\n\nThe `InjectionDetector.cs` and `SpeedHackDetector.cs` files are part of the anti-cheat system in the Brick-Force project. They are designed to detect and respond to unauthorized code injections and speed hacks respectively.\n\n`InjectionDetector.cs` is a MonoBehaviour script that can be attached to a GameObject in the Unity scene. It monitors the game for unauthorized code injection attempts by comparing the currently loaded assemblies to a list of allowed assemblies. If an unauthorized assembly is found, it triggers the `onInjectionDetected` callback and takes appropriate action. This class also provides methods for starting and stopping the detection process. For example, to start the detection process, you would call `InjectionDetector.Instance.StartDetection()`.\n\n`SpeedHackDetector.cs` is another MonoBehaviour script that can be attached to a GameObject in the Unity scene. It monitors the player's movement speed and detects if they are using any speed hacks or cheats. If a speed hack is detected, it triggers a callback function and disposes of the `SpeedHackDetector` instance. To start the speed hack detection process, you would call `SpeedHackDetector.Instance.StartDetection(callback, checkInterval, maxFalsePositives)`.\n\nThese scripts can be used in conjunction with other parts of the anti-cheat system to ensure fair gameplay. For example, they could be used alongside a wall hack detector or an aimbot detector. They could also be used in combination with a system that bans or penalizes players who are detected using cheats. \n\nHere is an example of how you might use these scripts in your game:\n\n```csharp\n// Attach the InjectionDetector and SpeedHackDetector to a GameObject\nInjectionDetector injectionDetector = gameObject.AddComponent<InjectionDetector>();\nSpeedHackDetector speedHackDetector = gameObject.AddComponent<SpeedHackDetector>();\n\n// Start the detection processes\ninjectionDetector.StartDetection();\nspeedHackDetector.StartDetection(OnSpeedHackDetected, 1.0f, 3);\n\n// Define the callback function for when a speed hack is detected\nvoid OnSpeedHackDetected()\n{\n    // Take appropriate action, such as banning the player or displaying a warning message\n}\n```\n\nIn summary, `InjectionDetector.cs` and `SpeedHackDetector.cs` are key components of the anti-cheat system in the Brick-Force project. They provide a way to detect and respond to code injections and speed hacks, helping to ensure fair gameplay.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\CodeStage.AntiCheat.Detectors\\summary.md"}}],["143",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\CodeStage.AntiCheat.ObscuredTypes\\ObscuredBool.cs)\n\nThe code provided is a part of the Brick-Force project and it defines a struct called `ObscuredBool` in the `CodeStage.AntiCheat.ObscuredTypes` namespace. This struct is used to store and manipulate boolean values in an obscured manner, making it harder for cheaters to modify the values.\n\nThe `ObscuredBool` struct has several private fields:\n- `cryptoKey`: a static byte variable that holds the encryption key used to encrypt and decrypt the boolean values.\n- `currentCryptoKey`: a byte variable that holds the current encryption key used for the struct instance.\n- `hiddenValue`: an integer variable that holds the encrypted value of the boolean.\n- `fakeValue`: a nullable boolean variable that holds the original value of the boolean if cheating is detected.\n- `inited`: a boolean variable that indicates whether the struct instance has been initialized.\n\nThe struct also has a static `Action` delegate called `onCheatingDetected`, which can be assigned a method to be called when cheating is detected.\n\nThe struct provides several methods and operators to manipulate the boolean values:\n- `SetNewCryptoKey(byte newKey)`: a static method that allows changing the encryption key.\n- `GetEncrypted()`: a method that returns the encrypted value of the boolean.\n- `SetEncrypted(int encrypted)`: a method that sets the encrypted value of the boolean.\n- `Encrypt(bool value)`: a static method that encrypts a boolean value using the current encryption key.\n- `Decrypt(int value)`: a static method that decrypts an encrypted value using the current encryption key.\n- `InternalDecrypt()`: a private method that decrypts the encrypted value and checks for cheating.\n- `Equals(object obj)`: an overridden method that compares the hidden values of two `ObscuredBool` instances.\n- `Equals(ObscuredBool obj)`: a method that compares the hidden values of two `ObscuredBool` instances.\n- `GetHashCode()`: an overridden method that returns the hash code of the decrypted value.\n- `ToString()`: an overridden method that returns the string representation of the decrypted value.\n- `implicit operator ObscuredBool(bool value)`: an implicit conversion operator that creates a new `ObscuredBool` instance from a boolean value.\n- `implicit operator bool(ObscuredBool value)`: an implicit conversion operator that returns the decrypted value of an `ObscuredBool` instance.\n\nThe purpose of this code is to provide a way to store and manipulate boolean values in an obscured manner, making it harder for cheaters to modify the values. The encryption and decryption methods ensure that the boolean values are not easily readable or modifiable by external sources. The `onCheatingDetected` delegate allows for custom actions to be taken when cheating is detected, such as logging or banning the cheater.\n\nHere is an example of how this code can be used in the larger project:\n\n```csharp\nObscuredBool isCheating = true; // Create a new ObscuredBool instance and set it to true\n\n// Change the encryption key\nObscuredBool.SetNewCryptoKey(123);\n\n// Get the encrypted value\nint encryptedValue = isCheating.GetEncrypted();\n\n// Set the encrypted value\nisCheating.SetEncrypted(encryptedValue);\n\n// Check if the value is true\nif (isCheating)\n{\n    // Do something if the value is true\n}\n```\n\nOverall, this code provides a way to store and manipulate boolean values in an obscured manner, enhancing the security of the Brick-Force project and making it more difficult for cheaters to modify the values.\n## Questions: \n 1. What is the purpose of the `ObscuredBool` struct?\n- The `ObscuredBool` struct is used to store and manipulate boolean values in an encrypted form.\n\n2. How does the encryption and decryption process work for `ObscuredBool`?\n- The encryption process involves XORing the boolean value with a crypto key, while the decryption process involves XORing the encrypted value with the same crypto key.\n\n3. What is the purpose of the `onCheatingDetected` action?\n- The `onCheatingDetected` action is a callback that is triggered when a cheating attempt is detected.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\CodeStage.AntiCheat.ObscuredTypes\\ObscuredBool.md"}}],["144",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\CodeStage.AntiCheat.ObscuredTypes\\ObscuredByte.cs)\n\nThe code provided is a part of the Brick-Force project and is used to implement an obscured byte data type. The purpose of this code is to provide a way to store and manipulate byte values in a way that obscures the actual value from being easily readable or modified by external sources.\n\nThe `ObscuredByte` struct is defined with several private fields: `currentCryptoKey`, `hiddenValue`, `fakeValue`, and `inited`. These fields are used to store the encrypted byte value, a fake value for cheating detection, and the current encryption key.\n\nThe `ObscuredByte` struct also includes a static `onCheatingDetected` action and a static `cryptoKey` byte. The `onCheatingDetected` action is used to handle any actions that need to be taken when cheating is detected, and the `cryptoKey` is used for encrypting and decrypting the byte value.\n\nThe struct includes several methods for encrypting, decrypting, and manipulating the byte value. The `GetEncrypted` method is used to retrieve the encrypted byte value, and the `SetEncrypted` method is used to set the encrypted byte value. The `EncryptDecrypt` methods are used for encrypting and decrypting the byte value using the `cryptoKey`.\n\nThe `InternalDecrypt` method is used to decrypt the byte value and handle cheating detection. If cheating is detected, the `onCheatingDetected` action is invoked. The struct also includes methods for comparing, converting, and hashing the byte value.\n\nThe struct includes implicit conversion operators to convert between `ObscuredByte` and `byte` types. It also includes overloaded operators for incrementing and decrementing the byte value.\n\nOverall, this code provides a way to store and manipulate byte values in an obscured manner, making it more difficult for external sources to read or modify the actual value. This can be useful in situations where data security is important, such as in game development or other applications where cheating prevention is necessary.\n## Questions: \n 1. What is the purpose of the `ObscuredByte` struct?\n- The `ObscuredByte` struct is used to store and manipulate byte values in an encrypted and obscured manner.\n\n2. How does the encryption and decryption process work?\n- The encryption and decryption process is done using the `EncryptDecrypt` method, which performs a bitwise XOR operation on the value with a crypto key.\n\n3. What is the purpose of the `onCheatingDetected` action?\n- The `onCheatingDetected` action is used to handle any actions that need to be taken when cheating is detected, such as logging or reporting the cheating incident.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\CodeStage.AntiCheat.ObscuredTypes\\ObscuredByte.md"}}],["145",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\CodeStage.AntiCheat.ObscuredTypes\\ObscuredChar.cs)\n\nThe code provided is a part of the Brick-Force project and it defines a struct called `ObscuredChar` in the `CodeStage.AntiCheat.ObscuredTypes` namespace. This struct is used to store and manipulate encrypted characters.\n\nThe `ObscuredChar` struct has several private fields: `cryptoKey`, `currentCryptoKey`, `hiddenValue`, `fakeValue`, and `inited`. \n\nThe `cryptoKey` field is a static char that is used as the encryption key for all instances of `ObscuredChar`. The `currentCryptoKey` field stores the current encryption key for a specific instance of `ObscuredChar`. The `hiddenValue` field stores the encrypted value of the character. The `fakeValue` field is used to store the decrypted value of the character if cheating is detected. The `inited` field is a boolean flag that indicates whether the struct has been initialized.\n\nThe struct also has a static `onCheatingDetected` action, which can be set to a callback function that will be called if cheating is detected.\n\nThe struct provides several methods and operators for manipulating the encrypted character:\n\n- `SetNewCryptoKey(char newKey)`: This method is used to set a new encryption key for all instances of `ObscuredChar`.\n\n- `GetEncrypted()`: This method returns the encrypted value of the character. If the current encryption key is different from the global encryption key, the hidden value is decrypted, re-encrypted with the new key, and then returned.\n\n- `SetEncrypted(char encrypted)`: This method sets the encrypted value of the character. If cheating is detected (i.e., `onCheatingDetected` is not null), the fake value is set to the decrypted value of the character.\n\n- `EncryptDecrypt(char value)`: This static method is used to encrypt or decrypt a character using the global encryption key.\n\n- `EncryptDecrypt(char value, char key)`: This static method is used to encrypt or decrypt a character using a specific encryption key.\n\n- `InternalDecrypt()`: This private method is used to decrypt the hidden value of the character. If the struct has not been initialized, it initializes the fields and decrypts the hidden value. If the current encryption key is different from the global encryption key, the hidden value is decrypted using the current key. If cheating is detected, the `onCheatingDetected` callback is called.\n\nThe struct also overrides several methods and operators:\n\n- `Equals(object obj)`: This method checks if the hidden value of the current instance is equal to the hidden value of another `ObscuredChar` instance.\n\n- `Equals(ObscuredChar obj)`: This method is the strongly-typed version of `Equals(object obj)`.\n\n- `ToString()`: This method returns the decrypted value of the character as a string.\n\n- `GetHashCode()`: This method returns the hash code of the decrypted value of the character.\n\n- `implicit operator ObscuredChar(char value)`: This operator allows implicit conversion from a char to an `ObscuredChar`. The char value is encrypted and a new `ObscuredChar` instance is created.\n\n- `implicit operator char(ObscuredChar value)`: This operator allows implicit conversion from an `ObscuredChar` to a char. The hidden value of the `ObscuredChar` instance is decrypted and returned.\n\n- `operator ++(ObscuredChar input)`: This operator is used to increment the hidden value of an `ObscuredChar` instance. The hidden value is decrypted, incremented by 1, and then re-encrypted.\n\n- `operator --(ObscuredChar input)`: This operator is used to decrement the hidden value of an `ObscuredChar` instance. The hidden value is decrypted, decremented by 1, and then re-encrypted.\n\nOverall, this code provides a way to store and manipulate encrypted characters in the Brick-Force project. It allows for secure storage and manipulation of characters, with the ability to detect cheating if the decrypted value is modified.\n## Questions: \n 1. What is the purpose of the `ObscuredChar` struct?\n- The `ObscuredChar` struct is used to store and manipulate encrypted characters.\n\n2. How does the encryption and decryption process work?\n- The encryption and decryption process is done using the `EncryptDecrypt` method, which XORs the character value with a crypto key.\n\n3. What is the purpose of the `onCheatingDetected` action?\n- The `onCheatingDetected` action is used to handle a cheating detection event, which is triggered when the encrypted value is modified without proper authorization.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\CodeStage.AntiCheat.ObscuredTypes\\ObscuredChar.md"}}],["146",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\CodeStage.AntiCheat.ObscuredTypes\\ObscuredDecimal.cs)\n\nThe code provided is a part of the Brick-Force project and it defines a struct called `ObscuredDecimal` in the `CodeStage.AntiCheat.ObscuredTypes` namespace. This struct is used to store and manipulate decimal values in an obscured manner, making it difficult for cheaters to modify the values.\n\nThe `ObscuredDecimal` struct contains several private fields, including `currentCryptoKey`, `hiddenValue`, `fakeValue`, and `inited`. These fields are used to store the encrypted decimal value, the current encryption key, a fake value for cheating detection, and a flag indicating whether the struct has been initialized.\n\nThe struct also contains a `DecimalLongBytesUnion` struct, which is used to convert between decimal values and their byte representation. This is done using the `FieldOffset` attribute to specify the memory layout of the struct.\n\nThe struct provides several methods for encrypting and decrypting decimal values. The `Encrypt` method takes a decimal value and encrypts it using the current encryption key. The `Decrypt` method takes an encrypted decimal value and decrypts it using the current encryption key. These methods use the `DecimalLongBytesUnion` struct to perform the encryption and decryption operations.\n\nThe `GetEncrypted` method returns the encrypted value stored in the `hiddenValue` field. If the current encryption key is different from the stored encryption key, the method first decrypts the value and then re-encrypts it using the current encryption key.\n\nThe `SetEncrypted` method takes an encrypted decimal value and stores it in the `hiddenValue` field. It also checks for cheating by comparing the decrypted value with the stored fake value.\n\nThe struct also provides methods for converting the obscured decimal value to a string representation using the `ToString` method. It also overrides the `Equals`, `GetHashCode`, and comparison operators to provide proper comparison and equality checks for obscured decimal values.\n\nOverall, this code provides a way to store and manipulate decimal values in an obscured manner, making it difficult for cheaters to modify the values. It uses encryption and decryption techniques to protect the values and includes cheating detection mechanisms to detect any attempts to modify the values.\n## Questions: \n 1. What is the purpose of the ObscuredDecimal struct?\n- The ObscuredDecimal struct is used to store and manipulate decimal values in an encrypted and obscured form.\n\n2. How does the encryption and decryption process work for the ObscuredDecimal struct?\n- The encryption process involves XORing the decimal value with a crypto key, and then converting the encrypted value into a byte array. The decryption process involves reversing the encryption steps and returning the decrypted decimal value.\n\n3. What is the significance of the onCheatingDetected action?\n- The onCheatingDetected action is a callback function that is triggered when cheating is detected. It is used to handle any actions or behaviors that should occur when cheating is detected in relation to the ObscuredDecimal struct.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\CodeStage.AntiCheat.ObscuredTypes\\ObscuredDecimal.md"}}],["147",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\CodeStage.AntiCheat.ObscuredTypes\\ObscuredDouble.cs)\n\nThe code provided is a part of the Brick-Force project and it defines a struct called `ObscuredDouble` in the `CodeStage.AntiCheat.ObscuredTypes` namespace. This struct is used to store and manipulate double values in an obscured manner, making it difficult for cheaters to modify the values.\n\nThe `ObscuredDouble` struct implements the `IEquatable<ObscuredDouble>` interface, which allows for comparison of two `ObscuredDouble` instances.\n\nThe struct contains several private fields:\n- `cryptoKey`: a static long variable that represents the encryption key used to encrypt and decrypt the double values.\n- `currentCryptoKey`: a long variable that represents the current encryption key used for the instance.\n- `hiddenValue`: a byte array that stores the encrypted value of the double.\n- `fakeValue`: a double variable that stores the decrypted value of the double, used for cheating detection.\n- `inited`: a boolean variable that indicates whether the struct has been initialized.\n\nThe struct also contains a static `Action` delegate called `onCheatingDetected`, which can be used to handle cheating detection events.\n\nThe struct provides several methods and operators for encrypting, decrypting, and manipulating the double values:\n- `SetNewCryptoKey`: a static method that allows setting a new encryption key.\n- `GetEncrypted`: a method that returns the encrypted value of the double.\n- `SetEncrypted`: a method that sets the encrypted value of the double.\n- `Encrypt`: a static method that encrypts a double value using the current encryption key.\n- `Decrypt`: a static method that decrypts an encrypted value using the current encryption key.\n- `InternalEncrypt`: a private method that encrypts a double value using a specified encryption key.\n- `InternalDecrypt`: a private method that decrypts the encrypted value using the current encryption key.\n- `ToString`: overrides the `ToString` method to return the decrypted value as a string.\n- `Equals`: overrides the `Equals` method to compare two `ObscuredDouble` instances.\n- `GetHashCode`: overrides the `GetHashCode` method to return the hash code of the decrypted value.\n- `implicit operator`: provides implicit conversion between `ObscuredDouble` and double types.\n- `++` and `--` operators: increment and decrement the decrypted value by 1.\n\nOverall, this code provides a way to store and manipulate double values in an obscured manner, making it difficult for cheaters to modify the values. It also includes cheating detection functionality through the `onCheatingDetected` delegate. This struct can be used in the larger Brick-Force project to protect sensitive double values from cheating attempts.\n## Questions: \n 1. What is the purpose of the ObscuredDouble struct?\n- The ObscuredDouble struct is used to store and manipulate double values in an encrypted and obscured form.\n\n2. How does the encryption and decryption process work?\n- The encryption process involves XORing the double value with a crypto key, and then converting the resulting value into a byte array. The decryption process involves XORing the byte array with the crypto key and converting it back into a double value.\n\n3. What is the purpose of the onCheatingDetected action?\n- The onCheatingDetected action is triggered when a potential cheating attempt is detected. It is used to handle any actions or behaviors that should occur when cheating is detected.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\CodeStage.AntiCheat.ObscuredTypes\\ObscuredDouble.md"}}],["148",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\CodeStage.AntiCheat.ObscuredTypes\\ObscuredFloat.cs)\n\nThe code provided is a part of the Brick-Force project and it defines a struct called `ObscuredFloat`. This struct is used to store and manipulate floating-point numbers in an encrypted and obscured manner. \n\nThe `ObscuredFloat` struct implements the `IEquatable` interface, which allows for comparison of two `ObscuredFloat` instances. It also overrides several methods such as `Equals`, `GetHashCode`, and `ToString` to provide custom behavior when working with `ObscuredFloat` objects.\n\nThe struct contains several private fields, including `currentCryptoKey`, `hiddenValue`, `fakeValue`, and `inited`. These fields are used to store the encrypted value, the current encryption key, a fake value for cheating detection, and a flag indicating whether the struct has been initialized.\n\nThe struct also contains a static field called `onCheatingDetected`, which is an `Action` delegate. This delegate can be assigned a method that will be called when cheating is detected. \n\nThe struct provides several methods for encrypting and decrypting floating-point values. The `Encrypt` method takes a float value and an optional encryption key, and returns an encrypted integer representation of the value. The `Decrypt` method takes an encrypted integer value and an optional encryption key, and returns the decrypted float value.\n\nThe struct also provides methods for setting and getting the encrypted value. The `SetEncrypted` method takes an encrypted integer value and sets the hiddenValue field accordingly. The `GetEncrypted` method retrieves the encrypted integer value from the hiddenValue field.\n\nThe struct also provides overloaded operators for incrementing and decrementing `ObscuredFloat` values. These operators increment or decrement the decrypted value and update the hiddenValue field accordingly.\n\nOverall, the `ObscuredFloat` struct provides a way to store and manipulate floating-point numbers in an encrypted and obscured manner, which can be useful for protecting sensitive data in the Brick-Force project.\n## Questions: \n 1. What is the purpose of the ObscuredFloat struct and how does it work?\n- The ObscuredFloat struct is used to store and manipulate floating-point numbers in an encrypted form. It uses a union of different data types to store the encrypted value and provides methods for encryption and decryption.\n\n2. How does the encryption and decryption process work for the ObscuredFloat struct?\n- The encryption process involves XORing the float value with a crypto key and storing the result as a byte array. The decryption process involves XORing the encrypted value with the crypto key and converting it back to a float.\n\n3. What is the purpose of the onCheatingDetected action and how is it used?\n- The onCheatingDetected action is a callback that is triggered when cheating is detected. It is used to perform actions or raise events when the encrypted value is modified in an unauthorized way.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\CodeStage.AntiCheat.ObscuredTypes\\ObscuredFloat.md"}}],["149",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\CodeStage.AntiCheat.ObscuredTypes\\ObscuredInt.cs)\n\nThe code provided is a struct called `ObscuredInt` that is used to store and manipulate integer values in an encrypted and obscured manner. It is part of the `CodeStage.AntiCheat.ObscuredTypes` namespace.\n\nThe purpose of this code is to provide a way to store sensitive integer values in a way that makes it difficult for users to cheat or manipulate the values. It achieves this by encrypting the values using a crypto key and storing the encrypted value in the `hiddenValue` field. The original value is stored in the `fakeValue` field, which can be used to detect cheating attempts.\n\nThe `ObscuredInt` struct has several methods and properties that allow for encryption, decryption, and manipulation of the stored value. Some of the key methods and properties include:\n\n- `GetEncrypted()`: This method returns the encrypted value of the `hiddenValue` field. If the crypto key has changed since the last encryption, it decrypts the value, re-encrypts it with the new key, and updates the `hiddenValue` field.\n\n- `SetEncrypted(int encrypted)`: This method sets the `hiddenValue` field to the provided encrypted value. If cheating is detected (i.e., the `onCheatingDetected` action is not null), it sets the `fakeValue` field to the decrypted value.\n\n- `Encrypt(int value)`: This method encrypts the provided value using the current crypto key and returns the encrypted value.\n\n- `Decrypt(int value)`: This method decrypts the provided value using the current crypto key and returns the decrypted value.\n\n- `InternalDecrypt()`: This private method is used internally to decrypt the `hiddenValue` field. If the struct has not been initialized, it initializes it by encrypting a value of 0. It then decrypts the `hiddenValue` field using the current or stored crypto key. If cheating is detected, it calls the `onCheatingDetected` action.\n\n- `ToString()`: This method overrides the default `ToString()` method and returns the decrypted value as a string.\n\n- `operator ++` and `operator --`: These operators allow for incrementing and decrementing the stored value. They decrypt the value, perform the operation, re-encrypt it, and update the `hiddenValue` field.\n\nOverall, this code provides a way to store and manipulate integer values in an obscured and encrypted manner, making it difficult for users to cheat or manipulate the values. It can be used in the larger project to protect sensitive integer data and ensure the integrity of the game.\n## Questions: \n 1. What is the purpose of the `ObscuredInt` struct?\n- The `ObscuredInt` struct is used to store and manipulate encrypted integer values.\n\n2. How does the encryption and decryption process work?\n- The encryption process is done using the XOR operation with a crypto key. The decryption process is the same, using the same crypto key.\n\n3. What is the purpose of the `fakeValue` field?\n- The `fakeValue` field is used to store the decrypted value of the `hiddenValue` field when cheating is detected.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\CodeStage.AntiCheat.ObscuredTypes\\ObscuredInt.md"}}],["150",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\CodeStage.AntiCheat.ObscuredTypes\\ObscuredLong.cs)\n\nThe code provided is a struct called `ObscuredLong` that is used to encrypt and decrypt long integer values. It is part of the `CodeStage.AntiCheat.ObscuredTypes` namespace.\n\nThe purpose of this code is to provide a way to store sensitive long integer values in an encrypted form, making it difficult for attackers to manipulate or cheat in the game. It achieves this by using a symmetric encryption algorithm, where the same key is used for both encryption and decryption.\n\nThe `ObscuredLong` struct has several private fields:\n- `cryptoKey` is a static long variable that holds the encryption key. By default, it is set to 444442L, but it can be changed using the `SetNewCryptoKey` method.\n- `currentCryptoKey` is a long variable that holds the current encryption key for the instance of `ObscuredLong`.\n- `hiddenValue` is a long variable that holds the encrypted value.\n- `fakeValue` is a long variable that holds the decrypted value, used for cheating detection.\n- `inited` is a boolean variable that indicates whether the instance has been initialized.\n\nThe struct provides methods for encryption and decryption:\n- `Encrypt` and `Decrypt` methods are used to encrypt and decrypt a long value using the current encryption key.\n- `GetEncrypted` method returns the encrypted value of the instance. If the current encryption key is different from the global encryption key, it decrypts the value, re-encrypts it with the global encryption key, and updates the current encryption key.\n- `SetEncrypted` method sets the encrypted value of the instance. If cheating is detected (the `onCheatingDetected` action is not null), it also sets the fake value to the decrypted value.\n- `InternalDecrypt` method is used internally to decrypt the hidden value. If the instance has not been initialized, it initializes it with the global encryption key and encrypts a default value. It then decrypts the hidden value using the current encryption key and checks for cheating by comparing the decrypted value with the fake value.\n\nThe struct also overrides several methods:\n- `Equals` methods are used to compare two instances of `ObscuredLong` for equality based on their hidden values.\n- `GetHashCode` method returns the hash code of the decrypted value.\n- `ToString` methods return the string representation of the decrypted value.\n\nThe struct also provides implicit conversion operators to convert between `ObscuredLong` and `long` types. It also provides overloaded increment and decrement operators to increment or decrement the hidden value.\n\nOverall, this code provides a way to store and manipulate sensitive long integer values in an encrypted form, making it difficult for attackers to manipulate or cheat in the game. It also includes cheating detection by comparing the decrypted value with the fake value.\n## Questions: \n 1. What is the purpose of the `ObscuredLong` struct?\n- The `ObscuredLong` struct is used to store and manipulate encrypted long values.\n\n2. How does the encryption and decryption process work?\n- The encryption process is done using the XOR operation with a crypto key. The decryption process is the same as the encryption process.\n\n3. What is the purpose of the `onCheatingDetected` action and how is it used?\n- The `onCheatingDetected` action is used to detect cheating in the code. It is triggered when the decrypted value does not match the fake value, indicating that the value has been tampered with.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\CodeStage.AntiCheat.ObscuredTypes\\ObscuredLong.md"}}],["151",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\CodeStage.AntiCheat.ObscuredTypes\\ObscuredQuaternion.cs)\n\nThe code provided is a part of the Brick-Force project and is used to implement an obscured version of the Quaternion data type in Unity. \n\nThe ObscuredQuaternion struct is defined with several private fields and methods. It has a hiddenValue field of type Quaternion, which stores the actual value of the quaternion. It also has a fakeValue field of type Quaternion, which is used to store a fake value in case cheating is detected. The inited field is a boolean flag that indicates whether the struct has been initialized or not. \n\nThe struct has a constructor that takes a Quaternion value and initializes the hiddenValue field with the provided value. It also sets the currentCryptoKey to the default cryptoKey value and sets the fakeValue to Quaternion.identity. \n\nThe struct has several public methods. The SetNewCryptoKey method allows the user to set a new cryptoKey value. The GetEncrypted method returns the encrypted value of the hiddenValue field. If the currentCryptoKey is different from the cryptoKey, it decrypts the hiddenValue and encrypts it again with the new cryptoKey. The SetEncrypted method sets the hiddenValue field to the provided encrypted value. If cheating is detected (onCheatingDetected is not null), it sets the fakeValue field to the decrypted hiddenValue. \n\nThe struct also has static methods for encrypting and decrypting Quaternion values. The Encrypt method takes a Quaternion value and encrypts each component using the ObscuredDouble.Encrypt method. The Decrypt method does the opposite, decrypting each component of the Quaternion value. \n\nThe InternalDecrypt method is a private method that decrypts the hiddenValue field. If the struct has not been initialized, it initializes it with default values. It then decrypts each component of the hiddenValue using the ObscuredDouble.Decrypt method. If cheating is detected and the fakeValue is not Quaternion.identity and the decrypted value is not equal to the fakeValue, it calls the onCheatingDetected method and sets it to null. \n\nThe struct also overrides the GetHashCode, ToString, and ToString(string format) methods to provide the decrypted value of the hiddenValue field. \n\nThe struct provides implicit conversion operators to convert between ObscuredQuaternion and Quaternion types. The implicit operator from Quaternion to ObscuredQuaternion encrypts the provided Quaternion value and sets the fakeValue field if cheating is detected. The implicit operator from ObscuredQuaternion to Quaternion decrypts the hiddenValue field and returns the decrypted value. \n\nOverall, this code provides a way to store and manipulate Quaternion values in an obscured manner to prevent cheating in the Brick-Force project.\n## Questions: \n 1. What is the purpose of the `ObscuredQuaternion` struct?\n- The `ObscuredQuaternion` struct is used to store and manipulate quaternion values in an encrypted form.\n\n2. How does the encryption work for the `ObscuredQuaternion` struct?\n- The encryption for the `ObscuredQuaternion` struct is done using a crypto key. The `Encrypt` method encrypts the quaternion values using the crypto key, and the `Decrypt` method decrypts the encrypted values using the same crypto key.\n\n3. What is the purpose of the `fakeValue` field in the `ObscuredQuaternion` struct?\n- The `fakeValue` field is used to store the decrypted value of the quaternion if cheating is detected. It is compared with the decrypted value to check for cheating.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\CodeStage.AntiCheat.ObscuredTypes\\ObscuredQuaternion.md"}}],["152",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\CodeStage.AntiCheat.ObscuredTypes\\ObscuredSByte.cs)\n\nThe code provided is a part of the Brick-Force project and it defines a struct called `ObscuredSByte` in the `CodeStage.AntiCheat.ObscuredTypes` namespace. This struct is used to store and manipulate encrypted sbyte values.\n\nThe `ObscuredSByte` struct has several private fields:\n- `cryptoKey`: a static sbyte variable that represents the encryption key used to encrypt and decrypt the values.\n- `currentCryptoKey`: a sbyte variable that represents the current encryption key used for the instance of `ObscuredSByte`.\n- `hiddenValue`: a sbyte variable that stores the encrypted value.\n- `fakeValue`: a sbyte variable that stores the decrypted value for comparison in case of cheating detection.\n- `inited`: a boolean variable that indicates whether the struct has been initialized.\n\nThe struct also has a static `Action` delegate called `onCheatingDetected`, which can be used to handle cheating detection events.\n\nThe struct provides several methods and operators for encryption, decryption, and manipulation of the encrypted values:\n- `SetNewCryptoKey`: a static method that allows changing the encryption key.\n- `GetEncrypted`: a method that returns the decrypted value by decrypting the `hiddenValue` using the current encryption key.\n- `SetEncrypted`: a method that sets the `hiddenValue` to the provided encrypted value and updates the `fakeValue` if cheating is detected.\n- `EncryptDecrypt`: a static method that can be used to encrypt or decrypt a sbyte value using the specified encryption key.\n- `InternalDecrypt`: a private method that decrypts the `hiddenValue` using the current or default encryption key and handles cheating detection.\n\nThe struct also overrides several methods from the `Object` class:\n- `Equals`: overrides the `Equals` method to compare the `hiddenValue` of two `ObscuredSByte` instances.\n- `ToString`: overrides the `ToString` method to return the decrypted value as a string.\n- `GetHashCode`: overrides the `GetHashCode` method to return the hash code of the decrypted value.\n- `ToString(IFormatProvider)`: overrides the `ToString` method to return the decrypted value as a string using the specified format provider.\n- `ToString(string, IFormatProvider)`: overrides the `ToString` method to return the decrypted value as a string using the specified format and format provider.\n\nThe struct also provides implicit conversion operators to convert between `ObscuredSByte` and sbyte types.\n\nOverall, this code provides a way to store and manipulate encrypted sbyte values, with built-in cheating detection. It allows for secure storage and manipulation of sensitive data within the Brick-Force project.\n## Questions: \n 1. What is the purpose of the `ObscuredSByte` struct?\n- The `ObscuredSByte` struct is used to store and manipulate a signed byte value in an encrypted and obscured manner.\n\n2. How does the encryption and decryption process work?\n- The encryption and decryption process is done using the `EncryptDecrypt` method, which performs a bitwise XOR operation on the value with a crypto key. The key can be set using the `SetNewCryptoKey` method.\n\n3. What is the purpose of the `onCheatingDetected` action and how is it used?\n- The `onCheatingDetected` action is used to detect if the value has been tampered with. It is triggered when the `SetEncrypted` method is called and the decrypted value does not match the stored fake value.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\CodeStage.AntiCheat.ObscuredTypes\\ObscuredSByte.md"}}],["153",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\CodeStage.AntiCheat.ObscuredTypes\\ObscuredShort.cs)\n\nThe code provided is a part of the Brick-Force project and is used to implement an obscured short data type. The purpose of this code is to provide a way to store and manipulate short values in a way that obscures their true values, making it difficult for users to cheat or manipulate the data.\n\nThe `ObscuredShort` struct is defined with several private fields: `currentCryptoKey`, `hiddenValue`, `fakeValue`, and `inited`. These fields are used to store the encrypted value, a fake value for cheating detection, and the current encryption key.\n\nThe `ObscuredShort` struct also includes a static `cryptoKey` field, which is used as the default encryption key for all instances of `ObscuredShort`. The `cryptoKey` can be changed using the `SetNewCryptoKey` method.\n\nThe `ObscuredShort` struct provides methods to get and set the encrypted value. The `GetEncrypted` method decrypts the value if the current encryption key is different from the default `cryptoKey`, and then returns the decrypted value. The `SetEncrypted` method sets the encrypted value and checks for cheating by comparing the decrypted value with the fake value.\n\nThe struct also includes methods for encrypting and decrypting short values using the `cryptoKey`. The `EncryptDecrypt` methods perform a bitwise XOR operation between the value and the key to encrypt or decrypt the value.\n\nThe `ObscuredShort` struct overrides several methods from the `Object` class, such as `Equals`, `ToString`, and `GetHashCode`, to provide functionality for comparing, converting, and hashing obscured short values.\n\nAdditionally, the struct includes implicit conversion operators to convert between `ObscuredShort` and `short` types. This allows for seamless integration with existing code that uses `short` values.\n\nThe struct also includes overloaded operators for incrementing and decrementing `ObscuredShort` values. These operators decrypt the value, perform the increment or decrement operation, and then encrypt the new value.\n\nOverall, this code provides a way to store and manipulate short values in an obscured manner, making it difficult for users to cheat or manipulate the data. It can be used in the larger Brick-Force project to protect sensitive short values and ensure the integrity of the game.\n## Questions: \n 1. What is the purpose of the `ObscuredShort` struct?\n- The `ObscuredShort` struct is used to store and manipulate short values in an encrypted and obscured manner.\n\n2. How does the encryption and decryption process work?\n- The encryption and decryption process is done using the `EncryptDecrypt` method, which performs a bitwise XOR operation on the value with a crypto key.\n\n3. What is the purpose of the `onCheatingDetected` action?\n- The `onCheatingDetected` action is used to handle any actions that need to be taken when cheating is detected, such as logging or reporting the cheating activity.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\CodeStage.AntiCheat.ObscuredTypes\\ObscuredShort.md"}}],["154",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\CodeStage.AntiCheat.ObscuredTypes\\ObscuredString.cs)\n\nThe code provided is a class called `ObscuredString` that is part of the `CodeStage.AntiCheat.ObscuredTypes` namespace. This class is used to encrypt and decrypt strings using a specified crypto key. It provides methods to set and get the encrypted value, as well as methods to encrypt and decrypt strings.\n\nThe class has the following properties and fields:\n- `onCheatingDetected`: a static Action that can be assigned to a method to be called when cheating is detected.\n- `cryptoKey`: a static string that represents the default crypto key used for encryption and decryption.\n- `currentCryptoKey`: a string that represents the current crypto key used for encryption and decryption.\n- `hiddenValue`: a string that represents the encrypted value of the string.\n- `fakeValue`: a string that represents the decrypted value of the string, used for cheating detection.\n- `inited`: a boolean flag that indicates whether the class has been initialized.\n\nThe class has the following methods:\n- `SetNewCryptoKey(string newKey)`: a static method that sets a new crypto key to be used for encryption and decryption.\n- `GetEncrypted()`: a method that returns the encrypted value of the string.\n- `SetEncrypted(string encrypted)`: a method that sets the encrypted value of the string and checks for cheating by comparing the decrypted value with the fake value.\n- `EncryptDecrypt(string value)`: a static method that encrypts and decrypts a string using the default crypto key.\n- `EncryptDecrypt(string value, string key)`: a static method that encrypts and decrypts a string using a specified crypto key.\n- `InternalDecrypt()`: a private method that decrypts the hidden value using the current crypto key and checks for cheating by comparing the decrypted value with the fake value.\n- `ToString()`: an overridden method that returns the decrypted value of the string.\n- `Equals(object obj)`: an overridden method that compares the hidden value of the string with another obscured string.\n- `Equals(ObscuredString value)`: a method that compares the hidden value of the string with another obscured string.\n- `Equals(ObscuredString value, StringComparison comparisonType)`: a method that compares the decrypted value of the string with the decrypted value of another obscured string using a specified comparison type.\n- `GetHashCode()`: an overridden method that returns the hash code of the decrypted value of the string.\n- `implicit operator ObscuredString(string value)`: an implicit conversion operator that encrypts a string and returns an obscured string.\n- `implicit operator string(ObscuredString value)`: an implicit conversion operator that decrypts an obscured string and returns a string.\n- `operator ==(ObscuredString a, ObscuredString b)`: an operator overload that compares two obscured strings for equality.\n- `operator !=(ObscuredString a, ObscuredString b)`: an operator overload that compares two obscured strings for inequality.\n\nThis class can be used in the larger project to securely store and transmit sensitive strings, such as passwords or API keys. By encrypting the strings using a crypto key, the sensitive information is protected from unauthorized access. The class also provides methods for comparing obscured strings and detecting cheating by comparing the decrypted value with a fake value.\n## Questions: \n 1. **What is the purpose of the `ObscuredString` class?**\nThe `ObscuredString` class is used to encrypt and decrypt strings using a crypto key.\n\n2. **How does the encryption and decryption process work?**\nThe encryption and decryption process is done using the `EncryptDecrypt` method, which takes a string value and a key as parameters. It performs an XOR operation between each character of the value and the corresponding character of the key, and returns the result as an encrypted or decrypted string.\n\n3. **What is the purpose of the `onCheatingDetected` action?**\nThe `onCheatingDetected` action is a callback that is triggered when cheating is detected during the decryption process. It is called if the decrypted value is not equal to the fake value that was set during the encryption process.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\CodeStage.AntiCheat.ObscuredTypes\\ObscuredString.md"}}],["155",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\CodeStage.AntiCheat.ObscuredTypes\\ObscuredUInt.cs)\n\nThe code provided is a part of the Brick-Force project and it defines a struct called ObscuredUInt. This struct is used to store and manipulate unsigned integer values in an obscured manner, making it difficult for users to cheat or modify the values.\n\nThe ObscuredUInt struct has several private fields:\n- cryptoKey: a static uint variable that represents the encryption key used to encrypt and decrypt the hidden value.\n- currentCryptoKey: a uint variable that represents the current encryption key used for the hidden value.\n- hiddenValue: a uint variable that stores the encrypted value.\n- fakeValue: a uint variable that stores the decrypted value for comparison in case of cheating detection.\n- inited: a bool variable that indicates whether the struct has been initialized.\n\nThe struct also has a public static Action variable called onCheatingDetected, which can be assigned a method to be called when cheating is detected.\n\nThe struct provides several methods and operators to manipulate the obscured unsigned integer values:\n- SetNewCryptoKey: a static method that allows changing the encryption key.\n- GetEncrypted: a method that returns the decrypted value if the currentCryptoKey matches the cryptoKey. Otherwise, it decrypts the hiddenValue using the currentCryptoKey and encrypts it again using the cryptoKey before returning it.\n- SetEncrypted: a method that sets the hiddenValue to the provided encrypted value and checks for cheating by comparing the decrypted value with the fakeValue.\n- Encrypt: static methods that encrypt a given value using the provided key or the cryptoKey.\n- Decrypt: static methods that decrypt a given value using the provided key or the cryptoKey.\n- InternalDecrypt: a private method that decrypts the hiddenValue using the currentCryptoKey and checks for cheating by comparing the decrypted value with the fakeValue.\n- Equals, ToString, GetHashCode: overridden methods for comparison and string representation of the decrypted value.\n- Implicit conversion operators: allow implicit conversion between ObscuredUInt and uint types.\n- Increment and decrement operators: increment or decrement the decrypted value and update the hiddenValue accordingly.\n\nThe purpose of this code is to provide a secure way to store and manipulate unsigned integer values in the Brick-Force project. By encrypting the values and checking for cheating, it helps prevent users from modifying the values and cheating in the game. This struct can be used throughout the project to store and manipulate various unsigned integer values securely.\n## Questions: \n 1. What is the purpose of the `ObscuredUInt` struct?\n- The `ObscuredUInt` struct is used to store and manipulate an unsigned integer value in an obscured manner, using encryption and decryption methods.\n\n2. How does the encryption and decryption process work?\n- The encryption process is performed by XORing the value with a crypto key. The decryption process is the same, XORing the value with the same crypto key.\n\n3. What is the purpose of the `onCheatingDetected` action and how is it used?\n- The `onCheatingDetected` action is used to handle a cheating detection event. It is triggered when the `SetEncrypted` method is called and the decrypted value does not match the previously stored fake value.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\CodeStage.AntiCheat.ObscuredTypes\\ObscuredUInt.md"}}],["156",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\CodeStage.AntiCheat.ObscuredTypes\\ObscuredULong.cs)\n\nThe code provided is a struct called `ObscuredULong` that is used to encrypt and decrypt unsigned long integer values. It is a part of the CodeStage.AntiCheat.ObscuredTypes namespace.\n\nThe purpose of this code is to provide a way to store and transmit sensitive unsigned long integer values in an encrypted form, making it difficult for attackers to manipulate or cheat with these values. It achieves this by using a symmetric encryption algorithm, where the same key is used for both encryption and decryption.\n\nThe struct has several private fields:\n- `cryptoKey`: a static ulong variable that holds the encryption key. By default, it is set to 444443uL, but it can be changed using the `SetNewCryptoKey` method.\n- `currentCryptoKey`: an instance-level ulong variable that holds the current encryption key for a specific instance of `ObscuredULong`.\n- `hiddenValue`: an instance-level ulong variable that holds the encrypted value.\n- `fakeValue`: an instance-level ulong variable that holds the decrypted value for comparison in case of cheating detection.\n- `inited`: an instance-level bool variable that indicates whether the struct has been initialized.\n\nThe struct provides several methods and operators for encryption, decryption, and manipulation of the encrypted value:\n- `GetEncrypted`: returns the encrypted value. If the current encryption key is different from the global encryption key, it decrypts the value, re-encrypts it with the global encryption key, and updates the current encryption key.\n- `SetEncrypted`: sets the encrypted value. If cheating detection is enabled (`onCheatingDetected` is not null), it also stores the decrypted value for comparison.\n- `Encrypt`: static method that encrypts a ulong value using the global encryption key or a custom key.\n- `Decrypt`: static method that decrypts a ulong value using the global encryption key or a custom key.\n- `InternalDecrypt`: private method that decrypts the hidden value using the current encryption key. It also performs cheating detection by comparing the decrypted value with the stored fake value.\n- `Equals`, `GetHashCode`, `ToString`: overrides of the respective methods from the Object class.\n- `ToString`: overrides of the ToString method with different parameters.\n- `implicit operator`: allows implicit conversion between ObscuredULong and ulong types.\n- `++` and `--` operators: increment and decrement the decrypted value by 1, re-encrypt it, and update the fake value if cheating detection is enabled.\n\nOverall, this code provides a way to securely store and transmit unsigned long integer values by encrypting them using a symmetric encryption algorithm. It also includes cheating detection functionality to detect any manipulation of the encrypted values. This struct can be used in the larger Brick-Force project to protect sensitive data and prevent cheating.\n## Questions: \n 1. What is the purpose of the `ObscuredULong` struct?\n- The `ObscuredULong` struct is used to store and manipulate an unsigned long integer value with encryption and decryption capabilities.\n\n2. How does the encryption and decryption process work?\n- The encryption process is performed by XORing the value with a crypto key. The decryption process is the same, XORing the value with the crypto key.\n\n3. What is the purpose of the `onCheatingDetected` action and how is it used?\n- The `onCheatingDetected` action is used to handle a cheating detection event. It is triggered when the `SetEncrypted` method is called and the `fakeValue` is not equal to the decrypted value.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\CodeStage.AntiCheat.ObscuredTypes\\ObscuredULong.md"}}],["157",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\CodeStage.AntiCheat.ObscuredTypes\\ObscuredUShort.cs)\n\nThe code provided is a struct called `ObscuredUShort` that is part of the `CodeStage.AntiCheat.ObscuredTypes` namespace. This struct is used to store and manipulate an encrypted unsigned short (ushort) value. \n\nThe purpose of this code is to provide a way to encrypt and decrypt ushort values, making it more difficult for users to cheat or manipulate the values in a game or application. It achieves this by using a crypto key to encrypt and decrypt the values.\n\nThe struct has several fields and methods that are used for encryption and decryption. \n\nThe `cryptoKey` field is a static ushort that is used as the default encryption key. The `currentCryptoKey` field is an instance-specific ushort that holds the current encryption key for a particular `ObscuredUShort` instance. The `hiddenValue` field stores the encrypted ushort value, while the `fakeValue` field is used to store the decrypted value for comparison in case of cheating detection. The `inited` field is a boolean flag that indicates whether the struct has been initialized.\n\nThe struct has methods for setting a new crypto key (`SetNewCryptoKey`), getting the encrypted value (`GetEncrypted`), setting the encrypted value (`SetEncrypted`), and encrypting or decrypting a ushort value (`EncryptDecrypt`). \n\nThe `InternalDecrypt` method is a private method that is used to decrypt the hidden value. It checks if the struct has been initialized and if the current crypto key is different from the default crypto key. If so, it uses the current crypto key for decryption. It also checks for cheating by comparing the decrypted value with the fake value and invoking the `onCheatingDetected` action if they are different.\n\nThe struct also overrides several methods from the `Object` class, such as `Equals`, `ToString`, and `GetHashCode`, to provide functionality specific to the encrypted ushort value.\n\nAdditionally, the struct provides implicit conversion operators to convert between `ObscuredUShort` and ushort values, as well as overloaded operators for increment and decrement operations.\n\nOverall, this code provides a way to store and manipulate encrypted ushort values, making it more difficult for users to cheat or manipulate the values in a game or application. It can be used in the larger project to protect sensitive ushort data and ensure data integrity.\n## Questions: \n 1. What is the purpose of the `ObscuredUShort` struct?\n- The `ObscuredUShort` struct is used to store and manipulate an unsigned short value in an encrypted and obscured manner.\n\n2. How does the encryption and decryption process work?\n- The encryption and decryption process is done using the `EncryptDecrypt` method, which performs a bitwise XOR operation on the value with a crypto key.\n\n3. What is the purpose of the `onCheatingDetected` action?\n- The `onCheatingDetected` action is a callback that is triggered when cheating is detected, allowing the developer to take appropriate action.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\CodeStage.AntiCheat.ObscuredTypes\\ObscuredUShort.md"}}],["158",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\CodeStage.AntiCheat.ObscuredTypes\\ObscuredVector2.cs)\n\nThe code provided is a struct called `ObscuredVector2` that is used to encrypt and decrypt Vector2 values. It is part of a larger project called Brick-Force and is located in the `CodeStage.AntiCheat.ObscuredTypes` namespace.\n\nThe purpose of this code is to provide a way to store Vector2 values in an encrypted form, making it difficult for users to manipulate or cheat with these values. It achieves this by using a cryptoKey to encrypt and decrypt the values.\n\nThe struct has several properties and methods that allow for encryption and decryption of Vector2 values. The `x` and `y` properties are used to get and set the encrypted values of the x and y components of the Vector2. When getting the values, the code checks for cheating by comparing the decrypted value with a fake value. If the difference between the decrypted value and the fake value is greater than a threshold, a cheating detection event is triggered. When setting the values, the code updates the hiddenValue with the encrypted value and sets the fakeValue if cheating detection is enabled.\n\nThe struct also provides methods to get and set the encrypted Vector2 value as a whole. The `GetEncrypted` method checks if the cryptoKey has changed and updates the hiddenValue if necessary. The `SetEncrypted` method sets the hiddenValue and updates the fakeValue if cheating detection is enabled.\n\nAdditionally, the struct provides static methods to encrypt and decrypt Vector2 values. The `Encrypt` method encrypts a Vector2 value using the cryptoKey, and the `Decrypt` method decrypts a Vector2 value using the cryptoKey.\n\nThe struct also includes private methods for internal encryption and decryption of the Vector2 values. These methods are used internally by the struct to perform the encryption and decryption operations.\n\nOverall, this code provides a way to store and manipulate Vector2 values in an encrypted form, making it more difficult for users to cheat or manipulate these values in the Brick-Force project.\n## Questions: \n 1. What is the purpose of the `ObscuredVector2` struct?\n- The `ObscuredVector2` struct is used to store and manipulate encrypted Vector2 values.\n\n2. How does the encryption and decryption process work for the `ObscuredVector2` struct?\n- The encryption process uses a crypto key to encrypt the x and y values of the Vector2 using the `ObscuredDouble.Encrypt` method. The decryption process uses the same crypto key to decrypt the encrypted values using the `ObscuredDouble.Decrypt` method.\n\n3. What is the purpose of the `onCheatingDetected` action and how is it used?\n- The `onCheatingDetected` action is used to detect cheating in the values of the `ObscuredVector2`. If the `fakeValue` is not equal to (0,0) and the difference between the decrypted value and the `fakeValue` is greater than 0.0005f, the `onCheatingDetected` action is invoked.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\CodeStage.AntiCheat.ObscuredTypes\\ObscuredVector2.md"}}],["159",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\CodeStage.AntiCheat.ObscuredTypes\\ObscuredVector3.cs)\n\nThe code provided is a struct called `ObscuredVector3` that is used to encrypt and decrypt Vector3 values. It is part of a larger project called Brick-Force, which likely involves some form of game development using the Unity game engine.\n\nThe purpose of this code is to provide a way to store Vector3 values in an encrypted format, making it more difficult for players to cheat or manipulate the values. It achieves this by using a cryptographic key to encrypt and decrypt the values.\n\nThe struct has several properties (`x`, `y`, `z`) that allow access to the individual components of the Vector3 value. These properties use the `InternalDecryptField` method to decrypt the hidden value and check for cheating. If cheating is detected (i.e., the decrypted value does not match the fake value), the `onCheatingDetected` action is invoked.\n\nThe struct also has an indexer that allows access to the Vector3 components using an index. This indexer uses the same decryption and cheating detection logic as the individual properties.\n\nThe struct provides methods to set a new crypto key (`SetNewCryptoKey`), get the encrypted value (`GetEncrypted`), and set the encrypted value (`SetEncrypted`). These methods use the `InternalDecrypt` and `Encrypt` methods to perform the encryption and decryption operations.\n\nThe `Encrypt` and `Decrypt` methods are used internally to encrypt and decrypt Vector3 values. They use the `ObscuredDouble` class to perform the encryption and decryption operations on each component of the Vector3 value.\n\nThe struct also overrides the `GetHashCode`, `ToString`, and `ToString(string format)` methods to provide the decrypted value's hash code and string representations.\n\nLastly, the struct provides implicit conversion operators to convert between `ObscuredVector3` and `Vector3` types. These operators use the encryption and decryption methods to perform the conversion.\n\nOverall, this code provides a way to store Vector3 values in an encrypted format, making it more difficult for players to cheat or manipulate the values in the Brick-Force project.\n## Questions: \n 1. What is the purpose of the `ObscuredVector3` struct?\n- The `ObscuredVector3` struct is used to store and manipulate encrypted Vector3 values.\n\n2. How does the encryption and decryption process work for the `ObscuredVector3` struct?\n- The encryption process involves encrypting each component of the Vector3 using the `ObscuredDouble.Encrypt` method. The decryption process involves decrypting each component of the encrypted Vector3 using the `ObscuredDouble.Decrypt` method.\n\n3. What is the purpose of the `onCheatingDetected` action and when is it triggered?\n- The `onCheatingDetected` action is triggered when cheating is detected. It is triggered if the `fakeValue` is not equal to a Vector3 with all components set to 0 and the difference between the decrypted value and the `fakeValue` is greater than 0.0005f.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\CodeStage.AntiCheat.ObscuredTypes\\ObscuredVector3.md"}}],["160",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ComboBox.cs)\n\nThe code provided is a class called \"ComboBox\" that is used to create a dropdown list with selectable items in Unity. This class is part of the larger Brick-Force project and can be used to create user interfaces that require dropdown functionality.\n\nThe ComboBox class has various properties and methods that allow customization and interaction with the dropdown list. Here is an overview of the important parts of the code:\n\n- The class is marked as [Serializable], which means instances of this class can be serialized and stored in files or transferred over the network.\n- The class has several private variables that store information about the state of the dropdown list, such as whether it is open or closed, the selected item index, and the GUI styles to be used.\n- The Initialize method is used to set up the initial state of the dropdown list. It takes parameters for whether the dropdown should have an image, the size of the dropdown shell, and whether the up and down buttons should be shown.\n- The setBattleUI method is used to set a flag indicating whether the dropdown is being used in a battle UI.\n- The setStyleNames method is used to set the names of the GUI styles to be used for the dropdown button, the down button, the up button, and the box.\n- The setBackground method is used to set the background colors of the dropdown button and the dropdown list when hovered over.\n- The setTextColor method is used to set the text colors of the dropdown button and the dropdown list when hovered over.\n- The SetGUIStyle method is used to set the font size, fixed width, and fixed height of the GUI style used for the dropdown button and the dropdown list.\n- The List method is the main method of the class that is used to display the dropdown list and handle user interaction. It takes parameters for the position of the dropdown button, the content of the button, and the content of the dropdown list. It returns the index of the selected item.\n- The ForceUnShow method is used to force the dropdown list to close.\n- The IsClickedComboButton method is used to check if the dropdown button has been clicked.\n- The SetSelectedItemIndex method is used to set the index of the selected item.\n- The GetSelectedItemIndex method is used to get the index of the selected item.\n- The NextSelectItemIndex method is used to move the selection to the next item in the list.\n- The GetNextSelectItemIndex method is used to get the index of the next item in the list.\n\nOverall, this ComboBox class provides a flexible and customizable dropdown list functionality that can be used in various user interfaces within the Brick-Force project. Developers can use this class to create dropdown menus with selectable items and handle user interaction with the dropdown list.\n## Questions: \n 1. What is the purpose of the ComboBox class?\n- The ComboBox class is used to create a dropdown list with selectable items in a graphical user interface.\n\n2. What are the parameters of the Initialize method?\n- The Initialize method takes in parameters for whether the ComboBox should have an image, the size of the ComboBox, and whether to show up and down buttons.\n\n3. What is the purpose of the List method?\n- The List method is used to display the ComboBox and handle user interactions, such as selecting an item from the dropdown list.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ComboBox.md"}}],["161",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Compass.cs)\n\nThe `Compass` class in the Brick-Force project is responsible for managing the destination level and other related information for the player. It is used to navigate between different levels or scenes in the game.\n\nThe class has several private variables, including `srcLevel` which stores the name of the current level, `dst` which represents the destination level, `channel` which stores the channel number, `roomIdx` which represents the room index, `roomPswd` which stores the room password, and `lobbyType` which represents the type of lobby.\n\nThe class also has a static instance `_instance` which is used to access the `Compass` instance throughout the project.\n\nThe class provides several public properties to access the private variables, such as `SrcLevel`, `Dst`, `Channel`, `RoomIdx`, `RoomPswd`, and `LobbyType`.\n\nThe `Compass` class has a public method `GetDestinationLevel()` which returns the name of the destination level based on the value of the `dst` variable.\n\nThe class also has two overloaded public methods `SetDestination()` which sets the destination level, channel, room index, and room password. The first overloaded method sets the room index and password to default values, while the second overloaded method does not set these values. These methods also perform some checks before setting the destination, such as checking if the current level is not the loading level and if the channel is not crowded.\n\nThe `Compass` class also has some private methods `Awake()`, `Start()`, and `Update()` which are empty and not used in this code.\n\nOverall, the `Compass` class is an important component in the Brick-Force project as it handles the navigation between different levels and manages the destination level and related information for the player. It provides methods to set the destination level and perform checks before navigating to the new level.\n## Questions: \n 1. **What is the purpose of the `Compass` class?**\nThe `Compass` class is responsible for managing the destination level, channel, room index, and room password for the game. It also provides methods to set and get the destination level.\n\n2. **What is the purpose of the `SetDestination` method?**\nThe `SetDestination` method is used to set the destination level, channel, room index, and room password for the game. It also checks if the channel is crowded or if it is only available for newbies.\n\n3. **What is the purpose of the `Awake` and `Start` methods?**\nThe `Awake` method ensures that the `Compass` instance is not destroyed when a new scene is loaded, while the `Start` method initializes the room index and room password to default values.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Compass.md"}}],["162",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ComposerTarget.cs)\n\nThe `ComposerTarget` class is a script that is used in the Brick-Force project. This script is responsible for managing the appearance and positioning of a target object in the game.\n\nThe script has three private variables: `mr`, `target`, and `transform`. `mr` is a reference to the `MeshRenderer` component attached to the game object that this script is attached to. `target` is a reference to a child game object called \"TargetBox\" that is expected to be present in the hierarchy. `transform` is a reference to the transform component of the game object.\n\nIn the `Start` method, the script initializes the `mr` and `target` variables by finding the `MeshRenderer` component and the \"TargetBox\" child object, respectively. This method is called when the game object is first created.\n\nThe `Update` method is empty and does not contain any code. This method is called every frame by the game engine, but in this case, it is not being used for any specific functionality.\n\nThe `ShowTarget` method is a public method that takes a boolean parameter `show`. It is used to control the visibility of the target object. If the `mr` variable is not null (meaning the `MeshRenderer` component was found), the `enabled` property of the `mr` variable is set to the value of the `show` parameter. This allows the target object to be shown or hidden based on the value passed to this method.\n\nThe `CenterAndSize` method is another public method that takes two `Vector3` parameters: `center` and `size`. This method is used to position and scale the target object. If the `target` variable is not null (meaning the \"TargetBox\" child object was found), the `localPosition` property of the `target` variable is set to the value of the `center` parameter, and the `localScale` property is set to the value of the `size` parameter. Additionally, a small offset of (0.05f, 0.05f, 0.05f) is added to the `size` parameter before setting the `localScale` property. This ensures that the target object is slightly larger than the specified size.\n\nOverall, this script provides functionality to show or hide a target object and to position and scale the target object within the game world. It can be used in the larger Brick-Force project to create interactive elements that require a target object. For example, it could be used to create shooting range targets or objects that need to be hit by projectiles.\n## Questions: \n 1. What is the purpose of the `ComposerTarget` class?\n- The `ComposerTarget` class is responsible for managing the appearance and positioning of a target object in the game.\n\n2. What does the `ShowTarget` method do?\n- The `ShowTarget` method controls the visibility of the target object by enabling or disabling its `MeshRenderer` component.\n\n3. What does the `CenterAndSize` method do?\n- The `CenterAndSize` method sets the position and scale of the target object based on the provided center and size vectors.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ComposerTarget.md"}}],["163",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Connecting.cs)\n\nThe code provided is a script called \"Connecting\" that is part of the Brick-Force project. This script is responsible for displaying a GUI (Graphical User Interface) element that shows the connection status of players in a multiplayer game.\n\nThe script contains a public variable called \"guiDepth\" which determines the layer of the GUI element. It also has a private variable called \"show\" which determines whether the GUI element should be shown or not. The \"show\" variable is accessed through a public property called \"Show\".\n\nThe Start() method sets the \"show\" variable to true, indicating that the GUI element should be shown when the game starts.\n\nThe Update() method is empty and does not contain any code.\n\nThe OnGUI() method is where the main functionality of the script is implemented. It is called every frame to draw the GUI element on the screen. The method first checks if the GUI should be shown based on certain conditions. If the GUI should be shown, it proceeds to draw the GUI element.\n\nThe GUI element displays a grid-like layout of players and their connection status. It uses various GUI functions and methods to achieve this. It iterates over an array of BrickManDesc objects, which represent the players in the game, and checks their connection status. If any player has a connection status of 2 or 3, the \"flag\" variable is set to false.\n\nIf the \"flag\" variable is true, indicating that all players have a connection status other than 2 or 3, the \"show\" variable is set to false, hiding the GUI element. Otherwise, the GUI element is drawn on the screen.\n\nThe GUI element consists of a rectangular box with labels and toggle buttons. The labels display the player's nickname, and the toggle buttons represent the connection status of each player. The GUI element is positioned in the center of the screen using the Screen.width and Screen.height properties.\n\nThe GUI element also includes functionality for kicking players. If the player is the master of the room, they can click on an \"X\" button next to a player's nickname to kick them from the game. This functionality is implemented using a GUI button and a network request to the server.\n\nOverall, this script is responsible for displaying a GUI element that shows the connection status of players in a multiplayer game and allows the master of the room to kick players if necessary. It is an important component of the larger Brick-Force project as it provides players with information about the status of their connections and allows for moderation of the game.\n## Questions: \n 1. What is the purpose of the `Connecting` class?\n- The purpose of the `Connecting` class is to handle the GUI display for connecting players in the game.\n\n2. What conditions need to be met for the `show` variable to be set to false?\n- The `show` variable will be set to false if any of the `BrickManDesc` objects in the `array` have a `Status` value of 2 or 3.\n\n3. What is the significance of the `flag2` variable and how is it determined?\n- The `flag2` variable is determined by checking if the `Master` value in the `RoomManager` instance is equal to the `Seq` value in the `MyInfoManager` instance. It is used for a specific condition in the GUI display.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Connecting.md"}}],["164",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ConsumableDesc.cs)\n\nThe code provided is a class called `ConsumableDesc` that represents a consumable item in the Brick-Force project. This class is used to define the properties and behavior of a consumable item, such as its name, textures for when it is enabled or disabled, cooltime (cooldown time) for using the item, whether it is a passive item, audio clips for its action and error sounds, whether it is a shooter tool, and the types of rooms in which it is disabled.\n\nThe `ConsumableDesc` class is marked with the `[Serializable]` attribute, which means that its instances can be serialized and deserialized, allowing them to be saved and loaded from disk or transmitted over a network.\n\nOne important property of the `ConsumableDesc` class is `IsDisableRoom`, which is a read-only property that determines whether the consumable item is disabled in the current room. It does this by iterating over the `disableByRoomType` array and checking if the current room type matches any of the types in the array. If a match is found, the property returns `true`, indicating that the item is disabled in the current room. If no match is found, the property returns `false`, indicating that the item is not disabled in the current room.\n\nThis class can be used in the larger Brick-Force project to define and manage consumable items. For example, it can be used to create a collection of consumable items that can be displayed in a user interface, allowing players to select and use them in the game. The `IsDisableRoom` property can be used to determine whether a consumable item should be disabled or enabled based on the current room type, providing a way to restrict the use of certain items in specific rooms.\n\nHere is an example of how the `ConsumableDesc` class could be used in code:\n\n```csharp\nConsumableDesc consumable = new ConsumableDesc();\nconsumable.name = \"Health Potion\";\nconsumable.enable = Resources.Load<Texture2D>(\"health_potion_enabled\");\nconsumable.disable = Resources.Load<Texture2D>(\"health_potion_disabled\");\nconsumable.cooltime = 10f;\nconsumable.passive = false;\nconsumable.actionClip = Resources.Load<AudioClip>(\"health_potion_action\");\nconsumable.errorClip = Resources.Load<AudioClip>(\"error_sound\");\nconsumable.isShooterTool = false;\nconsumable.disableByRoomType = new Room.ROOM_TYPE[] { Room.ROOM_TYPE.Dungeon, Room.ROOM_TYPE.BossRoom };\n\nif (consumable.IsDisableRoom)\n{\n    Debug.Log(\"Cannot use \" + consumable.name + \" in this room.\");\n}\nelse\n{\n    // Use the consumable item\n    // ...\n}\n```\n\nIn this example, a `ConsumableDesc` instance is created and its properties are set. The `IsDisableRoom` property is then used to check if the consumable item is disabled in the current room, and a message is logged accordingly.\n## Questions: \n 1. What is the purpose of the `ConsumableDesc` class?\n- The `ConsumableDesc` class is used to store information about a consumable item, such as its name, textures, cooltime, audio clips, and whether it is a shooter tool.\n\n2. What is the significance of the `IsDisableRoom` property?\n- The `IsDisableRoom` property checks if the current room type is included in the `disableByRoomType` array and returns true if it is, indicating that the consumable item should be disabled in that room.\n\n3. What is the purpose of the `disableByRoomType` array?\n- The `disableByRoomType` array stores the room types in which the consumable item should be disabled.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ConsumableDesc.md"}}],["165",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ConsumableManager.cs)\n\nThe code provided is a part of the Brick-Force project and is responsible for managing consumable items within the game. The `ConsumableManager` class is a MonoBehaviour that handles the retrieval of consumable items based on their name.\n\nThe `ConsumableManager` class has an array of `ConsumableDesc` objects called `consumables`. This array holds all the available consumable items in the game. Each `ConsumableDesc` object represents a specific consumable item and contains information such as its name, description, and other properties.\n\nThe class also has a static instance of `ConsumableManager` called `Instance`. This instance is used to access the `ConsumableManager` from other scripts in the game. The `Instance` property uses a singleton pattern to ensure that only one instance of `ConsumableManager` exists in the game. If there is no existing instance, it tries to find one using `Object.FindObjectOfType`. If it fails to find an instance, it logs an error message.\n\nThe `Get` method is used to retrieve a specific consumable item based on its name. It takes a string parameter `func` which represents the name of the consumable item. The method converts the `func` parameter to lowercase and then iterates through the `consumables` array to find a matching consumable item. If a match is found, the method returns the corresponding `ConsumableDesc` object. If no match is found, it returns null.\n\nThe `Awake`, `Start`, and `Update` methods are empty and do not have any functionality in the provided code. These methods are commonly used in Unity game development and can be used to perform initialization tasks or update game logic.\n\nOverall, the `ConsumableManager` class provides a centralized way to manage and retrieve consumable items in the Brick-Force game. Other scripts can access the `ConsumableManager` instance to retrieve specific consumable items based on their names. For example, a player script could use the `ConsumableManager.Instance.Get(\"health\")` method to retrieve the `ConsumableDesc` object for a health consumable item.\n## Questions: \n 1. What is the purpose of the `ConsumableManager` class?\n- The `ConsumableManager` class is responsible for managing consumable items in the game.\n\n2. How does the `Get` method work?\n- The `Get` method takes a string parameter `func`, converts it to lowercase, and then iterates through the `consumables` array to find a `ConsumableDesc` object with a matching `name` property. If a match is found, that `ConsumableDesc` object is returned.\n\n3. Why is the `Awake` method used?\n- The `Awake` method is used to ensure that the `ConsumableManager` instance is not destroyed when a new scene is loaded.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ConsumableManager.md"}}],["166",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ContextMenuManager.cs)\n\nThe `ContextMenuManager` class is responsible for managing the context menu in the Brick-Force project. It handles the creation, display, and interaction with the context menu.\n\nThe class has a reference to a `UserMenu` object, which represents the content of the context menu. The `isPopup` boolean variable is used to track whether the context menu is currently being displayed or not.\n\nThe class provides a static `Instance` property, which returns the singleton instance of the `ContextMenuManager`. This ensures that there is only one instance of the class throughout the project. The `Instance` property uses the `Object.FindObjectOfType` method to find an existing instance of the `ContextMenuManager` or create a new one if none exists.\n\nThe `Awake` method is called when the object is initialized and it uses the `Object.DontDestroyOnLoad` method to prevent the `ContextMenuManager` from being destroyed when a new scene is loaded.\n\nThe `Popup` method is used to display the context menu. It sets the `isPopup` variable to true and returns the `UserMenu` object. This allows other parts of the project to access and interact with the context menu.\n\nThe `OnGUI` method is called every frame and it is responsible for rendering the context menu. It checks if `isPopup` is true and then uses the `GUI.Window` method to display the context menu window. It also checks for clicks outside the context menu window using the `CheckClickOutside` method.\n\nThe `Clear` method is used to clear the context menu. It sets the `isPopup` variable to false.\n\nThe `CloseAll` method is used to close all open context menus. It calls the `OnClose` method of the `UserMenu` object and sets the `isPopup` variable to false.\n\nThe `Update` method is called every frame and it is responsible for updating the context menu. It checks if `isPopup` is true and then calls the `Update` method of the `UserMenu` object.\n\nOverall, the `ContextMenuManager` class provides a centralized way to manage the context menu in the Brick-Force project. It handles the creation, display, and interaction with the context menu, ensuring that only one instance is active at a time. Other parts of the project can use the `Popup` method to display the context menu and interact with it through the `UserMenu` object.\n## Questions: \n 1. What is the purpose of the `ContextMenuManager` class?\n- The `ContextMenuManager` class manages the display and functionality of a context menu.\n\n2. How does the `Popup` method work?\n- The `Popup` method sets the `isPopup` variable to true and returns the `userMenu` object.\n\n3. What is the purpose of the `CheckClickOutside` method?\n- The `CheckClickOutside` method checks if the mouse click is outside the bounds of the `userMenu` and sets the `isPopup` variable to false if it is.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ContextMenuManager.md"}}],["167",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\CreateClanDialog.cs)\n\nThe code provided is a class called \"CreateClanDialog\" that extends the \"Dialog\" class. This class is used to create a dialog box for creating a clan in the larger Brick-Force project. \n\nThe class has several public and private variables that define the layout and properties of the dialog box. These variables include the icon of the clan, the maximum length of the clan name, and the coordinates and dimensions of various UI elements within the dialog box.\n\nThe class also has several methods that handle different aspects of the dialog box. The \"SetClanNameAvailability\" method is used to set the availability of a given clan name. The \"Start\" method sets the ID of the dialog box. The \"OnPopup\" method sets the position of the dialog box on the screen. The \"InitDialog\" method initializes the dialog box by resetting the clan name and availability variables.\n\nThe class also has several private methods that handle the rendering of different UI elements within the dialog box. The \"DoTitle\" method renders the title of the dialog box. The \"DoComment\" method renders the clan name input field, the check availability button, and displays a comment based on the availability of the clan name. The \"CheckInput\" method checks the inputted clan name for validity.\n\nThe \"DoDialog\" method is the main method that handles the rendering and functionality of the dialog box. It renders the title, comment, and buttons for creating the clan. It also checks for various conditions such as the availability of the clan name and the player's point balance before allowing the creation of the clan.\n\nOverall, this code provides the functionality for creating a clan in the Brick-Force project by rendering a dialog box and handling user input and validation.\n## Questions: \n 1. What is the purpose of the `CreateClanDialog` class?\n- The `CreateClanDialog` class is a subclass of the `Dialog` class and is used to create a dialog for creating a clan in the game.\n\n2. What is the significance of the `SetClanNameAvailability` method?\n- The `SetClanNameAvailability` method is used to set the availability of a clan name and store the available name. It takes a clan name and a boolean value indicating whether the name is available.\n\n3. What conditions must be met in order to create a clan?\n- In order to create a clan, the player must have enough points (30000), not be a member of another clan, and have a clan name that is both available and matches the entered name.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\CreateClanDialog.md"}}],["168",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\CreateMatchTeamDialog.cs)\n\nThe code provided is a class called \"CreateMatchTeamDialog\" that extends the \"Dialog\" class. This class is responsible for creating a dialog box that allows the user to create a match team. \n\nThe class contains several member variables that define the position and size of various elements within the dialog box. These variables include \"crdOutline\", \"crdLeft\", \"crdRight\", \"crdNumPlayerBg\", \"crdCreateMatchTeamComment\", \"crdNumPlayerValue\", and \"crdCreate\". These variables are used to position and size the different UI elements within the dialog box.\n\nThe class also contains two integer variables, \"minPlayer\" and \"maxPlayer\", which define the minimum and maximum number of players that can be selected for the match team. There is also an integer variable \"numPlayer\" that represents the currently selected number of players.\n\nThe class overrides two methods from the base \"Dialog\" class: \"Start()\" and \"OnPopup()\". The \"Start()\" method sets the \"id\" variable of the dialog to a specific value. The \"OnPopup()\" method calculates the position of the dialog box based on the screen size.\n\nThe class also contains a method called \"InitDialog()\" that initializes the \"numPlayer\" variable to the minimum number of players.\n\nThe main functionality of the class is implemented in the \"DoDialog()\" method. This method is responsible for rendering the UI elements of the dialog box and handling user interactions. \n\nThe method first sets the GUI skin to a specific skin obtained from the \"GUISkinFinder\" class. It then renders a label at the top of the dialog box using the \"LabelUtil.TextOut()\" method. It also renders a box and a label to display a comment about creating a team.\n\nThe method then renders two buttons, one on the left and one on the right, to decrease and increase the number of players respectively. The current number of players is displayed in a box using the \"LabelUtil.TextOut()\" method.\n\nFinally, the method renders a button to create the match team. When this button is clicked, a network request is sent to create the squad with the specified number of players. The method also handles the close button and escape key press to close the dialog box.\n\nOverall, this class provides the functionality to create a match team by allowing the user to select the number of players and create the team. It handles rendering the UI elements and handling user interactions.\n## Questions: \n 1. What is the purpose of the `CreateMatchTeamDialog` class?\n- The `CreateMatchTeamDialog` class is a subclass of the `Dialog` class and is used to create a dialog box for creating a match team.\n\n2. What is the significance of the `numPlayer` variable?\n- The `numPlayer` variable represents the number of players in the match team and is used to determine the number of players selected for the match.\n\n3. What is the purpose of the `DoDialog` method?\n- The `DoDialog` method is responsible for rendering and handling user interactions with the dialog box. It returns a boolean value indicating whether the dialog box should be closed or not.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\CreateMatchTeamDialog.md"}}],["169",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\CSNetManager.cs)\n\nThe code provided is a part of the Brick-Force project and is contained in the `CSNetManager` class. This class is responsible for managing the network connections and communication within the game.\n\nThe `CSNetManager` class has several properties and methods that are used to handle network connections. \n\nThe `roundRobinIp` and `roundRobinPort` properties store the IP address and port number of the round-robin server. The `bfServer` and `bfPort` properties store the IP address and port number of the Brick-Force server.\n\nThe `Instance` property is a singleton pattern that ensures only one instance of the `CSNetManager` class is created. It returns the instance of the class if it exists, otherwise it creates a new instance and returns it.\n\nThe `Sock` and `SwitchAfter` properties are used to manage the TCP socket connections. The `Clear()` method is used to close the socket connections.\n\nThe `Awake()` method is called when the script instance is being loaded. It ensures that the `CSNetManager` object is not destroyed when a new scene is loaded.\n\nThe `Start()` method is called before the first frame update. It initializes the `Core` instance and sets the `sock` and `switchAfter` variables to null. It also checks if the game is running in a web player and prefetches the socket policy if necessary. It then retrieves the IP address of the round-robin server using DNS lookup.\n\nThe `Update()` method is called once per frame. It updates the socket connection, checks if the network is broken, and displays an error message if necessary.\n\nOverall, this code is responsible for managing the network connections and ensuring that the game can communicate with the Brick-Force server. It initializes the necessary variables, establishes the socket connections, and handles any errors or disconnections that may occur during gameplay.\n## Questions: \n 1. **What is the purpose of the CSNetManager class?**\nThe CSNetManager class is responsible for managing network connections and communication in the Brick-Force project.\n\n2. **What is the significance of the roundRobinIp and roundRobinPort variables?**\nThe roundRobinIp and roundRobinPort variables store the IP address and port number of the round-robin server used for network communication.\n\n3. **What is the purpose of the Clear() method?**\nThe Clear() method is used to close and clean up network connections by closing the sock and switchAfter objects.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\CSNetManager.md"}}],["170",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\CtfModeConfig.cs)\n\nThe code provided is a class called `CtfModeConfig` that is used in the larger Brick-Force project. This class is responsible for configuring and displaying the Capture the Flag (CTF) mode settings in the game.\n\nThe class contains various properties and methods that handle the GUI (Graphical User Interface) elements and logic for displaying and interacting with the CTF mode configuration. Let's go through the code to understand its purpose and functionality.\n\nThe class starts with some private fields, such as `nonavailable`, `crdThumbnail`, `crdAlias`, `crdMode`, `crdConfigBtn`, `crdOptionLT`, `crdLine`, `optionLX`, `optionRX`, `diff_y`, `crdBox`, `diff_y2`, `tooltipMessage`, and `weaponOptions`. These fields store various coordinates, dimensions, and other data used for positioning and rendering GUI elements.\n\nThe `Start()` method is empty and does not contain any code. It is likely intended to be overridden by subclasses or used for initialization purposes.\n\nThe `OnGUI()` method is responsible for rendering the CTF mode configuration GUI. It first checks if a thumbnail image for the current map is available. If not, it uses a default `nonavailable` image. It then renders the thumbnail image, along with any additional icons or decorations based on the map's properties.\n\nNext, it displays the alias and mode of the current room, along with various options such as time limit, weapon options, break-in settings, item drop settings, and team balance settings. These options are rendered using GUI elements such as boxes, labels, and buttons.\n\nThe `DoOption()` method is called within `OnGUI()` and handles the rendering of the various options mentioned above. It calculates the positions and values of the options based on the current room's settings.\n\nThe `ShowTooltip()` method is used to display a tooltip message when the user hovers over certain GUI elements. It renders the tooltip message as a label with a yellow background.\n\nOverall, this class provides the functionality to configure and display the CTF mode settings in the game. It handles the rendering of GUI elements, retrieves map and room data, and allows the user to interact with the options. This class is likely used in conjunction with other classes and components to create a complete CTF mode experience in the Brick-Force game.\n## Questions: \n 1. What is the purpose of the `Start()` method in the `CtfModeConfig` class?\n- The `Start()` method does not have any code inside it, so a smart developer might wonder why it is included in the class and what its intended purpose is.\n\n2. What is the significance of the `isRoom` variable in the `CtfModeConfig` class?\n- A smart developer might question why the `isRoom` variable is declared as a public boolean and what role it plays in the functionality of the code.\n\n3. What is the purpose of the `DoOption()` method in the `CtfModeConfig` class?\n- A smart developer might want to know what functionality the `DoOption()` method provides and how it is used within the code.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\CtfModeConfig.md"}}],["171",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\CustomGameConfig.cs)\n\nThe code provided defines a public class called `CustomGameConfig`. This class contains several static variables that can be used to configure certain aspects of the game. \n\nThe first variable is `useRandomInvite`, which is a boolean variable set to `true`. This variable is used to determine whether random invites should be used in the game. By default, random invites are enabled, but this can be changed by modifying the value of this variable.\n\nThe next three variables are integers: `limitChatTime`, `limitChatCount`, and `chatBlockTime`. These variables are used to set limits and restrictions on the chat feature in the game.\n\n`limitChatTime` represents the maximum amount of time a player can spend chatting in the game. This value is not initialized in the code provided, so it will default to 0 if not explicitly set elsewhere in the code.\n\n`limitChatCount` represents the maximum number of chat messages a player can send in a given time period. Like `limitChatTime`, this value is not initialized in the code provided.\n\n`chatBlockTime` represents the amount of time a player will be blocked from using the chat feature if they exceed the `limitChatCount`. Again, this value is not initialized in the code provided.\n\nThese variables can be accessed and modified by other classes and methods in the project. For example, if a developer wants to disable random invites, they can simply set the value of `useRandomInvite` to `false`:\n\n```\nCustomGameConfig.useRandomInvite = false;\n```\n\nSimilarly, if a developer wants to set a limit of 60 seconds for chat time, they can set the value of `limitChatTime` to 60:\n\n```\nCustomGameConfig.limitChatTime = 60;\n```\n\nOverall, this code provides a way to configure certain aspects of the game, such as random invites and chat restrictions, by modifying the values of the static variables in the `CustomGameConfig` class.\n## Questions: \n 1. **What is the purpose of the `CustomGameConfig` class?**\nThe `CustomGameConfig` class is likely used to store and manage various configuration settings for a custom game in the Brick-Force project.\n\n2. **What does the `useRandomInvite` variable control?**\nThe `useRandomInvite` variable likely controls whether or not random invites are enabled for the custom game. \n\n3. **What are the purposes of the `limitChatTime`, `limitChatCount`, and `chatBlockTime` variables?**\nThese variables likely control various aspects of the chat functionality in the custom game, such as the maximum time allowed for each chat message, the maximum number of chat messages allowed, and the duration of a chat block for a user who has violated chat rules.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\CustomGameConfig.md"}}],["172",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\c_Gachapon.cs)\n\nThe code provided defines a class called `c_Gachapon`. This class is used to represent a Gachapon item in the Brick-Force project. \n\nA Gachapon is a type of vending machine that dispenses random items when a player interacts with it. In the context of the Brick-Force project, this class is likely used to define the properties and behavior of Gachapon items.\n\nThe class has several public variables:\n\n- `code` is a string variable that represents the unique code or identifier of the Gachapon item.\n- `itemName` is a string variable that represents the name of the Gachapon item.\n- `classType` is an integer variable that represents the class or type of the Gachapon item.\n- `strtblCode` is a string variable that represents the localization code for the Gachapon item.\n- `icon` is a Texture2D variable that represents the icon or image associated with the Gachapon item.\n- `brickPoint` is an integer variable that represents the cost or value of the Gachapon item in terms of in-game currency.\n- `items` is an array of strings that represents the possible items that can be obtained from the Gachapon.\n- `qualities` is an array of integers that represents the quality or rarity of the items in the Gachapon.\n\nBy defining these variables, the `c_Gachapon` class provides a blueprint for creating and managing Gachapon items in the Brick-Force project. Developers can create instances of this class and set the values of its variables to define specific Gachapon items. For example:\n\n```csharp\nc_Gachapon gachaponItem = new c_Gachapon();\ngachaponItem.code = \"GACH001\";\ngachaponItem.itemName = \"Rare Sword\";\ngachaponItem.classType = 1;\ngachaponItem.strtblCode = \"GACH001_NAME\";\ngachaponItem.icon = Resources.Load<Texture2D>(\"SwordIcon\");\ngachaponItem.brickPoint = 100;\ngachaponItem.items = new string[] { \"Sword\", \"Shield\", \"Helmet\" };\ngachaponItem.qualities = new int[] { 3, 2, 1 };\n```\n\nIn this example, a new Gachapon item is created and its properties are set. The item has a code of \"GACH001\", a name of \"Rare Sword\", a class type of 1, a localization code of \"GACH001_NAME\", an icon loaded from a resource file, a brick point value of 100, and possible items of \"Sword\", \"Shield\", and \"Helmet\" with corresponding qualities of 3, 2, and 1.\n\nOverall, this code provides a foundation for defining and managing Gachapon items in the Brick-Force project.\n## Questions: \n 1. **What is the purpose of this class?**\nThe smart developer might want to know the overall purpose or functionality of the `c_Gachapon` class in order to understand its role within the project.\n\n2. **What do the different variables represent?**\nThe developer might want to know the meaning and usage of each variable in the class, such as `code`, `itemName`, `classType`, etc., in order to understand how they are used within the code.\n\n3. **Are there any methods or functions associated with this class?**\nThe developer might want to know if there are any additional methods or functions within the `c_Gachapon` class that are not shown in the provided code, in order to understand the full functionality of the class.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\c_Gachapon.md"}}],["173",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\DailyMissionMonitor.cs)\n\nThe code provided is a part of the Brick-Force project and is a script called \"DailyMissionMonitor\". This script is responsible for monitoring and displaying the daily missions in the game.\n\nThe script uses the Unity game engine and is attached to a game object in the scene. It contains several private variables that define the layout and positioning of the mission elements on the screen. These variables include the dimensions and coordinates of the mission title, labels, and toggles.\n\nThe script has three main methods: Start(), Update(), and OnGUI(). The Start() and Update() methods are currently empty and do not contain any code. The OnGUI() method is called every frame and is responsible for rendering the mission elements on the screen.\n\nIn the OnGUI() method, the script checks if the GUI is enabled and if there is an active mission available. If both conditions are met, it proceeds to render the mission elements. It sets the GUI skin, depth, and enables GUI interaction if there are no active modal dialogs.\n\nThe DoTitle() method is responsible for rendering the mission title and its associated texture on the screen. It uses the Rect and TextureUtil classes to calculate the position and draw the texture. It also uses the LabelUtil class to display the title text.\n\nThe DoDailyMission() method is responsible for rendering the individual daily missions on the screen. It uses a loop to iterate through the available missions and renders each mission's description, progress, and completion toggle. It uses the LabelUtil class to calculate the size of the description text and the GUI class to render the elements.\n\nOverall, this script is an essential part of the Brick-Force project as it handles the rendering of daily missions on the screen. It provides a visual representation of the missions and allows players to track their progress and complete them. This script can be used in conjunction with other scripts and game mechanics to create a comprehensive mission system within the game.\n## Questions: \n 1. What is the purpose of the `Start()` and `Update()` methods?\n- The `Start()` and `Update()` methods are empty and do not contain any code. A smart developer might wonder why these methods are included in the code if they are not being used.\n\n2. What is the significance of the `GUIDepth.LAYER` enum and how is it used?\n- The `GUIDepth.LAYER` enum is used to set the GUI depth in the `OnGUI()` method. A smart developer might want to know how this enum is defined and what effect it has on the GUI rendering.\n\n3. How is the `DoDailyMission()` method called and what does it do?\n- The `DoDailyMission()` method is called within the `OnGUI()` method. A smart developer might want to understand how this method is being invoked and what functionality it provides in relation to the daily missions in the game.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\DailyMissionMonitor.md"}}],["174",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\DateTimeLocal.cs)\n\nThe code provided is a class called `DateTimeLocal` that contains a single static method called `ToString`. This method takes a `DateTime` object as a parameter and returns a string representation of that date and time.\n\nThe purpose of this code is to format a `DateTime` object into a specific string format that includes the year, month, day, hour, minute, and second. It also uses a `StringMgr` class to retrieve localized strings for each component of the date and time.\n\nThe `ToString` method first initializes an empty string variable called `empty`. It then appends the year, month, day, hour, minute, and second components of the `DateTime` object to the `empty` string. Each component is converted to a string using the `ToString` method and concatenated with the `empty` string.\n\nAfter appending each component, the method retrieves the corresponding localized string for each component using the `StringMgr.Instance.Get` method. This method takes a string key as a parameter and returns the localized string associated with that key. The localized strings are appended to the `empty` string.\n\nFinally, the method appends the localized string for the second component of the date and time and returns the resulting string.\n\nHere is an example usage of the `ToString` method:\n\n```csharp\nDateTime dateTime = DateTime.Now;\nstring formattedDateTime = DateTimeLocal.ToString(dateTime);\nConsole.WriteLine(formattedDateTime);\n```\n\nThis code will retrieve the current date and time using the `DateTime.Now` property and pass it to the `ToString` method. The method will format the date and time into a string representation and print it to the console. The output will be something like \"2022YEAR10MONTH25DAY15HOUR30MIN45SEC\".\n## Questions: \n 1. What is the purpose of the `StringMgr.Instance.Get()` method calls?\n- The `StringMgr.Instance.Get()` method calls are used to retrieve localized strings for the corresponding keys (\"YEAR\", \"MONTH\", \"DAY\", \"HOUR\", \"MIN\", \"SEC\").\n\n2. Is the `ToString()` method intended to be used for formatting the date and time in a specific way?\n- Yes, the `ToString()` method is used to format the date and time by concatenating the year, month, day, hour, minute, and second values with their corresponding localized strings.\n\n3. Are there any potential performance issues with concatenating strings in a loop like this?\n- Yes, there could be potential performance issues with concatenating strings in a loop, as each concatenation creates a new string object. It might be more efficient to use a `StringBuilder` instead.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\DateTimeLocal.md"}}],["175",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\DefenseGuideDialog.cs)\n\nThe code provided is a class called `DefenseGuideDialog` that extends the `Dialog` class. This class is used to create a dialog box in the Brick-Force project. The purpose of this dialog box is to display a guide for defense strategies to the player.\n\nThe class has several public variables, including `imgList`, `labelList`, `toggle`, and `ok`. These variables are used to reference UI elements such as image lists, label lists, toggle buttons, and a button for the dialog box. These UI elements are likely used to display the content of the defense guide to the player.\n\nThe class also has a property called `DontShowThisMessageAgain`, which returns the value of the `toggle` variable. This property is used to determine whether the player has selected the option to not show the defense guide message again.\n\nThe `Start` method sets the `id` variable of the dialog box to a specific value from the `DialogManager` class. This value is used to identify the dialog box.\n\nThe `OnPopup` method calculates the position of the dialog box based on the screen size and the size of the dialog box itself.\n\nThe `InitDialog` method is empty and does not contain any code. It is likely intended to be used for initializing the dialog box, but it is not currently implemented.\n\nThe `DoDialog` method is the main method of the class and is responsible for drawing the UI elements and handling user interactions. It first sets the GUI skin to a specific skin obtained from the `GUISkinFinder` class. Then, it calls the `Draw` method on the `imgList`, `labelList`, `toggle`, and `ok` variables to draw the UI elements on the screen. It checks if the `ok` button is clicked and if the `DontShowThisMessageAgain` property is true. If both conditions are met, it saves the player's preference to not show the defense guide message again using the `MyInfoManager` class. Finally, it checks if there is no other popup menu open and calls the `WindowUtil.EatEvent` method to prevent further event handling. It then restores the GUI skin to its original value and returns the result.\n\nOverall, this code defines a dialog box for displaying a defense guide to the player in the Brick-Force project. It handles drawing the UI elements and saving the player's preference for not showing the guide again.\n## Questions: \n 1. What is the purpose of the `DefenseGuideDialog` class?\n- The `DefenseGuideDialog` class is a subclass of `Dialog` and represents a dialog box for a defense guide.\n\n2. What are the properties and components of the `DefenseGuideDialog` class?\n- The `DefenseGuideDialog` class has properties such as `imgList`, `labelList`, `toggle`, and `ok`, which are all UI elements used in the dialog box.\n\n3. What is the purpose of the `DoDialog()` method?\n- The `DoDialog()` method is responsible for drawing the UI elements of the dialog box and handling user interactions, such as clicking the `ok` button and saving a setting if the `DontShowThisMessageAgain` toggle is enabled. It returns a boolean value indicating whether the dialog box should be closed.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\DefenseGuideDialog.md"}}],["176",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\DefenseModeConfig.cs)\n\nThe code provided is a class called \"DefenseModeConfig\" that is used in the larger Brick-Force project. This class is responsible for managing the configuration and display of the defense mode in the game.\n\nThe class contains various properties and methods that handle the graphical user interface (GUI) elements and logic for displaying and interacting with the defense mode. The \"OnGUI\" method is the main method that is called to render the defense mode GUI.\n\nThe \"OnGUI\" method first retrieves the thumbnail image for the current room from the \"RegMapManager\" and assigns it to the \"thumbnail\" variable. If the thumbnail is not available, it assigns the \"nonavailable\" texture to the \"thumbnail\" variable. It then proceeds to draw the thumbnail image on the GUI using the \"TextureUtil.DrawTexture\" method.\n\nNext, it checks if the registered date of the current room's map is the same as the current date. If it is, it draws a new map icon on the thumbnail. If the map has a specific tag, such as \"glory\", \"medal\", or \"gold ribbon\", it draws the corresponding icon on the thumbnail. If the map is flagged as an abuse map, it draws an abuse icon on the thumbnail.\n\nThe method then displays the alias and mode of the current room using the \"LabelUtil.TextOut\" method. It also calls the \"DoOption\" method to display additional options for the room, such as the nuclear life option and time limit.\n\nFinally, if the configuration button is clicked, it opens the room configuration dialog.\n\nThe \"DoOption\" method is responsible for displaying the additional options for the room. It displays the nuclear life option, time limit, and other options based on the room's settings.\n\nThe \"ShowTooltip\" method is called when a tooltip is needed to display additional information. It draws a tooltip window on the GUI and displays the tooltip message.\n\nOverall, this class is an important part of the Brick-Force project as it handles the configuration and display of the defense mode in the game. It provides a user-friendly interface for players to interact with the defense mode and customize their room settings.\n## Questions: \n 1. What is the purpose of the `OnGUI()` method?\n- The `OnGUI()` method is responsible for rendering the graphical user interface for the DefenseModeConfig class. It displays various textures and labels based on the current state of the game.\n\n2. What does the `DoOption()` method do?\n- The `DoOption()` method is used to display and update various options related to the game room, such as the weapon option, time limit, and break-in status.\n\n3. What is the purpose of the `ShowTooltip()` method?\n- The `ShowTooltip()` method is responsible for displaying a tooltip message when the user hovers over certain GUI elements. It renders the tooltip message as a label with a yellow color.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\DefenseModeConfig.md"}}],["177",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\DetectorsUsageExample.cs)\n\nThe code provided is an example of how to use the `CodeStage.AntiCheat.Detectors` package in the Brick-Force project. This package provides functionality to detect cheating behaviors in the game, such as speed hacking and code injection.\n\nThe `DetectorsUsageExample` class is a MonoBehaviour script that is attached to a GameObject in the game scene. It has two public boolean variables, `injectionDetected` and `speedHackDetected`, which are used to track whether cheating behaviors have been detected.\n\nIn the `Start` method, the code sets up the detection for speed hacking and code injection. \n\nFor speed hacking detection, the `SpeedHackDetector.StartDetection` method is called. This method takes three parameters: a callback function to be executed when a speed hack is detected (`OnSpeedHackDetected`), a float value representing the interval at which the detection should be performed (1 second in this case), and an integer value representing the number of consecutive detections required to trigger the callback (5 in this case). This means that if the speed hack is detected 5 times within 1 second, the `OnSpeedHackDetected` function will be called.\n\nFor code injection detection, the `InjectionDetector.StartDetection` method is called. This method takes a callback function to be executed when a code injection is detected (`OnInjectionDetected`). The `InjectionDetector.Instance.autoDispose` and `InjectionDetector.Instance.keepAlive` properties are also set to true. These properties control the behavior of the injection detector, with `autoDispose` indicating whether the detector should automatically dispose itself after detecting an injection, and `keepAlive` indicating whether the detector should keep running even if the game object it is attached to is destroyed.\n\nThe `OnSpeedHackDetected` and `OnInjectionDetected` methods simply set the corresponding boolean variables to true and log a warning message to the console.\n\nOverall, this code sets up the detection for speed hacking and code injection and provides callback functions to handle the detection events. It allows the game to take appropriate actions when cheating behaviors are detected, such as banning the player or logging the incident for further investigation.\n## Questions: \n 1. What is the purpose of the `SpeedHackDetector` and `InjectionDetector` classes?\n- The `SpeedHackDetector` class is used to detect if a speed hack is being used in the game. The `InjectionDetector` class is used to detect if any code injection is occurring in the game.\n\n2. What does the `StartDetection` method do and what are its parameters?\n- The `StartDetection` method is used to start the detection process for either speed hacks or code injections. The parameters for the method include a callback function to be executed when a detection is made, a float value representing the detection interval, and an integer value representing the number of consecutive detections required to trigger the callback.\n\n3. What is the purpose of the `autoDispose` and `keepAlive` properties of the `InjectionDetector` class?\n- The `autoDispose` property is used to automatically dispose of the `InjectionDetector` instance when it is no longer needed. The `keepAlive` property is used to keep the `InjectionDetector` instance alive even if it is not actively detecting injections.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\DetectorsUsageExample.md"}}],["178",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Dialog.cs)\n\nThe code provided is a class called `Dialog` that is used in the larger Brick-Force project. This class represents a dialog window in the game and provides methods and properties to manage the dialog's behavior and appearance.\n\nThe `Dialog` class is marked with the `[Serializable]` attribute, which means that instances of this class can be serialized and stored in a file or sent over a network.\n\nThe class has several fields and properties:\n\n- `WindowStyle` is a string that represents the style of the dialog window. It has a default value of \"Window\".\n- `size` is a `Vector2` that represents the size of the dialog window.\n- `rc` is a `Rect` that represents the position and size of the dialog window.\n- `id` is an enum value of type `DialogManager.DIALOG_INDEX` that represents the unique identifier of the dialog.\n\nThe class also has several methods:\n\n- `Start()` is a virtual method that can be overridden in derived classes. It is called when the dialog is started.\n- `OnPopup()` is a virtual method that can be overridden in derived classes. It is called when the dialog is shown.\n- `OnClose(DialogManager.DIALOG_INDEX popup)` is a virtual method that can be overridden in derived classes. It is called when the dialog is closed.\n- `DoDialog()` is a virtual method that can be overridden in derived classes. It is called to determine if the dialog should be shown or not. It returns a boolean value indicating whether the dialog should be shown.\n- `Update()` is a virtual method that can be overridden in derived classes. It is called every frame to update the dialog's state.\n\nThe `Dialog` class provides a basic structure for creating and managing dialog windows in the Brick-Force game. Derived classes can inherit from this class and override its methods to customize the behavior and appearance of specific dialogs in the game.\n\nHere is an example of how the `Dialog` class can be used:\n\n```csharp\npublic class MyDialog : Dialog\n{\n    public override void Start()\n    {\n        // Custom initialization code for the dialog\n    }\n\n    public override void OnPopup()\n    {\n        // Custom code to execute when the dialog is shown\n    }\n\n    public override void OnClose(DialogManager.DIALOG_INDEX popup)\n    {\n        // Custom code to execute when the dialog is closed\n    }\n\n    public override bool DoDialog()\n    {\n        // Custom logic to determine if the dialog should be shown\n        return true;\n    }\n\n    public override void Update()\n    {\n        // Custom code to update the dialog's state every frame\n    }\n}\n\n// Usage:\nMyDialog myDialog = new MyDialog();\nmyDialog.Start();\nmyDialog.OnPopup();\nmyDialog.Update();\n```\n\nIn this example, a custom dialog class `MyDialog` is created by inheriting from the `Dialog` class. The overridden methods are implemented with custom logic specific to this dialog. An instance of `MyDialog` is then created and its methods are called to initialize, show, and update the dialog.\n## Questions: \n 1. What is the purpose of the `Dialog` class?\n- The `Dialog` class is used to create dialog windows in the game. It contains methods for starting, updating, and closing the dialog.\n\n2. What is the significance of the `WindowStyle` variable?\n- The `WindowStyle` variable determines the style of the dialog window. It is a string that specifies the style name.\n\n3. What is the purpose of the `DoDialog` method?\n- The `DoDialog` method is responsible for displaying the dialog window and handling user input. It returns a boolean value indicating whether the dialog should continue to be displayed or not.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Dialog.md"}}],["179",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\DirAttacker.cs)\n\nThe `DirAttacker` class in the Brick-Force project is responsible for managing and rendering a directional attacker object in the game. \n\nThe class has several private variables, including `lifeTime` (the duration the attacker will be visible), `image` (the texture of the attacker), `clrStart` and `clrEnd` (the starting and ending colors of the attacker), `clr` (the current color of the attacker), `deltaTime` (the time elapsed since the attacker was created), `attacker` (the ID of the attacker), and `cameraController` (a reference to the camera controller in the game).\n\nThe class has a public property `Attacker` that returns the ID of the attacker.\n\nThe constructor of the `DirAttacker` class takes in several parameters, including the attacker ID, texture, starting and ending colors, lifetime, and the camera controller. It initializes the private variables and calls the `Reset` method.\n\nThe `Reset` method resets the `deltaTime` and `clr` variables to their initial values.\n\nThe `Update` method is responsible for updating the attacker's color over time. It increments the `deltaTime` variable by the time elapsed since the last frame and calculates the new color using `Color.Lerp` based on the `deltaTime` and `lifeTime` values. It returns `true` if the attacker is still within its lifetime, and `false` otherwise.\n\nThe `Draw` method is responsible for rendering the attacker on the screen. It first retrieves the attacker's game object using the `BrickManManager` class. It then calculates the direction from the camera to the attacker's position and determines the angle between the camera's forward direction and the attacker's direction. Based on this angle, it adjusts the attacker's angle to face the camera properly.\n\nFinally, it sets the GUI color to the current attacker color, calculates the position and size of the attacker's texture on the screen, rotates the GUI matrix to match the attacker's angle, and draws the attacker's texture using `TextureUtil.DrawTexture`. It returns `true` to indicate that the attacker was successfully drawn.\n\nIn summary, the `DirAttacker` class manages and renders a directional attacker object in the game. It updates the attacker's color over time and draws it on the screen facing the camera. This class is likely used in the larger project to create and display various attackers in the game world.\n## Questions: \n 1. What is the purpose of the `DirAttacker` class?\n- The `DirAttacker` class is responsible for managing the visual representation of an attacker in the game.\n\n2. What does the `Update` method do?\n- The `Update` method updates the color of the attacker over time based on the specified start and end colors.\n\n3. What does the `Draw` method do?\n- The `Draw` method draws the attacker's image on the screen, rotating it based on the angle between the camera's forward direction and the direction towards the attacker.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\DirAttacker.md"}}],["180",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Direction.cs)\n\nThe code provided is a class called \"Direction\" that contains two static methods: \"DotNormal\" and \"IsNotSideOnXZPlane\", as well as a third static method called \"IsForward\". This class is used to calculate and determine the direction of an object in relation to a reference object in a 3D space.\n\nThe \"DotNormal\" method takes in two Vector3 parameters, \"a\" and \"b\", and calculates the dot product of their normalized versions using the \"Vector3.Dot\" method. The dot product is a mathematical operation that returns a scalar value representing the cosine of the angle between two vectors. In this case, the dot product is used to determine the similarity or alignment between two vectors. The method first normalizes the input vectors using the \"normalized\" property of the Vector3 class, ensuring that they have a magnitude of 1. It then returns the dot product of the normalized vectors.\n\nThe \"IsNotSideOnXZPlane\" method takes in a Vector3 parameter \"pos\" and a Transform parameter \"reference\". It calculates the direction of \"pos\" relative to \"reference\" on the XZ plane (ignoring the y-axis). It first calculates vector \"a\" by subtracting the position of \"reference\" from \"pos\" and setting the y-component of \"a\" to 0. It then calculates vector \"b\" by transforming the forward direction of \"reference\" to the world space and setting the y-component of \"b\" to 0. The method then calls the \"DotNormal\" method to calculate the dot product of \"a\" and \"b\". Finally, it returns a boolean value indicating whether the dot product falls within a specific range (-1 to -0.85 or 0.2 to 1), which determines if \"pos\" is not side-on to the XZ plane of \"reference\".\n\nThe \"IsForward\" method is similar to \"IsNotSideOnXZPlane\" but only checks if \"pos\" is in front of \"reference\" rather than checking its alignment on the XZ plane. It calculates vector \"a\" by subtracting the position of \"reference\" from \"pos\" and calculates vector \"b\" as the forward direction of \"reference\". It then calls the \"DotNormal\" method to calculate the dot product of \"a\" and \"b\". Finally, it returns a boolean value indicating whether the dot product is greater than 0, which determines if \"pos\" is in front of \"reference\".\n\nThese methods can be used in the larger Brick-Force project to determine the direction of objects in relation to a reference object. This information can be used for various purposes such as determining if an object is facing a certain direction, checking if an object is side-on to a plane, or calculating the alignment between two objects.\n## Questions: \n 1. What does the `DotNormal` method do and why is it important in this code? \nThe `DotNormal` method calculates the dot product of two normalized vectors. It is important in this code because it is used to determine the angle between two vectors, which is used in the `IsNotSideOnXZPlane` and `IsForward` methods.\n\n2. What does the `IsNotSideOnXZPlane` method check for and how does it determine if a position is not on the side of the XZ plane? \nThe `IsNotSideOnXZPlane` method checks if a position is not on the side of the XZ plane by calculating the dot product between the position vector and the forward vector of a reference transform. If the dot product falls within certain ranges, it returns true.\n\n3. How does the `IsForward` method determine if a position is in front of a reference transform? \nThe `IsForward` method determines if a position is in front of a reference transform by calculating the dot product between the position vector and the forward vector of the reference transform. If the dot product is greater than 0, it returns true.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Direction.md"}}],["181",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\DroppedItem.cs)\n\nThe code provided is a class called \"DroppedItem\" that represents an item dropped in the game. It contains various properties and a constructor that initializes these properties.\n\nThe purpose of this code is to create a dropped item object in the game world. The dropped item is represented by a GameObject and an associated effect (eff). The constructor takes in parameters such as the item sequence, item code, bullet count, and position (x, y, z) to create the dropped item.\n\nInside the constructor, the code first assigns the passed parameters to the corresponding properties of the DroppedItem object. It then retrieves the TWeapon object associated with the item code from the TItemManager and assigns it to a local variable tWeapon.\n\nNext, it instantiates the effect GameObject using the GlobalVars.Instance.droppedEff prefab and sets its position to the passed position (x, y, z). The instantiated effect is assigned to the eff property of the DroppedItem object.\n\nSimilarly, it instantiates the GameObject associated with the tWeapon's current prefab and assigns it to the obj property. The position and rotation of the obj GameObject are set to the passed position (x, y, z) and Quaternion.Euler(0f, 0f, 0f) respectively.\n\nThe code then enables the WeaponGadget component of the obj GameObject and disables the WeaponFunction component. It also sets the ItemSeq property of the WeaponFunction component to the item sequence.\n\nNext, it checks if the obj GameObject has an Aim component and disables it if it exists. Similarly, it checks if the obj GameObject has a Scope component and disables it if it exists.\n\nFinally, it sets the layer of the obj GameObject and its child objects to \"Default\" using the Recursively.SetLayer method.\n\nOverall, this code is responsible for creating a dropped item object in the game world with the associated GameObject, effect, and properties. It sets up the necessary components and properties of the dropped item for further interaction and functionality within the larger project.\n## Questions: \n 1. What is the purpose of the `DroppedItem` class?\n- The `DroppedItem` class is used to represent a dropped item in the game, storing information such as the item's sequence, code, bullet count, and associated game objects.\n\n2. What does the `DroppedItem` constructor do?\n- The `DroppedItem` constructor initializes a new instance of the `DroppedItem` class, setting the item's sequence, code, bullet counts, and creating and positioning the associated game objects.\n\n3. What are the purposes of the `WeaponGadget`, `WeaponFunction`, `Aim`, and `Scope` components on the `obj` game object?\n- The `WeaponGadget` component is enabled, while the `WeaponFunction` component is disabled. The `Aim` and `Scope` components are also disabled if they exist on the `obj` game object.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\DroppedItem.md"}}],["182",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\DummyUserDector.cs)\n\nThe code provided is a script called \"DummyUserDector\" that is part of the larger Brick-Force project. This script is responsible for detecting and managing dummy users in the game.\n\nThe script starts by defining an enum called \"USER_TYPE\" which has two possible values: \"ACTIVE_USER\" and \"LAZY_USER\". This enum is used to keep track of the type of user the script is currently dealing with.\n\nThe script also declares several private variables:\n- \"dummyTime\" is a float that keeps track of the time elapsed since the dummy user was last cleared.\n- \"timeout\" is a float that represents the maximum amount of time a dummy user can be active before being cleared.\n- \"userType\" is a variable of type \"USER_TYPE\" that stores the current type of user.\n\nThe script contains several methods:\n- \"Awake\" is called when the script is first loaded. It uses the \"DontDestroyOnLoad\" method to ensure that the script persists between scene changes.\n- \"Start\" is called at the beginning of the game. It calls the \"Clear\" method to reset the dummy user.\n- \"Clear\" is a private method that resets the dummy user by setting the \"userType\" to \"ACTIVE_USER\" and resetting the \"dummyTime\" to 0.\n- \"Update\" is called every frame. It checks several conditions to determine if the dummy user should be cleared or if it should transition from an active user to a lazy user. If the dummy user has been active for a certain amount of time, it is cleared and various actions are taken, such as setting a global variable to shut down the game, sending a logout request to the server, closing the network socket, and displaying a message box.\n\nIn the larger Brick-Force project, this script is likely used to manage and handle dummy users in the game. Dummy users are typically used for testing or simulation purposes and are not real players. This script ensures that dummy users are cleared after a certain amount of time and performs necessary actions when they are cleared. It also handles the transition from an active user to a lazy user if the dummy user has been active for a specific duration.\n## Questions: \n 1. What is the purpose of the `Awake()` method and why is `Object.DontDestroyOnLoad(this)` called within it?\n- The `Awake()` method is called when the script instance is being loaded. `Object.DontDestroyOnLoad(this)` is called to prevent the object from being destroyed when a new scene is loaded.\n\n2. What conditions need to be met for the code within the `Update()` method to execute?\n- The conditions that need to be met are: `MyInfoManager.Instance.Seq` is greater than 0, `BuffManager.Instance.netCafeCode` is equal to 0, `CSNetManager.Instance.Sock` is not null, and `CSNetManager.Instance.Sock.IsConnected()` returns true.\n\n3. What does the code do when `dummyTime` reaches the `timeout` value?\n- When `dummyTime` reaches the `timeout` value, the code calls the `Clear()` method, sets `GlobalVars.Instance.shutdownNow` to true, sends a logout request, closes the socket, shuts down the P2P manager, and adds a quit message to the message box.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\DummyUserDector.md"}}],["183",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\DurabilityEvent.cs)\n\nThe code provided is a class called `DurabilityEvent` that represents an event related to the durability of an item in the game. This class is likely used in the larger Brick-Force project to handle events related to the durability of weapons or other items.\n\nThe `DurabilityEvent` class has three public properties: `code`, `durability`, and `diff`. These properties represent the code or identifier of the item, the current durability of the item, and the difference in durability from the previous state, respectively.\n\nThe class also has a constructor that takes in these three properties and assigns them to the corresponding fields. This allows for easy initialization of a `DurabilityEvent` object with the necessary information.\n\nThe most important method in this class is the `ToString()` method, which overrides the base `ToString()` method. This method is responsible for generating a string representation of the `DurabilityEvent` object. It does this by retrieving the corresponding `TWeapon` object from the `TItemManager` using the `code` property. If the `TWeapon` object is not found, an empty string is returned.\n\nIf the `TWeapon` object is found, the method determines whether the `diff` property is less than or equal to 0. If it is, the key \"REPAIR_EVENT\" is used; otherwise, the key \"DECAY_EVENT\" is used. These keys are likely used to retrieve localized strings for displaying the event type.\n\nThe method then calculates the percentage of the current durability and the absolute value of the difference in durability relative to the maximum durability of the weapon. These percentages are then used to format a string using the `StringMgr` class, which likely handles localization and string formatting.\n\nOverall, this code provides a way to represent and generate a string representation of durability events for items in the game. It is likely used in the larger Brick-Force project to handle and display events related to the durability of weapons or other items.\n## Questions: \n 1. What is the purpose of the DurabilityEvent class?\n- The DurabilityEvent class is used to represent an event related to the durability of a weapon in the game.\n\n2. What parameters are required to create a DurabilityEvent object?\n- To create a DurabilityEvent object, the code (string), durability (int), and diff (int) parameters are required.\n\n3. What does the ToString() method of the DurabilityEvent class do?\n- The ToString() method calculates and returns a formatted string that represents the event, including the name of the weapon, the current durability percentage, and the change in durability percentage.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\DurabilityEvent.md"}}],["184",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\EditingMap.cs)\n\nThe code provided is a class called `EditingMap` that represents a map in the Brick-Force project. This class has three properties: `Seq`, `MapTitle`, and `MapSize`. \n\nThe `Seq` property is an integer that represents the sequence number of the map. It has a getter and a setter method, allowing other parts of the code to get and set the value of `Seq`. \n\nThe `MapTitle` property is a string that represents the title of the map. It also has a getter and a setter method, allowing other parts of the code to get and set the value of `MapTitle`. \n\nThe `MapSize` property is a character that represents the size of the map. It also has a getter and a setter method, allowing other parts of the code to get and set the value of `MapSize`. \n\nThe class also has a constructor that takes three parameters: `s`, `title`, and `size`. These parameters are used to initialize the `Seq`, `MapTitle`, and `MapSize` properties respectively. \n\nThis `EditingMap` class can be used in the larger Brick-Force project to represent and manipulate maps. For example, it can be used to create a new map by instantiating an `EditingMap` object and setting its properties:\n\n```csharp\nEditingMap newMap = new EditingMap(1, \"My Map\", 'L');\n```\n\nIn this example, a new map is created with a sequence number of 1, a title of \"My Map\", and a size of 'L'. The `newMap` object can then be used to perform various operations on the map, such as saving it to a database or displaying its details to the user. \n\nOverall, the `EditingMap` class provides a way to represent and manipulate maps in the Brick-Force project, allowing for easy management and customization of game maps.\n## Questions: \n 1. What is the purpose of the `EditingMap` class?\n- The `EditingMap` class is used to represent a map in the Brick-Force project, with properties for the sequence, title, and size of the map.\n\n2. What are the data types of the properties `seq`, `mapTitle`, and `mapSize`?\n- The `seq` property is of type `int`, the `mapTitle` property is of type `string`, and the `mapSize` property is of type `char`.\n\n3. How are the values of the properties `seq`, `mapTitle`, and `mapSize` set?\n- The values of the properties are set through the corresponding setter methods in the class.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\EditingMap.md"}}],["185",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\EditorTool.cs)\n\nThe code provided is a class called `EditorTool` that is a part of the larger Brick-Force project. This class represents a tool that can be used in the game's editor mode. It has various properties and methods that allow it to be activated, updated, and provide information about the tool.\n\nThe `EditorTool` class has the following properties:\n\n- `battleChat`: An instance of the `BattleChat` class, which is used for handling chat functionality in the game.\n- `item`: An instance of the `Item` class, which represents an item that can be used with the tool.\n- `editorToolScript`: An instance of the `EditorToolScript` class, which contains the script for the specific tool.\n- `active`: A boolean value indicating whether the tool is currently active or not.\n\nThe class also has the following read-only properties:\n\n- `IsActive`: Returns the value of the `active` property.\n- `Icon`: Returns a `Texture2D` object representing the icon for the tool. The icon is determined based on whether the tool is enabled or disabled.\n- `Hotkey`: Returns the name of the key that activates the tool, as defined in the `EditorToolScript` class.\n- `Name`: Returns the name of the tool, as defined in the `EditorToolScript` class.\n- `Amount`: Returns the amount of the item associated with the tool, as a string. If no item is associated, it returns an empty string.\n\nThe `EditorTool` class has the following methods:\n\n- `OnClose()`: A virtual method that can be overridden in derived classes. It is called when the tool is closed.\n- `IsEnable()`: A virtual method that can be overridden in derived classes. It determines whether the tool is enabled or not. By default, it always returns true.\n- `Update()`: A virtual method that can be overridden in derived classes. It is called to update the tool. By default, it always returns false.\n- `Activate(bool activate)`: A method that activates or deactivates the tool based on the value of the `activate` parameter. If the tool is deactivated, it calls the `OnClose()` method.\n\nOverall, this `EditorTool` class provides a base implementation for different tools that can be used in the game's editor mode. It allows for customization of the tool's behavior and provides properties and methods to interact with the tool and retrieve information about it.\n## Questions: \n 1. What is the purpose of the `EditorTool` class?\n- The `EditorTool` class is used to represent an editor tool in the Brick-Force project.\n\n2. What is the significance of the `IsActive` property?\n- The `IsActive` property returns a boolean value indicating whether the editor tool is currently active or not.\n\n3. What is the purpose of the `Activate` method?\n- The `Activate` method is used to activate or deactivate the editor tool. When the tool is deactivated, the `OnClose` method is called.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\EditorTool.md"}}],["186",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\EditorTools.cs)\n\nThe `EditorTools` class is a MonoBehaviour script that is part of the Brick-Force project. This script is responsible for managing the editor tools used in the game. It contains an array of `EditorToolScript` objects, which represent different types of editor tools. The purpose of this script is to initialize and update these editor tools, as well as handle their GUI representation.\n\nThe `Start` method is called when the script is first initialized. It retrieves the `BattleChat` component attached to the same GameObject as this script. It then sets the `desc` property of each `EditorToolScript` object in the `editorToolScripts` array by calling the `Get` method of the `ConsumableManager` class with the corresponding tool name as the argument. It also creates an array of `EditorTool` objects with the same length as the `editorToolScripts` array. For each `EditorToolScript` object, it checks the name of the tool and creates the corresponding `EditorTool` object. The `EditorTool` objects are initialized with the respective `EditorToolScript`, `BattleChat`, and `Item` objects.\n\nThe `Update` method is called every frame. It iterates through the `editorTool` array and calls the `Update` method of each `EditorTool` object. If the `Update` method returns true for any `EditorTool` object, it assigns that object to the `editorTool` variable.\n\nThe `OnGUI` method is responsible for rendering the GUI representation of the editor tools. It first checks if the GUI is enabled by checking the `isGuiOn` property of the `MyInfoManager` class. It then sets the GUI skin and depth, and disables the GUI if a modal dialog is active. It calculates the position and size of the GUI group based on the number of editor tools and their dimensions. It then begins the GUI group and iterates through the `editorTool` array. For each `EditorTool` object, it renders the tool's icon, hotkey, on/off status, and amount. The GUI group is then ended, and the GUI is enabled again and the original GUI skin is restored.\n\nThe `GetActiveEditorTool` method returns the name of the currently active editor tool. It iterates through the `editorTool` array and checks if the `IsActive` property of any `EditorTool` object is true. If it finds an active tool, it returns its name. Otherwise, it returns an empty string.\n\nThe `GetLineTool` method returns the `LineTool` object from the `editorTool` array if it is active and its name is \"line_tool\". It iterates through the `editorTool` array and checks if the `IsActive` property and name of any `EditorTool` object match the conditions. If it finds a matching tool, it casts it to a `LineTool` object and returns it. Otherwise, it returns null.\n\nIn summary, this script manages the editor tools used in the game by initializing and updating them, as well as rendering their GUI representation. It provides methods to retrieve the active editor tool and the line tool specifically.\n## Questions: \n 1. What is the purpose of the `EditorTools` class?\n- The `EditorTools` class is responsible for managing and displaying various editor tools in the game.\n\n2. What is the purpose of the `GetActiveEditorTool()` method?\n- The `GetActiveEditorTool()` method returns the name of the currently active editor tool.\n\n3. What is the purpose of the `OnGUI()` method?\n- The `OnGUI()` method is responsible for rendering the GUI elements for the editor tools, including icons, hotkeys, and status indicators.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\EditorTools.md"}}],["187",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\EditorToolScript.cs)\n\nThe code provided defines a class called `EditorToolScript` that is marked as `[Serializable]`. This means that objects of this class can be serialized and deserialized, allowing them to be converted into a format that can be stored or transmitted and then reconstructed back into an object.\n\nThe `EditorToolScript` class has two properties: `desc` and `inputKey`. \n\nThe `desc` property is of type `ConsumableDesc`. It is not clear from the provided code what the `ConsumableDesc` class is, but based on the name, it seems to be a description or metadata for a consumable item in the game. This property allows an instance of `EditorToolScript` to have a reference to a `ConsumableDesc` object.\n\nThe `inputKey` property is of type `string`. It is likely used to store a keyboard input key that is associated with this particular editor tool. This property allows an instance of `EditorToolScript` to have a specific input key assigned to it.\n\nThe purpose of this code is to define a data structure that represents an editor tool in the larger Brick-Force project. An editor tool is a feature in the game that allows players to modify or create game content, such as building structures or designing levels. Each editor tool may have its own set of properties and behaviors, and this `EditorToolScript` class provides a way to define and store those properties.\n\nHere is an example of how this code might be used in the larger project:\n\n```csharp\nEditorToolScript tool = new EditorToolScript();\ntool.desc = new ConsumableDesc();\ntool.inputKey = \"E\";\n\n// Serialize the tool object into a file\nstring serializedTool = Serialize(tool);\nSaveToFile(serializedTool, \"tool_data.txt\");\n\n// Deserialize the tool object from a file\nstring serializedToolFromFile = LoadFromFile(\"tool_data.txt\");\nEditorToolScript deserializedTool = Deserialize(serializedToolFromFile);\n\n// Use the deserialized tool object\nUseTool(deserializedTool);\n```\n\nIn this example, a new `EditorToolScript` object is created and assigned a `ConsumableDesc` object and an input key. The tool object is then serialized into a string representation and saved to a file. Later, the tool object is deserialized from the file and can be used in the game.\n## Questions: \n 1. **What is the purpose of the `[Serializable]` attribute on the `EditorToolScript` class?**\nThe `[Serializable]` attribute indicates that instances of the `EditorToolScript` class can be serialized and deserialized, allowing them to be stored or transmitted as data.\n\n2. **What is the `ConsumableDesc` type and how is it related to the `EditorToolScript` class?**\nThe `ConsumableDesc` type is a class or struct that is used as a property in the `EditorToolScript` class. It likely contains additional information about a consumable item that the `EditorToolScript` class needs to reference.\n\n3. **What is the purpose of the `inputKey` property in the `EditorToolScript` class?**\nThe `inputKey` property likely represents a keyboard input key that is associated with the `EditorToolScript` class. It may be used to determine user input for certain actions or behaviors within the code.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\EditorToolScript.md"}}],["188",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\EffectivePoint.cs)\n\nThe code provided defines a class called `EffectivePoint`. This class has three public properties: `position`, `color`, and `time`. \n\nThe `position` property is of type `Vector3` and represents the position of the effective point in a 3D space. `Vector3` is a built-in Unity class that represents a 3D vector or point in space. It has three components: `x`, `y`, and `z`, which are all floating-point numbers.\n\nThe `color` property is of type `Color` and represents the color of the effective point. `Color` is also a built-in Unity class that represents a color. It has four components: `r`, `g`, `b`, and `a`, which represent the red, green, blue, and alpha channels of the color, respectively. Each component is a floating-point number between 0 and 1.\n\nThe `time` property is of type `float` and represents the time at which the effective point was created or modified. `float` is a built-in data type in C# that represents a single-precision floating-point number.\n\nThe purpose of this code is to define a data structure that can be used to represent an effective point in a 3D space, along with its color and creation/modification time. This data structure can be used in various ways within the larger Brick-Force project. For example, it could be used to store and manipulate the positions, colors, and creation/modification times of various points in a 3D environment. It could also be used as a parameter or return type for functions or methods that operate on effective points.\n\nHere is an example of how this class could be used in code:\n\n```csharp\nEffectivePoint point = new EffectivePoint();\npoint.position = new Vector3(1.0f, 2.0f, 3.0f);\npoint.color = new Color(0.5f, 0.5f, 0.5f, 1.0f);\npoint.time = Time.time;\n\n// Accessing the properties of the effective point\nVector3 position = point.position;\nColor color = point.color;\nfloat time = point.time;\n```\n\nIn this example, a new `EffectivePoint` object is created and its properties are set. The properties can then be accessed and used as needed.\n## Questions: \n 1. **What is the purpose of the `EffectivePoint` class?**\nThe `EffectivePoint` class appears to represent a point in 3D space with additional properties such as color and time. A smart developer might want to know how this class is used and what functionality it provides.\n\n2. **What is the significance of the `position` property being of type `Vector3`?**\nThe `position` property being of type `Vector3` suggests that it represents a point in 3D space using x, y, and z coordinates. A smart developer might want to understand how this property is used and if there are any specific calculations or operations performed on it.\n\n3. **How is the `time` property used in conjunction with the `position` and `color` properties?**\nThe `time` property seems to be associated with the `position` and `color` properties, but its exact purpose is not clear from the given code. A smart developer might want to know how the `time` property is used and if it affects any behavior or functionality related to the `position` and `color` properties.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\EffectivePoint.md"}}],["189",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ELog.cs)\n\nThe code provided is a class called `ELog` that contains various logging and debugging methods. The purpose of this class is to provide a convenient way to log messages and track the execution time of certain parts of the code.\n\nThe class includes several overloaded `Log` methods that take different numbers of arguments. These methods concatenate the arguments with a space separator and append the current frame count using `Time.frameCount`. The resulting string is then logged using `UnityEngine.Debug.Log`. This allows developers to easily log messages with additional information such as variable values or timestamps.\n\nHere is an example usage of the `Log` method:\n\n```csharp\nELog.Log(\"This is a log message\", 42);\n```\n\nThis would output the following log message:\n\n```\nThis is a log message 42 [frameCount]\n```\n\nThe class also includes a `StackTrace` method that logs the current stack trace using `StackTraceUtility.ExtractStackTrace`. This can be useful for debugging purposes to see the call stack leading up to a certain point in the code.\n\nThe `TimerStart` method starts a stopwatch by resetting it and then starting it. This can be used to measure the execution time of a specific section of code. The `TimerCheck` methods log the elapsed ticks of the stopwatch, which can be used to determine the execution time in a more granular way than using seconds.\n\nHere is an example usage of the timer methods:\n\n```csharp\nELog.TimerStart();\n// Code to measure execution time\nELog.TimerCheck(\"Section 1\");\n```\n\nThis would output the following log message:\n\n```\nSection 1 Timer Check [elapsedTicks]\n```\n\nFinally, the `GC` method unloads unused assets and performs garbage collection using `Resources.UnloadUnusedAssets` and `System.GC.Collect`. This can be used to free up memory and improve performance in situations where resources are no longer needed.\n\nOverall, the `ELog` class provides a set of logging and debugging utilities that can be used throughout the project to log messages, track execution time, and perform garbage collection. These methods can be helpful for troubleshooting and optimizing the code.\n## Questions: \n 1. **Question:** What is the purpose of the `ELog` class?\n   - **Answer:** The `ELog` class provides logging and debugging functionality, including logging with stack traces, timers, and garbage collection.\n\n2. **Question:** How does the `TimerStart` method work?\n   - **Answer:** The `TimerStart` method resets and starts a stopwatch, which can be used to measure elapsed time.\n\n3. **Question:** What does the `GC` method do?\n   - **Answer:** The `GC` method unloads unused assets, performs garbage collection, and waits for pending finalizers to complete.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ELog.md"}}],["190",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\EnableScript.cs)\n\nThe code provided is a class called `EnableScript` that extends the `ScriptCmd` class. This class is likely a part of the larger Brick-Force project and is used to enable or disable a script.\n\nThe `EnableScript` class has two private fields: `id` and `enable`. These fields are used to store the ID of the script and a boolean value indicating whether the script should be enabled or disabled.\n\nThe class also has two public properties: `Id` and `Enable`. These properties provide access to the private fields and allow getting and setting their values. The `Id` property is of type `int` and the `Enable` property is of type `bool`.\n\nThe class overrides several methods from the `ScriptCmd` class. The `GetIconIndex` method returns an integer representing the icon index for the script. In this case, it always returns 0.\n\nThe `GetDescription` method returns a string representation of the script's description. It concatenates the string \"enablescript\" with the value of the `id` field, followed by the value of the `enable` field. The `ScriptCmd.ArgDelimeters[0]` is used as a delimiter between the different parts of the description.\n\nThe `GetDefaultDescription` method returns a default description for the script. It is similar to the `GetDescription` method, but with default values of `-1` for the `id` field and `true` for the `enable` field.\n\nThe `GetName` method returns the name of the script, which is \"EnableScript\".\n\nOverall, this code provides a class that represents an enable/disable script in the Brick-Force project. It allows getting and setting the ID and enable status of the script, as well as retrieving a description and default description for the script.\n## Questions: \n 1. What is the purpose of the `EnableScript` class?\n- The `EnableScript` class is a subclass of `ScriptCmd` and is used to enable or disable a script.\n\n2. What is the significance of the `Id` and `Enable` properties?\n- The `Id` property represents the ID of the script, and the `Enable` property represents whether the script should be enabled or disabled.\n\n3. What is the purpose of the `GetDescription` method?\n- The `GetDescription` method returns a string that describes the `EnableScript` object, including the ID and enable status of the script.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\EnableScript.md"}}],["191",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\EnemyRecognitor.cs)\n\nThe code provided is a script called \"EnemyRecognitor\" that is used in the Brick-Force project. This script is responsible for recognizing and displaying enemy players in the game.\n\nThe script starts by declaring a public variable called \"guiDepth\" of type \"GUIDepth.LAYER\". This variable determines the depth at which the enemy player labels will be displayed on the GUI.\n\nThe script also declares a private variable called \"enemy\" of type \"BrickManDesc\". This variable will store information about the enemy player that is currently being targeted.\n\nThe script also declares a private variable called \"cam\" of type \"Camera\". This variable will store a reference to the main camera in the scene.\n\nThe \"Start\" method is called when the script is first initialized. It checks if the \"cam\" variable is null and if so, it finds the main camera in the scene and assigns it to the \"cam\" variable.\n\nThe \"IsVisible\" method takes a position and a sequence number as parameters and returns a boolean value indicating whether the enemy player at that position is visible to the camera. It calculates the distance between the camera and the enemy player position and if it is greater than 15 units, it returns false. It then creates a layer mask that includes specific layers related to the game objects that can obstruct the view of the enemy player. It casts a ray from the camera towards the enemy player position and checks if it hits any game objects within the layer mask. If it does, it checks if the hit game object is a \"BoxMan\" (enemy player) and if its sequence number matches the provided sequence number. If both conditions are true, it returns true indicating that the enemy player is visible.\n\nThe \"OnGUI\" method is called every frame to update the GUI. It first checks if certain conditions are met, such as the enemy player nickname not being hidden, the GUI being turned on, and the player not being a spectator. It then sets the GUI skin, depth, and enables GUI interaction. It retrieves an array of game objects representing all the players in the game. For each player, it calculates two positions above the player's position. It checks if the player is hostile and not hidden, and then checks if the player is the currently targeted enemy player or if the player is visible to the camera using the \"IsVisible\" method. If either condition is true, it converts the player's position to viewport coordinates and checks if it is within the screen boundaries. If it is, it converts the player's position to screen coordinates and displays the player's nickname using a custom label utility.\n\nThe \"Update\" method is called every frame to update the state of the script. It first sets the \"enemy\" variable to null. If the \"cam\" variable is not null, it creates a layer mask similar to the one used in the \"IsVisible\" method. It casts a ray from the center of the screen towards the scene and checks if it hits any game objects within the layer mask. If it does, it checks if the hit game object is a \"BoxMan\" (enemy player) and if it is hostile. If both conditions are true, it assigns the enemy player's information to the \"enemy\" variable.\n\nIn summary, this script is responsible for recognizing and displaying enemy players in the game. It uses the camera to determine if an enemy player is visible and displays their nickname above their position on the screen. This script is likely used in the larger Brick-Force project to enhance the gameplay experience by providing players with information about enemy players in real-time.\n## Questions: \n 1. What is the purpose of the `IsVisible` method and how is it used in the code?\n- The `IsVisible` method checks if a given position is visible to the camera and returns a boolean value. It is used to determine if a player's position should be displayed on the screen.\n\n2. What is the purpose of the `OnGUI` method and when is it called?\n- The `OnGUI` method is responsible for rendering the enemy player's nickname on the screen if they are visible and meet certain conditions. It is called during the GUI rendering phase.\n\n3. What is the purpose of the `Update` method and when is it called?\n- The `Update` method is used to update the `enemy` variable by checking if the camera is pointing at an enemy player. It is called every frame to ensure the `enemy` variable is up to date.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\EnemyRecognitor.md"}}],["192",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Equip.cs)\n\nThe code provided is a simple script called \"Equip\" that is a part of the larger Brick-Force project. This script is written in C# and uses the Unity game engine.\n\nThe purpose of this script is to define a class called \"Equip\" that has a public variable called \"tItem\" of type \"TItem\". The \"TItem\" type is not defined in this script, so it is likely defined in another script or class within the project.\n\nThe \"Equip\" class is likely used to represent an equipment item in the game. By having a public variable of type \"TItem\", this script allows other scripts or classes to access and modify the equipment item associated with an instance of the \"Equip\" class.\n\nFor example, if we have an instance of the \"Equip\" class called \"equipInstance\", we can access and modify its \"tItem\" variable like this:\n\n```csharp\nequipInstance.tItem = new TItem();\n```\n\nThis code creates a new instance of the \"TItem\" class (which is assumed to be defined elsewhere) and assigns it to the \"tItem\" variable of the \"equipInstance\" object.\n\nThe \"Equip\" script itself does not contain any methods or functions, so its purpose is primarily to serve as a data container for the \"tItem\" variable. Other scripts or classes within the Brick-Force project can use instances of the \"Equip\" class to store and manipulate equipment items.\n\nOverall, this script plays a small but important role in the larger Brick-Force project by providing a way to represent and manage equipment items.\n## Questions: \n 1. What is the purpose of the `TItem` class and how is it related to the `Equip` class? \n- The `TItem` class is likely a custom class that represents an item, and the `Equip` class has a public variable `tItem` of type `TItem` to store an instance of an item.\n\n2. What other components or scripts are attached to the GameObject that this `Equip` script is attached to? \n- This code snippet does not provide any information about other components or scripts attached to the GameObject. \n\n3. How is the `Equip` class being used in the overall game logic? \n- Without additional context, it is unclear how the `Equip` class is being used in the game logic. It could potentially be used to handle equipping and managing items for a player character.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Equip.md"}}],["193",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Erasing.cs)\n\nThe code provided is a simple class called `Erasing` that is used to track the time elapsed between frames in a game or simulation. \n\nThe `Erasing` class has a single public field called `deltaTime`, which is a float value representing the time in seconds between the current frame and the previous frame. \n\nThe purpose of this class is to provide a way to measure the time between frames, which is useful for various game-related calculations and animations. For example, it can be used to control the speed of character movement, the rate of object spawning, or the timing of particle effects.\n\nBy updating the `deltaTime` field each frame, other parts of the game code can access this value and use it to calculate the necessary changes or animations based on the elapsed time. \n\nHere's an example of how this class might be used in a game loop:\n\n```csharp\nErasing erasing = new Erasing();\n\nwhile (gameRunning)\n{\n    // Calculate the time between frames\n    float deltaTime = erasing.deltaTime;\n\n    // Update game logic based on deltaTime\n    UpdateGameLogic(deltaTime);\n\n    // Render the game based on deltaTime\n    RenderGame(deltaTime);\n\n    // Wait for the next frame\n    WaitForNextFrame();\n}\n```\n\nIn this example, the `deltaTime` value is passed to the `UpdateGameLogic` and `RenderGame` methods, which can use it to adjust the game state and render the game accordingly. This ensures that the game runs smoothly regardless of the frame rate or performance of the system it is running on.\n\nOverall, the `Erasing` class provides a simple and convenient way to measure the time between frames in a game or simulation, allowing for more accurate and consistent animations and calculations.\n## Questions: \n 1. **What is the purpose of the `Erasing` class?**\nThe `Erasing` class appears to be a class that is used to track the time elapsed since the last erasing action in the Brick-Force project.\n\n2. **Why is the `deltaTime` variable declared as public?**\nThe `deltaTime` variable is declared as public, which means it can be accessed and modified by other classes or objects. It would be helpful to understand why this variable needs to be publicly accessible.\n\n3. **Why is the `deltaTime` variable initialized to 0f in the constructor?**\nThe `deltaTime` variable is initialized to 0f in the constructor of the `Erasing` class. It would be useful to know if this initial value has any significance or if it is just a default value.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Erasing.md"}}],["194",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Escape.cs)\n\nThe code provided is a script for the \"Escape\" class in the Brick-Force project. This class is responsible for managing various aspects of the game related to the player's escape from a certain location. \n\nThe code begins by declaring and initializing several variables, including a constant float value for the goal respawn time, a deltaTime variable for tracking time, a boolean variable for delaying loading, and references to other classes and components such as BattleChat and LocalController.\n\nThe InitializeFirstPerson() method is called to set up the player's first-person perspective. It retrieves the current weapon option from the RoomManager class and initializes an array of integers based on the weapon option. It then finds the player object in the scene and retrieves the EquipCoordinator and LocalController components attached to it. The EquipCoordinator component is used to initialize the player's weapons based on the weapon option, and the LocalController component is stored in the localController variable for later use.\n\nThe OnLoadComplete() method is called when the loading of the game is complete. It first calls the Load() method of the TrainManager class to load the train. It then retrieves a SpawnerDesc object from the BrickManager class based on the player's ticket. If a spawner is found, the localController's Spawn() method is called with the position and rotation of the spawner. Otherwise, a random spawn position and rotation are used. \n\nNext, the method checks if the player has enabled the escape guide dialog. If not, it retrieves the EscapeGuideDialog instance from the DialogManager class and initializes it. This dialog provides guidance to the player on how to escape from the current location.\n\nThe Start() method is called when the script starts. It performs various initialization tasks such as clearing dropped weapons, applying audio sources, setting up the camera for visual effects optimization, and calling the DoBuff() method of the ShooterTools component attached to the \"Main\" object in the scene.\n\nThe StartLoad() method is called to start the loading process. It first calls the Collect() method of the GC class to perform garbage collection. Then, it creates a new UserMap object and attempts to load the current map from the RoomManager class. If the map is successfully loaded, it assigns the userMap variable of the BrickManager class to the loaded map. Otherwise, it creates a new UserMap object and sends a cache brick request to the CSNetManager class.\n\nThe ResetGameStuff() method is called to reset various game-related data and objects. It calls the ResetGameStuff() method of the MyInfoManager class and the UnLoad() method of the TrainManager class. It also retrieves an array of BrickManDesc objects from the BrickManManager class and calls the ResetGameStuff() method for each object in the array.\n\nThe Awake() method is empty and does not contain any code.\n\nThe OnDisable() method is called when the script is disabled. If the application is currently loading a level, it calls the ResetGameStuff() method, unlocks the cursor, and clears the BrickManager.\n\nThe OnGUI() method is called to handle GUI rendering. It sets the GUI skin to the one obtained from the GUISkinFinder class.\n\nThe Update() method is called every frame. It first checks if the Connecting component is attached to the script and if it is currently showing. If so, it sets a flag to true. Then, it sets the lockCursor property of the Screen class based on various conditions, such as whether the application is loading a level, whether the player is chatting, whether a modal dialog is open, and whether the Connecting component is showing.\n\nIf the delayLoad variable is true, the method increments the deltaTime variable by the time since the last frame. If deltaTime exceeds 1 second, delayLoad is set to false and the StartLoad() method is called.\n\nIf delayLoad is false and the application is not loading a level, the method checks for various input conditions. If the player presses the main menu button and certain conditions are met, it opens the MenuEx dialog and checks if any players have taken too long to wait. If the player presses the help button and certain conditions are met, it opens the HelpWindow dialog. The method also updates the flashbang effect and checks if the goal respawn is active. If so, it increments the goalRespawnTime variable and if it exceeds 5 seconds, it sets isGoalRespawn to false, sends a reset signal to the EscapeGoalTrigger class, and respawns the player at a spawner position.\n\nThe GoalRespawn() method is a public method that resets the goal respawn time and sets isGoalRespawn to true.\n\nIn summary, this code manages the player's escape from a location in the game. It handles various initialization tasks, loading of game elements, GUI rendering, input handling, and respawn logic. It interacts with other classes and components to coordinate the gameplay experience.\n## Questions: \n 1. What is the purpose of the `InitializeFirstPerson()` method?\n- The `InitializeFirstPerson()` method is responsible for initializing the player's equipment and controller components based on the selected weapon option.\n\n2. What does the `OnLoadComplete()` method do?\n- The `OnLoadComplete()` method loads the train manager, spawns the player at a specific position, and displays an escape guide dialog if certain conditions are met.\n\n3. What is the purpose of the `ResetGameStuff()` method?\n- The `ResetGameStuff()` method resets various game-related components and clears the brick manager when the game is disabled or a new level is being loaded.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Escape.md"}}],["195",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\EscapeGoalTrigger.cs)\n\nThe code provided is a script for an EscapeGoalTrigger class in the Brick-Force project. This class is responsible for triggering a goal when a player enters a specific area in the game. \n\nThe class has a private static boolean variable called \"isSendGoal\" which keeps track of whether the goal has been sent or not. The variable is initially set to false. \n\nThe Start() method is called when the game starts and it calls the GoalSendReset() method. This method resets the \"isSendGoal\" variable to false. \n\nThe OnTriggerEnter() method is called when a player enters the trigger area. It first checks if the current scene is not the MapEditor scene. If it is not, it then checks if the colliding object has a LocalController component attached to it. If it does and the \"isSendGoal\" variable is false, it sets the \"isSendGoal\" variable to true and sends two network requests using the CSNetManager.Instance.Sock object. The first request is to send a respawn ticket request and the second request is to send an escape goal request. \n\nThe class also has two public static methods. The GoalSendReset() method resets the \"isSendGoal\" variable to false. This method can be called from other classes or scripts to reset the goal sending state. The IsSendGoal() method returns the current value of the \"isSendGoal\" variable. This method can be called from other classes or scripts to check if the goal has been sent or not. \n\nOverall, this class is used to handle the triggering of a goal when a player enters a specific area in the game. It keeps track of whether the goal has been sent or not and provides methods to reset the goal sending state and check the current state.\n## Questions: \n 1. What is the purpose of the `EscapeGoalTrigger` class?\n- The `EscapeGoalTrigger` class is responsible for triggering certain actions when a collider enters its trigger zone.\n\n2. What is the significance of the `GoalSendReset` method?\n- The `GoalSendReset` method is used to reset the `isSendGoal` variable to false, indicating that the goal has not been sent.\n\n3. What is the purpose of the `IsSendGoal` method?\n- The `IsSendGoal` method is used to check the value of the `isSendGoal` variable, indicating whether the goal has been sent or not.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\EscapeGoalTrigger.md"}}],["196",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\EscapeGuideDialog.cs)\n\nThe code provided is a class called `EscapeGuideDialog` that extends the `Dialog` class. This class is used to create a dialog box with various UI elements such as an image list, label list, toggle, and a button. The purpose of this code is to display a dialog box with some content and allow the user to interact with it.\n\nThe `EscapeGuideDialog` class has several public variables that represent the UI elements used in the dialog box. These variables include `imgList` (an instance of `UIImageList`), `labelList` (an instance of `UILabelList`), `toggle` (an instance of `UIToggle`), and `ok` (an instance of `UIMyButton`). These variables are used to draw and interact with the UI elements in the `DoDialog()` method.\n\nThe `Start()` method sets the `id` of the dialog box to a specific value from an enum called `DIALOG_INDEX`. This is likely used to identify and manage different types of dialogs in the larger project.\n\nThe `OnPopup()` method calculates the position of the dialog box based on the screen size and the size of the dialog box itself. This ensures that the dialog box is centered on the screen when it is displayed.\n\nThe `InitDialog()` method is empty and does not have any functionality. It is likely intended to be overridden in subclasses to initialize the dialog box with specific content.\n\nThe `DoDialog()` method is the main method that is called to display and handle user interaction with the dialog box. It first sets the GUI skin to a specific skin obtained from `GUISkinFinder.Instance.GetGUISkin()`. Then, it calls the `Draw()` method on the UI elements (`imgList`, `labelList`, `toggle`, and `ok`) to draw them on the screen. It checks if the `ok` button is clicked and if the `toggle` is checked. If the `toggle` is checked, it saves a specific value to an instance of `MyInfoManager` to indicate that the user has chosen to not show this message again. Finally, it returns a boolean value indicating whether the dialog box should be closed (`true`) or not (`false`).\n\nOverall, this code provides the functionality to create and display a dialog box with various UI elements and handle user interaction with it. It can be used in the larger project to show informative messages or prompts to the user and allow them to make choices or dismiss the dialog box.\n## Questions: \n 1. What is the purpose of the `EscapeGuideDialog` class?\n- The `EscapeGuideDialog` class is a subclass of `Dialog` and represents a dialog box for an escape guide.\n\n2. What is the purpose of the `InitDialog()` method?\n- The `InitDialog()` method does not have any code inside it, so a smart developer might wonder why it exists and what its intended purpose is.\n\n3. What does the `DoDialog()` method do?\n- The `DoDialog()` method is responsible for drawing the dialog elements, handling user input, and returning a boolean result indicating whether the dialog should be closed or not.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\EscapeGuideDialog.md"}}],["197",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\EscapeModeConfig.cs)\n\nThe code provided is a class called `EscapeModeConfig` that is used in the larger Brick-Force project. This class is responsible for displaying and handling the GUI elements related to the escape mode configuration in the game.\n\nThe `EscapeModeConfig` class has several private fields that define the positions and dimensions of various GUI elements, such as thumbnails, buttons, and labels. These fields are used to position and size the GUI elements correctly on the screen.\n\nThe `OnGUI` method is the main entry point of this class and is responsible for rendering the GUI elements on the screen. It first checks if a thumbnail image is available for the current map. If a thumbnail is available, it is displayed using the `TextureUtil.DrawTexture` method. Depending on the properties of the map, such as its tag mask, different icons are also displayed using the same method.\n\nThe method then displays the alias and mode of the current room using the `LabelUtil.TextOut` method. It also calls the `DoOption` method to display additional options related to the room, such as time limit and arrival count. If the user is the master of the room, a configuration button is displayed, which opens a dialog to change the room configuration when clicked.\n\nThe `DoOption` method is responsible for displaying the additional options related to the room. It uses the `LabelUtil.TextOut` method to display the option labels and values. The values are retrieved from the `room` object passed as a parameter to the method.\n\nThe `ShowTooltip` method is used to display a tooltip when the user hovers over a GUI element. It uses the `LabelUtil.TextOut` method to display the tooltip message.\n\nThe `Start` method is empty and does not have any functionality.\n\nIn summary, the `EscapeModeConfig` class is responsible for rendering and handling the GUI elements related to the escape mode configuration in the Brick-Force game. It displays the map thumbnail, room alias, room mode, and additional options such as time limit and arrival count. It also provides a configuration button for the room master to change the room configuration.\n## Questions: \n **Question 1:** What is the purpose of the `OnGUI()` method?\n    \n**Answer:** The `OnGUI()` method is responsible for rendering the graphical user interface for the EscapeModeConfig class. It displays various textures, labels, and buttons based on the current state of the game.\n\n**Question 2:** What does the `DoOption()` method do?\n    \n**Answer:** The `DoOption()` method is used to display and configure various options related to the game room, such as time limit, arrival count, break-in status, escape mode option, and item drop option.\n\n**Question 3:** What is the purpose of the `ShowTooltip()` method?\n    \n**Answer:** The `ShowTooltip()` method is called when there is a tooltip message to be displayed. It renders the tooltip message as a label with a yellow color in the upper-left corner of the GUI window.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\EscapeModeConfig.md"}}],["198",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\EscapeRanking.cs)\n\nThe `EscapeRanking` class is a script that is part of the Brick-Force project. It is responsible for managing the ranking system in the game. The code defines various variables and methods to handle the ranking display and updates.\n\nThe `Start` method is called when the script is initialized. It first finds the GameObject with the name \"Me\" and assigns it to the `localController` variable. If the GameObject or the `LocalController` component is not found, it logs an error message. It then initializes arrays for storing the current rank, next rank, and whether the rank has increased for each player. The arrays are filled with default values.\n\nThe `OnGUI` method is called to draw the GUI elements on the screen. It first checks if the GUI is enabled and if there are any active dialogs. It then begins a GUI group and draws the player's ranking and kill count. It also retrieves the top 3 rankings from the `BrickManManager` and displays their clan mark, nickname, and kill count. If the player's rank matches one of the top 3 rankings, their ranking image is updated. Finally, it ends the GUI group and enables the GUI.\n\nThe `Update` method is called every frame. It updates the ranking display and the effects for each rank.\n\nThe `UpdateRanking` method is responsible for updating the ranking information. It retrieves the sorted list of players from the `BrickManManager` and compares the player's kill count, score, and sequence number with the other players to determine their rank. It updates the `rankNext` array with the new rankings. If the player's rank has changed, it resets the ranking effect for the player. It also checks if any of the top 3 rankings have changed and resets their effects accordingly.\n\nThe `IsUpRankingBySeq` method checks if the player's rank has increased based on their sequence number.\n\nThe `IsUpRankingByRanking` method checks if a specific ranking has increased.\n\nThe `DrawClanMark` method is used to draw the clan mark for a player. It retrieves the background, color, and emblem textures for the clan mark from the `ClanMarkManager` and draws them on the screen.\n\nOverall, this script manages the ranking display and updates in the game. It retrieves the player's rank and updates it based on their kill count, score, and sequence number. It also updates the rankings for the top 3 players and displays their clan marks, nicknames, and kill counts. The script provides methods to check if a player's rank has increased and to draw the clan mark for a player.\n## Questions: \n 1. What is the purpose of the `UpdateRanking()` method?\n- The `UpdateRanking()` method is responsible for updating the ranking of players based on their kills, scores, and sequence numbers.\n\n2. What does the `IsUpRankingBySeq()` method do?\n- The `IsUpRankingBySeq()` method checks if a player's ranking has increased based on their sequence number.\n\n3. What is the purpose of the `DrawClanMark()` method?\n- The `DrawClanMark()` method is used to draw the clan mark of a player on the GUI using the provided rectangle and clan mark ID.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\EscapeRanking.md"}}],["199",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\EscapeScore.cs)\n\nThe code provided is a part of the Brick-Force project and is contained in a file called \"EscapeScore.cs\". This code is responsible for managing and displaying the score and goal information in the game's user interface (UI).\n\nThe `EscapeScore` class inherits from the `MonoBehaviour` class, which is a base class provided by the Unity game engine. This allows the class to have access to various Unity-specific functionalities and events.\n\nThe class has several public variables, including `guiDepth`, `scoreFont`, `goalFont`, `scoreBg`, `size`, `crdScore`, and `crdGoal`. These variables are used to configure the appearance and positioning of the score and goal elements in the UI.\n\nThe `Start` method is called when the game starts. It initializes the `score` variable to 0 and checks if the player is currently breaking into something. If the player is breaking into something, it sends a request to the server to retrieve the individual score.\n\nThe `OnEscapeScore` method is called when the player successfully escapes. It updates the scale of the `scoreFont` and sets the `score` variable to the total number of kills.\n\nThe `OnGUI` method is responsible for rendering the UI elements. It first checks if the GUI is enabled and then sets the GUI skin and depth. It then begins a GUI group with a specific size and position, and draws a background texture using the `scoreBg` variable. It then prints the current score and goal using the `scoreFont` and `goalFont` variables respectively. Finally, it ends the GUI group and resets the GUI skin.\n\nThe `Update` method is empty and does not contain any code. This suggests that the class does not require any continuous updates or calculations.\n\nOverall, this code is an essential part of the Brick-Force project as it handles the display and management of the score and goal information in the game's UI. It interacts with other components such as the `MyInfoManager`, `CSNetManager`, `DialogManager`, and `RoomManager` to retrieve and update the necessary data.\n## Questions: \n 1. What is the purpose of the `EscapeScore` class?\n- The `EscapeScore` class is responsible for displaying the score and goal information on the GUI.\n\n2. What is the significance of the `scoreFont` and `goalFont` variables?\n- The `scoreFont` and `goalFont` variables are used to specify the fonts to be used for displaying the score and goal information on the GUI.\n\n3. What triggers the `OnEscapeScore` method and what does it do?\n- The `OnEscapeScore` method is triggered by an event and it sets the scale of the `scoreFont` and updates the `score` variable with the total number of kills.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\EscapeScore.md"}}],["200",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\EscapeSituation.cs)\n\nThe `EscapeSituation` class is a script that is used to display information about players in a game situation. It is part of the larger Brick-Force project, which is a game that involves building and destroying virtual structures using bricks.\n\nThe purpose of this script is to show a graphical user interface (GUI) that displays information about each player in the game. The GUI is only shown when a specific button is pressed (`K_SITUATION`). The information displayed includes the player's clan mark, badge, nickname, kill count, score, and ping time. The GUI also includes a title for the current room.\n\nThe script uses various variables to define the positions and sizes of the GUI elements. For example, the `crdFrame` variable defines the position and size of the main frame of the GUI, while the `crdSituation` variable defines the position and size of the area where player information is displayed.\n\nThe `OnGUI` method is responsible for drawing the GUI. It first checks if the GUI should be shown based on the state of the game and the `on` variable. It then sets the GUI skin and depth, and begins a GUI group to contain all the GUI elements. It draws various boxes and labels to display the player information, using utility methods like `LabelUtil.TextOut` and `TextureUtil.DrawTexture` to handle the drawing.\n\nThe `GridOut` method is used to draw the information for each player. It takes in various parameters like the player's clan mark, XP, rank, nickname, kill count, and score, and uses the utility methods to draw the corresponding GUI elements.\n\nThe `VerifyLocalController` method is used to find and assign a reference to the `LocalController` component, which is responsible for controlling the player's character in the game.\n\nThe `Start` and `Update` methods are empty and do not have any functionality.\n\nIn summary, this script is used to display a GUI that shows information about each player in the game, including their clan mark, badge, nickname, kill count, score, and ping time. It is part of the larger Brick-Force project and is used to enhance the gameplay experience by providing players with relevant information about their opponents.\n## Questions: \n 1. What is the purpose of the `VerifyLocalController()` method?\n- The `VerifyLocalController()` method is used to check if the `localController` variable is null and if so, it finds the GameObject with the name \"Me\" and assigns its `LocalController` component to the `localController` variable.\n\n2. What does the `GridOut()` method do?\n- The `GridOut()` method is responsible for displaying information about a player in a grid format. It takes various parameters such as clan mark, XP, rank, nickname, kill count, score, average ping, status, and whether the player is dead or not, and displays them in the appropriate positions in the grid.\n\n3. What triggers the `OnGUI()` method to be called?\n- The `OnGUI()` method is called when the `isGuiOn` property of the `MyInfoManager.Instance` object is true and the `on` variable is also true.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\EscapeSituation.md"}}],["201",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Exit.cs)\n\nThe code provided is a class called \"Exit\" that extends the \"ScriptCmd\" class. This class is likely a part of a larger project called Brick-Force, which is not explicitly mentioned in the code.\n\nThe purpose of this code is to define the behavior and properties of an \"Exit\" command in the Brick-Force project. The \"Exit\" command is used to exit or terminate a certain process or action within the project.\n\nThe class has several methods that provide information about the \"Exit\" command. The \"GetDescription()\" method returns a string that describes the command, in this case, it returns the string \"Exit\". The \"GetIconIndex()\" method returns an integer that represents the index of the icon associated with the command, in this case, it returns the integer 4.\n\nThe class also has a static method called \"GetDefaultDescription()\" that returns a string with the default description of the command, which is \"exit\". This method is likely used to provide a default value for the description if it is not explicitly set.\n\nLastly, the class has a \"GetName()\" method that returns a string with the name of the command, which is also \"Exit\".\n\nOverall, this code defines the behavior and properties of the \"Exit\" command in the Brick-Force project. It provides methods to retrieve the description, icon index, default description, and name of the command. This class can be used in the larger project to handle the logic and functionality related to the \"Exit\" command. For example, it can be used to implement a button or menu option that allows the user to exit a certain process or action within the project.\n## Questions: \n 1. **What is the purpose of the `Exit` class?**\nThe `Exit` class is a subclass of `ScriptCmd` and it likely represents a command or action related to exiting or terminating a process.\n\n2. **What does the `GetDescription` method do?**\nThe `GetDescription` method returns a string that describes the purpose or functionality of the `Exit` class.\n\n3. **What is the significance of the `GetIconIndex` method?**\nThe `GetIconIndex` method returns an integer value that likely represents the index of an icon associated with the `Exit` class.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Exit.md"}}],["202",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ExitConfirmDialog.cs)\n\nThe code provided is a class called `ExitConfirmDialog` that extends the `Dialog` class. This class is responsible for displaying a confirmation dialog box when the user tries to exit a certain section of the game. The purpose of this code is to handle the logic and rendering of the exit confirmation dialog.\n\nThe `ExitConfirmDialog` class has several properties and methods that control its behavior. \n\nThe `text` property is a string that holds the message to be displayed in the dialog box. This message can be set using the `InitDialog` method, which takes a string parameter. There are two overloaded versions of this method - one that sets the `text` property and another that sets the `softExit` property to `true`. \n\nThe `msgY` property is a float that determines the vertical position of the message in the dialog box. \n\nThe `sizeOk` property is a `Vector2` that represents the size of the \"OK\" button in the dialog box. \n\nThe `Line` property is an integer that represents the number of lines in the `text` message. \n\nThe `IsLong` property is a boolean that indicates whether the `text` message is long enough to require a different layout in the dialog box. \n\nThe `softExit` property is a boolean that determines whether the exit action should be a soft exit or a hard exit. \n\nThe `closeButtonHide` property is a boolean that determines whether the close button should be hidden in the dialog box. \n\nThe `Start` method sets the `id` property of the dialog to a specific value. \n\nThe `OnPopup` method sets the position and size of the dialog box based on the screen size. \n\nThe `DoDialog` method is responsible for rendering the dialog box and handling user input. It first checks if the `text` property is empty. If it is, it displays a default exit message using the `LabelUtil.TextOut` method. If the `text` property is not empty, it calculates the number of lines in the `text` message and sets the `IsLong` property accordingly. It then displays the `text` message using the `LabelUtil.TextOut` method. \n\nThe method also checks for button clicks on the \"OK\" button and the close button. If the \"OK\" button is clicked, it performs the appropriate exit action based on the value of the `softExit` property. If the close button is clicked, it sets the `result` variable to `true`. \n\nThe `CloseButtonHide` method allows the caller to hide or show the close button in the dialog box by setting the `closeButtonHide` property.\n\nIn the larger project, this code would be used to display an exit confirmation dialog whenever the user tries to exit a certain section of the game. The dialog can be customized by setting the `text` property and other properties before showing the dialog. The result of the dialog can be obtained by calling the `DoDialog` method and checking the return value.\n## Questions: \n 1. What is the purpose of the `ExitConfirmDialog` class?\n- The `ExitConfirmDialog` class is a subclass of the `Dialog` class and is used to create a dialog box for confirming an exit action.\n\n2. What is the significance of the `IsLong` variable?\n- The `IsLong` variable is used to determine if the text in the dialog box is long enough to require a different layout and positioning.\n\n3. What is the purpose of the `InitDialog(string textMore)` method?\n- The `InitDialog(string textMore)` method is used to initialize the dialog with a specific text message that will be displayed in the dialog box.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ExitConfirmDialog.md"}}],["203",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ExplosionAttackGuideDialog.cs)\n\nThe code provided is a class called `ExplosionAttackGuideDialog` that extends the `Dialog` class. This class represents a dialog box that provides a guide for an explosion attack in the larger Brick-Force project. \n\nThe class has several public fields that are used to display various UI elements in the dialog box. These include `imgList`, `labelList`, `toggle`, and `ok`. The `imgList` and `labelList` are instances of `UIImageList` and `UILabelList` classes respectively, which are responsible for drawing images and labels in the dialog box. The `toggle` field is an instance of `UIToggle` class, which represents a toggle button that allows the user to choose whether to show the message again or not. The `ok` field is an instance of `UIMyButton` class, which represents a button that the user can click to close the dialog box.\n\nThe class also has a property called `DontShowThisMessageAgain`, which returns the value of the `toggle.toggle` field. This property is used to determine whether the user has chosen to not show the message again.\n\nThe class overrides two methods from the `Dialog` class: `Start()` and `OnPopup()`. The `Start()` method sets the `id` field of the dialog to a specific value. The `OnPopup()` method calculates the position of the dialog box based on the screen size.\n\nThe class has a method called `InitDialog()`, which is currently empty and does not have any functionality.\n\nThe class also overrides the `DoDialog()` method from the `Dialog` class. This method is responsible for drawing the UI elements in the dialog box and handling user interactions. It first sets the GUI skin to a specific skin obtained from `GUISkinFinder.Instance.GetGUISkin()`. Then, it calls the `Draw()` method on the `imgList`, `labelList`, `toggle`, and `ok` fields to draw the respective UI elements. It also displays a label with a formatted text using the `GUI.Label()` method. If the user clicks the `ok` button, it checks if the `DontShowThisMessageAgain` property is true, and if so, it saves a specific value to the `MyInfoManager.Instance` object. Finally, it checks if there is no other popup menu open and calls the `WindowUtil.EatEvent()` method to consume the event.\n\nIn summary, this code represents a dialog box that provides a guide for an explosion attack in the Brick-Force project. It displays various UI elements and allows the user to choose whether to show the message again or not. The code also handles user interactions and saves the user's preference if they choose to not show the message again.\n## Questions: \n 1. What is the purpose of the `ExplosionAttackGuideDialog` class?\n- The `ExplosionAttackGuideDialog` class is a subclass of `Dialog` and represents a dialog box for guiding the player on how to perform an explosion attack.\n\n2. What is the significance of the `DontShowThisMessageAgain` property?\n- The `DontShowThisMessageAgain` property returns the value of the `toggle` field, indicating whether the player has chosen to not show this message again.\n\n3. What is the purpose of the `DoDialog` method?\n- The `DoDialog` method is responsible for drawing the dialog box on the screen and handling user interactions. It returns a boolean value indicating whether the dialog should be closed.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ExplosionAttackGuideDialog.md"}}],["204",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ExplosionDefenceGuideDialog.cs)\n\nThe code provided is a class called `ExplosionDefenceGuideDialog` that extends the `Dialog` class. This class represents a dialog box that provides a guide for explosion defense in the larger Brick-Force project. \n\nThe class has several public fields, including `imgList`, `labelList`, `toggle`, and `ok`, which are all UI elements used in the dialog box. These fields are likely assigned in the Unity editor or through code elsewhere in the project.\n\nThe `DontShowThisMessageAgain` property returns the value of the `toggle` field's `toggle` property. This property is used to determine whether the user has selected the option to not show the message again.\n\nThe `Start` method sets the `id` field of the dialog to a specific value from the `DialogManager.DIALOG_INDEX` enum. This is likely used for identifying and managing different types of dialogs in the project.\n\nThe `OnPopup` method sets the `rc` field to a specific `Rect` value based on the screen size and the size of the dialog box. This is used to position the dialog box in the center of the screen when it is displayed.\n\nThe `InitDialog` method is empty and does not have any functionality. It may be intended to be overridden in subclasses or used for future development.\n\nThe `DoDialog` method is the main method that handles the rendering and functionality of the dialog box. It first sets the `skin` variable to the current GUI skin and then sets it to a specific GUI skin obtained from `GUISkinFinder.Instance.GetGUISkin()`. This suggests that the dialog box has a specific visual style defined by the GUI skin.\n\nThe method then retrieves a localized string using `StringMgr.Instance.Get(\"GUIDE_EXPLOSION_DEFENCE04\")` and formats it with a key code obtained from `custom_inputs.Instance.GetKeyCodeName(\"K_ACTION\")`. The resulting string is then displayed as a label at the position specified by the `crdMsg` field.\n\nNext, the `imgList`, `labelList`, `toggle`, and `ok` UI elements are drawn on the screen.\n\nIf the `ok` button is clicked, the method checks if the `DontShowThisMessageAgain` property is true. If it is, it saves a specific option related to explosion defense in the `MyInfoManager.Instance.SaveDonotCommonMask` method.\n\nFinally, if there is no other popup menu currently open, the `WindowUtil.EatEvent()` method is called to prevent further input events from being processed.\n\nOverall, this code represents a specific dialog box in the Brick-Force project that provides a guide for explosion defense. It handles rendering the UI elements, displaying text, and saving user preferences.\n## Questions: \n 1. What is the purpose of the `ExplosionDefenceGuideDialog` class?\n- The `ExplosionDefenceGuideDialog` class is a subclass of the `Dialog` class and represents a dialog for a guide on explosion defense.\n\n2. What is the purpose of the `InitDialog()` method?\n- The `InitDialog()` method does not have any code inside it, so a smart developer might wonder why it exists and what its intended purpose is.\n\n3. What is the significance of the `DontShowThisMessageAgain` property?\n- The `DontShowThisMessageAgain` property returns the value of the `toggle` field, so a smart developer might question why this property is used instead of directly accessing the `toggle` field.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ExplosionDefenceGuideDialog.md"}}],["205",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ExplosionMatchDesc.cs)\n\nThe code provided defines a class called `ExplosionMatchDesc`. This class is used to store information about an explosion in the Brick-Force project. \n\nThe class has several public properties:\n- `rounding` is a boolean property that indicates whether the explosion should be rounded or not.\n- `bombInstaller` is an integer property that represents the ID of the bomb installer.\n- `blastTarget` is an integer property that represents the ID of the target that was blasted.\n- `point` is a Vector3 property that represents the position of the explosion in 3D space.\n- `normal` is a Vector3 property that represents the normal vector of the explosion.\n\nThis class is likely used in the larger Brick-Force project to store information about explosions that occur in the game. It provides a convenient way to encapsulate and pass around information related to explosions. \n\nFor example, in the game logic, when an explosion occurs, an instance of `ExplosionMatchDesc` can be created and populated with the relevant information. This instance can then be passed to other parts of the code that need to know about the explosion. \n\nHere's an example of how this class might be used in the larger project:\n\n```csharp\nExplosionMatchDesc explosion = new ExplosionMatchDesc();\nexplosion.rounding = true;\nexplosion.bombInstaller = 1;\nexplosion.blastTarget = 2;\nexplosion.point = new Vector3(10, 5, 0);\nexplosion.normal = new Vector3(0, 0, 1);\n\n// Pass the explosion information to another part of the code\nGameManager.HandleExplosion(explosion);\n```\n\nIn this example, an instance of `ExplosionMatchDesc` is created and populated with some example values. The explosion information is then passed to the `HandleExplosion` method of the `GameManager` class, which can use the information to update the game state or perform other relevant actions.\n\nOverall, the `ExplosionMatchDesc` class provides a structured way to store and pass around information about explosions in the Brick-Force project.\n## Questions: \n 1. **What is the purpose of this class?**\nThe purpose of this class is not clear from the code provided. It would be helpful to know what functionality or feature this class is intended to support within the Brick-Force project.\n\n2. **What do the variables `rounding`, `bombInstaller`, `blastTarget`, `point`, and `normal` represent?**\nThe code does not provide any comments or explanations for these variables. It would be useful to know what each variable represents and how they are used within the class.\n\n3. **Are there any constraints or limitations on the values of the variables?**\nThe code does not specify any constraints or limitations on the values of the variables. It would be important to know if there are any specific rules or restrictions on the values that can be assigned to these variables.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ExplosionMatchDesc.md"}}],["206",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ExplosionMatchScore.cs)\n\nThe code provided is a script called \"ExplosionMatchScore\" that is part of the Brick-Force project. This script is responsible for displaying the scores and other information related to a match in the game.\n\nThe script contains several public variables that can be set in the Unity editor. These variables include the GUI depth, fonts for the red and blue team scores, a font for the goal count, and a background texture for the score display. There are also several Vector2 variables that determine the position of the score elements on the screen.\n\nThe script has two private variables, redTeamScore and blueTeamScore, which store the current scores for the red and blue teams, respectively.\n\nThe Start() method is called when the script is first initialized. It sets the initial values for the redTeamScore and blueTeamScore variables to 0. It also checks if the player is currently in the \"BreakingInto\" mode and if so, sends a score request to the CSNetManager.\n\nThe OnTeamScore() method is called when the scores for the red and blue teams are updated. It compares the new scores with the current scores and updates the redScoreFont and blueScoreFont fonts accordingly. The Scale property of these fonts is set to 2f, which likely means that the font size is increased to make the score stand out.\n\nThe OnGUI() method is responsible for drawing the score display on the screen. It first checks if the GUI is enabled and if so, sets the GUI skin and depth. It then begins a GUI group with a rectangle that determines the position and size of the score display. The score background texture is drawn using the DrawTexture() method from the TextureUtil class. Depending on whether the player is on the red or blue team, the flickerRed or flickerBlue effect is drawn. The red and blue team scores are printed using the redScoreFont and blueScoreFont fonts, respectively. The goal count is printed using the goalFont font. Finally, the GUI group is ended and the GUI skin is reset.\n\nThe Update() method is called every frame and updates the flickerRed and flickerBlue effects.\n\nIn summary, this script is responsible for displaying the scores and other information related to a match in the game. It sets the initial scores, updates the scores when they change, and draws the score display on the screen.\n## Questions: \n 1. What is the purpose of the `ExplosionMatchScore` class?\n- The `ExplosionMatchScore` class is responsible for displaying the scores and other information related to a match in the game.\n\n2. What is the significance of the `redTeamScore` and `blueTeamScore` variables?\n- These variables store the current scores of the red and blue teams respectively.\n\n3. What is the purpose of the `OnGUI` method?\n- The `OnGUI` method is responsible for rendering the graphical user interface (GUI) elements related to the match scores and other information.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ExplosionMatchScore.md"}}],["207",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ExplosionTimer.cs)\n\nThe `ExplosionTimer` class is a script that is used to manage the countdown timer for a specific game mode in the larger Brick-Force project. \n\nThe purpose of this code is to display a timer on the screen and update it every second. The timer starts at a specified time limit and counts down to zero. The timer is displayed as minutes and seconds in the format \"MM:SS\". \n\nThe code uses the Unity game engine and relies on several other classes and components. It has a reference to a `GUIDepth.LAYER` enum, which determines the depth of the GUI elements on the screen. It also has a `Vector2` variable called `offset`, which determines the position of the timer on the screen. The `bkgnd` variable is a `Texture2D` that represents the background image for the timer.\n\nThe code initializes several variables in the `Start()` method. It sets the `play` variable to 0, which keeps track of the number of times the timer has been updated. It also sets the `playDelta` variable to 0, which is used to determine when to update the timer. The `remain` variable is set to the initial time limit, which is obtained from a `RoomManager` instance. \n\nThe `Start()` method also finds the game object with the name \"Me\" and gets the `LocalController` component attached to it. If the `LocalController` component is not found, an error message is logged. \n\nThe `OnGUI()` method is responsible for drawing the timer on the screen. It uses the `GUI` class from Unity to set the GUI skin, depth, and enable/disable GUI elements based on the state of the `DialogManager`. The method calculates the minutes and seconds from the `remain` variable and displays them on the screen using the `LabelUtil.TextOut()` method. The appearance of the timer changes depending on whether the remaining time is less than 11 seconds.\n\nThe `Update()` method is called every frame and is responsible for updating the timer. It checks if the local player is the master player and if the `LocalController` component is not null. If these conditions are met, it updates the `playDelta` variable and sends a network request to update the timer on the server. If the current game mode is not \"Explosion\" or if the bomb is not installed, it updates the `deltaTime` variable and decrements the `remain` variable. \n\nThe `OnPlayTime()` and `OnTimer()` methods are event handlers that update the `play` and `remain` variables respectively when they receive network events from the server.\n\nIn summary, this code manages the countdown timer for a specific game mode in the Brick-Force project. It displays the timer on the screen, updates it every second, and sends network requests to update the timer on the server.\n## Questions: \n 1. What is the purpose of the `ExplosionTimer` class?\n- The `ExplosionTimer` class is responsible for managing the timer for an explosion in the game.\n\n2. What is the significance of the `TimeLimit` property?\n- The `TimeLimit` property is used to get or set the remaining time for the explosion.\n\n3. What is the purpose of the `IsBombInstalled` method?\n- The `IsBombInstalled` method is used to check if a bomb is installed for the explosion.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ExplosionTimer.md"}}],["208",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ExplosionUtil.cs)\n\nThe code provided is a utility class called `ExplosionUtil` that contains several static methods for handling explosions in the game. This class is likely used in the larger Brick-Force project to calculate and apply damage to various game objects and entities when an explosion occurs.\n\nThe `CalcPowFrom` method calculates the power of an explosion at a given position based on the distance from the bomb's position, the damage of the bomb, and the explosion radius. It returns the calculated power as a float value.\n\nThe `CheckMyself` method checks if the player's character is within the explosion radius. If the player is within range, it calculates the damage based on the player's position and the explosion parameters. If the calculated damage is greater than 0, it calls the `GetHit` method on the player's `LocalController` component to apply the damage.\n\nThe `CheckBoxmen` method checks for nearby enemy players within the explosion radius. It calculates the damage for each enemy player based on their position and the explosion parameters. If the calculated damage is greater than 0, it updates the `accumDamaged` property of the enemy player's `PlayerProperty` component and sends a network message to inform other players about the damage.\n\nThe `CheckMonster` method checks for nearby monsters within the explosion radius. It calculates the damage for each monster based on their position and the explosion parameters. If the calculated damage is greater than 0, it calls the `Hit` method on the `MonManager` instance to apply the damage to the monster.\n\nThe `CheckDestructibles` method checks for nearby destructible bricks within the explosion radius. It calculates the damage for each brick based on its position and the explosion parameters. If the calculated damage reduces the brick's hit points to 0 or below, it sends a network message to destroy the brick. Otherwise, it sends a network message to update the brick's hit points.\n\nThe `CheckBoxmen`, `CheckMon`, and `CheckDestructibles` methods are helper methods used by the above methods to find the relevant game objects within the explosion radius.\n\nOverall, this code provides a set of utility methods for handling explosions in the game, calculating damage, and applying it to various game objects and entities. It is likely used extensively throughout the Brick-Force project to handle explosions and their effects on the game world.\n## Questions: \n **Question 1:** What does the `CalcPowFrom` method do and how is it used?\n- The `CalcPowFrom` method calculates the power of an explosion based on the distance between the bomb position and a given position. It is used to determine the damage caused by the explosion.\n\n**Question 2:** What is the purpose of the `CheckMyself` method and how does it work?\n- The `CheckMyself` method checks if the player's position is within the explosion radius and calculates the damage inflicted on the player. If the damage is greater than 0, it calls the `GetHit` method of the `LocalController` component to apply the damage to the player.\n\n**Question 3:** What is the difference between the `CheckDestructibles` and `CheckMon` methods?\n- The `CheckDestructibles` method checks for destructible bricks within the explosion radius and applies damage to them. The `CheckMon` method checks for monsters within the explosion radius and applies damage to them.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ExplosionUtil.md"}}],["209",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ExpressionSet.cs)\n\nThe code provided defines a class called `ExpressionSet` that is used to store a set of materials for a specific expression. This class is marked as `[Serializable]`, which means that its instances can be serialized and deserialized, allowing them to be saved and loaded from disk or transmitted over a network.\n\nThe `ExpressionSet` class has two properties: `name` and `material`. The `name` property is a string that represents the name of the expression set. The `material` property is an array of `Material` objects, which are used to define the visual appearance of objects in the Unity game engine.\n\nThis code is likely part of a larger project that involves creating and managing different expressions for objects in a game. The `ExpressionSet` class allows the project to define different sets of materials for each expression, making it easy to switch between different visual styles for objects in the game.\n\nHere's an example of how this code might be used in the larger project:\n\n```csharp\n// Create a new expression set\nExpressionSet expressionSet = new ExpressionSet();\n\n// Set the name of the expression set\nexpressionSet.name = \"Happy\";\n\n// Create an array of materials for the expression set\nexpressionSet.material = new Material[3];\n\n// Set the materials for the expression set\nexpressionSet.material[0] = happyMaterial1;\nexpressionSet.material[1] = happyMaterial2;\nexpressionSet.material[2] = happyMaterial3;\n\n// Use the expression set in the game\nobject.SetExpressionSet(expressionSet);\n```\n\nIn this example, a new `ExpressionSet` object is created and its `name` property is set to \"Happy\". An array of `Material` objects is then created and assigned to the `material` property of the `ExpressionSet` object. Finally, the `ExpressionSet` object is used to set the expression set for an object in the game.\n\nOverall, this code provides a way to define and manage different sets of materials for expressions in a game, allowing for easy customization and variation in the visual appearance of objects.\n## Questions: \n 1. **What is the purpose of the `ExpressionSet` class?**\nThe `ExpressionSet` class appears to be a serializable class that represents a set of materials for a specific expression. \n\n2. **What is the significance of the `name` property in the `ExpressionSet` class?**\nThe `name` property in the `ExpressionSet` class likely represents the name or identifier of the expression set.\n\n3. **What is the purpose of the `material` array in the `ExpressionSet` class?**\nThe `material` array in the `ExpressionSet` class likely stores an array of materials that are associated with the expression set.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ExpressionSet.md"}}],["210",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\FacialExpressor.cs)\n\nThe code provided is a part of the Brick-Force project and is a script called \"FacialExpressor\". This script is responsible for managing facial expressions for a character in the game. \n\nThe script starts by defining an enumeration called \"EXPRESSION\" which lists various facial expressions that the character can have. These expressions include DEFAULT, ANGRY, CRY, DEATH, DIZZY, FEAR, LAUGH, LOSS, LOVE, NONSENSE, RAGE, SHOUT, SHY, SIGH, and SURPRISED.\n\nThe script also has a reference to a SkinnedMeshRenderer component called \"smrFace\" which is used to render the character's face. It also has an array of \"ExpressionSet\" objects called \"expression\". Each \"ExpressionSet\" object represents a set of materials for different facial expressions.\n\nThe script has a private variable called \"curExpression\" which represents the current facial expression of the character. It also has a private variable called \"curExprSet\" which represents the current set of materials for the character's facial expression.\n\nThe script has a method called \"ChangeFace\" which takes a SkinnedMeshRenderer component and a string as parameters. This method is used to change the character's facial expression by setting the appropriate materials on the SkinnedMeshRenderer component. It searches for the ExpressionSet object with the given name in the \"expression\" array and sets it as the current expression set. If the expression set is not found, it logs an error message. Finally, it sets the current expression to the DEFAULT expression and updates the materials on the SkinnedMeshRenderer component.\n\nThe script also has several private methods. The \"OnFeel\" method is called when the character feels a certain expression. It calls the \"SetExpression\" method to update the current expression.\n\nThe \"SetExpression\" method is responsible for setting the current expression. It converts the given expression to a zombie expression if certain conditions are met. It then updates the materials on the SkinnedMeshRenderer component.\n\nThe \"VerifyPlayerProperty\" method is used to check if the \"pp\" (PlayerProperty) variable is null and assigns it if it is.\n\nThe \"ConvertExpression4Zombie\" method is used to convert the given expression to a zombie expression if certain conditions are met. It checks if the game is in zombie mode, the current room type is zombie, the player property is not null, and the player is a zombie. If all conditions are met, it converts the expression to a zombie expression using the \"zombieExpression\" array.\n\nIn summary, this script is responsible for managing facial expressions for a character in the game. It allows for changing the character's facial expression by setting the appropriate materials on a SkinnedMeshRenderer component. It also has functionality to convert expressions to zombie expressions in certain conditions.\n## Questions: \n 1. What is the purpose of the `FacialExpressor` class?\n- The `FacialExpressor` class is responsible for changing the facial expression of a character in the game.\n\n2. What is the purpose of the `expression` array?\n- The `expression` array stores different sets of facial expressions that can be applied to the character.\n\n3. What is the significance of the `ConvertExpression4Zombie` method?\n- The `ConvertExpression4Zombie` method converts the given expression to a different expression if certain conditions are met, such as if the game mode is set to \"Zombie\" and the character is a zombie.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\FacialExpressor.md"}}],["211",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\FadeIn.cs)\n\nThe code provided is a script called \"FadeIn\" that is used in the Brick-Force project. This script is responsible for fading in the color of a game object over time. \n\nThe script starts by declaring a public variable called \"targetColor\" of type Color. This variable represents the color that the game object will fade into. \n\nThe script also declares a private variable called \"mr\" of type MeshRenderer. This variable will be used to store a reference to the MeshRenderer component attached to the game object. \n\nIn the Start() method, the script retrieves the MeshRenderer component attached to the game object using the GetComponent<MeshRenderer>() method. If the MeshRenderer component is not found, an error message is logged to the console using Debug.LogError(). \n\nIn the Update() method, the script retrieves the current color of the game object by accessing the \"_TintColor\" property of the material attached to the MeshRenderer component. The current color is then interpolated towards the target color using the Color.Lerp() method. The interpolation is done at a rate of 10f * Time.deltaTime, which ensures that the color change occurs smoothly over time. \n\nFinally, the updated color is set back to the material attached to the MeshRenderer component using the SetColor() method. The \"_TintColor\" property is updated with the new color, causing the game object to gradually fade into the target color. \n\nThis script can be used in the larger Brick-Force project to create visual effects such as fading in the color of game objects. It can be attached to any game object that has a MeshRenderer component, allowing for dynamic color changes during gameplay. \n\nExample usage:\n\n```csharp\n// Attach the FadeIn script to a game object with a MeshRenderer component\nGameObject cube = GameObject.Find(\"Cube\");\nFadeIn fadeInScript = cube.AddComponent<FadeIn>();\n\n// Set the target color to red\nfadeInScript.targetColor = Color.red;\n```\n\nIn this example, the FadeIn script is attached to a game object named \"Cube\" and the target color is set to red. As the game runs, the color of the cube will gradually fade from its current color to red.\n## Questions: \n 1. **What is the purpose of the FadeIn script?**\nThe FadeIn script is likely used to gradually change the color of a game object's material over time.\n\n2. **What is the significance of the targetColor variable?**\nThe targetColor variable is the color that the game object's material will eventually fade to.\n\n3. **What does the \"_TintColor\" property represent in the material?**\nThe \"_TintColor\" property is a property in the material that is being used to control the color of the game object.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\FadeIn.md"}}],["212",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\FadeOutDestroyer.cs)\n\nThe code provided is a script called \"FadeOutDestroyer\" that is used in the larger Brick-Force project. This script is responsible for fading out and destroying game objects with SkinnedMeshRenderer and MeshRenderer components.\n\nThe script starts by declaring two arrays, smrArray and mrArray, which will store references to SkinnedMeshRenderer and MeshRenderer components respectively. The fadeOutSpeed variable determines the speed at which the objects will fade out.\n\nIn the Start() method, the script retrieves all SkinnedMeshRenderer and MeshRenderer components attached to the game object and its children using the GetComponentsInChildren() method. Then, it calls two methods: ChangeSkinnedMeshRenderersShaderToFadeoutable() and ChangeMeshRenderersShaderToFadeoutable(). These methods change the shader of the materials used by the SkinnedMeshRenderer and MeshRenderer components to \"Transparent/Diffuse\", allowing the objects to fade out.\n\nThe ChangeSkinnedMeshRenderersShaderToFadeoutable() and ChangeMeshRenderersShaderToFadeoutable() methods iterate through the smrArray and mrArray respectively, and for each component, they set the shader to \"Transparent/Diffuse\" and retrieve the current color of the material. The color is then set back to the material to ensure the fade out effect works correctly.\n\nThe FadeOutSkinnedMeshRenderer() and FadeOutMeshRenderer() methods are responsible for fading out the SkinnedMeshRenderer and MeshRenderer components respectively. They iterate through the smrArray and mrArray, retrieve the current color of the material, and check if the alpha value of the color is greater than or equal to 0.0001f. If it is, the color is faded out by using the Mathf.Lerp() method to gradually decrease the alpha value based on the fadeOutSpeed and Time.deltaTime. The updated color is then set back to the material.\n\nIn the Update() method, the FadeOutSkinnedMeshRenderer() and FadeOutMeshRenderer() methods are called. The flag variable is used to check if all SkinnedMeshRenderer components have faded out. If both FadeOutMeshRenderer() and flag are true, the game object that this script is attached to is destroyed using the Object.Destroy() method.\n\nOverall, this script provides a way to fade out and destroy game objects with SkinnedMeshRenderer and MeshRenderer components. It can be used in the larger Brick-Force project to create visual effects such as objects disappearing or fading away.\n## Questions: \n 1. What is the purpose of the FadeOutDestroyer class?\n- The FadeOutDestroyer class is responsible for fading out and destroying game objects with skinned mesh renderers and mesh renderers.\n\n2. What is the significance of the fadeOutSpeed variable?\n- The fadeOutSpeed variable determines how quickly the objects fade out. \n\n3. What shader is being used to make the objects fade out?\n- The objects are using the \"Transparent/Diffuse\" shader to achieve the fade out effect.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\FadeOutDestroyer.md"}}],["213",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\FeverFx.cs)\n\nThe `FeverFx` class is a script that is used to create a fever effect in the game. It is a part of the larger Brick-Force project. \n\nThe purpose of this script is to display a visual effect on the screen when the player is in a fever state. The effect consists of two layers of textures that are gradually faded in and out. The script uses the `OnGUI` and `Update` methods to control the rendering of the effect.\n\nThe `screenFx` variable is an array of `Texture2D` objects that represent the textures to be displayed. The first texture in the array is used as the base layer, and the second texture is used as the second layer that fades in after a certain duration.\n\nThe `guiDepth` variable determines the rendering order of the GUI elements. It is set to `GUIDepth.LAYER.SCREEN_FX` by default.\n\nThe `localController` variable is a reference to the `LocalController` component attached to the same game object. It is used to check if the player is in a fever state.\n\nThe `deltaTime1` and `deltaTime2` variables are used to keep track of the time elapsed since the effect started. They are incremented in the `Update` method using `Time.deltaTime`.\n\nThe `FromColor` and `ToColor` variables represent the starting and ending colors of the textures. They are set to `Color.white` and `new Color(1f, 1f, 1f, 0f)` respectively.\n\nThe `screenColor1` and `screenColor2` variables represent the current colors of the textures. They are updated in the `Update` method using `Color.Lerp` to interpolate between the `FromColor` and `ToColor` values.\n\nThe `Start` method initializes the variables and gets a reference to the `LocalController` component.\n\nThe `reset` method resets the variables to their initial values.\n\nThe `OnGUI` method is called every frame to render the GUI elements. It checks if the player is in a fever state and if so, it sets the GUI skin, depth, and color. It then uses the `TextureUtil.DrawTexture` method to draw the textures on the screen.\n\nThe `Update` method is called every frame to update the colors of the textures. It checks if the player is in a fever state and if so, it updates the `deltaTime1` and `deltaTime2` variables and interpolates the colors accordingly.\n\nOverall, this script is responsible for rendering the fever effect on the screen when the player is in a fever state. It uses two layers of textures that fade in and out over time to create the effect.\n## Questions: \n 1. What is the purpose of the `FeverFx` class?\n- The `FeverFx` class is responsible for handling the visual effects related to a fever action in the game.\n\n2. What is the significance of the `screenFx` array?\n- The `screenFx` array holds the textures used for the fever effect. The first element is always displayed, and the second element is displayed after a certain duration.\n\n3. What is the role of the `localController` variable?\n- The `localController` variable is used to access the `ActingFever` property, which determines whether the fever effect should be active or not.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\FeverFx.md"}}],["214",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\FeverItem.cs)\n\nThe code provided is a class called \"FeverItem\" that inherits from the \"ActiveItemBase\" class. This class represents an item in the larger Brick-Force project that can be used to activate a \"fever mode\" in the game.\n\nThe class has an AudioClip variable called \"sndUseItem\" which represents the sound that will be played when the item is used. This variable is not initialized or used in the provided code.\n\nThe class has two empty methods, \"Awake()\" and \"Update()\", which are part of the MonoBehaviour class in Unity. These methods are typically used for initialization and updating game objects, but in this case, they are not implemented.\n\nThe class also has a public method called \"StartItem()\" which overrides the method with the same name in the base class. This method is called when the item is used by the player. \n\nInside the \"StartItem()\" method, it first checks if the \"useUserSeq\" variable is equal to the \"Seq\" variable of the \"MyInfoManager.Instance\" object. If they are equal, it calls the \"activeFeverMode()\" method of the \"GlobalVars.Instance\" object. This method is likely responsible for activating the \"fever mode\" in the game.\n\nNext, it finds the game object with the name \"Me\" using the \"GameObject.Find()\" method. If the game object is found, it gets the \"AudioSource\" component attached to it and plays the \"sndUseItem\" sound using the \"PlayOneShot()\" method.\n\nOverall, this code represents a specific item in the Brick-Force game that, when used, activates a \"fever mode\" and plays a sound effect. The class provides the functionality to start the \"fever mode\" and play the sound effect when the item is used by the player.\n## Questions: \n 1. What is the purpose of the `Awake()` and `Update()` methods in this code?\n- The smart developer might ask why these methods are empty and if they are meant to be implemented later with specific functionality.\n\n2. What is the significance of the `StartItem()` method and how is it being used?\n- The smart developer might ask how and when the `StartItem()` method is being called, and what the `useUserSeq` and `MyInfoManager.Instance.Seq` variables represent.\n\n3. What is the purpose of the `sndUseItem` AudioClip and how is it being used?\n- The smart developer might ask where the `sndUseItem` AudioClip is being assigned and how it is being played in the code.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\FeverItem.md"}}],["215",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\FirePacket.cs)\n\nThe code provided defines a class called `FirePacket` that represents a packet of information related to firing a weapon in the Brick-Force project. This class is likely used to transmit data about a weapon firing event between different components or systems within the larger project.\n\nThe `FirePacket` class has several public fields: `shooter`, `slot`, `usID`, `shootpos`, and `shootdir`. These fields store information about the shooter, the slot of the weapon being fired, the ID of the weapon, the position from which the weapon was fired (`shootpos`), and the direction in which the weapon was fired (`shootdir`).\n\nThe class also has a constructor that takes in several parameters: `_shooter`, `_slot`, `_id`, `p`, and `d`. These parameters are used to initialize the corresponding fields of the `FirePacket` object. The `_shooter` parameter represents the ID of the shooter, the `_slot` parameter represents the slot of the weapon, the `_id` parameter represents the ID of the weapon, `p` represents the position from which the weapon was fired, and `d` represents the direction in which the weapon was fired.\n\nThis `FirePacket` class can be used in the larger Brick-Force project to facilitate communication and synchronization between different components or systems related to weapon firing. For example, when a player fires a weapon, an instance of the `FirePacket` class can be created and populated with the relevant information. This packet can then be sent to other systems or components, such as the server or other players, to inform them about the weapon firing event. By using this class, the project can ensure that all necessary information about the firing event is transmitted accurately and consistently.\n\nHere is an example of how the `FirePacket` class could be used in the Brick-Force project:\n\n```csharp\nFirePacket firePacket = new FirePacket(123, 1, 456, new Vector3(1, 2, 3), new Vector3(0, 0, 1));\n// Create a new FirePacket object with the shooter ID 123, weapon slot 1, weapon ID 456,\n// firing position (1, 2, 3), and firing direction (0, 0, 1)\n\n// Send the firePacket to the server or other players\nnetworkManager.SendFirePacket(firePacket);\n```\n\nIn this example, a `FirePacket` object is created with the relevant information and then sent to the `networkManager` to be transmitted to the server or other players. This allows the firing event to be accurately communicated and processed by the appropriate systems or components in the Brick-Force project.\n## Questions: \n 1. **What is the purpose of the FirePacket class?**\nThe FirePacket class appears to be a data structure used to store information about a fired projectile, such as the shooter's ID, slot, ID of the projectile, and the position and direction of the shot.\n\n2. **What are the data types of the parameters in the FirePacket constructor?**\nThe parameters in the FirePacket constructor are of type int, byte, int, Vector3, and Vector3 respectively.\n\n3. **What is the significance of casting the slot and usID variables to byte and ushort respectively?**\nThe casting of the slot variable to byte and the usID variable to ushort suggests that these variables are expected to have specific ranges or values that are within the range of the byte and ushort data types.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\FirePacket.md"}}],["216",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\FireSndPacket.cs)\n\nThe code provided is a class called `FireSndPacket` that is marked as `[Serializable]`. This class is used to create objects that represent a packet of data related to firing a weapon in the larger Brick-Force project.\n\nThe `FireSndPacket` class has two public fields: `shooter` and `slot`. The `shooter` field is an integer that represents the ID of the player who is firing the weapon. The `slot` field is a byte that represents the slot number of the weapon being fired.\n\nThe class also has a constructor that takes two parameters: `_shooter` and `_slot`. These parameters are used to initialize the `shooter` and `slot` fields of the object being created. The `slot` parameter is cast to a byte before being assigned to the `slot` field.\n\nThe purpose of this class is to provide a standardized way of packaging and transmitting data related to firing a weapon in the Brick-Force project. By creating objects of the `FireSndPacket` class and populating them with the relevant data, the project can easily send and receive information about weapon firing events.\n\nHere is an example of how this class might be used in the larger project:\n\n```csharp\n// Create a new FireSndPacket object with shooter ID 123 and slot number 2\nFireSndPacket packet = new FireSndPacket(123, 2);\n\n// Serialize the packet object to a byte array for transmission\nbyte[] serializedPacket = Serialize(packet);\n\n// Send the serialized packet over the network\n\n// On the receiving end, deserialize the byte array back into a FireSndPacket object\nFireSndPacket receivedPacket = Deserialize(serializedPacket);\n\n// Access the shooter and slot fields of the received packet\nint shooterID = receivedPacket.shooter;\nbyte weaponSlot = receivedPacket.slot;\n\n// Use the received data to handle the weapon firing event\nHandleWeaponFiring(shooterID, weaponSlot);\n```\n\nIn summary, the `FireSndPacket` class is a data structure used in the Brick-Force project to represent information about firing a weapon. It provides a standardized way of packaging and transmitting this data, making it easier for different parts of the project to communicate and handle weapon firing events.\n## Questions: \n 1. **What is the purpose of the FireSndPacket class?**\nThe FireSndPacket class appears to be a serializable class that represents a packet of data related to firing a weapon. It contains information about the shooter and the slot of the weapon being fired.\n\n2. **What does the 'Serializable' attribute do?**\nThe [Serializable] attribute indicates that objects of the FireSndPacket class can be converted into a binary format for storage or transmission.\n\n3. **Why is the 'slot' variable cast to a byte in the constructor?**\nThe 'slot' variable is cast to a byte in the constructor to ensure that it can only hold values within the range of a byte. This may be necessary for compatibility or memory optimization reasons.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\FireSndPacket.md"}}],["217",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\FLAGGuideDialog.cs)\n\nThe code provided is a class called `FLAGGuideDialog` that extends the `Dialog` class. This class is used to create a dialog box with various UI elements such as an image list, label list, toggle, and button. The purpose of this code is to display a dialog box to the user and allow them to interact with the UI elements.\n\nThe `FLAGGuideDialog` class has several public variables that represent the UI elements in the dialog box. These variables include `imgList` (an instance of the `UIImageList` class), `labelList` (an instance of the `UILabelList` class), `toggle` (an instance of the `UIToggle` class), and `ok` (an instance of the `UIMyButton` class). These variables are used to draw and interact with the UI elements in the `DoDialog()` method.\n\nThe `DoDialog()` method is responsible for drawing the UI elements and handling user interactions. It first sets the GUI skin to a custom skin obtained from `GUISkinFinder.Instance.GetGUISkin()`. Then, it calls the `Draw()` method on each UI element to draw them on the screen. After that, it checks if the `ok` button is clicked. If it is, it checks if the `toggle` is checked. If it is, it saves a flag in the `MyInfoManager` class to indicate that the user has chosen to not show this message again. Finally, it sets the GUI skin back to the original skin and returns the result.\n\nThe `Start()` method sets the `id` of the dialog to a predefined value from `DialogManager.DIALOG_INDEX.FLAG_GUIDE`. The `OnPopup()` method calculates the position of the dialog box based on the screen size.\n\nThe `InitDialog()` method is empty and does not have any functionality.\n\nIn summary, this code defines a dialog box class with UI elements and methods to draw and interact with those elements. It can be used in the larger project to display a dialog box to the user and handle their interactions.\n## Questions: \n 1. What is the purpose of the `FLAGGuideDialog` class?\n- The `FLAGGuideDialog` class is a subclass of the `Dialog` class and represents a dialog box in the game.\n\n2. What is the purpose of the `InitDialog()` method?\n- The `InitDialog()` method does not have any code inside it, so a smart developer might wonder why it is included in the class and what its intended purpose is.\n\n3. What does the `DoDialog()` method do?\n- The `DoDialog()` method is responsible for drawing the dialog box on the screen and handling user interactions with the dialog, such as clicking the \"ok\" button.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\FLAGGuideDialog.md"}}],["218",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\FlashBang.cs)\n\nThe code provided is a class called \"FlashBang\" that inherits from another class called \"HandBomb\". This class represents a flashbang grenade in the game. \n\nThe purpose of this code is to handle the behavior and functionality of the flashbang grenade. It contains methods for modifying the grenade's properties, updating its state, and handling its throwing and detonation. \n\nThe \"Start\" method is called when the object is first created. It calls several other methods to initialize the grenade's properties and state. \n\nThe \"Modify\" method is responsible for modifying the grenade's properties based on various factors. It first checks if a certain build option is enabled and if a certain condition is met, it modifies the texture of the grenade's mesh renderer. It then retrieves a component called \"WeaponFunction\" and uses it to retrieve a \"WpnMod\" object from a \"WeaponModifier\" instance. If the object exists, it updates the grenade's properties such as maximum ammo, explosion time, speed factor, throw force, and radius. It also retrieves a \"WpnModEx\" object from the \"WeaponModifier\" instance and updates the grenade's persist time and continue time properties. Finally, it retrieves a \"TWeapon\" object from a \"Weapon\" component and uses it to retrieve an \"Item\" object from a \"MyInfoManager\" instance. It then checks if the item exists and updates the grenade's throw force, radius, and continue time properties based on the item's upgrade properties. \n\nThe \"OnGUI\" method is responsible for drawing the grenade's crosshair, ammo count, and detonating state on the game's GUI. \n\nThe \"Update\" method is called every frame and is responsible for updating the grenade's behavior. It first checks if the game's brick manager is loaded and if so, it performs various checks and updates. It checks for cheating by calling a method from a \"NoCheat\" instance, updates the ammo time, and sends a network message to enable or disable the grenade based on its ammo count. It then verifies the camera and local controller, updates the cross effect, and checks if the grenade can be thrown. If the grenade is not detonating and the fire button is pressed, it removes the safety clip. If the grenade is detonating and the fire button is released, it plays a throw animation and sends a network message to throw the grenade. If the grenade is detonating, it updates the detonator time and if the detonator time exceeds the explosion time, it uses the ammo, creates an explosion effect, and restarts the grenade's state. \n\nThe \"Throw\" method is responsible for throwing the grenade. It checks if the grenade is detonating and if so, it uses the ammo, plays a throw sound, creates a projectile object, adds a force to the projectile, and sends a network message to create the projectile. It then updates the detonating state, shows the grenade's model without the body and clip, and if the ammo count is zero, sends a network message to disable the grenade. \n\nOverall, this code provides the functionality for the flashbang grenade in the game, including modifying its properties, updating its state, and handling its throwing and detonation.\n## Questions: \n 1. What is the purpose of the `Modify()` method?\n- The `Modify()` method is responsible for modifying the properties of the FlashBang object based on various conditions and values from other components and managers.\n\n2. What does the `Update()` method do?\n- The `Update()` method is responsible for updating the state of the FlashBang object, including checking for input, detonating the bomb, and restarting the bomb.\n\n3. What is the purpose of the `Throw()` method?\n- The `Throw()` method is responsible for throwing the FlashBang object, including creating the projectile, applying forces, and sending network messages.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\FlashBang.md"}}],["219",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Flying.cs)\n\nThe code provided defines a class called `Flying`. This class represents a flying object in the Brick-Force project. \n\nThe `Flying` class has several private fields: `seq`, `tItem`, `amount`, and `isRareItem`. These fields store information about the flying object, such as its sequence number, the item it represents, the amount of the item, and whether the item is rare or not. \n\nThe class also has a public field called `deltaTime`, which represents the time difference between the current frame and the previous frame. \n\nThe class provides public properties for accessing the private fields: `Seq`, `Template`, `Amount`, and `IsRareItem`. These properties allow other parts of the project to read the values of these fields, but not modify them directly. \n\nThe class has a constructor that takes in the sequence number, item template, amount, and rarity of the flying object. It initializes the private fields with the provided values and sets the `deltaTime` field to 0. \n\nThis `Flying` class is likely used in the larger Brick-Force project to represent flying objects, such as power-ups or collectible items, that can be interacted with by the player. Other parts of the project can create instances of the `Flying` class and set the necessary properties to define the behavior and appearance of the flying object. The `Flying` objects can then be updated and rendered in the game world based on the `deltaTime` value. \n\nHere is an example of how the `Flying` class could be used in the project:\n\n```csharp\n// Create a new flying object\nFlying flyingObject = new Flying(1, itemTemplate, 10, true);\n\n// Get the sequence number of the flying object\nlong sequenceNumber = flyingObject.Seq;\n\n// Get the amount of the item represented by the flying object\nint itemAmount = flyingObject.Amount;\n\n// Check if the flying object represents a rare item\nbool isRare = flyingObject.IsRareItem;\n```\n## Questions: \n 1. What is the purpose of the `Flying` class?\n- The `Flying` class appears to represent a flying object in the game. It contains properties related to the object's sequence, item template, amount, rarity, and delta time.\n\n2. What is the significance of the `Seq`, `Template`, `Amount`, and `IsRareItem` properties?\n- The `Seq` property returns the sequence of the flying object. The `Template` property returns the item template associated with the object. The `Amount` property returns the amount of the item. The `IsRareItem` property indicates whether the item is rare or not.\n\n3. What is the purpose of the `deltaTime` field and how is it used?\n- The `deltaTime` field is a float value that represents the time difference between frames. It is initialized to 0f in the constructor of the `Flying` class. The purpose of this field and how it is used within the code is not clear from the given code snippet.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Flying.md"}}],["220",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\FriendlyPlayerNames.cs)\n\nThe code provided is a script called \"FriendlyPlayerNames\" that is used in the Brick-Force project. This script is responsible for displaying the nicknames of friendly players above their characters in the game world.\n\nThe script starts by declaring a public variable called \"guiDepth\" of type \"GUIDepth.LAYER\". This variable is used to determine the depth at which the GUI elements will be rendered in the game world.\n\nIn the Start() method, the script finds the main camera in the scene by searching for a GameObject with the name \"Main Camera\". If a camera is found, it assigns it to the \"cam\" variable. This camera will be used later to convert the positions of the player characters from world space to screen space.\n\nThe OnGUI() method is called every frame to render the GUI elements. Inside this method, the script checks if the player's own nickname should be hidden, if the GUI is enabled, and if the player is not a spectator. If these conditions are met, the script proceeds to render the nicknames of friendly players.\n\nFirst, it sets the GUI skin to the one obtained from the GUISkinFinder.Instance. Then, it sets the GUI depth to the value of the \"guiDepth\" variable. The GUI.enabled property is set to true if there are no modal dialogs currently active.\n\nNext, the script retrieves an array of GameObjects representing the player characters from the BrickManManager.Instance. It then iterates over each GameObject in the array and retrieves its position. The y-coordinate of the position is increased by 2 units to position the nickname above the character.\n\nThe script checks if the GameObject has a PlayerProperty component and if it is not hostile and not hidden. If these conditions are met, it converts the position of the character from world space to viewport space using the camera's WorldToViewportPoint() method. If the character is within the viewport, it converts the position from world space to screen space using the camera's WorldToScreenPoint() method.\n\nFinally, the script uses the LabelUtil.TextOut() method to render the nickname of the player above their character. The position of the label is determined by the screen space position of the character, and the nickname is displayed in green with a black outline.\n\nThe Update() method is empty and does not contain any code.\n\nIn summary, this script is responsible for rendering the nicknames of friendly players above their characters in the game world. It uses the camera to convert the positions of the characters from world space to screen space and then renders the nicknames using the LabelUtil.TextOut() method. This script is likely used in the larger Brick-Force project to enhance the player's visual experience and improve gameplay by allowing them to easily identify friendly players.\n## Questions: \n 1. What is the purpose of the `FriendlyPlayerNames` class?\n- The `FriendlyPlayerNames` class is responsible for displaying the nicknames of friendly players in the game.\n\n2. What is the significance of the `guiDepth` variable?\n- The `guiDepth` variable determines the layer depth of the GUI elements related to player names. \n\n3. What conditions need to be met for a player's nickname to be displayed?\n- The player's nickname will be displayed if the `hideOurForcesNickname` flag is false, the GUI is enabled, and the player is not a spectator.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\FriendlyPlayerNames.md"}}],["221",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\FriendsDialog.cs)\n\nThe code provided is a class called \"FriendsDialog\" that extends the \"Dialog\" class. This class is responsible for displaying and managing the Friends dialog in the larger Brick-Force project. \n\nThe purpose of this code is to create a dialog window that allows the user to manage their friends and bans within the game. The dialog window consists of two tabs: \"Friends\" and \"Bans\". The user can switch between these tabs to view and interact with their friends and bans respectively.\n\nThe class contains various member variables that store textures, strings, and other UI-related data. These variables are used to define the layout and appearance of the dialog window.\n\nThe class overrides several methods from the base \"Dialog\" class. The \"Start\" method initializes the dialog by setting its ID and creating an array of strings for the tab labels. The \"OnPopup\" method is called when the dialog is displayed and is responsible for setting up the UI elements and retrieving localized strings for the tab labels.\n\nThe \"Update\" method is called every frame and is responsible for updating the state of the dialog. In this case, it checks if the selected tab is the \"Friends\" tab and sends a network request to retrieve the user's friends information once every second.\n\nThe \"DoDialog\" method is the main method that handles the rendering and interaction of the dialog window. It uses GUI functions to draw the UI elements, such as labels, buttons, and scroll views, and handles user input, such as button clicks and mouse events. The method also interacts with other classes and systems in the larger project, such as the \"MyInfoManager\" and \"CSNetManager\" classes, to retrieve and update the user's friends and bans information.\n\nOverall, this code provides the functionality for the Friends dialog in the Brick-Force project, allowing users to manage their friends and bans within the game.\n## Questions: \n 1. What is the purpose of the `FriendsDialog` class?\n- The `FriendsDialog` class represents a dialog window for managing friends and bans in the game.\n2. What is the significance of the `tabKey` and `tab` variables?\n- The `tabKey` variable is an array of string keys used to retrieve localized tab names, while the `tab` variable is an array of actual tab names.\n3. What does the `Update` method do?\n- The `Update` method is called every frame and it sends a network request to check for updates if the selected tab is the \"Friends\" tab.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\FriendsDialog.md"}}],["222",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\FunctionPointer.cs)\n\nThe given code defines a delegate called `FunctionPointer` which is used to reference a method that takes no arguments and returns a boolean value. \n\nA delegate is a type that represents references to methods with a particular parameter list and return type. It allows methods to be passed as parameters to other methods, stored as variables, and invoked indirectly through those variables. In this case, the `FunctionPointer` delegate can be used to reference any method that matches its signature.\n\nThe purpose of this code is to provide a way to pass a method as a parameter to another method or store it as a variable. This can be useful in scenarios where a method needs to be executed conditionally or dynamically.\n\nFor example, let's say we have a method called `CheckCondition` that takes a `FunctionPointer` delegate as a parameter and executes it. If the delegate method returns `true`, it performs a certain action, otherwise, it performs a different action. Here's an example:\n\n```csharp\npublic bool MethodA()\n{\n    // Some logic\n    return true;\n}\n\npublic bool MethodB()\n{\n    // Some logic\n    return false;\n}\n\npublic void CheckCondition(FunctionPointer function)\n{\n    if (function())\n    {\n        // Perform action A\n    }\n    else\n    {\n        // Perform action B\n    }\n}\n\n// Usage\nCheckCondition(MethodA); // This will perform action A\nCheckCondition(MethodB); // This will perform action B\n```\n\nIn the above example, the `CheckCondition` method takes a `FunctionPointer` delegate as a parameter and invokes it using the `function()` syntax. Depending on the return value of the delegate method, it performs different actions.\n\nIn the larger project, this code can be used to provide flexibility and extensibility by allowing methods to be passed as parameters or stored as variables. It can be used to implement various conditional or dynamic behaviors based on the result of the delegate method.\n## Questions: \n 1. What is the purpose of the `FunctionPointer` delegate?\n- The `FunctionPointer` delegate is used to reference a method that takes no parameters and returns a boolean value.\n\n2. How is the `FunctionPointer` delegate used in the rest of the codebase?\n- The `FunctionPointer` delegate is likely used as a callback mechanism, allowing methods to be passed as arguments to other methods or stored as variables.\n\n3. Are there any specific requirements or constraints on the methods that can be assigned to the `FunctionPointer` delegate?\n- Without further information, it is unclear if there are any specific requirements or constraints on the methods that can be assigned to the `FunctionPointer` delegate.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\FunctionPointer.md"}}],["223",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\GadgetCannon.cs)\n\nThe code provided is a script for a class called \"GadgetCannon\" in the Brick-Force project. This class is responsible for managing the behavior and functionality of a cannon gadget in the game. \n\nThe class has several member variables, including references to various game objects and components, such as muzzleFire, bulletTrail, muzzleFxInstances, cannonController, and audioSource. These variables are used to store references to objects and components that are necessary for the cannon's functionality.\n\nThe Start() method is called when the cannon is initialized. It initializes the fireCount variable to 0 and retrieves references to the CannonController component and AudioSource component attached to the same game object as the GadgetCannon script. If any of these references are null, an error message is logged.\n\nThe Update() method is empty and does not contain any code. This suggests that the cannon's behavior is not updated or changed dynamically during gameplay.\n\nThe DoFireSound() method is responsible for playing the sound effect associated with firing the cannon. It checks if the cannonController and audioSource variables are not null, and if so, adjusts the volume of the audioSource based on the value of a mute flag. It then plays the fireSound audio clip using the PlayOneShot() method.\n\nThe DoMuzzleFire() method is responsible for creating and animating the muzzle fire effect when the cannon is fired. It checks if the cannonController and muzzleFxInstances variables are not null, and if the cannonController has a valid array of muzzles. It then creates a new muzzle fire effect game object at the position of the current muzzle, and sets its parent and rotation. Finally, it emits particles from the child objects of the muzzle fire effect.\n\nThe Fire() method is called when the cannon is fired. It checks if the cannonController is not null and if the BrickSeq and Shooter properties of the cannonController match the provided cannon and shooter parameters. If so, it increments the fireCount, triggers the fire animation on the cannonController, and calls the DoFireSound() and DoMuzzleFire() methods. It also calls the Shoot() method to create a bullet trail effect.\n\nThe Shoot() method is responsible for creating the bullet trail effect when the cannon is fired. It checks if the bulletTrail variable is not null, and if so, creates a new bullet trail effect game object at the specified origin and with the specified direction. It also sets the speed of the bullet object attached to the bullet trail effect.\n\nThe Move() method is called when the cannon is moved. It checks if the cannonController is not null and if the BrickSeq and Shooter properties of the cannonController match the provided cannon and shooter parameters. If so, it calls the Move() method on the cannonController, passing in the provided x and y parameters.\n\nIn summary, this code manages the behavior of a cannon gadget in the Brick-Force game. It handles firing the cannon, playing sound effects, creating muzzle fire and bullet trail effects, and moving the cannon. This class is likely used in conjunction with other classes and scripts to create a fully functional cannon gadget in the game.\n## Questions: \n 1. What is the purpose of the `GadgetCannon` class?\n- The `GadgetCannon` class is responsible for handling the firing and movement of a cannon in the game.\n\n2. What is the purpose of the `DoFireSound` method?\n- The `DoFireSound` method is responsible for playing the sound effect of the cannon firing.\n\n3. What is the purpose of the `Move` method?\n- The `Move` method is used to move the cannon to a specified position on the game screen.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\GadgetCannon.md"}}],["224",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\GameCautionManager.cs)\n\nThe `GameCautionManager` class is responsible for managing and displaying caution messages in the game. It is a singleton class, meaning that there can only be one instance of it in the game.\n\nThe `maxTime` variable represents the maximum time in seconds before a caution message is displayed. The `delta` variable keeps track of the time passed since the last caution message was displayed. The `nextdelta` variable is used to delay the display of the second caution message. The `isnext` variable is a flag that indicates whether the second caution message should be displayed. The `outmsg1` and `outmsg2` variables are flags that indicate whether the first and second caution messages have been displayed, respectively. The `hour` variable keeps track of the number of hours that have passed since the first caution message was displayed.\n\nThe `Instance` property is a getter that returns the singleton instance of the `GameCautionManager` class. If the instance is null, it tries to find an existing instance in the scene. If it fails to find an instance, it logs an error message.\n\nThe `Awake` method is called when the object is initialized and makes sure that the object is not destroyed when a new scene is loaded.\n\nThe `Update` method is called every frame. It first checks if the game is running in a specific build option (Netmarble or Developer). If it is, it increments the `delta` variable by the time passed since the last frame. If the `delta` exceeds the `maxTime`, it resets the `delta`, sets the `isnext` flag to true, sets the `outmsg1` flag to true, and increments the `hour` variable. This means that a caution message will be displayed. If the `isnext` flag is true, it increments the `nextdelta` variable. If the `nextdelta` exceeds 5 seconds, it resets the `nextdelta`, sets the `isnext` flag to false, and sets the `outmsg2` flag to true. This means that the second caution message will be displayed.\n\nIf the `outmsg1` flag is true, it finds the \"Main\" game object in the scene and checks if it has a `Lobby` component with the `bChatView` flag set to true. If it does, it broadcasts a message to the game object to display a caution message with the current hour. The `outmsg1` flag is then set to false. It does the same check for a `BattleChat` component.\n\nIf the `outmsg2` flag is true, it does the same checks as above but displays a different caution message.\n\nIn summary, this code manages the display of caution messages in the game based on the elapsed time. It checks if the game is running in a specific build option and displays caution messages at specific intervals. The caution messages are displayed in the game's lobby and battle chat.\n## Questions: \n 1. What is the purpose of the `maxTime` variable and how is it used in the code?\n- The `maxTime` variable represents the maximum time allowed for gameplay. It is used to determine when to display warning messages to the player.\n\n2. What is the significance of the `isnext` variable and how is it used in the code?\n- The `isnext` variable is used to control the timing of the second warning message. It is set to true after the `maxTime` has elapsed and is set to false after a certain delay.\n\n3. What is the purpose of the `outmsg1` and `outmsg2` variables and how are they used in the code?\n- The `outmsg1` and `outmsg2` variables are used to track whether the first and second warning messages have been displayed, respectively. They are set to true when the corresponding warning message is sent and set to false afterwards.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\GameCautionManager.md"}}],["225",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\GameGrade.cs)\n\nThe `GameGrade` class in the Brick-Force project is responsible for displaying a grade texture on the screen for a certain period of time. \n\nThe class has several private variables, including `texGrade`, which is a Texture2D object representing the grade texture to be displayed, and `crdBg`, which is a Rect object representing the position and size of the grade texture on the screen. \n\nThere are also several float variables, such as `delta` and `maxDelta`, which are used to keep track of the time elapsed since the grade texture was last shown, and the maximum time interval between showing the grade texture. \n\nThe class also has a boolean variable `showPic`, which determines whether the grade texture should be shown or not. \n\nThe class has a static instance variable `_instance` and a static property `Instance` that allows other classes to access the `GameGrade` instance. \n\nThe `Awake` method is called when the object is initialized and it ensures that the `GameGrade` object is not destroyed when a new scene is loaded. \n\nThe `OnGUI` method is responsible for drawing the grade texture on the screen. It checks if the game is being played in a specific mode (Netmarble or Developer) and then calls the `TextureUtil.DrawTexture` method to draw the grade texture on the screen. \n\nThe `Update` method is called every frame and it updates the `delta` variable with the time elapsed since the last frame. If the elapsed time exceeds the `maxDelta` value, the `showPic` variable is set to true, indicating that the grade texture should be shown. The `deltaShow` variable is also updated to keep track of the time the grade texture has been shown. If the elapsed time exceeds the `maxDeltaShow` value, the `showPic` variable is set to false, indicating that the grade texture should no longer be shown. \n\nOverall, the purpose of this code is to display a grade texture on the screen for a certain period of time, based on the elapsed time and specified intervals. This functionality can be used in the larger Brick-Force project to provide visual feedback or rewards to the player based on their performance or progress in the game.\n## Questions: \n 1. What is the purpose of the `GameGrade` class?\n- The purpose of the `GameGrade` class is not clear from the provided code. It seems to handle GUI elements related to game grading, but more information is needed to determine its exact purpose.\n\n2. What is the significance of the `maxDelta` and `maxDeltaShow` variables?\n- The `maxDelta` variable determines the maximum value that the `delta` variable can reach before it is reset to 0. The `maxDeltaShow` variable determines the maximum value that the `deltaShow` variable can reach before the `showPic` variable is set to false.\n\n3. What is the purpose of the `OnGUI` method?\n- The `OnGUI` method is responsible for rendering GUI elements related to game grading. It checks if the game is being built for Netmarble or in developer mode before rendering the GUI elements.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\GameGrade.md"}}],["226",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\GdgtBrickComposer.cs)\n\nThe code provided is a class called `GdgtBrickComposer` that extends the `WeaponGadget` class. This class is part of the larger Brick-Force project and is responsible for composing and controlling the behavior of a brick weapon gadget.\n\nThe `GdgtBrickComposer` class has several private variables, including `muzzle`, `muzzleFxInstance`, `transformFever`, and `objFever`. These variables are used to store references to various game objects and components that are needed for the functionality of the brick weapon gadget.\n\nThe `Compose` method is the main entry point for composing the brick weapon gadget. It takes a boolean parameter `isDel` which determines whether the gadget is being composed or decomposed. Inside the `Compose` method, several other methods are called to perform various actions. \n\nThe `CreateMuzzleFire` method is responsible for creating a muzzle fire effect when the weapon is fired. It checks if the `muzzle` and `muzzleFire` components are not null, and if so, it instantiates a muzzle fire game object and attaches it to the muzzle position. It then emits particles from the muzzle fire effect.\n\nThe `FireSound` and `DelFireSound` methods are responsible for playing the fire and clip out sounds respectively. They check if the `brickSoundChange` property is false and if the audio source and sound clips are not null, and if so, they play the corresponding sound.\n\nThe `Start` method is called when the gadget is started and it initializes the `muzzle` variable by searching for a child object with the name \"Dummy_fire_effect\". It also calls the `InitializeAnimation` method to set up the animation properties.\n\nThe `updateFever` method updates the position and rotation of the `objFever` game object based on the `transformFever` position and rotation.\n\nThe `Update` method is called every frame and it calls the `updateFever` method.\n\nThe `DoFireAnimation` method plays the fire animation if it is not already playing. If it is playing, it sets the animation time to a quarter of its length.\n\nThe `InitializeAnimation` method sets up the animation properties for the gadget, including the wrap mode, layer, and crossfade.\n\nThe `setFever` method is responsible for setting the fever mode of the gadget. If `isOn` is true, it destroys the `objFever` game object if it exists, searches for a child object with the name \"Dummy_fire_effect\" to set the `transformFever` variable, and instantiates a new `objFever` game object. If `isOn` is false, it destroys the `objFever` game object and sets the `transformFever` variable to null.\n\nOverall, this code provides the functionality for composing and controlling a brick weapon gadget in the Brick-Force project. It handles the creation of muzzle fire effects, playing sounds, updating animations, and managing the fever mode of the gadget.\n## Questions: \n 1. What is the purpose of the `Compose` method?\n- The `Compose` method is responsible for creating the muzzle fire, playing the appropriate fire sound, and triggering the fire animation.\n\n2. What is the significance of the `muzzle` variable and how is it initialized?\n- The `muzzle` variable is a reference to the transform of the muzzle of the weapon. It is initialized in the `Start` method by searching for a child transform with the name \"Dummy_fire_effect\".\n\n3. What is the purpose of the `setFever` method and how does it work?\n- The `setFever` method is used to enable or disable a fever effect on the weapon. If `isOn` is true, it creates a fever effect at the position of the `transformFever` transform. If `isOn` is false, it destroys the fever effect and resets the `transformFever` reference.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\GdgtBrickComposer.md"}}],["227",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\GdgtClockBomb.cs)\n\nThe code provided is a class called `GdgtClockBomb` that extends the `WeaponGadget` class. This class is part of the larger Brick-Force project and is responsible for managing the visibility and behavior of a clock bomb gadget in the game.\n\nThe `GdgtClockBomb` class has several private variables: `explosionMatch` of type `ExplosionMatch` and `desc` of type `BrickManDesc`. These variables are used to store references to other components and objects in the game.\n\nThe `Install` method is an overridden method from the `WeaponGadget` class. It takes a boolean parameter `install` and is called when the gadget is installed or uninstalled. If `install` is true, it calls the `StartFireSound` method of the `Weapon` component attached to the game object. If `install` is false, it calls the `EndFireSound` method of the `Weapon` component.\n\nThe `EnsureVisibility` method is responsible for determining whether the clock bomb should be shown or hidden based on the current state of the `explosionMatch` and `desc` variables. If the `explosionMatch`'s `BombInstaller` property matches the `desc`'s `Seq` property, the bomb is hidden. Otherwise, if the `desc`'s `IsHidePlayer` property is false, the bomb is shown.\n\nThe `VerifyBrickManDesc` method checks if the `desc` variable is null and if so, it retrieves the `Desc` property from the first `PlayerProperty` component found in the hierarchy of the game object.\n\nThe `VerifyExplosionMatch` method checks if the `explosionMatch` variable is null and if so, it finds the game object with the name \"Main\" and retrieves the `ExplosionMatch` component attached to it.\n\nThe `Show` method enables the `MeshRenderer` component on all child game objects of the current game object, making the clock bomb visible.\n\nThe `Hide` method disables the `MeshRenderer` component on all child game objects of the current game object, making the clock bomb invisible. It also calls the `EndFireSound` method of the `Weapon` component.\n\nThe `Start` and `Update` methods are empty and currently do not have any functionality.\n\nIn summary, this code manages the visibility and behavior of a clock bomb gadget in the game. It handles the installation and uninstallation of the gadget, determines whether the bomb should be shown or hidden based on certain conditions, and provides methods to show or hide the bomb.\n## Questions: \n 1. What is the purpose of the `Install` method?\n- The `Install` method is responsible for starting or ending the fire sound of the weapon gadget, depending on the value of the `install` parameter.\n\n2. What is the purpose of the `EnsureVisibility` method?\n- The `EnsureVisibility` method is used to determine whether the gadget should be hidden or shown based on the values of `desc` and `explosionMatch`.\n\n3. What is the purpose of the `VerifyBrickManDesc` method?\n- The `VerifyBrickManDesc` method is used to check if the `desc` variable is null and if so, it assigns the `Desc` property of the first `PlayerProperty` component found in the hierarchy to `desc`.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\GdgtClockBomb.md"}}],["228",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\GdgtFlashBang.cs)\n\nThe code provided is a part of the Brick-Force project and is a class called \"GdgtFlashBang\". This class extends the \"WeaponGadget\" class and is responsible for managing the behavior of a flashbang gadget in the game.\n\nThe class has several fields and methods that control the functionality of the flashbang gadget. Let's go through each of them:\n\n1. `dic`: This is a dictionary that stores the flashbang projectiles. The key is an integer index and the value is an instance of the `ProjectileWrap` class, which wraps the flashbang projectile game object.\n\n2. `selfExplosion`: This is a reference to a game object that represents the explosion effect when the flashbang explodes.\n\n3. `Start()`: This method is called when the flashbang gadget is initialized. It checks if the game is using a specific weapon texture and applies it to the flashbang gadget if necessary. It also initializes the `dic` dictionary.\n\n4. `EnableHandbomb(bool enable)`: This method enables or disables the visibility of the flashbang gadget in the player's hand. It iterates through the child mesh renderers of the flashbang gadget and sets their enabled property based on the `enable` parameter.\n\n5. `OnDisable()`: This method is called when the flashbang gadget is disabled. It destroys all the flashbang projectiles in the `dic` dictionary and clears the dictionary.\n\n6. `GetWeaponBY()`: This method returns the weapon type of the flashbang gadget. It retrieves the `Weapon` component attached to the flashbang gadget and checks its `weaponBy` property. If the `Weapon` component or `WeaponFunction` component is not found, it returns a default weapon type.\n\n7. `ToProjectileWrap()`: This method converts the `dic` dictionary into an array of `ProjectileWrap` objects and returns it. It iterates through the key-value pairs in the `dic` dictionary and adds the values to a list. Finally, it converts the list to an array and returns it.\n\n8. `Throw(int index, Vector3 initPos, Vector3 pos, Vector3 rot, bool bSoundvoc, bool IsYang)`: This method is called when the flashbang gadget is thrown. It creates a new flashbang projectile game object, sets its position and rotation, and adds it to the `dic` dictionary. It also plays a sound effect based on the weapon type.\n\n9. `SelfKaboom(Vector3 pos)`: This method is called when the flashbang gadget explodes. It instantiates an explosion effect game object at the specified position. It also switches the visibility of the flashbang gadget and updates the global variables.\n\n10. `Kaboom(int index)`: This method is called when a specific flashbang projectile explodes. It retrieves the explosion game object from the projectile, instantiates it at the projectile's position, and removes the projectile from the `dic` dictionary. It also switches the visibility of the flashbang gadget and updates the global variables.\n\n11. `LetProjectileFly()`: This method is called to make all the flashbang projectiles fly. It iterates through the key-value pairs in the `dic` dictionary and calls the `Fly()` method on each `ProjectileWrap` object.\n\n12. `Fly(int index, Vector3 pos, Vector3 rot, float range)`: This method is called to update the target position, rotation, and range of a specific flashbang projectile. It retrieves the projectile from the `dic` dictionary using the index and updates its properties.\n\nOverall, this code manages the behavior of the flashbang gadget in the game. It handles the initialization, throwing, exploding, and updating of flashbang projectiles. It also provides methods to enable or disable the visibility of the flashbang gadget and retrieve information about the weapon type.\n## Questions: \n **Question 1:** What is the purpose of the `EnableHandbomb` method?\n    \n**Answer:** The `EnableHandbomb` method is used to enable or disable the visibility of the handbomb object by enabling or disabling the `MeshRenderer` components.\n\n**Question 2:** What does the `ToProjectileWrap` method return?\n    \n**Answer:** The `ToProjectileWrap` method returns an array of `ProjectileWrap` objects that are stored in the `dic` dictionary.\n\n**Question 3:** What is the purpose of the `Fly` method?\n    \n**Answer:** The `Fly` method is used to update the target position, target rotation, and range of a specific projectile in the `dic` dictionary.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\GdgtFlashBang.md"}}],["229",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\GdgtGrenade.cs)\n\nThe `GdgtGrenade` class is a subclass of the `WeaponGadget` class and is part of the larger Brick-Force project. This class represents a grenade gadget that can be used as a weapon in the game. \n\nThe class has several fields and methods that are used to control the behavior of the grenade. The `dic` field is a dictionary that stores references to the grenades that have been thrown. The `selfExplosion` field is a reference to a game object that represents the explosion effect when the grenade detonates.\n\nThe `Start` method is called when the grenade is instantiated. It checks if a certain build option is enabled and if a certain condition is met, it updates the textures of the grenade's mesh renderers.\n\nThe `EnableHandbomb` method is used to enable or disable the visibility of the grenade's mesh renderers and skinned mesh renderers.\n\nThe `OnDisable` method is called when the grenade is disabled. It destroys all the projectiles in the `dic` dictionary and clears the dictionary.\n\nThe `GetWeaponBY` method returns the `weaponBy` field of the `WeaponFunction` component attached to the grenade. This field represents the type of weapon the grenade is categorized as.\n\nThe `ToProjectileWrap` method converts the `dic` dictionary into an array of `ProjectileWrap` objects and returns it.\n\nThe `Throw` method is called when the grenade is thrown. It instantiates a new projectile game object and adds it to the `dic` dictionary. It also plays a sound effect and sets the rigidbody and projectile components of the projectile game object to certain states.\n\nThe `SelfKaboom` method is called when the grenade detonates. It instantiates an explosion effect game object at a specified position.\n\nThe `Kaboom` method is called when a specific grenade in the `dic` dictionary detonates. It instantiates an explosion effect game object at the position of the grenade and destroys the grenade game object.\n\nThe `LetProjectileFly` method is called to make all the projectiles in the `dic` dictionary start moving towards their target positions.\n\nThe `Fly` method is called to update the target position, target rotation, and range of a specific projectile in the `dic` dictionary.\n\nOverall, this code represents the behavior of a grenade gadget in the Brick-Force game. It handles the throwing, detonation, and movement of grenades, as well as the visual effects associated with them.\n## Questions: \n **Question 1:** What is the purpose of the `EnableHandbomb` method?\n- The `EnableHandbomb` method is used to enable or disable the visibility of the handbomb object by enabling or disabling the `MeshRenderer` and `SkinnedMeshRenderer` components.\n\n**Question 2:** What does the `Throw` method do?\n- The `Throw` method is responsible for instantiating a bullet or body object and adding it to the `dic` dictionary with a unique index. It also plays a sound effect and sets the initial position, rotation, and kinematic state of the object.\n\n**Question 3:** What is the purpose of the `Kaboom` method?\n- The `Kaboom` method is used to create an explosion effect at the position of a projectile with a given index. It instantiates the explosion object and destroys the projectile object.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\GdgtGrenade.md"}}],["230",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\GdgtMelee.cs)\n\nThe code provided is a class called `GdgtMelee` that inherits from the `WeaponGadget` class. This class represents a melee weapon gadget in the larger Brick-Force project. \n\nThe `Fire` method is an overridden method from the `WeaponGadget` class. It takes in three parameters: `projectile`, `origin`, and `direction`. However, in the provided code, the method only calls the `FireSound` method of the `Weapon` component attached to the same game object. This suggests that the `Fire` method is responsible for playing the sound effect associated with firing the melee weapon gadget.\n\nThe `Start` method is a Unity lifecycle method that is called when the game object is first initialized. In this method, there is a conditional statement that checks if a certain build option is enabled (`BuildOption.Instance.Props.useUskWeaponTex`) and if `applyUsk` is true. If both conditions are met, the method proceeds to modify the textures of the skinned mesh renderers and mesh renderers attached to the game object.\n\nThe method first retrieves all the `SkinnedMeshRenderer` components attached to the game object using the `GetComponentsInChildren` method. It then iterates over each `SkinnedMeshRenderer` and checks if its `material.mainTexture` is not null and if the texture name exists in the `UskManager` instance. If both conditions are met, the method retrieves the modified texture from the `UskManager` and assigns it to the `material.mainTexture` of the `SkinnedMeshRenderer`.\n\nThe method then performs the same process for the `MeshRenderer` components attached to the game object.\n\nIn summary, the purpose of this code is to handle the firing sound effect of the melee weapon gadget and modify the textures of the skinned mesh renderers and mesh renderers attached to the game object, based on certain build options and conditions. This code is likely part of a larger system that manages different types of weapons and their associated functionalities in the Brick-Force project.\n## Questions: \n 1. What is the purpose of the `Fire` method and what does it do?\n- The `Fire` method is responsible for playing the fire sound of the weapon, but it does not actually fire any projectiles.\n\n2. What is the significance of the condition `BuildOption.Instance.Props.useUskWeaponTex && applyUsk` in the `Start` method?\n- The condition checks if the `useUskWeaponTex` property is true in the `Props` object of the `BuildOption.Instance` and if `applyUsk` is also true. If both conditions are met, the method proceeds to modify the main textures of the skinned mesh renderers and mesh renderers.\n\n3. What is the purpose of the `UskManager` class and how is it used in this code?\n- The `UskManager` class is used to retrieve textures based on their names. In this code, it is used to replace the main textures of the skinned mesh renderers and mesh renderers with the textures retrieved from the `UskManager` instance.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\GdgtMelee.md"}}],["231",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\GdgtSenseBomb.cs)\n\nThe code provided is a script for a class called \"GdgtSenseBomb\" that extends the \"WeaponGadget\" class. This class represents a sense bomb gadget in the game. \n\nThe purpose of this code is to handle the functionality of the sense bomb gadget, including its visual effects and interactions with other game objects. \n\nThe class has several private variables, including \"beamObj\" and \"bombObj\" which represent the visual objects for the sense bomb and its beam, \"explosion\" which represents the explosion effect, \"expPos\" which stores the position of the explosion, \"senseBombSeq\" which keeps track of the sequence of the sense bomb, \"installingEff\" which represents the installation effect, \"installing\" which indicates whether the sense bomb is being installed, \"dtWaitBeam\" which keeps track of the time since the beam was activated, \"maxWaitBeam\" which determines the maximum time to wait for the beam to be activated, \"vBomb\" which stores the position of the sense bomb, \"vBombNormal\" which stores the normal vector of the sense bomb, and \"playerslot\" which represents the player's slot.\n\nThe \"Start\" method is called when the object is initialized and it sets the local rotation of the object and applies a texture if the \"useUskWeaponTex\" option is enabled.\n\nThe \"EnableHandbomb\" method enables or disables the visibility of the sense bomb object based on the \"enable\" parameter.\n\nThe \"OnDisable\" method is called when the object is disabled.\n\nThe \"IsRed\" method checks if the player is on the red team based on the current room type and the player's slot.\n\nThe \"activeBeam\" method is called to activate the sense bomb's beam effect. It increments the \"dtWaitBeam\" variable and if it exceeds the \"maxWaitBeam\" value, it destroys the installation effect object and instantiates the beam object.\n\nThe \"SetSenseBeam\" method is called to set the sense beam for the sense bomb. It instantiates the sense bomb object, sets its position and rotation, and instantiates the installation effect object.\n\nThe \"Kaboom\" method is called to trigger the explosion of the sense bomb. It checks if the provided index matches the current sense bomb sequence and if so, it instantiates the explosion effect object and destroys the beam and bomb objects.\n\nThe \"Update\" method is called every frame and it calls the \"activeBeam\" method.\n\nIn the larger project, this code would be used to handle the functionality of the sense bomb gadget. It would be responsible for creating and destroying the sense bomb and its visual effects, as well as triggering the explosion effect when necessary. It would also handle the activation and deactivation of the sense bomb's beam effect.\n## Questions: \n 1. What is the purpose of the `EnableHandbomb` method?\n- The `EnableHandbomb` method is used to enable or disable the visibility of the handbomb object by enabling or disabling the mesh renderers.\n\n2. What is the significance of the `IsRed` method?\n- The `IsRed` method determines whether the player is on the red team or not based on the current room type and the player slot.\n\n3. What does the `Kaboom` method do?\n- The `Kaboom` method is responsible for creating an explosion effect at the position of the bomb and destroying the beam and bomb objects.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\GdgtSenseBomb.md"}}],["232",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\GdgtShutgun.cs)\n\nThe code provided is a class called \"GdgtShutgun\" that inherits from the \"WeaponGadget\" class. This class represents a specific type of weapon gadget called a shotgun in the larger Brick-Force project. \n\nThe purpose of this code is to handle the functionality and behavior of the shotgun gadget. It contains various methods that are responsible for different actions related to the gadget, such as playing sounds, creating visual effects, and firing projectiles.\n\nThe class has several private variables, including \"muzzle\" and \"shell\" which are used to store references to specific game objects representing the muzzle and shell of the shotgun. It also has variables for storing references to various visual effects instances and a dictionary for storing projectile objects.\n\nThe class overrides several methods from the base class, such as \"ClipOut\", \"ClipIn\", and \"BoltUp\", which are responsible for playing specific sounds when the gadget is used. These methods call the \"GadgetSound\" method of the \"Weapon\" component attached to the gadget.\n\nThe class also has several private methods that handle the creation of visual effects, such as \"CreateShell\" and \"CreateMuzzleFire\". These methods instantiate and position visual effect game objects based on the muzzle and shell references. The \"Shoot\" method is responsible for creating and positioning a bullet projectile based on the origin and direction parameters.\n\nThe \"Fire\" method is called when the gadget is fired. It calls the \"FireSound\", \"CreateMuzzleFire\", \"CreateShell\", and \"Shoot\" methods to play sounds, create visual effects, and fire a projectile.\n\nThe class also has several methods that are specific to different types of launchers, such as \"GetMuzzleFireEffByLauncher\" and \"GetMissileByLauncher\". These methods return specific game objects based on the launcher type.\n\nThe \"Fire2\" method is called when a secondary fire is triggered. It sets the launcher type, creates muzzle fire and smoke effects, and instantiates a missile object.\n\nThe \"Fly\" method is called to update the position and rotation of the missile object.\n\nThe \"KaBoom\" method is called when the missile explodes. It instantiates an explosion effect and destroys the missile and smoke effects.\n\nThe \"Start\" method is called when the gadget is initialized. It sets up references to the muzzle and shell game objects and initializes the animation.\n\nThe \"DoFireAnimation\" method is responsible for playing the fire animation.\n\nThe \"InitializeAnimation\" method sets up the animation properties and plays the idle animation.\n\nThe \"GunAnim\" method is called to play specific animations based on the provided parameter.\n\nThe \"Update\" method is called every frame and updates the position of the projectile objects and plays the idle animation if no other animations are playing.\n\nIn summary, this code represents the functionality and behavior of a shotgun gadget in the Brick-Force project. It handles the creation of visual effects, playing sounds, and firing projectiles.\n## Questions: \n 1. What is the purpose of the `GdgtShutgun` class?\n- The `GdgtShutgun` class is a subclass of `WeaponGadget` and represents a specific type of weapon gadget in the game.\n2. What is the role of the `dic` dictionary in this code?\n- The `dic` dictionary is used to store and manage instances of `ProjectileWrap` objects, which represent projectiles fired by the weapon gadget.\n3. What is the significance of the `Launcher` variable and how is it used?\n- The `Launcher` variable is an enum that represents the type of launcher associated with the weapon gadget. It is used in various methods to determine the appropriate effects and objects to use based on the launcher type.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\GdgtShutgun.md"}}],["233",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\GdgtXmasBomb.cs)\n\nThe code provided is a class called \"GdgtXmasBomb\" that inherits from the \"WeaponGadget\" class. This class represents a specific type of weapon gadget in the larger Brick-Force project. \n\nThe purpose of this code is to define the behavior and functionality of the \"GdgtXmasBomb\" weapon gadget. It contains various properties and methods that control the behavior of the gadget, such as enabling or disabling the gadget, throwing projectiles, triggering explosions, and managing the projectiles.\n\nThe class has several properties, including \"smoke\", \"tail\", \"selfExplosion\", and \"dic\". These properties are used to store references to various game objects and data structures that are used in the functionality of the gadget.\n\nThe \"Start\" method is called when the gadget is initialized. It checks a build option and applies a texture to the gadget's mesh renderers if the option is enabled. It also initializes the \"dic\" dictionary, which is used to store references to the projectiles thrown by the gadget.\n\nThe \"EnableHandbomb\" method is used to enable or disable the visibility of the gadget's mesh renderers. It takes a boolean parameter \"enable\" and sets the \"enabled\" property of each mesh renderer to the value of \"enable\".\n\nThe \"OnDisable\" method is called when the gadget is disabled. It destroys all the projectiles stored in the \"dic\" dictionary and clears the dictionary.\n\nThe \"GetWeaponBY\" method returns the \"weaponBy\" property of the \"WeaponFunction\" component attached to the gadget's parent \"Weapon\" component. If the \"Weapon\" or \"WeaponFunction\" components are not found, it returns a default value.\n\nThe \"ToProjectileWrap\" method converts the projectiles stored in the \"dic\" dictionary into an array of \"ProjectileWrap\" objects and returns it.\n\nThe \"Throw\" method is called when the gadget is thrown. It creates a new projectile game object, sets its position and rotation, and adds it to the \"dic\" dictionary.\n\nThe \"SelfKaboom\" method triggers an explosion effect at a given position. It instantiates the \"selfExplosion\" and \"smoke\" game objects at the specified position.\n\nThe \"Kaboom\" method triggers an explosion effect for a specific projectile in the \"dic\" dictionary. It instantiates the explosion and smoke game objects at the position of the projectile, and then destroys the projectile.\n\nThe \"LetProjectileFly\" method calls the \"Fly\" method for each projectile in the \"dic\" dictionary. This method is responsible for updating the position and rotation of the projectiles to make them move towards their target position.\n\nThe \"Fly\" method updates the target position, target rotation, and range of a specific projectile in the \"dic\" dictionary. This method is called to update the movement of a projectile.\n\nOverall, this code defines the behavior and functionality of the \"GdgtXmasBomb\" weapon gadget in the Brick-Force project. It provides methods to enable or disable the gadget, throw projectiles, trigger explosions, and manage the projectiles.\n## Questions: \n 1. **What is the purpose of the `GdgtXmasBomb` class?**\nThe `GdgtXmasBomb` class is a subclass of `WeaponGadget` and represents a specific type of weapon gadget in the game. It contains methods and properties related to the functionality of this gadget.\n\n2. **What is the purpose of the `dic` dictionary?**\nThe `dic` dictionary is used to store and manage instances of `ProjectileWrap` objects. It is initialized in the `Start()` method and is used in various methods to add, remove, and access `ProjectileWrap` objects.\n\n3. **What is the purpose of the `Throw()` method?**\nThe `Throw()` method is responsible for throwing the gadget. It instantiates a new projectile object based on the `BulletOrBody` property of the `Weapon` component attached to the same game object as the `GdgtXmasBomb` script. It also handles sound effects and adds the projectile to the `dic` dictionary.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\GdgtXmasBomb.md"}}],["234",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\GhostSwitch.cs)\n\nThe code provided is for a class called \"GhostSwitch\" in the Brick-Force project. This class is responsible for enabling and disabling the \"ghost\" mode for a player character in the game.\n\nThe class has several private variables, including a boolean variable \"isGhost\" to keep track of whether the player is currently in ghost mode, and references to various components of the player character such as SkinnedMeshRenderers, MeshRenderers, Colliders, and ParticleRenderers. These variables will be used to enable or disable these components when the player enters or exits ghost mode.\n\nThe class has several methods. The \"Start\" method is empty and does not contain any code.\n\nThe \"VerifyDesc\" method is used to check if the \"desc\" variable is null. If it is null, it tries to get the \"Desc\" property from a \"PlayerProperty\" component attached to the same game object. If the \"Desc\" property is not null, it assigns it to the \"desc\" variable. This method is called in the \"Update\" method to ensure that the \"desc\" variable is always up to date.\n\nThe \"Update\" method is called every frame and is responsible for checking the \"desc\" variable. If the \"desc\" variable is not null and the \"IsHidePlayer\" property of the \"desc\" variable is true (indicating that the player should be in ghost mode), and the player is not already in ghost mode, the \"EnableGhost\" method is called. If the \"IsHidePlayer\" property is false (indicating that the player should not be in ghost mode), and the player is currently in ghost mode, the \"DisableGhost\" method is called.\n\nThe \"EnableGhost\" method is responsible for enabling the ghost mode for the player. It first checks if the player is not already in ghost mode. If not, it sets the \"isGhost\" variable to true. Then, it retrieves all the ParticleRenderers, Colliders, MeshRenderers, and SkinnedMeshRenderers attached to the player character and disables them by setting their \"enabled\" property to false. It also stores references to these disabled components in separate arrays for later use.\n\nThe \"DisableGhost\" method is responsible for disabling the ghost mode for the player. It first checks if the player is currently in ghost mode. If so, it sets the \"isGhost\" variable to false. Then, it iterates over the arrays of disabled ParticleRenderers, MeshRenderers, SkinnedMeshRenderers, and Colliders, and enables them by setting their \"enabled\" property to true. Finally, it sets the arrays of disabled components to null.\n\nIn summary, this code allows the player character to enter and exit ghost mode by enabling or disabling various components of the character. This can be used in the larger Brick-Force project to implement a gameplay mechanic where the player can become invisible or intangible to other players or enemies.\n## Questions: \n 1. What is the purpose of the GhostSwitch class?\n- The GhostSwitch class is responsible for enabling and disabling the \"ghost\" effect on the player character.\n\n2. What is the significance of the desc variable?\n- The desc variable is used to store the BrickManDesc object, which contains information about the player character's properties.\n\n3. What does the EnableGhost() method do?\n- The EnableGhost() method disables various components (ParticleRenderer, Collider, MeshRenderer, SkinnedMeshRenderer) on the player character to create the \"ghost\" effect.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\GhostSwitch.md"}}],["235",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\GiveBuildGun.cs)\n\nThe code provided is a class called `GiveBuildGun` that extends the `ScriptCmd` class. This class represents a command in the larger Brick-Force project that gives the player a build gun. \n\nThe `GiveBuildGun` class has a private string variable called `code` and a public property called `Code` that allows access to this variable. The `Code` property has a getter and a setter, which allows other parts of the code to get and set the value of `code`.\n\nThe class overrides several methods from the `ScriptCmd` class. The `GetIconIndex` method returns the index of the icon associated with the `GiveBuildGun` command. In this case, it returns the value 7.\n\nThe `GetDescription` method returns a string that describes the `GiveBuildGun` command. It concatenates the string \"givebuildgun\" with the first element of the `ArgDelimeters` array from the `ScriptCmd` class, and then appends the value of the `code` variable. The `ArgDelimeters` array is a static property of the `ScriptCmd` class that holds delimiters used in the command arguments.\n\nThe `GetDefaultDescription` method returns a default description for the `GiveBuildGun` command. It is similar to the `GetDescription` method, but it appends an empty string instead of the value of the `code` variable.\n\nThe `GetName` method returns the name of the `GiveBuildGun` command, which is \"GiveBuildGun\".\n\nIn the larger Brick-Force project, this `GiveBuildGun` class would be used to define and handle the logic for the \"givebuildgun\" command. Other parts of the code could create an instance of this class and use its methods and properties to get information about the command and perform actions related to giving the player a build gun. For example, other parts of the code could call the `GetDescription` method to display information about the command to the player.\n## Questions: \n 1. What is the purpose of the `GiveBuildGun` class?\n- The `GiveBuildGun` class is a subclass of `ScriptCmd` and represents a command to give a build gun.\n\n2. What is the significance of the `Code` property?\n- The `Code` property is a string that holds the code for the `GiveBuildGun` command.\n\n3. What is the purpose of the `GetDescription` method?\n- The `GetDescription` method returns a string that describes the `GiveBuildGun` command, including the code.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\GiveBuildGun.md"}}],["236",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\GiveWeapon.cs)\n\nThe code provided is a class called `GiveWeapon` that extends the `ScriptCmd` class. This class is likely a part of the larger Brick-Force project and is responsible for defining the behavior of a command that gives a weapon to a player.\n\nThe `GiveWeapon` class has a private string variable called `weaponCode` and a corresponding public property called `WeaponCode`. This property allows other classes to get and set the value of the `weaponCode` variable. \n\nThe class overrides several methods from the `ScriptCmd` class. The `GetIconIndex` method returns the index of the icon associated with the `GiveWeapon` command. In this case, it always returns 6.\n\nThe `GetDescription` method returns a string that describes the `GiveWeapon` command. It concatenates the string \"giveweapon\" with the first element of the `ScriptCmd.ArgDelimeters` array (which is likely a delimiter used in the larger project) and the value of the `weaponCode` variable. \n\nThe `GetDefaultDescription` method returns a default description for the `GiveWeapon` command. It is similar to the `GetDescription` method, but it appends an empty string to the end.\n\nThe `GetName` method returns the name of the `GiveWeapon` command, which is \"GiveWeapon\".\n\nOverall, this code defines the behavior of the `GiveWeapon` command in the Brick-Force project. It allows other classes to get and set the weapon code, retrieve the icon index, and get the description and name of the command. This class can be used in the larger project to handle the logic and functionality related to giving weapons to players.\n## Questions: \n 1. What is the purpose of the `GiveWeapon` class?\n- The `GiveWeapon` class is a subclass of `ScriptCmd` and is used to define a command for giving a weapon in the Brick-Force game.\n\n2. What is the purpose of the `WeaponCode` property?\n- The `WeaponCode` property is used to get or set the code of the weapon that will be given when the `GiveWeapon` command is executed.\n\n3. What is the significance of the `GetDefaultDescription` method?\n- The `GetDefaultDescription` method returns the default description for the `GiveWeapon` command, which is \"giveweapon\" followed by an argument delimiter and an empty string.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\GiveWeapon.md"}}],["237",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\GM_COMMAND_LOGER.cs)\n\nThe code provided is a class called `GM_COMMAND_LOGER` that is part of the Brick-Force project. This class is responsible for logging and sending usage information for various game commands. \n\nThe class contains an enum called `GM_COMMAND_LOG` which lists all the possible game commands that can be logged. Each command is represented by a unique identifier. \n\nThe class also has a static boolean array called `sendUseCommand` which keeps track of whether a specific command has been sent or not. This array is initialized with a size of 24 and all elements are set to false initially. \n\nThe `SendLog` method is used to send a log for a specific command. It takes a `GM_COMMAND_LOG` parameter which represents the command to be logged. The method first checks if the provided command is within the range of valid commands. If it is, it checks if the `sendUseCommand` array is null. If it is, it initializes the array and sets all elements to false. Then, it checks if the command is resendable by calling the `IsResendAble` method. If it is, it sends the log to the server using the `CSNetManager.Instance.Sock.SendCS_GM_COMMAND_USAGE_LOG_REQ` method.\n\nThe `IsResendAble` method is used to determine if a specific command is resendable. It takes a `GM_COMMAND_LOG` parameter and checks if the command is one of the specific commands that can be resent. If it is, it checks if the corresponding element in the `sendUseCommand` array is false. If it is, it sets the element to true and returns true. If the element is already true, it returns false. For all other commands, it returns true.\n\nOverall, this code provides a way to log and send usage information for specific game commands. It ensures that duplicate logs for certain commands are not sent multiple times. This functionality can be used in the larger Brick-Force project to track and analyze how players are using different game commands.\n## Questions: \n 1. What is the purpose of the GM_COMMAND_LOG enum?\n- The GM_COMMAND_LOG enum is used to define different types of GM commands that can be logged.\n\n2. What is the purpose of the SendLog method?\n- The SendLog method is used to send a log of a GM command usage to the CSNetManager.\n\n3. What is the purpose of the IsResendAble method?\n- The IsResendAble method is used to determine if a GM command log can be resent or not, based on the type of command and whether it has already been sent before.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\GM_COMMAND_LOGER.md"}}],["238",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\GrbMain.cs)\n\nThe code provided is a script for the GrbMain class in the Brick-Force project. This class is responsible for handling the main menu screen of the game. \n\nThe script starts by defining an enum called STEP, which represents the different steps or states that the main menu can be in. These steps include FADE_IN, WAIT, FADE_OUT, AUTO_LOGIN, AUTO_LOGIN_TO_RUNUP, and AUTO_LOGIN_TO_NETMARBLE.\n\nThe script also includes public variables for the grbLogo texture and the fade in, wait, and fade out times. These variables can be set in the Unity editor to customize the appearance and timing of the main menu.\n\nThe Awake() method is empty and does not contain any code.\n\nThe Start() method calls the FadeIn() method, which sets the step to FADE_IN and initializes the deltaTime variable to 0.\n\nThe OnGUI() method is responsible for drawing the main menu screen. It checks if the grbLogo texture is not null and then sets the GUI skin and GUI color based on the current step. The grbLogo texture is drawn at the center of the screen using the DrawTexture method from the TextureUtil class.\n\nThe FadeIn() method sets the step to FADE_IN and resets the deltaTime variable to 0.\n\nThe FadeOut() method sets the step to FADE_OUT and resets the deltaTime variable to 0.\n\nThe Wait() method sets the step to WAIT and resets the deltaTime variable to 0.\n\nThe MoveNext() method is called in the Update() method when the current step is FADE_OUT and the deltaTime exceeds the fadeOutTime. This method checks if certain levels can be loaded and then performs different actions based on the build options and tokens. For example, if the build option is set to runup, it extracts tokens from the web parameters and attempts to open a TCP connection. If the build option is not runup, it extracts a token and checks if it is empty. If it is empty, it loads the Login level. Otherwise, it sets the AutoLogin option and opens a TCP connection.\n\nThe Update() method is called every frame and updates the deltaTime variable. It also checks the current step and performs different actions based on the elapsed time and the current step. For example, if the current step is FADE_IN and the deltaTime exceeds the fadeInTime, it calls the Wait() method.\n\nThe OnRoundRobin() method is called when the round robin event occurs. It opens a TCP connection to the Brick-Force server.\n\nThe OnServiceFail() method is called when a service fails. It exits the game.\n\nThe OnSeed() method is called when the seed event occurs. It sends different requests to the server based on the current step.\n\nThe OnLoginFail() method is called when a login fails. It exits the game.\n\nThe OnLoginFailMessage() method is called when a login fail message is received. It displays an exit confirm dialog with the message.\n\nIn summary, this script handles the main menu screen of the Brick-Force game. It controls the fading in and out of the main menu logo, handles different steps and actions based on the elapsed time and build options, and communicates with the server for login and other requests.\n## Questions: \n 1. What is the purpose of the `FadeIn`, `FadeOut`, and `Wait` methods?\n- The `FadeIn` method sets the step to `FADE_IN` and resets the `deltaTime` to 0. The `FadeOut` method sets the step to `FADE_OUT` and resets the `deltaTime` to 0. The `Wait` method sets the step to `WAIT` and resets the `deltaTime` to 0. These methods are used to control the fading in and out of the GUI logo.\n\n2. What is the purpose of the `MoveNext` method?\n- The `MoveNext` method checks if certain levels can be loaded and performs different actions based on the conditions. It extracts values from parameters and sets the `step` accordingly. It also handles different scenarios for auto login.\n\n3. What is the purpose of the `OnRoundRobin`, `OnServiceFail`, `OnSeed`, `OnLoginFail`, and `OnLoginFailMessage` methods?\n- The `OnRoundRobin` method opens a new `SockTcp` connection to the Brick-Force server. The `OnServiceFail` method exits the application. The `OnSeed` method sends different requests based on the current `step`. The `OnLoginFail` method exits the application. The `OnLoginFailMessage` method displays an exit confirmation dialog with a specific message. These methods handle different events and actions based on the current state of the application.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\GrbMain.md"}}],["239",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\GUIDepth.cs)\n\nThe code provided defines a public class called `GUIDepth` that contains an enum called `LAYER`. This enum represents different layers or depths that can be used in a graphical user interface (GUI) system. Each layer is assigned a specific value, which determines its position in the GUI hierarchy.\n\nThe purpose of this code is to provide a standardized way of organizing and managing the different layers in the GUI system of the Brick-Force project. By using this enum, developers can easily reference and manipulate the different layers in their code.\n\nFor example, if a developer wants to display a loading screen on top of all other GUI elements, they can set the layer of the loading screen to `LOADING`:\n\n```csharp\nGUIElement loadingScreen = new GUIElement();\nloadingScreen.Layer = GUIDepth.LAYER.LOADING;\n```\n\nSimilarly, if a developer wants to display a menu below the loading screen but above the game controls, they can set the layer of the menu to `MENU`:\n\n```csharp\nGUIElement menu = new GUIElement();\nmenu.Layer = GUIDepth.LAYER.MENU;\n```\n\nThis code can be used throughout the project to ensure consistent layering of GUI elements. It provides a clear and intuitive way for developers to understand and manage the depth of different GUI components.\n\nIn the larger context of the Brick-Force project, this code is likely used in conjunction with other GUI-related classes and components to create a visually appealing and interactive user interface. By defining and using specific layers, the project can ensure that GUI elements are displayed in the correct order and hierarchy, improving the overall user experience.\n## Questions: \n 1. **What is the purpose of the `GUIDepth` class?**\nThe `GUIDepth` class is likely used to define and organize the different layers of the graphical user interface (GUI) in the Brick-Force project.\n\n2. **What is the significance of the values assigned to each layer in the `LAYER` enum?**\nThe values assigned to each layer in the `LAYER` enum likely determine the order in which the GUI elements are rendered, with lower values being rendered first and higher values being rendered last.\n\n3. **Are there any other classes or components that interact with the `GUIDepth` class?**\nTo fully understand the role and functionality of the `GUIDepth` class, it would be helpful to know if there are any other classes or components that interact with it, such as a GUI manager or renderer.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\GUIDepth.md"}}],["240",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\GUISkinFinder.cs)\n\nThe `GUISkinFinder` class is responsible for managing the GUI skin used in the Brick-Force project. A GUI skin is a collection of graphical styles and settings that define the appearance of GUI elements in the game.\n\nThe `GUISkinFinder` class has a public `guiSkin` variable of type `GUISkin`, which represents the GUI skin used in the project. This variable can be set in the Unity editor or through code.\n\nThe class also has a private static array `builtinGUIStyleNames` that contains the names of the built-in GUI styles provided by Unity. These styles include \"box\", \"button\", \"toggle\", \"label\", and others.\n\nThe class has a static property `Instance` that provides a singleton instance of the `GUISkinFinder` class. This ensures that there is only one instance of the class throughout the project. The instance is obtained by finding an object of type `GUISkinFinder` in the scene. If no instance is found, an error message is logged.\n\nThe `Awake` method is called when the object is initialized. It uses `Object.DontDestroyOnLoad` to prevent the object from being destroyed when a new scene is loaded.\n\nThe `UpdateFont` method is used to update the font used in the GUI skin. It takes a `Font` parameter `curFont` and sets the `font` property of the `guiSkin` to `curFont`. It also updates the font of all the GUI styles in the `guiSkin` and the built-in GUI styles.\n\nThe `GetGUISkin` method simply returns the `guiSkin` variable.\n\nThe `LanguageChanged` method is called when the language in the game is changed. It calls the `SetFont` method of the `LangOptManager` class to update the font used for language options. It then finds the \"Main\" object in the scene and sends a message to its \"OnLanguageChanged\" method.\n\nOverall, the `GUISkinFinder` class provides functionality to manage the GUI skin used in the Brick-Force project. It allows for updating the font used in the GUI skin and handles language changes in the game.\n## Questions: \n 1. What is the purpose of the `GUISkinFinder` class?\n- The `GUISkinFinder` class is responsible for finding and updating the GUI skin used in the game.\n\n2. What is the significance of the `builtinGUIStyleNames` array?\n- The `builtinGUIStyleNames` array contains the names of the built-in GUI styles that are used in the game.\n\n3. What does the `UpdateFont` method do?\n- The `UpdateFont` method updates the font used in the GUI skin and all the GUI styles associated with it.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\GUISkinFinder.md"}}],["241",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\GUISkinHolder.cs)\n\nThe code provided is a class called `GUISkinHolder` that is a part of the larger Brick-Force project. This class is responsible for holding a reference to a GUI skin, which is a collection of graphical assets used to define the appearance of the user interface in the game.\n\nThe purpose of this class is to provide a centralized location for accessing the GUI skin throughout the project. By holding a reference to the GUI skin, other classes and scripts can easily access and use the skin without having to search for it or create a new instance.\n\nOne possible use case for this class is in the creation of GUI elements, such as buttons or labels, in the game. When creating a GUI element, the developer can simply reference the GUI skin held by the `GUISkinHolder` class to apply the desired visual style to the element. This promotes consistency in the appearance of the user interface across different parts of the game.\n\nHere is an example of how the `GUISkinHolder` class can be used:\n\n```csharp\npublic class MyGUIElement : MonoBehaviour\n{\n    private GUISkinHolder guiSkinHolder;\n\n    private void Start()\n    {\n        // Get a reference to the GUISkinHolder instance\n        guiSkinHolder = FindObjectOfType<GUISkinHolder>();\n    }\n\n    private void OnGUI()\n    {\n        // Apply the GUI skin to the button\n        GUI.skin = guiSkinHolder.GUISkin;\n\n        // Create a button with the GUI skin\n        if (GUI.Button(new Rect(10, 10, 100, 50), \"Click me\"))\n        {\n            // Handle button click event\n        }\n    }\n}\n```\n\nIn this example, the `MyGUIElement` class retrieves a reference to the `GUISkinHolder` instance in the `Start` method. Then, in the `OnGUI` method, the GUI skin held by the `GUISkinHolder` instance is applied to the button using `GUI.skin`. This ensures that the button will have the desired visual style defined by the GUI skin.\n\nOverall, the `GUISkinHolder` class plays a crucial role in the Brick-Force project by providing a centralized location for accessing and using the GUI skin, promoting consistency and ease of use in the creation of the game's user interface.\n## Questions: \n 1. What is the purpose of the `GUISkinHolder` class?\n- The `GUISkinHolder` class is likely used to hold and manage a GUI skin in the Unity game engine.\n\n2. Why is the `UnityEngine` namespace being used?\n- The `UnityEngine` namespace is being used to access the necessary classes and functionality provided by the Unity game engine.\n\n3. What other methods or properties does the `GUISkinHolder` class have?\n- Without additional code provided, it is not possible to determine what other methods or properties the `GUISkinHolder` class has.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\GUISkinHolder.md"}}],["242",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\GUISkinHolderCordi.cs)\n\nThe code provided is a class called `GUISkinHolderCordi` that is derived from the `MonoBehaviour` class in the Unity game engine. \n\nBased on the code provided, it appears that the purpose of this class is to hold a reference to a GUI skin. A GUI skin is a collection of graphical resources that define the appearance of user interface elements in a game. It includes things like fonts, colors, textures, and styles.\n\nBy creating a separate class to hold the GUI skin reference, it allows other scripts or components in the game to easily access and use the GUI skin without having to search for it or duplicate the reference.\n\nHere is an example of how this class might be used in the larger project:\n\n```csharp\nusing UnityEngine;\n\npublic class MyGUIComponent : MonoBehaviour\n{\n    public GUISkinHolderCordi guiSkinHolder;\n\n    private void OnGUI()\n    {\n        GUI.skin = guiSkinHolder.GUISkin; // Set the GUI skin to the one held by the GUISkinHolderCordi instance\n\n        // Use the GUI skin to draw UI elements\n        GUI.Label(new Rect(10, 10, 100, 20), \"Hello, World!\");\n    }\n}\n```\n\nIn this example, we have another script called `MyGUIComponent` that needs to use a GUI skin to draw UI elements on the screen. By adding a public field of type `GUISkinHolderCordi`, we can assign a reference to a `GUISkinHolderCordi` instance in the Unity editor.\n\nInside the `OnGUI` method, we can then access the GUI skin held by the `GUISkinHolderCordi` instance and set it as the current GUI skin using `GUI.skin = guiSkinHolder.GUISkin`. This allows us to use the GUI skin to draw UI elements, such as the label in the example.\n\nOverall, the `GUISkinHolderCordi` class provides a convenient way to store and access a GUI skin reference in the larger project, making it easier to manage and reuse GUI resources throughout the game.\n## Questions: \n 1. What is the purpose of the `GUISkinHolderCordi` class?\n- The purpose of the `GUISkinHolderCordi` class is not clear from the provided code. It seems to be a script attached to a GameObject in the Unity game engine, but its functionality is not evident.\n\n2. Why is the `UnityEngine` namespace being used?\n- The `UnityEngine` namespace is being used to access the Unity engine's classes and functionality. It is likely that the `GUISkinHolderCordi` class relies on Unity's GUI skin system or other Unity-specific features.\n\n3. Are there any methods or variables defined within the `GUISkinHolderCordi` class?\n- The provided code does not show any methods or variables defined within the `GUISkinHolderCordi` class. It is possible that they exist but are not included in the code snippet.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\GUISkinHolderCordi.md"}}],["243",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\GUITextureHolder.cs)\n\nThe code provided is a class called `GUITextureHolder` that is used to hold and provide access to various textures used in the Brick-Force project. \n\nThe class contains multiple arrays of `Texture2D` objects, each representing a different category of textures. For example, there are arrays for channel tabs, lobby tabs, briefing tabs, item textures, map textures, and more. Each array holds multiple textures of the corresponding category.\n\nThe purpose of this class is to provide a centralized location for accessing these textures throughout the project. By having all the textures stored in one place, it becomes easier to manage and update them. Other parts of the project can simply reference this class to obtain the required textures.\n\nFor example, if a script needs to access the channel tab textures, it can simply access the `ChannelTab` property of the `GUITextureHolder` class, which returns the `channelTab` array. This allows the script to access the individual textures within the array.\n\nAdditionally, the class provides a property called `Loading`, which returns a random loading texture based on the currently loaded level in the game. This property is used to display a loading screen with a random texture when transitioning between different game modes or levels.\n\nOverall, the `GUITextureHolder` class serves as a central repository for all the textures used in the Brick-Force project. It provides a convenient way for other parts of the project to access and use these textures, improving code organization and maintainability.\n## Questions: \n 1. What is the purpose of the `GUITextureHolder` class?\n- The `GUITextureHolder` class is used to hold various arrays of `Texture2D` objects that are used for GUI elements in the game.\n\n2. What is the significance of the different arrays of `Texture2D` objects?\n- The different arrays of `Texture2D` objects represent different GUI elements in the game, such as channel tabs, lobby tabs, item types, map types, etc.\n\n3. How is the `Loading` property used?\n- The `Loading` property returns a random `Texture2D` object from the appropriate array based on the current loaded level in the game. It is likely used to display loading screens or loading icons specific to different game modes.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\GUITextureHolder.md"}}],["244",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\HandBomb.cs)\n\nThe code provided is a class called \"HandBomb\" that extends the \"WeaponFunction\" class. This class represents a hand bomb weapon in the larger project called Brick-Force. \n\nThe purpose of this code is to define the behavior and properties of a hand bomb weapon in the game. It includes variables to store information such as the maximum ammo, current ammo, explosion object, crosshair textures, throw animation, throw force, ammo font, explosion time, and persist time. \n\nThe class also includes getter and setter methods for these variables, allowing other parts of the code to access and modify them. For example, the \"CurAmmo\" property returns the current ammo value, and the \"MaxAmmo\" property allows setting the maximum ammo value. \n\nThe code includes several methods that define the functionality of the hand bomb weapon. The \"UpgradeMaxAmmo\" method calculates the maximum ammo based on certain factors and upgrades it accordingly. The \"Reset\" method resets the current ammo to the maximum ammo value and synchronizes it with the server. The \"AddBonusBomb\" method adds a bonus bomb to the current ammo count. The \"Charge\" method checks if the ammo is full and resets it if not. The \"UseAmmo\" method decreases the current ammo count when the weapon is used. The \"IsFullAmmo\" method checks if the current ammo is equal to or greater than the maximum ammo. \n\nThe code also includes methods for handling the drawing and behavior of the hand bomb weapon. The \"Restart\" method resets the detonator time, sets the detonating and throwing flags, and shows or hides the grenade object based on the current ammo count. The \"SetDrawn\" method sets the drawn flag and either restarts or cancels the ongoing process based on the drawn flag. The \"DrawCrossHair\" method draws the crosshair on the screen. The \"RemoveSafetyClip\" method removes the safety clip, sets the detonating flag, and shows the grenade object. The \"ShowGrenade\" method shows or hides the grenade object based on the body and clip parameters. \n\nOverall, this code provides the functionality and behavior of a hand bomb weapon in the Brick-Force game. It allows players to use and interact with the hand bomb weapon, including throwing it, tracking the ammo count, and displaying the appropriate visuals on the screen.\n## Questions: \n 1. What is the purpose of the `maxAmmo` variable and how is it used in the code?\n- The `maxAmmo` variable represents the maximum amount of ammunition that the `HandBomb` object can hold. It is used to determine if the object has reached its maximum ammo capacity in the `IsFullAmmo()` method.\n\n2. What is the purpose of the `detonating` variable and how is it used in the code?\n- The `detonating` variable is a boolean flag that indicates whether the bomb is currently in the process of detonating. It is used in the `DrawDetonating()` method to determine whether to display the detonation progress bar.\n\n3. What is the purpose of the `curAmmoSecure` variable and how is it used in the code?\n- The `curAmmoSecure` variable is a `SecureInt` object that securely stores the current amount of ammunition for the `HandBomb` object. It is used in various methods to get and set the value of `curAmmo`, ensuring that it cannot be easily tampered with.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\HandBomb.md"}}],["245",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\HelpWindow.cs)\n\nThe code provided is a class called \"HelpWindow\" that extends the \"Dialog\" class. This class represents a help window in the larger Brick-Force project. The purpose of this code is to display a help window with various information and instructions for the user.\n\nThe class contains several public Texture2D variables, such as \"help_font\", \"helpBar_bg\", \"brickKey\", \"chatKey\", \"etcKey\", \"keyboard\", \"mouse\", \"moveKey\", and \"weaponKey\". These variables hold the textures that will be used to display images in the help window.\n\nThe class also contains several private Rect and Vector2 variables that define the positions and sizes of various elements in the help window. These variables are used to position and align the textures and text in the window.\n\nThe class has a boolean variable \"bOpenWindow\" that determines whether the help window is open or not. There is also a Vector2 variable \"scrollPosition\" that keeps track of the scroll position of the help window.\n\nThe class overrides the \"Start\" and \"OnPopup\" methods from the base \"Dialog\" class. The \"Start\" method sets the ID of the help window and the size of the window. The \"OnPopup\" method sets the position of the help window based on the screen size.\n\nThe main functionality of the class is implemented in the \"DoDialog\" method. This method is called to display and handle user interactions with the help window. It first sets the focus to the help window if it doesn't already have it. It then sets the GUI skin to the appropriate skin for the help window.\n\nThe method then begins a GUI group and draws various textures and labels using the provided textures and positions. It uses utility methods like \"TextureUtil.DrawTexture\" and \"LabelUtil.TextOut\" to draw the textures and labels on the screen.\n\nThe method also handles user input by checking if the escape key is pressed. If the escape key is pressed, the method returns true, indicating that the help window should be closed.\n\nIn summary, this code represents a help window in the Brick-Force project. It displays various textures and labels to provide information and instructions to the user. The user can interact with the window and close it by pressing the escape key.\n## Questions: \n 1. What is the purpose of the `HelpWindow` class?\n- The `HelpWindow` class is a subclass of `Dialog` and represents a help window in the game.\n\n2. What are the dimensions and positions of the various UI elements in the `HelpWindow`?\n- The dimensions and positions of the UI elements are defined by the various `Rect` variables in the code.\n\n3. How does the scrolling functionality work in the `HelpWindow`?\n- The scrolling functionality is implemented using the `GUI.BeginScrollView` and `GUI.EndScrollView` methods, with the `scrollPosition` and `viewRect` variables controlling the scrolling behavior.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\HelpWindow.md"}}],["246",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\HexDump.cs)\n\nThe code provided is a class called `HexDump` that is used for dumping the hexadecimal representation of a byte array to a text file. \n\nThe class has a public static string variable called `dataPath` which is initially set to an empty string. This variable is used to store the path of the file where the hexadecimal dump will be written.\n\nThere is also a public static boolean variable called `needDump` which is not used in the provided code. It is likely used elsewhere in the project to determine if a hexadecimal dump is needed.\n\nThe class has a private static method called `_Dump` which takes a `TextWriter` object, a byte array, a start index, a length, and a prefix as parameters. This method writes the prefix to the `TextWriter` object and then converts the specified portion of the byte array to a hexadecimal string using the `BitConverter.ToString` method. The resulting hexadecimal string is then written to the `TextWriter` object.\n\nThe class also has a public static method called `Dump` which takes a file name, a byte array, a start index, a length, and a prefix as parameters. This method is likely the main method used for dumping the hexadecimal representation of a byte array to a file. However, the implementation of this method is missing in the provided code, so it does not currently perform any actions.\n\nTo use this class in the larger project, one would need to call the `Dump` method and provide the necessary parameters to specify the byte array to be dumped, the file name to write the dump to, and any desired prefix for each line of the dump. For example:\n\n```csharp\nbyte[] data = { 0x12, 0x34, 0x56, 0x78 };\nstring fileName = \"dump.txt\";\nstring prefix = \"Line: \";\nint startIndex = 0;\nint length = data.Length;\n\nHexDump.Dump(fileName, data, startIndex, length, prefix);\n```\n\nThis would dump the hexadecimal representation of the `data` byte array to a file named \"dump.txt\" with each line prefixed by \"Line: \".\n## Questions: \n 1. **Question:** What is the purpose of the `HexDump` class?\n   - **Answer:** The purpose of the `HexDump` class is not clear from the provided code. It would be helpful to know what functionality or behavior this class is intended to provide.\n\n2. **Question:** What is the significance of the `dataPath` variable?\n   - **Answer:** The significance of the `dataPath` variable is not apparent from the provided code. It would be useful to understand why this variable is declared and how it is used within the code.\n\n3. **Question:** What is the purpose of the `Dump` method?\n   - **Answer:** The purpose of the `Dump` method is not evident from the provided code. It would be beneficial to know what this method is intended to do and how it is expected to be used.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\HexDump.md"}}],["247",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\HitBrickPacket.cs)\n\nThe code provided defines a class called `HitBrickPacket` that represents a packet of information related to hitting a brick in the game. This class is likely used in the larger Brick-Force project to handle interactions between projectiles and bricks.\n\nThe `HitBrickPacket` class has several public properties that store information about the hit. These properties include:\n- `firePacket`: A reference to the `FirePacket` object that represents the projectile that hit the brick.\n- `isBullet`: A boolean value indicating whether the hit was caused by a bullet.\n- `brickseq`: An integer value representing the sequence number of the brick that was hit.\n- `hitpoint`: A `Vector3` object representing the point of impact on the brick.\n- `hitnml`: A `Vector3` object representing the normal vector of the surface that was hit.\n- `destructable`: A boolean value indicating whether the brick is destructible.\n- `layer`: A byte value representing the layer of the brick.\n- `damage`: A ushort value representing the amount of damage caused by the hit.\n\nThe class also has a constructor that takes in all the necessary parameters to initialize the properties of the `HitBrickPacket` object.\n\nThis class can be used in the larger Brick-Force project to handle the logic and effects of hitting a brick with a projectile. For example, when a projectile collides with a brick, the game can create a new `HitBrickPacket` object and populate it with the relevant information. This object can then be passed to other parts of the game to handle the effects of the hit, such as reducing the health of the brick or triggering any associated events or animations.\n\nHere's an example of how the `HitBrickPacket` class could be used in the larger project:\n\n```csharp\nFirePacket firePacket = new FirePacket();\nbool isBullet = true;\nint brickseq = 1;\nVector3 hitpoint = new Vector3(10, 5, 0);\nVector3 hitnml = new Vector3(0, 0, 1);\nbool destructable = true;\nint layer = 0;\nint damage = 10;\n\nHitBrickPacket hitPacket = new HitBrickPacket(firePacket, isBullet, brickseq, hitpoint, hitnml, destructable, layer, damage);\n\n// Pass the hitPacket to other parts of the game for further processing\n```\n\nIn summary, the `HitBrickPacket` class in the Brick-Force project represents a packet of information related to hitting a brick with a projectile. It is used to store and pass around the relevant data about the hit, allowing other parts of the game to handle the effects and logic associated with the hit.\n## Questions: \n 1. What is the purpose of the `HitBrickPacket` class?\n- The `HitBrickPacket` class is used to store information about a hit on a brick, such as the hit point, normal vector, damage, and whether the brick is destructible.\n\n2. What is the purpose of the `FirePacket` variable?\n- The `FirePacket` variable is used to store information about the firing action that caused the hit on the brick.\n\n3. What is the significance of the `layer` variable being cast to a `byte` and the `damage` variable being cast to a `ushort`?\n- The `layer` variable is cast to a `byte` to limit its value to a range of 0-255, while the `damage` variable is cast to a `ushort` to limit its value to a range of 0-65535. This ensures that the values of these variables are within the appropriate range for their respective data types.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\HitBrickPacket.md"}}],["248",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\HitCompass.cs)\n\nThe `HitCompass` class is a script that is part of the larger Brick-Force project. It is responsible for managing and displaying directional hit indicators on the player's screen.\n\nThe script contains several public variables that can be customized in the Unity editor. These variables include `guiDepth`, which determines the layer depth of the GUI elements, `compassColor`, which sets the color of the hit compass, `compassColorChild`, which sets the color of the hit compass for child objects, and `zeroColor`, which sets the color of the hit compass when the direction is zero.\n\nThe script also contains a private variable `lifeTime` which determines the duration for which the hit compass is displayed on the screen. Additionally, there is an array of `Texture2D` objects called `hitCompass`, which stores the different textures for the hit compass.\n\nThe `Start` method is called when the script is initialized. It initializes the `attackers` dictionary and finds the main camera in the scene. If the camera is found, it gets the `CameraController` component attached to it.\n\nThe `OnDirectionalHit` method is called when a directional hit occurs. It checks if the current room type is not an escape room. If it is not, it retrieves the attacker's game object using the `BrickManManager` class. If the attacker's game object is found, it checks if the attacker is already in the `attackers` dictionary. If it is, it resets the attacker's hit compass. If the attacker is not in the dictionary, it creates a new `DirAttacker` object and adds it to the `attackers` dictionary.\n\nThe `OnGUI` method is responsible for drawing the hit compasses on the screen. It checks if the GUI is enabled and if the current dialog is not modal. It then iterates through the `attackers` dictionary and calls the `Draw` method on each `DirAttacker` object. If the `Draw` method returns false, it adds the attacker's key to a list. After iterating through all the attackers, it removes the attackers in the list from the `attackers` dictionary. Finally, it resets the GUI settings to their original values.\n\nThe `Update` method is called every frame. It iterates through the `attackers` dictionary and calls the `Update` method on each `DirAttacker` object. If the `Update` method returns false, it adds the attacker's key to a list. After iterating through all the attackers, it removes the attackers in the list from the `attackers` dictionary.\n\nIn summary, the `HitCompass` script manages and displays hit compass indicators on the player's screen. It keeps track of attackers and their hit compasses, and updates and draws them accordingly. This script is likely used in the larger Brick-Force project to provide visual feedback to the player when they are being attacked from a certain direction.\n## Questions: \n 1. What is the purpose of the `HitCompass` class?\n- The `HitCompass` class is responsible for managing and displaying directional hit indicators on the screen.\n\n2. What is the significance of the `attackers` dictionary?\n- The `attackers` dictionary stores information about the attackers and their corresponding directional hit indicators.\n\n3. What conditions need to be met for a directional hit indicator to be added to the `attackers` dictionary?\n- A directional hit indicator will be added to the `attackers` dictionary if the current room type is not an escape room, the attacker exists in the game, and the player is not below 12 years old.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\HitCompass.md"}}],["249",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\HitImpactPacket.cs)\n\nThe code provided defines a class called `HitImpactPacket`. This class is used to store information about a hit impact in the game. It has several properties including `firePacket`, `layer`, `hitpoint`, and `hitnml`. \n\nThe `firePacket` property is of type `FirePacket` and is used to store information about the fire event that caused the hit impact. The `layer` property is of type `byte` and represents the layer of the object that was hit. The `hitpoint` property is of type `Vector3` and represents the position in 3D space where the hit occurred. The `hitnml` property is also of type `Vector3` and represents the normal vector of the surface that was hit.\n\nThe class has a constructor that takes in parameters for each of these properties. The constructor initializes the properties with the provided values. The `layer` parameter is cast to a `byte` before being assigned to the `layer` property.\n\nThis `HitImpactPacket` class can be used in the larger project to store and pass around information about hit impacts. For example, when a projectile hits an object in the game, a new instance of `HitImpactPacket` can be created and populated with the relevant information. This instance can then be passed to other parts of the game that need to handle the hit impact, such as applying damage to the object or triggering visual effects.\n\nHere is an example of how the `HitImpactPacket` class could be used in code:\n\n```csharp\nFirePacket firePacket = new FirePacket();\nint layer = 5;\nVector3 hitpoint = new Vector3(10, 5, 0);\nVector3 hitnml = new Vector3(0, 1, 0);\n\nHitImpactPacket hitImpact = new HitImpactPacket(firePacket, layer, hitpoint, hitnml);\n\n// Use the hitImpact instance to handle the hit impact\n// ...\n```\n\nIn this example, a new `HitImpactPacket` instance is created and initialized with the provided values. This instance can then be used to handle the hit impact in the game.\n## Questions: \n 1. **What is the purpose of the `HitImpactPacket` class?**\nThe `HitImpactPacket` class is used to store information about a hit impact, including the fire packet, layer, hit point, and hit normal.\n\n2. **What is the `FirePacket` class and how is it related to the `HitImpactPacket` class?**\nThe `FirePacket` class is not shown in the provided code, so a smart developer might wonder what it is and how it is used in relation to the `HitImpactPacket` class.\n\n3. **Why is the `layer` variable casted to a byte in the constructor?**\nThe `layer` variable is casted to a byte in the constructor, so a smart developer might question why this casting is necessary and what impact it has on the functionality of the code.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\HitImpactPacket.md"}}],["250",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\HitManPacket.cs)\n\nThe code provided defines a class called `HitManPacket` that represents a packet of information related to a hit made by a player in the game. The purpose of this class is to store and organize the data associated with a hit, such as the player who made the hit, the body part that was hit, the position and normal of the hit, the amount of damage inflicted, the rigidity of the hit, the weapon used, and whether the hit was lucky or not.\n\nThe class has several public properties that store the different pieces of information related to the hit. These properties include `firePacket`, `hitMan`, `hitPart`, `hitpoint`, `hitnml`, `damage`, `rigidity`, `weaponBy`, and `bLucky`. \n\nThe class also has a constructor that takes in all the necessary parameters to initialize the properties. The constructor assigns the parameter values to the corresponding properties of the class. Some of the parameters are casted to different data types, such as `hitPart` being casted to a byte and `damage` being casted to a ushort.\n\nThis `HitManPacket` class can be used in the larger project to represent and transmit hit information between different components of the game. For example, when a player makes a hit, an instance of the `HitManPacket` class can be created and populated with the relevant information. This instance can then be passed to other parts of the game, such as the networking system, to transmit the hit information to other players or game servers.\n\nHere is an example of how the `HitManPacket` class can be used:\n\n```csharp\nFirePacket firePacket = new FirePacket();\nint hitMan = 1;\nint hitPart = 2;\nVector3 hitpoint = new Vector3(10, 5, 3);\nVector3 hitnml = new Vector3(0, 1, 0);\nint damage = 50;\nfloat rigidity = 0.5f;\nint weaponBy = 3;\nbool bLucky = true;\n\nHitManPacket hitPacket = new HitManPacket(firePacket, hitMan, hitPart, hitpoint, hitnml, damage, rigidity, weaponBy, bLucky);\n```\n\nIn this example, a new instance of the `HitManPacket` class is created and initialized with the provided values. This instance can then be used to transmit the hit information to other parts of the game.\n## Questions: \n 1. What is the purpose of the `HitManPacket` class?\n- The `HitManPacket` class is used to store information about a hit made by a player in the game, including the hitman's ID, hit part, hit point, hit normal, damage, rigidity, weapon used, and whether it was a lucky hit or not.\n\n2. What is the purpose of the `FirePacket` class and how is it related to the `HitManPacket` class?\n- The `FirePacket` class is not shown in the provided code, but it is referenced in the `HitManPacket` class as a parameter in the constructor. It is likely that the `FirePacket` class is used to store information about a fired projectile or weapon, and the `HitManPacket` class uses this information to create a hit event.\n\n3. What is the purpose of the `weaponBy` variable and why is it cast to `ushort`?\n- The `weaponBy` variable is used to store the ID of the weapon used in the hit. It is cast to `ushort` to limit the range of possible values for the weapon ID, as it is unlikely that the ID would exceed the maximum value that can be stored in a `ushort` data type.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\HitManPacket.md"}}],["251",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\HitMonPacket.cs)\n\nThe code provided is a class called `HitMonPacket` that is used to create instances of a packet object. This packet object contains information related to a hit on a target in the game. \n\nThe class has several public variables: `firePacket`, `hitMon`, `damage`, `rigidity`, and `hitpoint`. \n\n- `firePacket` is an instance of the `FirePacket` class, which is not provided in the code snippet. It is likely that this class contains information about the firing action that caused the hit. \n- `hitMon` is an unsigned short integer that represents the target of the hit. \n- `damage` is an unsigned short integer that represents the amount of damage caused by the hit. \n- `rigidity` is a floating-point number that represents the rigidity of the hit. \n- `hitpoint` is a `Vector3` object that represents the position of the hit on the target. \n\nThe class has a constructor that takes in parameters corresponding to the public variables and assigns them to the respective variables. The constructor also performs type casting for `hitMon` and `damage` to ensure they are of type `ushort`. \n\nThis class is likely used in the larger project to handle and transmit hit information between different game components or systems. For example, when a player fires a weapon and hits a target, an instance of `HitMonPacket` can be created to encapsulate the relevant hit information and then passed to other systems for processing or transmission. \n\nHere is an example of how this class could be used:\n\n```csharp\nFirePacket firePacket = new FirePacket();\nint hitMon = 123;\nint damage = 50;\nfloat rigidity = 0.5f;\nVector3 hitpoint = new Vector3(1.0f, 2.0f, 3.0f);\n\nHitMonPacket hitMonPacket = new HitMonPacket(firePacket, hitMon, damage, rigidity, hitpoint);\n```\n\nIn this example, a new instance of `HitMonPacket` is created with the provided values. This packet can then be used to transmit hit information to other parts of the game.\n## Questions: \n 1. What is the purpose of the `HitMonPacket` class?\n- The `HitMonPacket` class is used to store information about a hit on a monster, including the fire packet, hit monster ID, damage, rigidity, and hit point.\n\n2. What is the purpose of the `FirePacket` class?\n- The code references a `FirePacket` class, but it is not included in the provided code. A smart developer might wonder what the `FirePacket` class does and how it is related to the `HitMonPacket` class.\n\n3. Why are the `hitMon` and `damage` variables cast to `ushort` in the constructor?\n- The `hitMon` and `damage` variables are cast to `ushort` in the constructor. A smart developer might question why this casting is necessary and if there are any potential implications or limitations associated with it.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\HitMonPacket.md"}}],["252",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\HitPart.cs)\n\nThe code provided is a script called \"HitPart\" that is a part of the larger Brick-Force project. This script is responsible for defining different types of body parts that can be hit in the game and determining the impact of those hits.\n\nThe script starts by importing the necessary Unity engine module. It then defines an enumeration called \"TYPE\" that represents different body parts that can be hit. The available body parts are HEAD, BODY, ARM, FOOT, and BRAIN.\n\nThe script also includes several public variables. The \"damageFactor\" variable is a float that determines the amount of damage inflicted when a body part is hit. The \"part\" variable is of type \"TYPE\" and represents the specific body part that this script instance represents. The \"hitImpact\", \"hitImpactChild\", and \"luckyImpact\" variables are GameObjects that represent the visual effects that occur when a body part is hit.\n\nThe script also includes a method called \"GetHitImpact()\". This method checks if the player's age, as determined by the \"MyInfoManager\" class, is below 12. If it is, the method returns the \"hitImpactChild\" GameObject. Otherwise, it returns the \"hitImpact\" GameObject. This method is likely used to determine the appropriate visual effect to display when a body part is hit, depending on the player's age.\n\nOverall, this script is responsible for defining the different body parts that can be hit in the game and determining the appropriate visual effects and damage factor for each body part. It is likely used in conjunction with other scripts and game mechanics to handle player interactions and combat mechanics in the Brick-Force game.\n## Questions: \n 1. **What is the purpose of the `HitPart` class?**\nThe `HitPart` class is responsible for managing different types of body parts and their associated damage factors and impact effects.\n\n2. **What is the significance of the `TYPE` enum?**\nThe `TYPE` enum represents different body parts such as head, body, arm, foot, and brain. It is likely used to categorize and differentiate the body parts within the game.\n\n3. **What is the purpose of the `GetHitImpact()` method?**\nThe `GetHitImpact()` method returns the appropriate hit impact GameObject based on the player's age. If the player is below 12 years old, it returns the `hitImpactChild` GameObject, otherwise it returns the `hitImpact` GameObject.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\HitPart.md"}}],["253",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\HIT_KIND.cs)\n\nThe code provided is an enumeration called `HIT_KIND` that defines different kinds of hits in the context of the Brick-Force project. \n\nThe `HIT_KIND` enumeration has five possible values: `NONE`, `BRICK`, `HUMAN`, `MON`, and `OTHER`. Each value represents a different kind of hit that can occur in the game. \n\n- `NONE` represents a hit that does not fall into any of the other categories. It is assigned a value of -1, indicating that it is the default value when no other kind of hit is applicable.\n- `BRICK` represents a hit on a brick object in the game. This could be a hit from a player or another object.\n- `HUMAN` represents a hit on a human character in the game. This could be a hit from another player or an object.\n- `MON` represents a hit on a monster character in the game. This could be a hit from a player or an object.\n- `OTHER` represents a hit that does not fall into any of the other specific categories. This could be a hit from an environmental object or a special kind of hit that is not covered by the other categories.\n\nThis enumeration is likely used throughout the larger Brick-Force project to categorize and handle different kinds of hits that occur in the game. It provides a standardized way to identify and differentiate between different types of hits, which can be useful for various game mechanics and logic.\n\nHere is an example of how this enumeration could be used in code:\n\n```java\nHIT_KIND hit = getHitKind(); // Get the kind of hit that occurred\n\nif (hit == HIT_KIND.BRICK) {\n    // Handle hit on a brick object\n    // ...\n} else if (hit == HIT_KIND.HUMAN) {\n    // Handle hit on a human character\n    // ...\n} else if (hit == HIT_KIND.MON) {\n    // Handle hit on a monster character\n    // ...\n} else if (hit == HIT_KIND.OTHER) {\n    // Handle hit that does not fall into any specific category\n    // ...\n} else {\n    // Handle hit that is not categorized\n    // ...\n}\n```\n\nIn this example, the code checks the value of the `hit` variable and performs different actions based on the kind of hit that occurred. This allows for specific handling of different types of hits in the game.\n## Questions: \n 1. **What is the purpose of the `HIT_KIND` enum?**\nThe `HIT_KIND` enum is used to represent different types of hits in the game, such as hitting a brick, a human, a monster, or something else.\n\n2. **What does the `NONE` value represent in the `HIT_KIND` enum?**\nThe `NONE` value in the `HIT_KIND` enum represents a hit that does not correspond to any specific type, and is typically used as a default or placeholder value.\n\n3. **Are there any specific actions or behaviors associated with each value in the `HIT_KIND` enum?**\nWithout further context or additional code, it is not clear if there are any specific actions or behaviors associated with each value in the `HIT_KIND` enum.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\HIT_KIND.md"}}],["254",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\IconReq.cs)\n\nThe code provided defines a class called `IconReq`. This class is used to represent an icon request in the larger Brick-Force project. \n\nThe `IconReq` class has three properties: `code`, `iconPath`, and `CDN`. \n\n- The `code` property is a string that represents the code associated with the icon request. \n- The `iconPath` property is a string that represents the path to the icon file. \n- The `CDN` property is a `WWW` object that represents the content delivery network (CDN) used to retrieve the icon file. \n\nThe `IconReq` class also has a constructor that takes two parameters: `c` and `p`. These parameters are used to initialize the `code` and `iconPath` properties respectively. The `CDN` property is set to `null` by default. \n\nThis class can be used in the larger Brick-Force project to handle icon requests. For example, when a user requests an icon, an instance of the `IconReq` class can be created with the appropriate code and icon path. This instance can then be used to retrieve the icon file from the CDN. \n\nHere is an example of how the `IconReq` class can be used in the larger project:\n\n```csharp\n// Create an instance of IconReq\nIconReq iconRequest = new IconReq(\"123\", \"path/to/icon.png\");\n\n// Retrieve the icon file from the CDN\niconRequest.CDN = new WWW(iconRequest.iconPath);\n\n// Use the retrieved icon file\nif (iconRequest.CDN.isDone)\n{\n    // Display the icon to the user\n    Sprite icon = Sprite.Create(iconRequest.CDN.texture, new Rect(0, 0, iconRequest.CDN.texture.width, iconRequest.CDN.texture.height), Vector2.zero);\n    // ...\n}\n```\n\nIn this example, an instance of `IconReq` is created with the code \"123\" and the icon path \"path/to/icon.png\". The `CDN` property is then set to a new `WWW` object that retrieves the icon file from the CDN. Once the retrieval is complete, the icon file can be used, for example, to display the icon to the user.\n## Questions: \n 1. **What is the purpose of the `IconReq` class?**\nThe `IconReq` class appears to be a data structure that holds information about an icon, including its code, iconPath, and a reference to a CDN (Content Delivery Network).\n\n2. **What is the significance of the `WWW` type for the `CDN` field?**\nThe `WWW` type is commonly used in Unity for making web requests. It is likely that the `CDN` field is intended to store a reference to a web request for the icon.\n\n3. **Why is the `CDN` field initially set to `null` in the constructor?**\nThe `CDN` field is initially set to `null` in the constructor, which suggests that it may be assigned a value later on, possibly when the web request for the icon is made.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\IconReq.md"}}],["255",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ImageFont.cs)\n\nThe code provided is a class called \"ImageFont\" that represents a font made up of images. This class is used to display numbers using the provided images as digits. \n\nThe class has several properties and methods that control the appearance and behavior of the font. \n\nThe \"digits\" property is an array of Texture2D objects that represent the images for each digit. These images are used to display the numbers. \n\nThe \"alignment\" property is of type TextAnchor and determines the alignment of the displayed numbers. \n\nThe \"ceilNumber\" and \"floorNumber\" properties define the range of numbers that will be displayed with different colors. If the number being displayed is greater than or equal to \"ceilNumber\", the font color will be set to \"ceilColor\". If the number is less than or equal to \"floorNumber\", the font color will be set to \"floorColor\". \n\nThe \"normalScale\" property determines the default scale of the font. \n\nThe \"scale\" property is used to adjust the scale of the font dynamically. \n\nThe \"accel\" property is used to control the speed at which the font scale changes. \n\nThe \"Digits\" property is a getter and setter for the \"digits\" property. \n\nThe \"_alignment\" property is a getter and setter for the \"alignment\" property. \n\nThe \"CeilNumber\" property is a getter and setter for the \"ceilNumber\" property. \n\nThe \"FloorNumber\" property is a getter and setter for the \"floorNumber\" property. \n\nThe \"CceilColor\" property is a getter and setter for the \"ceilColor\" property. \n\nThe \"FloorColor\" property is a getter and setter for the \"floorColor\" property. \n\nThe \"Scale\" property is a setter for the \"scale\" property. \n\nThe \"Print\" method is used to display a number using the font. It takes a position (pos) and a number as parameters. The method calculates the scale of the font based on the current scale and the time that has passed since the last frame. It then iterates over each digit in the number and adds the corresponding image to a list. The method also calculates the total width and height of the displayed number. The alignment of the number is then applied to the position. Finally, the method sets the font color based on the range of the number and draws each digit image on the screen using the TextureUtil.DrawTexture method. \n\nIn summary, this code provides a way to display numbers using images as digits. It allows for customization of the font appearance and behavior, such as alignment, color, and scale. This class can be used in the larger project to create visually appealing and dynamic number displays.\n## Questions: \n 1. What is the purpose of the `ImageFont` class?\n- The `ImageFont` class represents a font made up of images, and it is used to print numbers on the screen.\n\n2. What does the `Print` method do?\n- The `Print` method takes a position and a number as input and prints the number on the screen using the images in the `digits` array.\n\n3. What is the purpose of the `scale` and `accel` variables?\n- The `scale` variable is used to control the size of the printed numbers, and the `accel` variable is used to control the speed at which the size changes.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ImageFont.md"}}],["256",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\IndividualMatch.cs)\n\nThe code provided is a script for the \"IndividualMatch\" class in the Brick-Force project. This class is responsible for managing the gameplay of an individual match within the larger game. \n\nThe code begins by declaring several private variables, including \"deltaTime\" (used for timing purposes), \"delayLoad\" (a boolean flag to control the loading of game assets), \"battleChat\" (a reference to the BattleChat component), and \"localController\" (a reference to the LocalController component).\n\nThe \"InitializeFirstPerson\" method is called to initialize the first-person perspective for the player. It first checks the selected weapon option and assigns an array of integers based on the option. Then, it finds the player's game object (\"Me\") and checks if it exists. If it does, it retrieves the EquipCoordinator component and initializes it with the array of integers. It also retrieves the LocalController component and assigns it to the \"localController\" variable.\n\nThe \"OnLoadComplete\" method is called when the game assets finish loading. It first calls the \"Load\" method of the TrainManager instance. Then, it retrieves a spawner object from the BrickManager instance based on the player's ticket. If a spawner is found, it calls the \"Spawn\" method of the localController component with the spawner's position and rotation. If no spawner is found, it calls the \"Spawn\" method with a random spawn position and rotation. Next, it checks if the \"DONOT_BATTLE_GUIDE\" flag is set in the MyInfoManager instance. If not, it retrieves the BattleGuideDialog instance and checks if it exists and if the \"DontShowThisMessageAgain\" flag is not set. If both conditions are met, it calls the \"InitDialog\" method of the BattleGuideDialog instance.\n\nThe \"Start\" method is called when the script starts. It first clears all dropped weapons, applies the audio source settings, and disables the flashbang effect. Then, it calls the \"InitializeFirstPerson\" method. It retrieves the BattleChat component and assigns it to the \"battleChat\" variable. It calls the \"OnStart\" method of the BrickManManager instance. It sets up the camera for visual effects optimization using the VfxOptimizer instance. Finally, it sets the \"delayLoad\" flag to true and initializes the \"deltaTime\" variable to 0.\n\nThe \"StartLoad\" method is called to start loading the game assets. It first calls the garbage collector to free up memory. Then, it creates a new UserMap instance and tries to load the current map from the RoomManager instance. If the map is successfully loaded, it assigns it to the userMap variable of the BrickManager instance. Otherwise, it creates a new UserMap instance and sends a cache brick request to the CSNetManager instance.\n\nThe \"ResetGameStuff\" method is called to reset various game-related data. It calls the \"ResetGameStuff\" method of the WantedManager and MyInfoManager instances. It unloads the train assets using the TrainManager instance. It retrieves an array of BrickManDesc objects from the BrickManManager instance and iterates over them, calling the \"ResetGameStuff\" method for each object.\n\nThe remaining methods, \"Awake\", \"OnDisable\", \"OnGUI\", and \"Update\", are standard Unity methods that handle various events and update the game state. They perform tasks such as handling GUI skin, updating the screen lock cursor, checking for button inputs, and updating flashbang effects.\n\nIn summary, this code manages the gameplay of an individual match in the Brick-Force game. It initializes the player's first-person perspective, handles the loading of game assets, spawns the player in the game world, manages game-related data, and updates the game state based on player inputs.\n## Questions: \n 1. What is the purpose of the `InitializeFirstPerson()` method?\n- The `InitializeFirstPerson()` method is responsible for initializing the player's equipment and controller based on the selected weapon option.\n\n2. What does the `OnLoadComplete()` method do?\n- The `OnLoadComplete()` method loads the train manager, spawns the player at a specific position, and displays a battle guide dialog if necessary.\n\n3. What is the purpose of the `ResetGameStuff()` method?\n- The `ResetGameStuff()` method is used to reset various game-related components and managers, including the wanted manager, user map, my info manager, and brick man descriptors.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\IndividualMatch.md"}}],["257",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\IndividualMatchConfig.cs)\n\nThe code provided is a class called `IndividualMatchConfig` that is used in the larger Brick-Force project. This class is responsible for displaying and managing the configuration options for an individual match within the game.\n\nThe `IndividualMatchConfig` class contains various properties and methods that are used to display and interact with the match configuration UI. Let's go through the code to understand its functionality:\n\n- The class is marked with the `[Serializable]` attribute, which means that its instances can be serialized and stored in a file or sent over the network.\n\n- The class has several private fields that define the positions and dimensions of various UI elements, such as thumbnails, buttons, and labels.\n\n- The class also has some constant values and string arrays that define the available weapon options for the match.\n\n- The `OnGUI` method is the main entry point for rendering the match configuration UI. It first retrieves the thumbnail image for the current map from the `RegMapManager` and displays it. It then checks various conditions to determine which additional icons to display on the thumbnail, such as a new map icon or a special tag icon. It also checks if the map is marked as an abuse map and displays an abuse icon accordingly. The method also displays the alias and mode of the current room, and calls the `DoOption` method to display the match options.\n\n- The `DoOption` method is responsible for displaying the match options, such as time limit, kill count, weapon options, and other room settings. It uses the `LabelUtil` class to render the labels and boxes for each option.\n\n- The `ShowTooltip` method is called when the user hovers over a UI element and displays a tooltip with additional information about the element.\n\n- The `Start` method is empty and does not contain any code.\n\nIn summary, the `IndividualMatchConfig` class is used to display and manage the configuration options for an individual match in the Brick-Force game. It retrieves information about the current map and room, and displays various UI elements and labels to allow the player to configure the match settings. The class also handles user interactions, such as clicking on the configuration button to open a dialog for changing the room configuration.\n## Questions: \n 1. What is the purpose of the `OnGUI()` method?\n- The `OnGUI()` method is responsible for rendering the graphical user interface for the Brick-Force game. It displays various textures, labels, and buttons based on the current state of the game.\n\n2. What does the `DoOption()` method do?\n- The `DoOption()` method is used to display and update the options for a specific game room. It sets the time limit, kill count, weapon options, and other room settings based on the values stored in the `room` object.\n\n3. What is the significance of the `Serializable` attribute on the `IndividualMatchConfig` class?\n- The `Serializable` attribute indicates that instances of the `IndividualMatchConfig` class can be serialized and deserialized, allowing them to be stored in a file or sent over a network.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\IndividualMatchConfig.md"}}],["258",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\IndividualMatchScore.cs)\n\nThe code provided is a script called \"IndividualMatchScore\" that is a part of the Brick-Force project. This script is responsible for displaying the individual match score on the Heads-Up Display (HUD) during gameplay.\n\nThe script contains several public variables that can be set in the Unity editor. These variables include the GUI depth, score font, goal font, score background texture, size of the score display, and the coordinates for the score and goal text.\n\nThe script also has a private variable called \"score\" that keeps track of the current score. The score is initially set to 0 in the Start() method.\n\nThe Start() method is called when the script is first initialized. In this method, the score is set to 0 and a check is made to see if the player is currently breaking into something. If the player is breaking into something, a request is sent to the server to update the individual score.\n\nThe OnIndividualScore() method is called when the individual score is updated. In this method, the score font is scaled to 2 and the score is updated with the new total kill count.\n\nThe OnGUI() method is responsible for rendering the score display on the HUD. It first checks if the GUI is enabled in the game settings. If it is enabled, it retrieves the GUI skin and sets the GUI depth. It then begins a GUI group with a rectangle that represents the size and position of the score display. The score background texture is drawn within this group, and the score and goal text are printed using the score and goal fonts at the specified coordinates. Finally, the GUI group is ended and the GUI skin is reset.\n\nThe Update() method is empty and does not contain any code.\n\nOverall, this script is an essential part of the Brick-Force project as it handles the display of the individual match score on the HUD during gameplay. It allows players to see their current score and the goal score they need to achieve.\n## Questions: \n 1. What is the purpose of the `OnIndividualScore` method?\n- The `OnIndividualScore` method is called when the individual score is updated, and it updates the score font and assigns the new score value.\n\n2. What is the purpose of the `Start` method?\n- The `Start` method initializes the score variable to 0 and sends a request for the individual score if the player is breaking into something.\n\n3. What is the purpose of the `OnGUI` method?\n- The `OnGUI` method is responsible for rendering the graphical user interface (GUI) elements related to the individual match score, including the score background, score font, and goal font.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\IndividualMatchScore.md"}}],["259",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\IndividualMatchSituation.cs)\n\nThe code provided is a part of the Brick-Force project and is contained within the `IndividualMatchSituation` class. This class is responsible for displaying the individual match situation in the game. It is attached to a game object in the Unity scene.\n\nThe code contains various variables that define the positions and sizes of different GUI elements, such as icons, text boxes, and labels. These variables are used to position and style the GUI elements in the `OnGUI` method.\n\nThe `OnGUI` method is called every frame and is responsible for rendering the GUI elements on the screen. It first checks if the GUI is enabled and if the individual match situation is turned on. If both conditions are met, it proceeds to render the GUI elements.\n\nThe method starts by setting the GUI skin and depth, and then begins a GUI group with a specific position and size. It then draws a box and a label for the current room title. Next, it draws a green box and a text box for the first row of the individual match situation. It also draws an icon using a texture.\n\nAfter that, it draws labels for different columns, such as \"MARK\", \"BADGE\", \"CHARACTER\", \"KILL/ASSIST/DEATH\", \"SCORE\", and \"PING\". These labels represent the headers for each column in the individual match situation.\n\nNext, it iterates over a list of players in the game and draws their information in a grid format. It checks if the player is the local player and if their score is higher than the current player being rendered. If so, it draws a special box to highlight the local player's information.\n\nFinally, it draws the clan mark, badge, nickname, kill/assist/death count, score, and ping for each player. The color of the ping label depends on the value of the average ping. If the ping is above 0.3, it is displayed in red. If it is between 0.1 and 0.3, it is displayed in yellow. If it is below 0.1, it is displayed in green. If the player is not in the game or is waiting/loading, a different label is displayed.\n\nThe `VerifyLocalController` method is used to find the local player's controller and assign it to the `localController` variable. This method is called in the `OnGUI` method to ensure that the local player's information is displayed correctly.\n\nThe `Start` and `Update` methods are empty and do not contain any code.\n\nIn summary, this code is responsible for rendering the individual match situation GUI in the game. It displays information about each player, such as their clan mark, badge, nickname, kill/assist/death count, score, and ping. It also highlights the local player's information if their score is higher than other players.\n## Questions: \n 1. What is the purpose of the `VerifyLocalController()` method?\n- The `VerifyLocalController()` method is used to check if the `localController` variable is null and assign it the `LocalController` component of the \"Me\" GameObject if it exists.\n\n2. What does the `GridOut()` method do?\n- The `GridOut()` method is responsible for displaying the information of a player in the GUI, such as their clan mark, XP, rank, nickname, kill/assist/death stats, score, average ping, and status.\n\n3. What is the purpose of the `on` variable and how is it updated?\n- The `on` variable is used to determine whether the GUI should be displayed or not. It is updated in the `Update()` method based on the state of the `DialogManager` and a custom input button \"K_SITUATION\".","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\IndividualMatchSituation.md"}}],["260",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Infection.cs)\n\nThe code provided defines a class called `Infection`. This class represents an infection event in the larger Brick-Force project. \n\nThe `Infection` class has two private integer variables: `host` and `newZombie`. These variables store the IDs of the host and the newly infected zombie, respectively. \n\nThe class also has two public properties: `Host` and `NewZombie`. These properties provide read-only access to the private variables `host` and `newZombie`, respectively. This means that other parts of the code can retrieve the values of these variables but cannot modify them directly. \n\nThe `Infection` class has a constructor that takes two integer parameters: `_host` and `_newZombie`. These parameters are used to initialize the `host` and `newZombie` variables. \n\nThe purpose of this code is to represent an infection event in the Brick-Force project. It provides a way to store and retrieve information about the host and the newly infected zombie. \n\nHere's an example of how this code might be used in the larger project:\n\n```csharp\n// Create a new infection event\nInfection infection = new Infection(123, 456);\n\n// Retrieve the host and new zombie IDs\nint hostID = infection.Host;\nint newZombieID = infection.NewZombie;\n\n// Print the IDs\nConsole.WriteLine(\"Host ID: \" + hostID);\nConsole.WriteLine(\"New Zombie ID: \" + newZombieID);\n```\n\nIn this example, we create a new `Infection` object with the host ID of 123 and the new zombie ID of 456. We then retrieve these IDs using the `Host` and `NewZombie` properties and print them to the console. This allows us to track and display information about infection events in the Brick-Force project.\n## Questions: \n 1. **What is the purpose of the `Infection` class?**\nThe `Infection` class represents an infection event in the Brick-Force project, where a host becomes a new zombie. \n\n2. **What are the meanings of the `host` and `newZombie` variables?**\nThe `host` variable represents the original host before infection, while the `newZombie` variable represents the new zombie that resulted from the infection.\n\n3. **What is the significance of the `Host` and `NewZombie` properties?**\nThe `Host` and `NewZombie` properties provide read-only access to the `host` and `newZombie` variables respectively, allowing other parts of the code to retrieve their values.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Infection.md"}}],["261",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Infernum\\SteamDLL.cs)\n\nThe code provided is a C# class called `SteamDLL` that contains a series of `DllImport` attributes. These attributes are used to import functions from a native DLL file called `steam_api`. \n\nThe purpose of this code is to provide a C# interface to the Steam API, which is a set of functions and services provided by the Steam platform. The Steam API allows developers to integrate their games or applications with Steam features such as user authentication, friends list, matchmaking, achievements, and more.\n\nThe `DllImport` attribute is used to specify the name of the DLL file and the calling convention for the imported functions. The `CallingConvention.Cdecl` specifies that the functions use the C calling convention, which is the default convention for most C and C++ libraries.\n\nThe `extern` keyword is used to declare the imported functions, which are then defined in the native DLL file. These functions are declared as `static extern` and have the same signature as the corresponding functions in the DLL file.\n\nFor example, the `SteamAPI_Init` function is imported from the `steam_api` DLL file and is declared as a `public static extern` function in the `SteamDLL` class. This function is used to initialize the Steam API and must be called before any other Steam API functions can be used.\n\nHere is an example of how the `SteamAPI_Init` function can be used in a larger project:\n\n```csharp\nusing Infernum;\n\npublic class Game\n{\n    public void Initialize()\n    {\n        if (SteamDLL.SteamAPI_Init())\n        {\n            // Steam API initialized successfully\n            // Perform other initialization tasks\n        }\n        else\n        {\n            // Steam API initialization failed\n            // Handle the error\n        }\n    }\n}\n```\n\nIn this example, the `Initialize` method of the `Game` class calls the `SteamAPI_Init` function from the `SteamDLL` class to initialize the Steam API. If the initialization is successful, the method can proceed with other initialization tasks. If the initialization fails, the method can handle the error accordingly.\n\nOverall, this code provides a C# interface to the Steam API, allowing developers to integrate their games or applications with Steam features.\n## Questions: \n 1. What is the purpose of this code?\n- This code is a wrapper for the Steam API, allowing the program to interact with various Steam features and services.\n\n2. What are the different functions being imported from the \"steam_api\" library?\n- The code imports functions such as SteamAPI_Shutdown, SteamAPI_IsSteamRunning, SteamAPI_RestartAppIfNecessary, SteamAPI_WriteMiniDump, SteamAPI_SetMiniDumpComment, SteamClient, SteamUser, SteamFriends, SteamUtils, SteamMatchMaking, SteamUserStats, SteamApps, SteamNetworking, SteamMatchmakingServers, SteamRemoteStorage, SteamScreenshots, SteamHTTP, and SteamUnifiedMessages.\n\n3. What is the purpose of the \"DllImport\" attribute?\n- The \"DllImport\" attribute is used to import functions from a native library (in this case, \"steam_api\") into managed code. It allows the program to call functions from the native library.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Infernum\\SteamDLL.md"}}],["262",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/.autodoc\\docs\\json\\Assembly-CSharp\\Infernum)\n\nThe `SteamDLL.cs` file in the `Infernum` folder of the `Assembly-CSharp` project provides a C# interface to the Steam API. This is achieved through the use of `DllImport` attributes, which import functions from a native DLL file named `steam_api`.\n\nThe Steam API provides a set of functions and services that allow developers to integrate their games or applications with Steam features. These features include user authentication, friends list, matchmaking, achievements, and more.\n\nThe `DllImport` attribute specifies the name of the DLL file and the calling convention for the imported functions. The `CallingConvention.Cdecl` is used, which is the default convention for most C and C++ libraries.\n\nThe `extern` keyword is used to declare the imported functions, which are then defined in the native DLL file. These functions are declared as `static extern` and have the same signature as the corresponding functions in the DLL file.\n\nFor instance, the `SteamAPI_Init` function is imported from the `steam_api` DLL file and is declared as a `public static extern` function in the `SteamDLL` class. This function is used to initialize the Steam API and must be called before any other Steam API functions can be used.\n\nHere is an example of how the `SteamAPI_Init` function can be used:\n\n```csharp\nusing Infernum;\n\npublic class Game\n{\n    public void Initialize()\n    {\n        if (SteamDLL.SteamAPI_Init())\n        {\n            // Steam API initialized successfully\n            // Perform other initialization tasks\n        }\n        else\n        {\n            // Steam API initialization failed\n            // Handle the error\n        }\n    }\n}\n```\n\nIn this example, the `Initialize` method of the `Game` class calls the `SteamAPI_Init` function from the `SteamDLL` class to initialize the Steam API. If the initialization is successful, the method can proceed with other initialization tasks. If the initialization fails, the method can handle the error accordingly.\n\nIn conclusion, `SteamDLL.cs` provides a C# interface to the Steam API, allowing developers to integrate their games or applications with Steam features.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Infernum\\summary.md"}}],["263",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\InstalledBomb.cs)\n\nThe code provided is for a class called \"InstalledBomb\" in the Brick-Force project. This class is responsible for managing the behavior and functionality of a bomb object in the game. \n\nThe class has several public variables that define different game objects, audio clips, textures, and fonts used by the bomb. These variables are set in the Unity editor and provide customization options for the bomb's appearance and sound.\n\nThe class also has private variables that store various states and timers used by the bomb. These variables include deltaTime, notifyDelta, flickerDelta, popDelta, popNext, status, and beep. These variables are used to keep track of the bomb's state and control its behavior.\n\nThe class has several private methods that are used for initialization and verification. The \"Start\" method is called when the bomb is first created and is responsible for setting the initial state of the bomb, verifying the audio source, verifying the explosion match, hiding the bomb, and initializing the animation.\n\nThe class also has several public methods that can be called externally to control the bomb's behavior. The \"Blast\" method is called when the bomb is detonated and is responsible for changing the bomb's state to \"blasted\", instantiating an explosion effect, and hiding the bomb. The \"Install\" method is called when the bomb is installed and is responsible for changing the bomb's state to \"installed\", showing the bomb, playing the ticking sound, and setting the bomb's position and rotation. The \"Uninstall\" method is called when the bomb is uninstalled and is responsible for changing the bomb's state to \"uninstalled\", showing the bomb, playing the disarm sound, and triggering a pop effect. The \"SetDeltaTime\" method is called to update the bomb's delta time, which is used to track the time since the bomb was installed.\n\nThe class also has an \"OnGUI\" method that is responsible for rendering the bomb's GUI elements, such as the background, timer digits, and colon separator. This method is only called if the game's GUI is enabled.\n\nThe class also has an \"Update\" method that is called every frame and is responsible for updating the bomb's behavior based on its current state and delta time. This method checks if the bomb is blastable, updates the delta time, and plays the appropriate animation and sound based on the bomb's state and time remaining.\n\nIn summary, the \"InstalledBomb\" class is responsible for managing the behavior and functionality of a bomb object in the Brick-Force game. It handles the installation, uninstallation, and detonation of the bomb, as well as updating its appearance and sound based on its current state and time remaining.\n## Questions: \n 1. What is the purpose of the `VerifyAudioSource()` method and how is it used in the code?\n- The `VerifyAudioSource()` method is used to check if the `audioSource` variable is null and if so, assign it the value of the `AudioSource` component attached to the game object. It is used to ensure that the `audioSource` variable is properly initialized before being used to play audio clips.\n\n2. What is the purpose of the `InitializeAnimation()` method and how is it used in the code?\n- The `InitializeAnimation()` method is used to find the appropriate animation component named \"clockbomb\" and assign it to the `bipAnimation` variable. It also sets the wrap mode and layers for different animation states. It is used to initialize the animation component for the bomb.\n\n3. What is the purpose of the `Blast()` method and how is it used in the code?\n- The `Blast()` method is used to change the status of the bomb to \"BLASTED\", instantiate a kaboom explosion effect at the bomb's position, and hide the bomb. It is used to simulate the explosion of the bomb.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\InstalledBomb.md"}}],["264",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\InvincibleArmor.cs)\n\nThe code provided is for a class called \"InvincibleArmor\" in the Brick-Force project. This class is responsible for creating and managing an invincible armor object in the game.\n\nThe class has several member variables:\n- \"UnbreakableCapsule\" is a reference to a GameObject that represents the invincible armor.\n- \"lifeTime\" is a float that determines how long the armor will last before being destroyed.\n- \"armor\" is a reference to the instantiated armor object.\n- \"deltaTime\" is a float that keeps track of the time since the armor was enabled.\n- \"waitDestroy\" is a boolean flag that indicates whether the armor is waiting to be destroyed.\n- \"deltaTimeWaitDestroy\" is a float that keeps track of the time since the armor started waiting to be destroyed.\n\nThe class has several methods:\n- \"Start\" is a Unity callback method that initializes the member variables.\n- \"Enable\" is a method that enables the armor. It checks if the armor is already instantiated, and if not, it instantiates the \"UnbreakableCapsule\" object and assigns it to the \"armor\" variable. It also resets the \"deltaTime\" variable.\n- \"Destroy\" is a method that destroys the armor. If the armor is not null, it immediately destroys the armor object and sets the \"waitDestroy\" flag to false. If the armor is null, it sets the \"waitDestroy\" flag to true.\n- \"Update\" is a Unity callback method that is called every frame. It updates the position of the armor object to match the position of the \"InvincibleArmor\" object. It also checks if the armor has exceeded its lifetime. If it has, it destroys the armor object and sets the \"armor\" variable to null. Additionally, if the \"waitDestroy\" flag is true, it increments the \"deltaTimeWaitDestroy\" variable and checks if it has exceeded a threshold of 0.1 seconds. If it has, it destroys the armor object and sets the \"armor\" variable to null, and sets the \"waitDestroy\" flag to false.\n\nIn the larger project, this class can be used to create a power-up or special ability that grants the player temporary invincibility. The \"Enable\" method can be called when the power-up is activated, and the \"Destroy\" method can be called when the power-up expires or is deactivated. The \"Update\" method ensures that the armor object follows the \"InvincibleArmor\" object and is destroyed after its lifetime has elapsed.\n## Questions: \n 1. What is the purpose of the `UnbreakableCapsule` GameObject and how is it used in the code?\n- The `UnbreakableCapsule` GameObject is used to create an instance of an unbreakable capsule object when the `Enable()` method is called.\n\n2. What is the significance of the `lifeTime` variable and how does it affect the behavior of the code?\n- The `lifeTime` variable determines how long the `armor` GameObject will exist before it is destroyed. If the `deltaTime` exceeds the `lifeTime`, the `armor` GameObject is destroyed.\n\n3. What is the purpose of the `waitDestroy` variable and how does it affect the behavior of the code?\n- The `waitDestroy` variable is used to delay the destruction of the `armor` GameObject. If the `Destroy()` method is called while `armor` is null, the `waitDestroy` variable is set to true and the destruction of the `armor` GameObject is delayed until a certain amount of time has passed.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\InvincibleArmor.md"}}],["265",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\InvincibleFx.cs)\n\nThe code provided is for a class called \"InvincibleFx\" in the Brick-Force project. This class is responsible for displaying a visual effect when the player is in an invincible state. \n\nThe class has several public and private variables. The \"guiDepth\" variable determines the depth at which the GUI elements will be rendered. The \"shieldFx\" variable is a Texture2D object that represents the visual effect of the shield. The \"clrFrom\" and \"clrTo\" variables define the starting and ending colors of the shield effect. The \"flickerFrom\" and \"flickerTo\" variables determine the duration of the flickering effect. \n\nThe class also has a private variable called \"localController\" which is of type \"LocalController\". This variable is used to access the player's invincibility status and the invincibility timer. \n\nThe class has several methods. The \"VerifyLocalController\" method is used to check if the \"localController\" variable is null and if so, it retrieves the \"LocalController\" component attached to the same game object. The \"Start\" method is called when the script is enabled and it calls the \"VerifyLocalController\" method. \n\nThe \"OnGUI\" method is responsible for rendering the shield effect on the screen. It checks if the \"localController\" variable is not null and if the player is invincible and the \"showFx\" flag is true. It then sets the GUI skin, depth, and color. It uses the \"Color.Lerp\" method to interpolate between the \"clrFrom\" and \"clrTo\" colors based on the normalized invincible timer value. It then calls the \"TextureUtil.DrawTexture\" method to draw the shield effect on the screen. Finally, it resets the GUI color and enables the GUI. \n\nThe \"OnRespawn\" method is called when the player respawns and it resets the \"deltaTime\" and \"showFx\" variables. \n\nThe \"Update\" method is called every frame and it updates the shield effect. It checks if the \"localController\" variable is not null and if the player is invincible. It uses the \"Mathf.Lerp\" method to interpolate between the \"flickerFrom\" and \"flickerTo\" values based on the normalized invincible timer value. It then updates the \"deltaTime\" variable with the time since the last frame. If the \"showFx\" flag is true, it checks if the \"deltaTime\" is greater than the \"flicker\" value. If so, it resets the \"deltaTime\" and sets the \"showFx\" flag to false. If the \"showFx\" flag is false, it checks if the \"deltaTime\" is greater than the \"flickerTo\" value. If so, it resets the \"deltaTime\" and sets the \"showFx\" flag to true. \n\nIn summary, this code is responsible for rendering a shield effect on the screen when the player is in an invincible state. The shield effect flickers based on the invincible timer value and the colors of the shield can be customized. This class is likely used in conjunction with other classes and scripts to provide visual feedback to the player during gameplay.\n## Questions: \n 1. What is the purpose of the `InvincibleFx` class?\n- The `InvincibleFx` class is responsible for displaying a shield effect on the screen when the player is invincible.\n\n2. What is the significance of the `shieldFx` variable?\n- The `shieldFx` variable holds the texture that is used to display the shield effect on the screen.\n\n3. What is the purpose of the `VerifyLocalController` method?\n- The `VerifyLocalController` method is used to check if the `localController` variable is null and assign it the value of the `LocalController` component attached to the same game object if it is null.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\InvincibleFx.md"}}],["266",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Invite.cs)\n\nThe code provided defines a class called `Invite`. This class is used to represent an invitation in the larger Brick-Force project. \n\nThe `Invite` class has several public properties, including `invitorSeq`, `invitorNickname`, `channelIndex`, `roomNo`, `mode`, `pswd`, `clanSeq`, `squadIndex`, and `squadCounterIndex`. These properties store information related to the invitation, such as the sequence number of the invitor, the nickname of the invitor, the index of the channel, the room number, the mode, the password, the sequence number of the clan, the index of the squad, and the counter index of the squad.\n\nThis class can be used in various parts of the Brick-Force project where invitations need to be created, stored, and manipulated. For example, when a player wants to invite another player to join a game or a clan, an instance of the `Invite` class can be created and populated with the relevant information. This instance can then be passed to other parts of the project that handle invitations, such as the user interface or the networking module.\n\nHere is an example of how the `Invite` class can be used:\n\n```csharp\nInvite invite = new Invite();\ninvite.invitorSeq = 123;\ninvite.invitorNickname = \"John\";\ninvite.channelIndex = 1;\ninvite.roomNo = 456;\ninvite.mode = 2;\ninvite.pswd = \"password\";\ninvite.clanSeq = 789;\ninvite.squadIndex = 3;\ninvite.squadCounterIndex = 4;\n```\n\nIn this example, an instance of the `Invite` class is created and its properties are set with sample values. These values can then be used by other parts of the project to handle the invitation.\n\nOverall, the `Invite` class provides a structured way to represent and manage invitations in the Brick-Force project. It helps to organize and encapsulate the relevant information related to invitations, making it easier to work with and maintain the codebase.\n## Questions: \n 1. **What is the purpose of this class?**\nThe class `Invite` seems to represent an invitation in the Brick-Force project, but it is unclear what specific functionality or behavior it provides.\n\n2. **What do the different variables represent?**\nThe variables `invitorSeq`, `invitorNickname`, `channelIndex`, `roomNo`, `mode`, `pswd`, `clanSeq`, `squadIndex`, and `squadCounterIndex` are present in the class, but it is not clear what each of them represents or how they are used within the project.\n\n3. **Are there any methods or functions associated with this class?**\nThe code provided only includes the class definition, but it does not show if there are any methods or functions associated with the `Invite` class. It would be helpful to know if there are any additional behaviors or operations related to invitations in the Brick-Force project.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Invite.md"}}],["267",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\InviteManager.cs)\n\nThe `InviteManager` class is a component in the Brick-Force project that manages a list of `Invite` objects. It provides methods to add, remove, and retrieve invite data.\n\nThe `InviteManager` class has a public list called `listInvite` which stores instances of the `Invite` class. This list is initially empty.\n\nThe class also has a private static instance variable `_instance` and a public static property `Instance`. The `Instance` property is a singleton pattern implementation that ensures only one instance of the `InviteManager` class is created. It uses the `Object.FindObjectOfType` method to find an existing instance of `InviteManager` in the scene or creates a new one if none exists. If the instance is not found or created, it logs an error message.\n\nThe `Awake` method is called when the `InviteManager` object is initialized. It uses `Object.DontDestroyOnLoad` to prevent the object from being destroyed when a new scene is loaded.\n\nThe `AddInvite` method takes an `Invite` object as a parameter and adds it to the `listInvite` list. It first calls the `Remove` method to remove any existing invite with the same `invitorSeq` value. Then it adds the new invite to the list. It also checks if an instance of the `InviteNoticeDialog` is already open and if so, it initializes the dialog.\n\nThe `Remove` method takes an integer `key` as a parameter and removes the invite with the matching `invitorSeq` value from the `listInvite` list. It iterates through the list and compares the `invitorSeq` value of each invite with the `key` value. If a match is found, it removes the invite from the list and exits the loop.\n\nThe `RemoveAll` method clears the `listInvite` list and stores the first invite in the list in the `savedForClan` variable.\n\nThe `GetData` method returns the value of the `savedForClan` variable.\n\nOverall, the `InviteManager` class provides functionality to manage a list of invites, add new invites, remove invites by key, and retrieve invite data. It also ensures that only one instance of the `InviteManager` class exists in the scene. This class can be used in the larger Brick-Force project to handle invite-related operations and manage invite data.\n## Questions: \n 1. What is the purpose of the `InviteManager` class?\n- The `InviteManager` class is responsible for managing a list of invites and performing operations such as adding, removing, and retrieving invites.\n\n2. What is the significance of the `Instance` property?\n- The `Instance` property is a singleton pattern implementation that ensures there is only one instance of the `InviteManager` class throughout the application.\n\n3. What does the `RemoveAll` method do?\n- The `RemoveAll` method clears the list of invites and saves the first invite in the list to a variable called `savedForClan`.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\InviteManager.md"}}],["268",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\InviteNoticeDialog.cs)\n\nThe code provided is a class called `InviteNoticeDialog` that extends the `Dialog` class. This class represents a dialog box that is used to display and handle invite notices in the larger Brick-Force project.\n\nThe `InviteNoticeDialog` class has several public fields that represent various UI elements such as buttons, labels, and images. These fields are assigned in the Unity editor and are used to reference the corresponding UI elements in the dialog box.\n\nThe `Start` method is overridden from the base `Dialog` class and is called when the dialog is first created. In this method, the `id` field of the dialog is set to a specific value from the `DialogManager.DIALOG_INDEX` enum. Additionally, several UI elements are added to a `scrollView` object, which is a `UIScrollView` component that allows for scrolling through a list of invite notices.\n\nThe `OnPopup` method is also overridden from the base `Dialog` class and is called when the dialog is shown. In this method, the position and size of the dialog box are calculated based on the screen size.\n\nThe `InitDialog` method is a placeholder method that currently does nothing. It can be used to initialize the dialog with any necessary data or settings.\n\nThe `DoDialog` method is the main method of the class and is called every frame to update and draw the dialog. It returns a boolean value indicating whether the dialog should be closed or not. \n\nIn this method, the current GUI skin is set to a specific skin obtained from `GUISkinFinder.Instance.GetGUISkin()`. Then, the `imgList` and `labelList` UI elements are drawn. If the `inviteSetUp` button is clicked, all invites are removed and a `SettingDialog` is shown with a specific tab selected. If the `allRejection` button is clicked, all invites are removed. If the `exit` or `btnClose` buttons are clicked, all invites are removed and the `result` variable is set to `true`.\n\nNext, the `scrollView` is updated with the number of invite notices in the `listInvite` list from the `InviteManager` class. The `scrollView` is then scrolled through and each invite notice is drawn. If the `go` button is clicked, the `Compass` class is used to set the destination to a specific level and the invite is removed. If the `no` button is clicked, the invite is removed.\n\nFinally, if there are no active popups, the `WindowUtil.EatEvent()` method is called to prevent any further input events from being processed. The GUI skin is then reset to the original skin and the `result` variable is returned.\n\nOverall, this code represents a dialog box that is used to display and handle invite notices in the Brick-Force project. It allows the user to accept or reject invites and perform certain actions based on the clicked buttons.\n## Questions: \n 1. What is the purpose of the `InitDialog()` method?\n- The purpose of the `InitDialog()` method is not clear from the code provided. It would be helpful to have more information or comments within the code to understand its purpose.\n\n2. What does the `DoDialog()` method do?\n- The `DoDialog()` method handles the logic for drawing and interacting with the dialog UI elements. It returns a boolean value indicating whether the dialog should be closed or not.\n\n3. What is the significance of the `scrollView` variable?\n- The `scrollView` variable is used to manage the scrolling functionality for the list of invites in the dialog. It is used to set the list count, position, and draw the scroll view.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\InviteNoticeDialog.md"}}],["269",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Kaboom.cs)\n\nThe code provided is a script called \"Kaboom\" that is written in C# and is a part of the larger Brick-Force project. This script is responsible for creating explosions in the game at random intervals.\n\nThe script contains several public and private variables. The public variables include \"explosion\", which is a reference to a GameObject that represents the explosion effect, and \"noapplyUsk\", which is a boolean flag that determines whether or not to apply a specific muzzle effect. The private variables include \"minKaboomTime\" and \"maxKaboomTime\", which define the minimum and maximum time intervals between explosions, \"kaboomDelta\", which keeps track of the time since the last explosion, and \"nextKaboom\", which stores the time at which the next explosion should occur.\n\nThe script has two main methods: \"Start()\" and \"Update()\". The \"Start()\" method is called once when the script is first initialized and sets the initial values of \"kaboomDelta\" and \"nextKaboom\" to 0.\n\nThe \"Update()\" method is called every frame and is responsible for checking if it is time to create an explosion. It first increments \"kaboomDelta\" by the time that has passed since the last frame. If \"kaboomDelta\" exceeds \"nextKaboom\", it means that it is time to create an explosion. The script then resets \"kaboomDelta\" to 0 and generates a new random value for \"nextKaboom\" within the specified range.\n\nNext, the script checks the value of \"noapplyUsk\". If it is false, it checks if a specific muzzle effect called \"useUskMuzzleEff\" is enabled. If it is not enabled, it instantiates the \"explosion\" GameObject at the current position of the script's GameObject. If \"useUskMuzzleEff\" is enabled, it checks if another GameObject called \"explosionUsk\" is not null, and if so, it instantiates it at the current position.\n\nIf \"noapplyUsk\" is true, it simply instantiates the \"explosion\" GameObject at the current position.\n\nIn summary, this script is responsible for creating explosions in the game at random intervals. The specific explosion effect to be used can be customized by assigning a GameObject to the \"explosion\" variable. The script also provides the option to apply a specific muzzle effect based on the value of \"noapplyUsk\". This script can be used in the larger Brick-Force project to add dynamic and random explosions to the gameplay.\n## Questions: \n 1. What is the purpose of the `Kaboom` class?\n- The `Kaboom` class is responsible for creating explosions in the game.\n\n2. What is the significance of the `noapplyUsk` variable?\n- The `noapplyUsk` variable determines whether or not to apply a specific muzzle effect when creating explosions.\n\n3. What is the purpose of the `minKaboomTime` and `maxKaboomTime` variables?\n- The `minKaboomTime` and `maxKaboomTime` variables determine the range of time intervals between each explosion.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Kaboom.md"}}],["270",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\KeyDef.cs)\n\nThe code provided is a class definition for a KeyDef object. This object is used to define and store information about a specific key used in the game. \n\nThe KeyDef class is marked with the [Serializable] attribute, which means that instances of this class can be serialized and stored in a file or sent over a network. This allows the game to save and load key configurations for each player.\n\nThe class has several properties:\n- `name`: a string that represents the name of the key. This could be a descriptive name like \"Jump\" or \"Shoot\".\n- `category`: an enum value that represents the category of the key. The enum `CATEGORY` defines several categories such as \"COMMON\", \"SHOOTER_MODE\", \"BUILD_MODE\", \"WEAPON_CHANGE\", and \"BUNGEE_MODE\". This allows the game to group keys based on their functionality.\n- `defaultInputKey`: a KeyCode value that represents the default key assigned to this action. KeyCode is an enumeration of all possible keys on a keyboard, such as \"A\", \"Space\", or \"Escape\".\n- `altDefaultInputKey`: a KeyCode value that represents an alternate default key assigned to this action. This allows the player to customize their key bindings by providing an alternative key for the action.\n\nThis KeyDef class is likely used in the larger Brick-Force project to manage and configure key bindings for the game. It provides a structured way to define and store information about each key, including its name, category, and default key assignments. This information can then be used by other parts of the game to handle player input and perform the appropriate actions based on the key pressed.\n\nHere is an example of how this class could be used in the larger project:\n\n```csharp\nKeyDef jumpKey = new KeyDef();\njumpKey.name = \"Jump\";\njumpKey.category = KeyDef.CATEGORY.COMMON;\njumpKey.defaultInputKey = KeyCode.Space;\njumpKey.altDefaultInputKey = KeyCode.JoystickButton0;\n\n// Save the jumpKey object to a file or send it over the network\nSaveKeyConfig(jumpKey);\n\n// Load the jumpKey object from a file or receive it over the network\nKeyDef loadedKey = LoadKeyConfig();\n\n// Use the loadedKey object to handle player input\nif (Input.GetKeyDown(loadedKey.defaultInputKey))\n{\n    PerformJump();\n}\n```\n\nIn this example, a KeyDef object is created to represent the \"Jump\" action. The object is then saved or sent over the network using the `SaveKeyConfig` function. Later, the object is loaded using the `LoadKeyConfig` function, and the default key assigned to the action is used to check for player input and perform the jump action.\n## Questions: \n 1. **What is the purpose of the `KeyDef` class?**\nThe `KeyDef` class is used to define and store information about different types of keys, including their name, category, and default input keys.\n\n2. **What are the possible values for the `CATEGORY` enum?**\nThe possible values for the `CATEGORY` enum are `COMMON`, `SHOOTER_MODE`, `BUILD_MODE`, `WEAPON_CHANGE`, and `BUNGEE_MODE`.\n\n3. **What is the purpose of the `altDefaultInputKey` property?**\nThe `altDefaultInputKey` property is used to store an alternative default input key for a specific key definition.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\KeyDef.md"}}],["271",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\KeyDefByBuild.cs)\n\nThe code provided defines a class called `KeyDefByBuild` that is marked as `[Serializable]`. This means that objects of this class can be serialized and deserialized, allowing them to be easily stored or transmitted.\n\nThe `KeyDefByBuild` class has two properties: `target` and `keyDefs`. \n\nThe `target` property is of type `BuildOption.TARGET`. It is not clear from the given code what `BuildOption` is, but it can be assumed that it is another class or enum that defines different build options. The `target` property represents the target build option for a specific key definition.\n\nThe `keyDefs` property is an array of `KeyDef` objects. Again, it is not clear from the given code what `KeyDef` is, but it can be assumed that it is another class that defines key definitions. The `keyDefs` property represents the key definitions associated with the target build option.\n\nThis code can be used in the larger project to define and store key definitions for different build options. For example, if the project has different build options like \"debug\" and \"release\", the `KeyDefByBuild` class can be used to define the key definitions for each of these build options. The `target` property can be set to the corresponding build option, and the `keyDefs` property can be populated with the key definitions.\n\nHere is an example of how this code can be used:\n\n```csharp\nKeyDefByBuild keyDefByBuild = new KeyDefByBuild();\nkeyDefByBuild.target = BuildOption.TARGET.Debug;\n\nKeyDef[] keyDefs = new KeyDef[2];\nkeyDefs[0] = new KeyDef(\"key1\", \"value1\");\nkeyDefs[1] = new KeyDef(\"key2\", \"value2\");\nkeyDefByBuild.keyDefs = keyDefs;\n\n// Serialize the object\nstring serializedObject = Serialize(keyDefByBuild);\n\n// Deserialize the object\nKeyDefByBuild deserializedObject = Deserialize(serializedObject);\n```\n\nIn this example, a `KeyDefByBuild` object is created and populated with a target build option of \"debug\" and two key definitions. The object is then serialized into a string using a `Serialize` method, and later deserialized back into a `KeyDefByBuild` object using a `Deserialize` method.\n## Questions: \n 1. **What is the purpose of the `[Serializable]` attribute on the `KeyDefByBuild` class?**\nThe `[Serializable]` attribute indicates that instances of the `KeyDefByBuild` class can be serialized and deserialized, allowing them to be easily stored or transmitted.\n\n2. **What is the `BuildOption.TARGET` type and how is it used in the `KeyDefByBuild` class?**\nThe `BuildOption.TARGET` type is likely an enumeration or a class defined elsewhere in the codebase. It is used as the type of the `target` field in the `KeyDefByBuild` class, indicating that `target` can hold a value from the `BuildOption.TARGET` type.\n\n3. **What is the purpose of the `KeyDef[]` array in the `KeyDefByBuild` class?**\nThe `KeyDef[]` array represents a collection of `KeyDef` objects. It is used to store multiple instances of the `KeyDef` class, allowing for multiple key definitions to be associated with a single `KeyDefByBuild` instance.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\KeyDefByBuild.md"}}],["272",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\KickDialog.cs)\n\nThe code provided is a class called \"KickDialog\" that extends another class called \"Dialog\". This class is used to create a dialog box that allows the user to kick players who have taken too long to wait in a game. \n\nThe class contains several public variables that define the position and size of various elements within the dialog box. These variables include \"crdXLT\", \"crdX\", \"crdLeftTop\", \"crdNickname\", and \"offset\". These variables are of type Vector2 and float and are used to calculate the positions and sizes of different UI elements within the dialog box.\n\nThe class overrides two methods from the base \"Dialog\" class: \"Start()\" and \"OnPopup()\". The \"Start()\" method sets the \"id\" variable of the dialog to a specific value from an enum called \"DIALOG_INDEX\". The \"OnPopup()\" method calls a method called \"CalcSize()\" to calculate the size of the dialog box.\n\nThe class also overrides a method called \"DoDialog()\" which is responsible for rendering the dialog box and handling user interactions. Inside this method, the \"CalcSize()\" method is called again to ensure that the size of the dialog box is up to date. The method then retrieves a GUISkin from a GUISkinFinder instance and sets it as the current GUISkin. It then uses the \"LabelUtil.TextOut()\" method to render a label with the text \"KICKOFF\" at the center of the dialog box.\n\nNext, the method retrieves an array of \"BrickManDesc\" objects from a \"BrickManManager\" instance. It iterates over each object in the array and renders a button with an \"X\" symbol next to it. If the button is clicked, it sends a kick request to a \"CSNetManager\" instance. It also renders the nickname of the player next to the button.\n\nAfter rendering all the buttons and nicknames, the method checks if a popup is currently open. If not, it calls a method called \"WindowUtil.EatEvent()\" to prevent any further input events from being processed. Finally, it restores the original GUISkin and returns a boolean value indicating whether the dialog box should be closed or not.\n\nThe class also contains a private method called \"CalcSize()\" which is responsible for calculating the size of the dialog box based on the number of players who have taken too long to wait. It retrieves the array of \"BrickManDesc\" objects again and iterates over each object. If the object has a property called \"IsTooLong4Init\" set to true, it increments the \"size.y\" variable by the \"offset\" value. Finally, it sets the \"rc\" variable to a Rect object representing the position and size of the dialog box on the screen.\n\nOverall, this code provides the functionality to create a dialog box for kicking players who have taken too long to wait in a game. It calculates the size of the dialog box based on the number of players and renders buttons and labels for each player.\n## Questions: \n 1. What is the purpose of the `KickDialog` class?\n- The `KickDialog` class is a subclass of `Dialog` and is used to display a dialog box for kicking players in the game.\n\n2. What is the significance of the `CalcSize` method?\n- The `CalcSize` method is used to calculate the size of the dialog box based on the number of players who took too long to wait.\n\n3. What is the purpose of the `DoDialog` method?\n- The `DoDialog` method is responsible for rendering the dialog box and handling user interactions, such as kicking a player.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\KickDialog.md"}}],["273",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\KICKOUT_VOTE.cs)\n\nThe code provided is an enumeration called `KICKOUT_VOTE`. An enumeration is a set of named values that represent a set of possible options or choices. In this case, the `KICKOUT_VOTE` enumeration represents the reasons for kicking out a player in the Brick-Force project.\n\nThe enumeration consists of five named values: `NO_REASON`, `WHY_BAD_WORD`, `WHY_BAD_MANNER`, `WHY_HACK`, and `WHY_ETC`. Each of these values is assigned a numeric value, starting from 0 and incrementing by powers of 2 (1, 2, 4, 8). \n\nThe purpose of this enumeration is to provide a standardized set of reasons for kicking out a player in the Brick-Force project. By using an enumeration, the code can easily refer to these reasons by their names instead of using arbitrary numeric values. This improves code readability and maintainability.\n\nHere is an example of how this enumeration might be used in the larger project:\n\n```java\npublic class Player {\n    private KICKOUT_VOTE kickoutVote;\n\n    public void setKickoutVote(KICKOUT_VOTE kickoutVote) {\n        this.kickoutVote = kickoutVote;\n    }\n\n    public void kickoutPlayer() {\n        switch (kickoutVote) {\n            case NO_REASON:\n                // Handle no reason for kicking out the player\n                break;\n            case WHY_BAD_WORD:\n                // Handle kicking out the player for using bad words\n                break;\n            case WHY_BAD_MANNER:\n                // Handle kicking out the player for bad manners\n                break;\n            case WHY_HACK:\n                // Handle kicking out the player for hacking\n                break;\n            case WHY_ETC:\n                // Handle kicking out the player for other reasons\n                break;\n        }\n    }\n}\n```\n\nIn this example, the `Player` class has a `kickoutVote` property of type `KICKOUT_VOTE`. The `setKickoutVote` method is used to set the reason for kicking out the player. The `kickoutPlayer` method then uses a switch statement to handle the different reasons for kicking out the player based on the value of `kickoutVote`.\n\nOverall, this code provides a standardized set of reasons for kicking out a player in the Brick-Force project and allows for easy handling of these reasons in the larger project.\n## Questions: \n 1. **What is the purpose of this enum?**\nThe enum appears to represent different reasons for kicking out a player in the Brick-Force game, but it is unclear how this enum is used in the code or what actions are taken based on the different values.\n\n2. **What do the different values of the enum represent?**\nThe enum values are assigned numeric values (0, 1, 2, 4, 8), but it is not clear what each value represents in terms of reasons for kicking out a player. \n\n3. **Are there any other possible reasons for kicking out a player?**\nThe enum includes values for \"WHY_ETC\" which suggests that there may be additional reasons for kicking out a player, but it is unclear if these are the only reasons or if there are other possible values not included in the enum.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\KICKOUT_VOTE.md"}}],["274",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\KillerPortrait.cs)\n\nThe code provided is for a class called \"KillerPortrait\" in the Brick-Force project. This class is responsible for displaying a portrait of the killer in the game when a player is killed. \n\nThe class has several member variables, including a GUI depth, an array of strings representing different vocalizations, a texture for the killer's portrait frame, a delta time variable, a KillInfo object, a boolean to determine whether to show the portrait, and several Rect and Vector2 variables to define the position and size of the portrait and its components.\n\nThe Start() method is empty and does not contain any code.\n\nThe OnGUI() method is responsible for rendering the killer's portrait on the screen. It first checks if the GUI is enabled and if the killInfo object is not null. If both conditions are met, it retrieves the GameObject of the killer using the BrickManManager and checks if it has a Camera component enabled. If a camera is found, it begins a GUI group and draws the killer's portrait, frame, and nickname using the TextureUtil and LabelUtil utility classes. Finally, it ends the GUI group and restores the original GUI skin.\n\nThe OnKillLog() method is called when a player is killed. It checks if the victim's sequence matches the player's own sequence and if the killer's sequence is different from the victim's sequence. If both conditions are met, it sets the killInfo object to the received KillInfo object, resets the delta time, and sets the show boolean to false.\n\nThe Update() method is responsible for updating the state of the killer's portrait. It first checks if the killInfo object is not null. If it is not null, it increments the delta time by the time passed since the last frame. If the delta time exceeds the hide time, it resets the killInfo object, delta time, and show boolean. If the show boolean is false and the delta time exceeds the show time, it sets the show boolean to true and retrieves the GameObject of the killer. If the GameObject is not null, it checks if it has a LookCoordinator component and plays a vocalization based on whether the LookCoordinator is for a Yang character or not.\n\nIn summary, the KillerPortrait class is responsible for displaying the killer's portrait when a player is killed in the game. It retrieves the killer's GameObject, checks if it has a Camera component, and renders the portrait, frame, and nickname on the screen. It also plays a vocalization based on the type of character the killer is.\n## Questions: \n 1. What is the purpose of the `KillerPortrait` class?\n- The `KillerPortrait` class is responsible for displaying a portrait of the killer in the game.\n\n2. What is the significance of the `showTime` and `hideTime` variables?\n- The `showTime` variable determines how long the killer portrait is shown on the screen, while the `hideTime` variable determines how long it takes for the portrait to disappear.\n\n3. What is the purpose of the `OnKillLog` method?\n- The `OnKillLog` method is called when a kill event occurs in the game, and it updates the `killInfo` variable with the relevant information about the kill.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\KillerPortrait.md"}}],["275",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\KillInfo.cs)\n\nThe code provided is a class called \"KillInfo\" that represents information about a kill event in the game. This class is likely used in the larger Brick-Force project to store and manage data related to kills that occur during gameplay.\n\nThe class has several private fields, including constants for the lifetime and alpha time of the kill info, as well as variables for the killer's name, victim's name, victim's sequence, killer's sequence, weapon texture, headshot texture, delta time, alpha value, dragY value, and weaponBy value.\n\nThe class also has several public properties that provide access to these private fields. These properties include \"Killer\", \"Victim\", \"VictimSequence\", \"KillerSequence\", \"WeaponTex\", \"HeadShot\", \"IsAlive\", \"IsAlpha\", \"Alpha\", \"DragY\", and \"WeaponBy\". These properties allow other parts of the code to read and modify the values stored in the private fields.\n\nThe class has a constructor that takes in several parameters, including the killer's nickname, victim's nickname, weapon image, headshot image, killer's sequence, victim's sequence, and the weaponBy value. The constructor initializes the private fields with the provided values and sets the delta time to 0.\n\nThe class also has an \"Update\" method that is likely called every frame in the game. This method increments the delta time by the time that has passed since the last frame. This allows the class to keep track of how long the kill info has been active.\n\nOverall, this class provides a way to store and manage information about kill events in the game. It allows other parts of the code to access and modify this information as needed. For example, other parts of the code could use the \"Killer\" property to display the name of the player who made the kill, or use the \"IsAlive\" property to determine if the kill info is still active.\n## Questions: \n 1. What is the purpose of the `Update()` method in the `KillInfo` class?\n- The `Update()` method is used to update the `deltaTime` variable by adding the current frame's time to it.\n\n2. What is the significance of the `IsAlive` property in the `KillInfo` class?\n- The `IsAlive` property returns a boolean value indicating whether the `deltaTime` is less than 5f, which determines if the `KillInfo` object is still considered alive.\n\n3. What is the purpose of the `Alpha` property in the `KillInfo` class?\n- The `Alpha` property is used to get or set the value of the `alpha` variable, which represents the transparency of the `KillInfo` object.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\KillInfo.md"}}],["276",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\KillLog.cs)\n\nThe code provided is for a class called \"KillLog\" in the Brick-Force project. This class is responsible for managing and displaying kill logs in the game. \n\nThe class has several member variables, including a Queue of KillInfo objects called \"logQ\", a GUI depth enum called \"guiDepth\", a float variable called \"logHeight\", and a Vector2 variable called \"headShotSize\". It also has two Color variables called \"clrKiller\" and \"clrDead\", which are initialized to Color.white in the Start() method.\n\nThe Awake() method initializes the logQ variable by creating a new instance of the Queue class.\n\nThe Start() method sets the clrKiller and clrDead variables to specific colors using a method called GetByteColor2FloatColor() from the GlobalVars class.\n\nThe OnKillLog() method is an event handler that is called when a new kill log is received. It adds the KillInfo object to the logQ queue.\n\nThe OnGUI() method is responsible for rendering the kill logs on the screen. It first checks if the GUI is enabled, and then sets the GUI skin, depth, and enabled properties. It then iterates over each KillInfo object in the logQ queue and renders the necessary GUI elements for each log entry. The GUI elements include boxes, labels, and textures for the weapon, victim, killer, and headshot. The position and size of each GUI element is calculated based on the logHeight, headShotSize, and the dimensions of the textures and labels. The color of the labels is determined by the GetColor() method, which takes a sequence number as input and returns a color based on the player's team and slot.\n\nThe Update() method is responsible for updating the state of each KillInfo object in the logQ queue. It calls the Update() method on each KillInfo object and removes any objects from the queue that are no longer alive.\n\nThe GetColor() method is a helper method that determines the color of the labels based on the player's team and slot. It checks if the game is in a team vs team scene and then retrieves the player's slot number. If the slot number is less than 8, it returns the clrKiller color, otherwise it returns the clrDead color.\n\nIn summary, the KillLog class manages and displays kill logs in the game. It uses a queue to store the kill log entries and renders them on the screen using GUI elements. The color of the labels is determined based on the player's team and slot. This class is likely used in the larger Brick-Force project to provide visual feedback to players when kills occur in the game.\n## Questions: \n 1. What is the purpose of the `KillLog` class?\n- The `KillLog` class is responsible for displaying kill information in the game's GUI.\n\n2. What is the purpose of the `logQ` variable and how is it used?\n- The `logQ` variable is a queue that stores `KillInfo` objects. It is used to keep track of the kill information that needs to be displayed in the GUI.\n\n3. What is the purpose of the `GetColor` method and when is it called?\n- The `GetColor` method returns a color based on the given sequence. It is called in the `OnGUI` method to determine the color of the text displayed in the GUI based on the sequence of the player.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\KillLog.md"}}],["277",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\LabelUtil.cs)\n\nThe `LabelUtil` class in the `Brick-Force` project provides utility methods for working with GUI labels in Unity. These methods allow for modifying the style, size, and position of labels, as well as calculating their length and size.\n\nThe `ToBold` method takes a style name as input and sets the font style of that style to bold. Similarly, the `ToNormal` method sets the font style of a style to normal.\n\nThe `PushSize` method takes a style name and a font size as input. It saves the current style and font size, and then sets the font size of the specified style to the given size. The `PopSize` method restores the previously saved font size.\n\nThe `CalcLength` method calculates the length of a given text string using a specified style. It returns a `Vector2` representing the width and height of the text.\n\nThe `CalcSize` method calculates the size of a given text string using a specified style and a maximum width. If the calculated width exceeds the maximum width, the method adjusts the height of the text to fit within the width. It returns a `Vector2` representing the adjusted width and height.\n\nThe `TextOut` methods are used to display text labels on the screen. They take various parameters such as position, text, style, text color, outline color, and alignment. The methods calculate the size of the text using the specified style, adjust the position based on the alignment, and then display the text label using the specified style, colors, and position. The `TextOut` method with a `width` parameter truncates the text if it exceeds the specified width, adding ellipsis at the end.\n\nThese utility methods can be used in the larger project to easily modify and display GUI labels with different styles, sizes, and positions. For example, they can be used to create dynamic UI elements such as buttons, tooltips, or information panels. The methods provide flexibility in customizing the appearance of labels and handling text that exceeds a certain width.\n## Questions: \n 1. What is the purpose of the `LabelUtil` class?\n- The `LabelUtil` class provides utility methods for working with GUI labels in Unity.\n\n2. What does the `ToBold` method do?\n- The `ToBold` method takes a style name as input and sets the font style of that style to bold.\n\n3. What is the purpose of the `TextOut` method?\n- The `TextOut` method is used to display text on the GUI. It takes various parameters such as position, text, style, and colors to customize the appearance of the text.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\LabelUtil.md"}}],["278",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\LangOptManager.cs)\n\nThe `LangOptManager` class is responsible for managing language options and fonts in the Brick-Force project. It contains various properties, methods, and event handlers to handle language selection, font loading, and progress tracking.\n\nThe `LANG_OPT` enum represents the available language options in the game, such as Korean, English, Simplified Chinese, etc. The `langNames` array stores the names of these languages.\n\nThe `languages` array holds the textures for each language option, which can be used to display language flags or icons in the user interface.\n\nThe `levels` array stores the names of the game levels. This is used to track the progress of level streaming in the `Update` method.\n\nThe `skinHolders` array is not used in this code and its purpose is unclear.\n\nThe `fonts` array holds the fonts for each language option. The `fontNames` array stores the names of these fonts, and the `fontVersions` array stores the versions of the fonts.\n\nThe `toss` array contains some text strings related to the language options.\n\nThe `onceStreamed` boolean flag is used to track whether the levels have been streamed once.\n\nThe `streamingProgress` float variable stores the progress of level streaming.\n\nThe `LangOpt` property gets and sets the current language option. It also saves the selected language option in the `PlayerPrefs` for future use.\n\nThe `CurFont` property returns the font for the current language option.\n\nThe `Instance` property is a singleton pattern implementation that returns the instance of the `LangOptManager` class.\n\nThe `IsFontReady` property returns a boolean value indicating whether the font is ready for use.\n\nThe `GetAgbById` method returns a string based on the provided ID.\n\nThe `GetAgbCurrent` method returns a string based on the current language option.\n\nThe `GetLangName` method returns the name of the language based on the provided ID.\n\nThe `Awake` method initializes some variables and ensures that the `LangOptManager` object is not destroyed when a new scene is loaded.\n\nThe `SetFont` method sets the font for the current language option. If the font is already loaded, it updates the font in the `GUISkinFinder` class. Otherwise, it loads the font using the `AssetBundleLoadManager` class.\n\nThe `OnDestroy` method is empty and does not have any functionality.\n\nThe `AlreadyLoadedFont` method checks if a font for a specific language is already loaded and returns its index in the `fonts` array.\n\nThe `Start` method initializes the `langOpt` variable based on the default language option specified in the `BuildOption` class. If language selection is enabled, it checks if the selected language is supported and falls back to the default language if not. It also initializes the `fonts` array and loads the font for the current language option using the `AssetBundleLoadManager` class.\n\nThe `readyFont` method checks if the font is ready for use. If so, it updates the font in the `GUISkinFinder` class and sets the `isFontReady` flag to true.\n\nThe `Update` method checks if the font is ready and if the game is running in a web player. If so, it calculates the progress of level streaming based on the `levels` array and sets the `onceStreamed` flag if the streaming progress reaches 99.99999%.\n\nThe `OnGUI` method is responsible for displaying the loading progress if the game is running in a web player and the streaming progress is less than 99.99999%.\n\nOverall, the `LangOptManager` class provides functionality for managing language options and fonts in the Brick-Force project. It allows the user to select a language, loads the corresponding font, and tracks the progress of level streaming.\n## Questions: \n 1. What is the purpose of the `LangOptManager` class?\n- The `LangOptManager` class manages language options and fonts for the game.\n2. How does the `LangOptManager` class handle font loading?\n- The `LangOptManager` class checks if the font for the selected language is already loaded. If not, it requests the font to be loaded from an asset bundle.\n3. What is the purpose of the `readyFont()` method?\n- The `readyFont()` method checks if the font has been loaded from the asset bundle and updates the GUI skin with the new font.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\LangOptManager.md"}}],["279",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\LAUNCHER.cs)\n\nThe code provided is an enumeration called `LAUNCHER` that represents different types of launchers in the Brick-Force project. \n\nAn enumeration is a set of named values that represent a set of possible options or choices. In this case, the `LAUNCHER` enumeration represents the different types of launchers that can be used in the game. \n\nThe enumeration has three values: `NONE`, `GRANADE`, and `ROCKET`. Each value is assigned an integer value, with `NONE` being -1, `GRANADE` being 0, and `ROCKET` being 1. \n\nThis enumeration can be used in the larger Brick-Force project to represent the different types of launchers that a player can choose from. For example, if a player wants to select a launcher for their character, they can use this enumeration to specify the type of launcher they want. \n\nHere is an example of how this enumeration can be used in code:\n\n```csharp\nLAUNCHER selectedLauncher = LAUNCHER.GRANADE;\n\nif (selectedLauncher == LAUNCHER.GRANADE)\n{\n    // Code to handle the selection of a granade launcher\n}\nelse if (selectedLauncher == LAUNCHER.ROCKET)\n{\n    // Code to handle the selection of a rocket launcher\n}\nelse\n{\n    // Code to handle the case where no launcher is selected\n}\n```\n\nIn this example, the `selectedLauncher` variable is assigned the value `LAUNCHER.GRANADE`. The code then uses an `if` statement to check the value of `selectedLauncher` and execute the appropriate code based on the selected launcher. \n\nOverall, this enumeration provides a way to represent and work with the different types of launchers in the Brick-Force project. It allows for easy selection and handling of different launcher types in the game.\n## Questions: \n 1. **What is the purpose of the `LAUNCHER` enum?**\nThe `LAUNCHER` enum is used to represent different types of launchers in the game, such as grenades and rockets.\n\n2. **Why is the `NONE` value assigned a value of -1?**\nThe `NONE` value is assigned a value of -1 to indicate that it is not a valid launcher type.\n\n3. **Are there any other values that can be added to the `LAUNCHER` enum?**\nBased on the given code, it is not clear if there are any other values that can be added to the `LAUNCHER` enum.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\LAUNCHER.md"}}],["280",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\LevelUpCompensation.cs)\n\nThe code provided defines a class called `LevelUpCompensation`. This class has four public properties: `evt`, `code`, `opt`, and `amount`. It also has a constructor that takes in four parameters and assigns them to the corresponding properties.\n\nThe purpose of this class is to represent a level up compensation in the larger project. It seems that when a player levels up in the game, they are given some sort of compensation, which is represented by an instance of the `LevelUpCompensation` class. \n\nThe `evt` property represents the event associated with the compensation. It is of type `int`, which suggests that it may be an identifier or a code for a specific event. \n\nThe `code` property is a string that may contain additional information about the compensation. It is not clear what this information might be, but it could be used to provide more details about the compensation.\n\nThe `opt` property is of type `int` and it is not clear what it represents. It could be an option or a choice related to the compensation.\n\nThe `amount` property represents the amount of compensation given to the player. It is of type `int`, suggesting that it may be a numerical value.\n\nHere is an example of how this class could be used in the larger project:\n\n```csharp\nLevelUpCompensation compensation = new LevelUpCompensation(1, \"bonus\", 2, 100);\n```\n\nIn this example, a new instance of the `LevelUpCompensation` class is created with the following values: `evt` is set to 1, `code` is set to \"bonus\", `opt` is set to 2, and `amount` is set to 100. This could represent a level up event where the player receives a bonus of 100 units.\n\nOverall, the `LevelUpCompensation` class provides a way to represent and store information about level up compensations in the larger Brick-Force project.\n## Questions: \n 1. **What is the purpose of the `LevelUpCompensation` class?**\nThe `LevelUpCompensation` class appears to be a data structure that represents compensation for leveling up in the game. \n\n2. **What do the variables `evt`, `code`, `opt`, and `amount` represent?**\nThe variables `evt`, `code`, `opt`, and `amount` likely represent different attributes or properties of the level up compensation, but without further context it is unclear what each variable specifically represents.\n\n3. **What is the significance of the constructor parameters `_evt`, `_code`, `_opt`, and `_amount`?**\nThe constructor parameters `_evt`, `_code`, `_opt`, and `_amount` are used to initialize the corresponding variables in the `LevelUpCompensation` class. It is unclear why the parameters have the underscore prefix and what values they are expected to hold.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\LevelUpCompensation.md"}}],["281",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\LevelUpCompensationManager.cs)\n\nThe `LevelUpCompensationManager` class is responsible for managing the compensation data for leveling up in the game. It provides methods to load the compensation data from either a web server or the local file system, parse the data, and retrieve the compensation for a specific level.\n\nThe `LevelUpCompensationManager` class is a singleton, meaning that there can only be one instance of it in the game. The `Instance` property ensures that only one instance is created and provides access to that instance.\n\nThe `Awake` method is called when the object is initialized and ensures that the `LevelUpCompensationManager` object is not destroyed when a new scene is loaded. This ensures that the compensation data is preserved throughout the game.\n\nThe `Start` method initializes the `levelupCompens` list, which will hold the compensation data.\n\nThe `Load` method is responsible for loading the compensation data. It first checks if the game is running in a web player or not. If it is running in a web player, it starts a coroutine to load the data from a web server using a `WWW` object. If it is not running in a web player, it calls the `LoadFromLocalFileSystem` method to load the data from the local file system.\n\nThe `LoadFromWWW` method is a coroutine that downloads the compensation data from a web server. It constructs a URL based on the server address and the file name, and then uses a `WWW` object to download the data. Once the data is downloaded, it is parsed using a `CSVLoader` object and the `Parse` method is called to populate the `levelupCompens` list.\n\nThe `LoadFromLocalFileSystem` method loads the compensation data from the local file system. It first checks if the \"Resources\" directory exists and then constructs the file path based on the directory and file name. It uses a `CSVLoader` object to load the data from the file. If the data is successfully loaded, it is parsed using the `Parse` method.\n\nThe `Parse` method takes a `CSVLoader` object as input and parses the data. It iterates over each row in the data and extracts the values for the event, code, option, and amount. It trims and converts the values as necessary and creates a new `LevelUpCompensation` object with the parsed values. The `LevelUpCompensation` object is then added to the `levelupCompens` list.\n\nThe `getCurCompensation` method takes a level as input and returns the compensation data for that level. It iterates over the `levelupCompens` list and checks if the level matches the event value of any `LevelUpCompensation` object. If a match is found, the corresponding `LevelUpCompensation` object is returned.\n\nThe `Clear` method clears the `levelupCompens` list, removing all compensation data.\n\nThe `Add` method takes the event, code, option, and amount as input and adds a new `LevelUpCompensation` object to the `levelupCompens` list.\n\nOverall, the `LevelUpCompensationManager` class provides functionality to load and manage compensation data for leveling up in the game. It can load the data from a web server or the local file system, parse the data, retrieve the compensation for a specific level, and add new compensation data. This class is an important component of the larger project as it allows for the management of leveling up rewards and compensations.\n## Questions: \n 1. **What is the purpose of the `LevelUpCompensationManager` class?**\nThe `LevelUpCompensationManager` class is responsible for managing level up compensations in the game. It loads compensations from a local file or from a web server and provides methods to retrieve and add compensations.\n\n2. **What is the purpose of the `Load()` method?**\nThe `Load()` method is responsible for loading level up compensations. It checks if the game is running in a web player or not, and then calls the appropriate method (`LoadFromWWW()` or `LoadFromLocalFileSystem()`) to load the compensations.\n\n3. **What is the purpose of the `Parse()` method?**\nThe `Parse()` method is responsible for parsing the loaded CSV data and creating `LevelUpCompensation` objects. It reads values from the CSV file, trims and converts them to the appropriate data types, and then creates `LevelUpCompensation` objects with the parsed values.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\LevelUpCompensationManager.md"}}],["282",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\LineTool.cs)\n\nThe `LineTool` class is a part of the Brick-Force project and is used as a tool for drawing lines in the game. It inherits from the `EditorTool` class and provides functionality for creating and manipulating lines made of bricks.\n\nThe class has several private fields, including `start` and `end` vectors that represent the start and end points of the line, a `rotation` byte that stores the rotation of the bricks in the line, and two queues of `GameObject` instances called `line` and `invisible`. The `line` queue stores the bricks that make up the line, while the `invisible` queue stores unused bricks that can be reused when needed.\n\nThe class also has a `prefab` field that represents a dummy brick object used for creating new bricks in the line, and a `phase` field of the `PHASE` enum type that keeps track of the current phase of the line drawing process.\n\nThe class has a constructor that takes an `EditorToolScript`, an `Item`, a `GameObject` dummy, and a `BattleChat` object as parameters. It initializes the `line` and `invisible` queues, sets the `prefab` field to the provided dummy object, and sets the `start` and `end` vectors to a default value.\n\nThe class provides various methods for manipulating the line, such as `Reset`, `PopDummy`, `PushDummy`, `IsEnable`, `Update`, `CheckCount`, `CheckEmpty`, `MoveFirst`, `MoveNext`, `ClearLine`, `GoBack`, `SetStart`, `SetPreview`, `SetEnd`, `ReverseLine`, `PushPoint`, and `Draw3DLine`. These methods handle tasks such as clearing the line, adding and removing bricks from the line, checking if the line can be moved or modified, and drawing the line in 3D space.\n\nOverall, the `LineTool` class is an important component of the Brick-Force project as it allows players to create and manipulate lines made of bricks in the game. It provides a user-friendly interface for drawing lines and handles the logic behind creating and modifying the line.\n## Questions: \n **Question 1:** What is the purpose of the `LineTool` class?\n    \n**Answer:** The `LineTool` class is used as an editor tool for drawing lines in a game environment.\n\n**Question 2:** What is the significance of the `PHASE` enum?\n    \n**Answer:** The `PHASE` enum is used to represent the different phases of the line drawing process, such as the start and end points.\n\n**Question 3:** How does the `Draw3DLine` method work?\n    \n**Answer:** The `Draw3DLine` method uses the Bresenham's line algorithm to calculate the points along a 3D line and adds them to the `line` queue.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\LineTool.md"}}],["283",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\LineToolDialog.cs)\n\nThe code provided is a class called \"LineToolDialog\" that extends the \"Dialog\" class. This class is used to create a dialog box for a line tool in the larger Brick-Force project. The purpose of this code is to handle the functionality and display of the line tool dialog box.\n\nThe class has several member variables, including textures for the gauge frame and gauge, booleans for tracking progress and whether the tool is currently being used, and references to other objects such as the line tool itself, a brick object, and an item object.\n\nThe class has several methods that are used to initialize and update the dialog box. The \"Start\" method sets the ID of the dialog box. The \"OnPopup\" method sets the position of the dialog box on the screen. The \"InitDialog\" method initializes the dialog box with the line tool and brick objects, and checks if the player has the necessary function to use the line tool. The \"DoDialog\" method updates and displays the dialog box, including the progress gauge and buttons for starting and closing the tool. The \"MoveFirst\" method is called when the player clicks the start button, and it moves the line tool to the first position and sends a network request to update the server. The \"MoveNext\" method is called when the player successfully moves the line tool to the next position, and it updates the progress count and sends a network request to update the server.\n\nOverall, this code provides the functionality and display for the line tool dialog box in the Brick-Force project. It allows the player to use the line tool to create a line of bricks by moving the tool to different positions. The dialog box displays the progress of the line tool and allows the player to start and close the tool.\n## Questions: \n 1. What is the purpose of the `LineToolDialog` class?\n- The `LineToolDialog` class is a subclass of `Dialog` and represents a dialog box for a line tool in the game. It handles the initialization, display, and interaction of the dialog.\n\n2. What is the significance of the `gaugeFrame` and `gauge` variables?\n- The `gaugeFrame` and `gauge` variables are Texture2D objects used to display a progress gauge in the dialog. `gaugeFrame` represents the frame of the gauge, while `gauge` represents the filled portion of the gauge.\n\n3. What is the purpose of the `MoveFirst` and `MoveNext` methods?\n- The `MoveFirst` method is called when the user clicks the \"START\" button in the dialog. It initiates the first move of the line tool and sends a network request to update the game state. The `MoveNext` method is called after each move of the line tool and updates the progress count and sends a network request if there are more moves remaining.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\LineToolDialog.md"}}],["284",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\LoadBrickMain.cs)\n\nThe code provided is a part of the Brick-Force project and is contained in the `LoadBrickMain` class. This class is responsible for displaying a loading screen with an image and a logo while other assets are being loaded in the background. \n\nThe `loadingImage` variable is a reference to a texture that will be displayed as the background image of the loading screen. The `logoSize` variable determines the size of the logo that will be displayed on the loading screen.\n\nThe `OnGUI` method is responsible for rendering the loading screen. It first sets the GUI skin to the one obtained from the `GUISkinFinder` instance. Then, it calculates the position of the loading image and draws it using the `TextureUtil.DrawTexture` method. Next, it checks if a logo is available and if so, it calculates the position of the logo and draws it on the loading screen. Finally, it displays a text label at the bottom of the screen showing the progress of loading others using the `LabelUtil.TextOut` method.\n\nThe `Update` and `LateUpdate` methods are empty and do not contain any code. They are likely placeholders for future functionality that may be added to the class.\n\nThe `LateUpdate` method is interesting as it checks if a specific condition is met before loading another scene called \"LoadOthers\". It checks if the `result4TeamMatch` variable of the `BrickManager` instance is not null, if the level \"LoadOthers\" can be loaded, and if the loading of the \"LoadOthers\" scene has not already started. If all these conditions are met, it calls the `SceneLoadManager` instance to asynchronously load the \"LoadOthers\" scene.\n\nIn summary, this code is responsible for displaying a loading screen with an image, logo, and progress text while other assets are being loaded in the background. It also includes a condition to load another scene once certain conditions are met. This code is likely used in the larger Brick-Force project to provide a visually appealing loading experience for the players.\n## Questions: \n 1. What is the purpose of the `Start()` method?\n- The purpose of the `Start()` method is not clear from the code provided. It appears to be empty and does not contain any code.\n\n2. What does the `OnGUI()` method do?\n- The `OnGUI()` method is responsible for rendering the loading image, logo, and progress text on the screen using the Unity GUI system.\n\n3. What conditions need to be met for the `LateUpdate()` method to execute the `SceneLoadManager.Instance.SceneLoadLevelAsync(\"LoadOthers\")` code?\n- The `LateUpdate()` method will execute the `SceneLoadManager.Instance.SceneLoadLevelAsync(\"LoadOthers\")` code if the `BrickManager.Instance.result4TeamMatch` is not null, the level \"LoadOthers\" can be loaded, and the scene load for \"LoadOthers\" has not already started.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\LoadBrickMain.md"}}],["285",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\LoadBuildOption.cs)\n\nThe code provided is a part of the Brick-Force project and is contained in a file called \"LoadBuildOption\". This code is written in C# and utilizes the Unity game engine.\n\nThe purpose of this code is to handle the loading of a build option in the game. It is attached to a game object in the scene and is responsible for instantiating the build option object when the game starts. The build option object is specified by the \"buildOption\" variable, which is a reference to a prefab in the Unity editor.\n\nIn the Start() method, the code uses the Object.Instantiate() method to create an instance of the build option object. This method takes the build option prefab as a parameter and returns a reference to the instantiated object. This allows the build option to be displayed in the game when it starts.\n\nIn the Update() method, the code checks if the scene has not yet changed and if the \"Bootstrap\" scene can be loaded and is not already being loaded. If these conditions are met, the code calls the SceneLoadManager.Instance.SceneLoadLevelAsync() method to asynchronously load the \"Bootstrap\" scene. This method takes the scene name as a parameter and starts loading the scene in the background. The code also sets the \"isChangeScene\" variable to true to prevent the scene from being loaded multiple times.\n\nThis code is likely used in the larger Brick-Force project to handle the initial loading of the game and to display the build option to the player. The build option object could be a menu or a selection screen where the player can choose different options before starting the game. By loading the \"Bootstrap\" scene asynchronously, the game can continue to run smoothly while the scene is being loaded in the background.\n\nExample usage:\n\n```csharp\n// Attach the LoadBuildOption script to a game object in the scene\nGameObject loadBuildOptionObject = new GameObject(\"LoadBuildOption\");\nLoadBuildOption loadBuildOption = loadBuildOptionObject.AddComponent<LoadBuildOption>();\n\n// Set the build option prefab in the Unity editor\nloadBuildOption.buildOption = buildOptionPrefab;\n```\n## Questions: \n 1. **Question:** What is the purpose of the `LoadBuildOption` class?\n   - **Answer:** The `LoadBuildOption` class is responsible for instantiating a `buildOption` GameObject and changing the scene to \"Bootstrap\" under certain conditions.\n\n2. **Question:** What is the significance of the `isChangeScene` variable?\n   - **Answer:** The `isChangeScene` variable is used to ensure that the scene is only changed once. It prevents multiple scene changes from occurring.\n\n3. **Question:** What is the role of the `SceneLoadManager` class and its methods?\n   - **Answer:** The `SceneLoadManager` class is responsible for managing scene loading. The `SceneLoadLevelAsync` method is used to load the \"Bootstrap\" scene asynchronously, while the `IsLoadStart` method checks if the scene loading process has started for the \"Bootstrap\" scene.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\LoadBuildOption.md"}}],["286",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Loading.cs)\n\nThe code provided is a script called \"Loading\" that is part of the Brick-Force project. This script is responsible for displaying a loading screen with a progress bar and tips while the game is loading. \n\nThe script uses the Unity game engine and is written in C#. It contains several public variables that can be set in the Unity editor, such as the blackOut texture, the GUI depth, an array of loading textures, an array of tip keys, and an array of TipDef objects. \n\nThe OnGUI() method is called every frame by Unity's GUI system. It first checks if the BrickManager.Instance.IsLoaded flag is false, indicating that the game is still loading. If the game is still loading, it proceeds to draw the loading screen. \n\nThe loading screen consists of a blackOut texture that covers the entire screen, a loading texture that is randomly selected from the loadings array, and a logo texture that is positioned at the top right corner of the loading screen. The tip text is displayed at the bottom center of the loading screen. \n\nThe Start() method is called when the script is first initialized. It randomly selects a loading texture from the loadings array and sets it to the loading variable. It then checks if there are any moreTipKeys defined and if the target matches the current build target. If there are moreTipKeys and the target matches, it adds the number of tips in the moreTipKeys array to the total number of tips. It then creates a new string array with the size of the total number of tips and copies the tipKeys and moreTipKeys tips into the array. Finally, it selects a random tip from the array using the StringMgr.Instance.Get() method and sets it to the tip variable. \n\nIn summary, this script is responsible for displaying a loading screen with a progress bar and tips while the game is loading. It allows for customization of the loading screen by setting various public variables in the Unity editor. The loading screen is displayed using the OnGUI() method, and the loading texture and tip text are randomly selected from arrays defined in the Start() method.\n## Questions: \n 1. What is the purpose of the `OnGUI()` method?\n- The `OnGUI()` method is responsible for rendering the loading screen UI elements if the BrickManager is not yet loaded.\n\n2. What determines the size and position of the loading screen elements?\n- The size and position of the loading screen elements are determined by the `width` and `height` variables, which are calculated based on the screen dimensions and the dimensions of the loading texture.\n\n3. How is the `tip` text displayed on the loading screen?\n- The `tip` text is displayed using the `LabelUtil.TextOut()` method, which takes in the position, text, font style, color, and other parameters to render the text on the screen.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Loading.md"}}],["287",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\LOBBYCHAT_STYLE.cs)\n\nThe code provided is an enumeration called `LOBBYCHAT_STYLE`. An enumeration is a set of named values that represent a set of possible options or choices. In this case, the enumeration represents different styles or types of lobby chat in the Brick-Force project.\n\nThe `LOBBYCHAT_STYLE` enumeration has four possible values: `HIGH`, `MIDDLE`, `LOW`, and `CLANMATCH`. These values represent different levels or categories of lobby chat. \n\nThe purpose of this enumeration is to provide a way to categorize and differentiate lobby chat messages based on their style or importance. This can be useful in various parts of the Brick-Force project where lobby chat messages need to be handled differently based on their style.\n\nFor example, in the code that handles lobby chat messages, the `LOBBYCHAT_STYLE` enumeration can be used to determine how to display or prioritize the messages. Messages with a `HIGH` style may be displayed prominently or given more importance, while messages with a `LOW` style may be displayed less prominently or given less importance.\n\nHere is an example of how this enumeration can be used in code:\n\n```java\nLOBBYCHAT_STYLE messageStyle = getMessageStyle(); // Get the style of the lobby chat message\n\nswitch (messageStyle) {\n    case HIGH:\n        // Display the message prominently or give it more importance\n        break;\n    case MIDDLE:\n        // Display the message with medium importance\n        break;\n    case LOW:\n        // Display the message less prominently or give it less importance\n        break;\n    case CLANMATCH:\n        // Handle the message specifically for clan matches\n        break;\n    default:\n        // Handle any other unknown or unexpected message style\n        break;\n}\n```\n\nIn this example, the `getMessageStyle()` method retrieves the style of the lobby chat message. The code then uses a switch statement to handle the message based on its style. Depending on the style, different actions can be taken, such as displaying the message differently or handling it in a specific way for clan matches.\n\nOverall, the `LOBBYCHAT_STYLE` enumeration provides a way to categorize and handle lobby chat messages based on their style or importance in the Brick-Force project.\n## Questions: \n 1. **What is the purpose of this enum?**\nThe enum `LOBBYCHAT_STYLE` is likely used to define different styles or levels of chat messages in the lobby of the Brick-Force game. \n\n2. **What are the possible values for this enum?**\nThe possible values for this enum are `HIGH`, `MIDDLE`, `LOW`, and `CLANMATCH`. \n\n3. **How is this enum used in the codebase?**\nTo fully understand how this enum is used in the codebase, further investigation is needed. It could be used to determine the display style of chat messages or to filter chat messages based on their style.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\LOBBYCHAT_STYLE.md"}}],["288",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\LOBBY_TYPE.cs)\n\nThe code provided is an enumeration called `LOBBY_TYPE`. An enumeration is a special data type that allows a variable to be a set of predefined constants. In this case, the `LOBBY_TYPE` enumeration defines five constants: `BASE`, `SHOP`, `EQUIP`, `MAP`, and `ROOMS`.\n\nThe purpose of this code is to provide a way to represent different types of lobbies in the larger Brick-Force project. A lobby is a virtual space where players can gather, interact, and access different features of the game. By using an enumeration, the code ensures that only the predefined lobby types can be used, providing a clear and consistent way to refer to different lobbies throughout the project.\n\nFor example, the `LOBBY_TYPE.BASE` constant can be used to represent the base lobby, where players start the game and access basic features. Similarly, the `LOBBY_TYPE.SHOP` constant can be used to represent the shop lobby, where players can buy in-game items. The other constants can be used in a similar way to represent different types of lobbies in the game.\n\nBy using the `LOBBY_TYPE` enumeration, the code improves the readability and maintainability of the project. Instead of using arbitrary strings or numbers to represent different lobbies, developers can use the predefined constants, which are self-explanatory and easier to understand.\n\nHere is an example of how the `LOBBY_TYPE` enumeration can be used in the larger Brick-Force project:\n\n```java\npublic class Lobby {\n    private LOBBY_TYPE type;\n    \n    public Lobby(LOBBY_TYPE type) {\n        this.type = type;\n    }\n    \n    public void enter() {\n        // Logic for entering the lobby based on its type\n        switch (type) {\n            case BASE:\n                // Logic for entering the base lobby\n                break;\n            case SHOP:\n                // Logic for entering the shop lobby\n                break;\n            case EQUIP:\n                // Logic for entering the equip lobby\n                break;\n            case MAP:\n                // Logic for entering the map lobby\n                break;\n            case ROOMS:\n                // Logic for entering the rooms lobby\n                break;\n        }\n    }\n}\n```\n\nIn this example, the `Lobby` class has a `type` property of type `LOBBY_TYPE`. The `enter()` method uses a switch statement to perform different actions based on the type of the lobby. This allows the code to handle different lobbies in a consistent and organized manner.\n## Questions: \n 1. **What is the purpose of this enum?**\nThe enum is likely used to represent different types of lobbies in the Brick-Force game, such as the base lobby, shop lobby, equipment lobby, map lobby, and rooms lobby.\n\n2. **Are there any additional values that can be added to this enum?**\nWithout further information, it is unclear if there are any additional values that can be added to this enum. The code provided only shows the initial set of values.\n\n3. **How is this enum used in the codebase?**\nTo fully understand the usage of this enum, it would be necessary to examine other parts of the codebase where this enum is referenced or utilized.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\LOBBY_TYPE.md"}}],["289",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\LongTimePlayDialog.cs)\n\nThe code provided is a class called \"LongTimePlayDialog\" that extends the \"Dialog\" class. This class is used to create a dialog box that displays information about a long-time play reward system in the game. \n\nThe class contains several public variables that are used to reference UI elements such as images, labels, and buttons. These variables are assigned in the Unity editor and are used to display the relevant information in the dialog box.\n\nThe class also contains private variables that store information about the play time, reward count, reset time, cycle time, and maximum reward count. These variables are used to calculate the remaining time until the next reward can be claimed.\n\nThe class has a property called \"RemainMinuteUntilReward\" which calculates the remaining time until the next reward can be claimed. This property is calculated based on the current time, the server data since time, the play time, and the cycle time. If the maximum reward count has been reached, the property returns -1.\n\nThe class has several methods that are used to initialize the dialog, set the data for the dialog, reset the PC bang data, and update the dialog. The \"InitDialog\" method is used to initialize the dialog based on whether the game is being exited or not. The \"SetData\" method is used to set the data for the dialog, such as the play time, reward count, reset time, cycle time, and maximum reward count. The \"ResetPCBangData\" method is used to reset the PC bang data based on whether the PC bang buff is active or not. The \"Update\" method is empty and does not perform any actions.\n\nThe \"DoDialog\" method is the main method that is called to display and update the dialog. This method is called every frame and is responsible for drawing the UI elements, updating the values, and handling button clicks. The method returns a boolean value indicating whether the dialog should be closed or not.\n\nOverall, this code is used to create and manage a dialog box that displays information about a long-time play reward system in the game. It handles the UI elements, updates the values, and handles user interactions.\n## Questions: \n 1. What is the purpose of the `InitDialog` method?\n- The `InitDialog` method is used to initialize the dialog by resetting the PCBang data and setting the visibility of certain UI elements based on the value of the `isGameExit` parameter.\n\n2. What does the `RemainMinuteUntilReward` property calculate?\n- The `RemainMinuteUntilReward` property calculates the remaining minutes until the next reward can be claimed. It takes into account the current play time, reward count, cycle, and server data since time.\n\n3. What is the purpose of the `ResetPCBangData` method?\n- The `ResetPCBangData` method is used to update the UI elements based on whether the player has a PCBang buff active or not. It sets the text and visibility of certain UI elements accordingly.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\LongTimePlayDialog.md"}}],["290",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Magazine.cs)\n\nThe code provided is a class called \"Magazine\" that represents a magazine of ammunition for a weapon in the larger Brick-Force project. The purpose of this class is to manage the ammunition count, reload the magazine, and fire the weapon.\n\nThe class has several private variables, including \"max\" which represents the maximum capacity of the magazine, \"curSecure\" which is an instance of a SecureInt class used to securely store the current ammunition count, and \"tmp\" which is a temporary variable used during reloading and firing operations.\n\nThe class has several properties, including \"Max\" which gets and sets the maximum capacity of the magazine, and \"Cur\" which gets and sets the current ammunition count. The \"Cur\" property also performs additional checks to ensure that the current ammunition count is valid and not exceeding the maximum capacity. If the count is invalid, the \"HardExit\" method of the \"BuildOption\" class is called.\n\nThe class also has a \"Empty\" property which returns true if the current ammunition count is less than or equal to zero, and a \"Ratio\" property which calculates the ratio of the current ammunition count to the maximum capacity.\n\nThe class has several methods, including \"CanFire\" which returns true if the current ammunition count is greater than zero, \"CanReload\" which returns true if the current ammunition count is less than the maximum capacity, \"Reset\" which resets the current ammunition count to zero, and \"addAmmo\" which adds ammunition to the magazine. The \"addAmmo\" method checks if the magazine is already full and returns false if it is. Otherwise, it adds the ammunition to the current count, ensuring that it does not exceed the maximum capacity.\n\nThe class also has a \"Reload\" method which takes an amount of ammunition to reload and returns the remaining ammunition that could not be loaded. The method checks if the amount of ammunition to reload is less than the remaining capacity in the magazine. If it is, it adds the ammunition to the current count and sets the remaining ammunition to zero. Otherwise, it adds the remaining capacity to the current count and subtracts it from the amount of ammunition to reload.\n\nFinally, the class has a \"Fire\" method which checks if the current ammunition count is greater than zero. If it is, it subtracts one from the current count and returns true. Otherwise, it returns false.\n\nOverall, this class provides functionality to manage the ammunition count of a weapon's magazine, reload the magazine, and fire the weapon. It ensures that the ammunition count is within the valid range and provides methods to check if the weapon can fire or be reloaded.\n## Questions: \n 1. **What is the purpose of the `SecureInt` class and how does it work?**\nThe `SecureInt` class is used to securely store and retrieve the value of the `cur` property. It uses encryption or other security measures to protect the value from being accessed or modified by unauthorized code.\n\n2. **What is the significance of the `NoCheat` class and its `UnhideVal` and `HideVal` methods?**\nThe `NoCheat` class is used to hide and unhide the value of the `cur` property. The `UnhideVal` method is used to retrieve the actual value of `cur` after it has been hidden, while the `HideVal` method is used to hide a given value before assigning it to `cur`.\n\n3. **What is the purpose of the `Empty` property and how is it determined?**\nThe `Empty` property is used to check if the `cur` property is less than or equal to 0. It returns `true` if `cur` is empty (i.e., has no ammo) and `false` otherwise.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Magazine.md"}}],["291",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\MapeditAuthorityDialog.cs)\n\nThe code provided is a class called `MapeditAuthorityDialog` that extends the `Dialog` class. This class is responsible for displaying and managing a dialog box related to the authority and permissions of users in a game room. \n\nThe class contains several member variables, including `Texture2D` objects for different room states (`LockedRoom`, `UnlockedRoom`, `roomMaster`), a `DevInfo` object that holds information about the developer, and various `Vector2` and `Rect` objects that define the positions and sizes of UI elements within the dialog box.\n\nThe `Start()` method sets the `id` of the dialog box to a specific value from an enum called `DIALOG_INDEX`.\n\nThe `OnPopup()` method is called when the dialog box is displayed. It sets the size and position of the dialog box based on the screen size and the current room information. It also sets the value of the `roomPswd` variable based on whether the room is locked or not.\n\nThe `InitDialog()` method is empty and does not have any functionality.\n\nThe `IsDeveloper()` method checks if the current user is the developer of the game. If the user is the developer, it sets the values of the `devInfo` object with the user's level, rank, and nickname. If the user is not the developer, it checks if any other user in the room is the developer and sets the `devInfo` object accordingly. This method returns a boolean value indicating whether the current user is a developer.\n\nThe `CheckAuth()` method checks if the current user has the authority to edit the map. If the user is the developer, it returns true. Otherwise, it displays a message indicating that the user does not have map editing authority and returns false.\n\nThe `DoDialog()` method is responsible for rendering and handling user interactions with the dialog box. It first checks if the return key was pressed and sets a boolean flag accordingly. It then checks if a certain amount of time has passed and displays a message if necessary.\n\nThe method then sets the GUI skin to a specific skin and retrieves an array of `BrickManDesc` objects, which represent users in the game room. It displays the current channel name, room name, and the number of players in the room.\n\nNext, it renders a locked room icon and a password field for entering the room password. If the current user is not the developer, the password field is disabled. If the return key was pressed and the current user is the developer, it sends a network request to change the room configuration.\n\nThe method then renders a section for displaying and managing the authority and permissions of users in the room. If the current user is the developer, it displays the developer's information and allows them to toggle their editor status. If the current user is not the developer, it displays the information and toggle buttons for other users in the room. It also allows the current user to exile other users from the room.\n\nOverall, this code manages the display and interaction of a dialog box related to the authority and permissions of users in a game room. It allows the developer to change the room configuration and manage the authority and permissions of other users.\n## Questions: \n 1. What is the purpose of the `InitDialog()` method?\n- The purpose of the `InitDialog()` method is not clear from the code provided. It is likely used to initialize the dialog, but without further information, it is difficult to determine its exact purpose.\n\n2. What does the `IsDeveloper()` method do?\n- The `IsDeveloper()` method checks if the current user is a developer by comparing their user ID with the IDs of the developers stored in the `BrickManManager` class. If a match is found, the method sets the `devInfo` object with the developer's information and returns true.\n\n3. What is the purpose of the `CheckAuth()` method?\n- The `CheckAuth()` method checks if the current user has the authority to perform map editing actions. If the user is not the owner of the map, the method displays a message and returns false. Otherwise, it returns true.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\MapeditAuthorityDialog.md"}}],["292",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\MapEditGuideDialog.cs)\n\nThe code provided is a class called `MapEditGuideDialog` that extends the `Dialog` class. This class is used to create a dialog box that displays a guide for editing maps in the larger Brick-Force project. \n\nThe class has several public fields that are used to reference UI elements within the dialog box. These include `imgList`, `labelList`, `toggle`, and `ok`. These fields are of specific types (`UIImageList`, `UILabelList`, `UIToggle`, and `UIMyButton`) that are likely custom UI components specific to the Brick-Force project.\n\nThe class also has a property called `DontShowThisMessageAgain` which returns the value of the `toggle.toggle` field. This property is likely used to determine whether the user has selected the option to not show the guide message again.\n\nThe class overrides two methods from the `Dialog` class: `Start()` and `OnPopup()`. The `Start()` method sets the `id` field to a specific value from the `DialogManager.DIALOG_INDEX` enum. The purpose of this is unclear without more context, but it likely relates to managing different types of dialogs within the larger project. The `OnPopup()` method sets the `rc` field to a specific `Rect` value based on the screen size and the size of the dialog box. This is likely used to position the dialog box in the center of the screen.\n\nThe class also has a method called `InitDialog()` which currently does nothing. It is unclear what the purpose of this method is without more context.\n\nThe most important method in this class is `DoDialog()`. This method is responsible for drawing the UI elements, handling user interactions, and returning a boolean value indicating whether the dialog should be closed. The method first sets the `skin` variable to the current GUI skin and then sets it to a specific GUI skin obtained from `GUISkinFinder.Instance.GetGUISkin()`. This suggests that the dialog box may have a custom skin specific to the Brick-Force project.\n\nThe method then calls the `Draw()` method on the `imgList`, `labelList`, `toggle`, and `ok` fields to draw the corresponding UI elements on the screen. It checks if the `ok` button has been clicked and if so, it checks if the `DontShowThisMessageAgain` property is true. If it is, it saves a specific value to the `MyInfoManager.Instance` and sets the `result` variable to true.\n\nFinally, the method checks if there is no other popup menu open and if so, it calls `WindowUtil.EatEvent()` to prevent further event handling. It then sets the GUI skin back to the original value and returns the `result` variable.\n\nIn summary, this code defines a class that represents a dialog box for displaying a guide for editing maps in the Brick-Force project. It handles drawing the UI elements, user interactions, and saving user preferences.\n## Questions: \n 1. What is the purpose of the `MapEditGuideDialog` class?\n- The `MapEditGuideDialog` class is a subclass of the `Dialog` class and represents a dialog box used for map editing guidance.\n\n2. What are the properties and components of the `MapEditGuideDialog` class?\n- The `MapEditGuideDialog` class has properties such as `imgList`, `labelList`, `toggle`, and `ok`, which are all UI elements used in the dialog box.\n\n3. What is the purpose of the `DoDialog()` method?\n- The `DoDialog()` method is responsible for drawing and handling user interactions with the dialog box. It returns a boolean value indicating whether the dialog box should be closed or not.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\MapEditGuideDialog.md"}}],["293",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\MapEditingInfo.cs)\n\nThe `MapEditingInfo` class is a script that is used for map editing in the Brick-Force project. It is attached to a game object in the Unity game engine. \n\nThe class has several public variables that can be accessed and modified by other scripts or components. These variables include:\n- `thumbnail`: a RenderTexture object that represents the thumbnail image of the map being edited.\n- `width` and `height`: floats that represent the width and height of the map.\n- `guiDepth`: an enum variable of type `GUIDepth.LAYER` that determines the GUI depth of the map editing interface.\n- `constructor`: a Texture2D object that represents the constructor image of the map.\n- `crdSize`: a Vector2 object that represents the size of the map editing interface.\n- `crdConstructor`, `crdThumbnail`, and `crdThumbnailOutline`: Rect objects that define the positions and sizes of various elements in the map editing interface.\n\nThe class also has a method called `ThumbnailToPNG()` that converts the thumbnail RenderTexture to a byte array in PNG format. This method is used to save the thumbnail image of the map.\n\nThe class also overrides the `OnGUI()` method, which is a Unity callback method that is called when the GUI is being rendered. In this method, the script checks if the GUI is enabled and if the map editing interface should be displayed. If so, it sets the GUI skin, depth, and enables/disables the GUI based on the state of the dialog manager. It then retrieves the current user map info and checks if the BrickManager has loaded the map. If both conditions are met, it begins a GUI group and draws the constructor and thumbnail images on the screen using the specified positions and sizes. It also draws a box outline around the thumbnail image. Finally, it ends the GUI group and enables the GUI.\n\nOverall, this script is responsible for managing the map editing interface and displaying the constructor and thumbnail images of the map being edited. It also provides a method to convert the thumbnail image to PNG format for saving purposes.\n## Questions: \n 1. What is the purpose of the `ThumbnailToPNG()` method?\n- The `ThumbnailToPNG()` method converts the `thumbnail` RenderTexture into a PNG byte array.\n\n2. What is the significance of the `crdSize` and `crdConstructor` variables?\n- The `crdSize` variable represents the size of a group in the GUI, while the `crdConstructor` variable represents the position and size of the constructor texture within that group.\n\n3. What conditions need to be met for the GUI elements to be displayed in the `OnGUI()` method?\n- The GUI elements will only be displayed if `MyInfoManager.Instance.isGuiOn` is true, `cur` is not null, and `BrickManager.Instance.IsLoaded` is true.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\MapEditingInfo.md"}}],["294",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\MapEditor.cs)\n\nThe `MapEditor` class is a script that is part of the Brick-Force project. It is responsible for managing the map editing functionality within the game. \n\nThe `MapEditor` class has several member variables, including `guiDepth`, `authMark`, `editMark`, `deltaTime`, `delayLoad`, `battleChat`, `localController`, `bLoaded`, `loadPlayherList`, `waitBoxWidth`, and `waitBoxHeight`. These variables are used to store various data and settings related to the map editor.\n\nThe `Start()` method is called when the script is first initialized. It performs several initialization tasks, such as clearing dropped weapons, applying audio sources, and initializing the first-person perspective. It also initializes the `battleChat` component and calls the `OnStart()` method of the `BrickManManager` instance.\n\nThe `Awake()` method is empty and does not perform any actions.\n\nThe `StartLoad()` method is called to start loading the map. It first calls `GC.Collect()` to perform garbage collection, then creates a new `UserMap` instance and sends a cache brick request to the server using the `CSNetManager` instance.\n\nThe `OnGUI()` method is responsible for rendering the graphical user interface (GUI) elements related to the map editor. It checks if the map has been loaded (`bLoaded`) and if the GUI is enabled (`MyInfoManager.Instance.isGuiOn`). If both conditions are true, it sets the GUI skin, depth, and enables GUI drawing. It then draws two textures (`authMark` and `editMark`) at specific positions on the screen.\n\nThe `InitializeFirstPerson()` method is called to initialize the first-person perspective. It first creates an array of usables, then finds the game object with the name \"Me\". If the game object is found, it gets the `EquipCoordinator` component and initializes it with the usables array. It also gets the `LocalController` component.\n\nThe `OnLoadComplete()` method is called when the map loading is complete. It sends a resume room request to the server using the `CSNetManager` instance, spawns the local player at a random spawn position, sets `bLoaded` to true, and shows a map edit guide dialog if it has not been disabled.\n\nThe `ResetGameStuff()` method is called to reset game-related data and settings using the `MyInfoManager` instance.\n\nThe `OnDisable()` method is called when the script is disabled. If the application is still loading a level, it resets game-related stuff, unlocks the cursor, clears the user map slot, and clears the brick manager.\n\nThe `Update()` method is called every frame. It checks if the connecting component is showing and sets a flag accordingly. It then locks the cursor based on various conditions, such as not loading a level, not showing the menu, not chatting, not showing a modal dialog, and not showing the connecting component. It also handles delay loading and checks for input to open the main menu or map edit authority dialog.\n\nThe `AddLoadPlayer()` and `RemoveLoadPlayer()` methods are used to add or remove players from the `loadPlayherList` list.\n\nOverall, the `MapEditor` class is responsible for managing the map editing functionality within the game. It handles initialization, loading, GUI rendering, input handling, and player management.\n## Questions: \n 1. What is the purpose of the `StartLoad()` method?\n- The `StartLoad()` method is responsible for initializing the user map and sending a cache brick request to the server.\n\n2. What does the `OnLoadComplete()` method do?\n- The `OnLoadComplete()` method is called when the loading of the map is complete. It sends a resume room request to the server, spawns the local player, and displays a map edit guide dialog if necessary.\n\n3. What is the purpose of the `AddLoadPlayer()` and `RemoveLoadPlayer()` methods?\n- The `AddLoadPlayer()` and `RemoveLoadPlayer()` methods are used to add or remove player sequences from the `loadPlayerList` list, which keeps track of players who are currently loading.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\MapEditor.md"}}],["295",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\MapEvalDlg.cs)\n\nThe code provided is a class called `MapEvalDlg` that extends the `Dialog` class. This class is responsible for displaying a dialog box that allows the user to evaluate a map in the game. The purpose of this code is to provide a user interface for the player to input their evaluation of a map and submit it to the server.\n\nThe `MapEvalDlg` class has several member variables that define the position and size of various UI elements in the dialog box. These variables include `crdOutline`, `crdGood`, `crdBad`, `crdLineEval`, `crdEvalFld`, `crdWarn1`, `crdWarn2`, `strEval`, `maxEvalLength`, `isGood`, `isBad`, and `playmap`.\n\nThe `Start()` method sets the `id` of the dialog box to a specific value from the `DialogManager` class.\n\nThe `OnPopup()` method sets the size and position of the dialog box based on the screen size.\n\nThe `InitDialog()` method initializes the member variables related to the evaluation of the map.\n\nThe `DoDialog()` method is responsible for rendering the UI elements and handling user input. It first sets the GUI skin to a specific skin from the `GUISkinFinder` class. It then renders the title of the dialog box and a blue outline box. It calls the `DoGoodBad()` method to render the \"good\" and \"bad\" toggle buttons and their labels. It renders a text field for the user to input their evaluation of the map. It also renders two warning labels. Finally, it renders two buttons - one for submitting the evaluation and one for closing the dialog box.\n\nThe `DoGoodBad()` method is responsible for rendering the \"good\" and \"bad\" toggle buttons and their labels. It also handles the logic for ensuring that only one of the buttons can be selected at a time.\n\nOverall, this code provides a user interface for the player to evaluate a map in the game and submit their evaluation to the server. It handles rendering the UI elements and handling user input for the evaluation process.\n## Questions: \n 1. What is the purpose of the `MapEvalDlg` class?\n- The `MapEvalDlg` class is a dialog class that handles the evaluation of a map in the game.\n2. What is the significance of the `strEval` variable?\n- The `strEval` variable stores the evaluation text provided by the player for the map.\n3. What happens when the player clicks the \"DO_EVAL\" button?\n- If the player has selected either the \"Good\" or \"Bad\" option and provided an evaluation text, the `CSNetManager` sends a map evaluation request to the server.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\MapEvalDlg.md"}}],["296",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\MapInfoDlg.cs)\n\nThe code provided is a class called `MapInfoDlg` that extends the `Dialog` class. This class is responsible for displaying information about a map in the game. It contains various properties and methods that handle the display and interaction with the map information.\n\nThe class has several public properties, such as `nonAvailable`, `icon`, and various `Vector2` and `Rect` variables that define the positions and sizes of different elements on the dialog box. These properties are used to store and access the textures, icons, and coordinates for displaying the map information.\n\nThe class also has private fields `regMap` and `userMap` of types `RegMap` and `UserMapInfo`, respectively. These fields store the information about the map being displayed. The `GetRegMap()` and `GetUserMap()` methods provide access to these fields.\n\nThe `Start()` method sets the `id` field of the dialog to a specific value from the `DialogManager.DIALOG_INDEX` enum.\n\nThe `OnPopup()` method calculates the position of the dialog box based on the screen size and sets the `rc` field to the calculated position.\n\nThe `InitDialog(RegMap mi)` and `InitDialog(UserMapInfo mi)` methods initialize the `regMap` and `userMap` fields, respectively, with the provided map information.\n\nThe `DrawThumbnail()` method displays the thumbnail image of the map. It checks whether the map is a user map or a registered map and then uses the `TextureUtil.DrawTexture()` method to draw the thumbnail image on the dialog box.\n\nThe `PrintMapInfo()` method displays various information about the map, such as the map alias, developer, last modified date, possible modes, and mode list. It uses the `LabelUtil.TextOut()` method to display the text on the dialog box.\n\nThe `CanMakeRoom()` method checks whether a room can be created with the current map. It checks if there is already a room, if the current channel is null, and if the map is downloaded. It returns a boolean value indicating whether a room can be created.\n\nThe `DoDialog()` method is the main method that handles the display and interaction of the dialog box. It sets the GUI skin, draws the icon and title, and calls the `DrawThumbnail()` and `PrintMapInfo()` methods to display the map information. It also checks if buttons for canceling, creating a room, renaming the map, and deleting or saving the map should be displayed based on the current map and channel conditions. It handles button clicks and returns a boolean value indicating whether the dialog should be closed.\n\nIn summary, this code defines a dialog box that displays information about a map in the game. It allows users to view the map thumbnail, map details, and perform actions such as creating a room, renaming the map, and deleting or saving the map. This class is likely used in the larger project to provide a user interface for managing and interacting with maps in the game.\n## Questions: \n 1. What is the purpose of the `InitDialog` methods?\n- The `InitDialog` methods are used to initialize the `userMap` and `regMap` variables with the provided map information.\n\n2. What does the `CanMakeRoom` method check for?\n- The `CanMakeRoom` method checks if a room can be created based on certain conditions, such as if there is already a room, if there is a current channel, and if the map is downloaded.\n\n3. What is the purpose of the `DoDialog` method?\n- The `DoDialog` method handles the main functionality of the dialog, including drawing the UI elements, handling button clicks, and returning a boolean result.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\MapInfoDlg.md"}}],["297",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\MapIntroDlg.cs)\n\nThe code provided is a class called `MapIntroDlg` that extends the `Dialog` class. This class is responsible for displaying a dialog box that allows the user to introduce a map. \n\nThe `MapIntroDlg` class has several member variables. The `crdIntroArea` variable is a `Rect` object that defines the position and size of the text area where the user can input the map introduction. The `mapIntroduce` variable is a string that stores the user's input for the map introduction. The `maxIntroduceLength` variable is an integer that represents the maximum length of the map introduction. The `mapSeq` variable is an integer that stores the sequence number of the map.\n\nThe `Start` method is overridden from the `Dialog` class and sets the `id` of the dialog to `MAPINTRO`. The `OnPopup` method is also overridden and sets the size and position of the dialog box.\n\nThe `InitDialog` method takes an integer parameter `seq` and sets the `mapSeq` variable to that value.\n\nThe `DoDialog` method is the main method of the class and is responsible for rendering the dialog box and handling user input. It first sets the GUI skin to the skin obtained from `GUISkinFinder.Instance.GetGUISkin()`. It then renders the title of the dialog using the `LabelUtil.TextOut` method. Next, it renders a text area where the user can input the map introduction using the `GUI.TextArea` method. It also renders a label that displays the number of characters entered and the maximum allowed characters. \n\nThe method then renders two buttons, one for confirming the map introduction and one for closing the dialog. If the confirm button is clicked, the `introTemp` variable is set to the value of `mapIntroduce` and a network request is sent to change the map introduction using the `CSNetManager.Instance.Sock.SendCS_CHG_MAP_INTRO_REQ` method. If the close button is clicked or the escape key is pressed, the method returns `true` to indicate that the dialog should be closed.\n\nFinally, the method sets the GUI skin back to the original skin and checks if the dialog is a popup. If it is not a popup, it consumes the event using the `WindowUtil.EatEvent` method.\n\nIn the larger project, this code would be used to display a dialog box where the user can input a map introduction. The map introduction can then be saved and used in the game.\n## Questions: \n 1. What is the purpose of the `InitDialog` method and how is it used?\n- The `InitDialog` method is used to initialize the `mapSeq` variable with a given value. It is likely used to set the sequence number of the map for which the dialog is being displayed.\n\n2. What is the significance of the `mapIntroduce` variable and how is it used?\n- The `mapIntroduce` variable is a string that represents the introduction text for a map. It is used to store the text entered by the user in a text area GUI element.\n\n3. What is the purpose of the `DoDialog` method and what actions does it perform?\n- The `DoDialog` method is responsible for rendering and handling user interactions with the dialog. It displays various GUI elements, such as labels and buttons, and performs actions such as sending a network request to change the map introduction text. The method returns a boolean value indicating whether the dialog should be closed or not.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\MapIntroDlg.md"}}],["298",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\MapPriceChangeDlg.cs)\n\nThe code provided is a class called `MapPriceChangeDlg` that extends the `Dialog` class. This class represents a dialog box that allows the user to change the price of a map in the game. \n\nThe class contains several private variables that define the position and size of various UI elements within the dialog box. These variables include `crdOutline`, `crdCurPrice`, `crdCurPrice2`, `crdChangePrice`, `crdChangePriceFld`, and `crdPriceExp`. \n\nThe class also has several other variables such as `strPrice`, `maxPriceLength`, `mapSeq`, and `mapPrice` that are used to store and manipulate data related to the map price.\n\nThe `Start()` method sets the `id` of the dialog box to a specific value from the `DialogManager` class.\n\nThe `OnPopup()` method sets the size and position of the dialog box based on the screen size.\n\nThe `InitDialog()` method is used to initialize the dialog box with the map sequence and price.\n\nThe `DoDialog()` method is the main method that is called to display and handle user interactions with the dialog box. It first sets the GUI skin to a specific skin obtained from the `GUISkinFinder` class. It then uses the `LabelUtil` class to display various text labels on the dialog box.\n\nThe method also includes a text field where the user can enter a new price for the map. The entered price is validated and manipulated using regular expressions and string manipulation methods. The entered price is then parsed into an integer and checked for validity. If the price is valid, it is stored in the `strPrice` variable and sent to the server using the `CSNetManager` class.\n\nThe method also includes two buttons, one for confirming the price change and one for closing the dialog box.\n\nOverall, this class represents a dialog box that allows the user to change the price of a map in the game. It handles user input, validates and manipulates the entered price, and sends the new price to the server.\n## Questions: \n 1. What is the purpose of the `InitDialog` method and how is it used?\n- The `InitDialog` method is used to initialize the `mapSeq` and `mapPrice` variables. It is likely used to set the initial values for the map sequence and price before displaying the dialog.\n\n2. What is the purpose of the `DoDialog` method and what does it return?\n- The `DoDialog` method is responsible for rendering and handling user interactions with the dialog. It returns a boolean value indicating whether the dialog should be closed or not.\n\n3. What is the purpose of the `mapSeq` and `mapPrice` variables?\n- The `mapSeq` variable is used to store the sequence number of the map, while the `mapPrice` variable is used to store the current price of the map. These variables are likely used in the rendering and handling of the dialog.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\MapPriceChangeDlg.md"}}],["299",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\MarkDialog.cs)\n\nThe code provided is a class called \"MarkDialog\" that extends the \"Dialog\" class. This class is used to create a dialog box for changing a clan mark in the larger Brick-Force project. \n\nThe class contains various Rect variables that define the positions and sizes of different elements within the dialog box. These elements include the icon, comment box, main tab, backgrounds, frames, amblums, and the clan mark itself. \n\nThe class also contains variables to keep track of the current selected options for the backgrounds, frames, amblums, and the clan mark. These variables are used to update the clan mark when the user makes a selection. \n\nThe class has several methods that are responsible for rendering different elements of the dialog box. These methods include \"DoTitle\", \"DoComment\", \"DoMainTab\", \"DoBackgrounds\", \"DoFrames\", \"DoAmblums\", and \"DoClanMark\". These methods use the Rect variables to position and size the elements correctly. \n\nThe \"DoDialog\" method is the main method of the class that is responsible for rendering the entire dialog box and handling user interactions. It uses the other methods to render the different elements of the dialog box and updates the clan mark when the user makes a selection. \n\nOverall, this class is used to create a dialog box that allows the user to change the clan mark in the Brick-Force project. It provides a visual interface for selecting different backgrounds, frames, and amblums, and updates the clan mark accordingly.\n## Questions: \n 1. What is the purpose of the `MarkDialog` class?\n- The `MarkDialog` class is a subclass of the `Dialog` class and represents a dialog box for changing a mark in the game.\n2. What are the different elements that can be selected in the dialog box?\n- The dialog box has three main tabs: \"CLAN_MARK_BG\", \"CLAN_MARK_COLOR\", and \"CLAN_MARK_AMBLUM\". Each tab represents a different element that can be selected: backgrounds, frames, and amblums respectively.\n3. How is the selected mark value updated and used?\n- The selected mark value is stored in the `curMark` variable and is used to determine which mark to display in the `DoClanMark` method. It is also used to send a change mark request to the server when the \"OK\" button is clicked.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\MarkDialog.md"}}],["300",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\MatchEnder.cs)\n\nThe `MatchEnder` class in the Brick-Force project is responsible for handling the end of a match and displaying the appropriate UI elements and images. \n\nThe class has several public variables that can be set in the Unity editor or through code. The `guiDepth` variable determines the depth of the GUI elements, the `wait` variable determines the amount of time to wait before loading the next level, and the `loadLevel` variable determines the name of the level to load after the match ends. The `endImage` variable is an array of Texture2D objects that represent the images to be displayed at the end of the match.\n\nThe class also has private variables such as `ending` and `deltaTime`. The `ending` variable keeps track of the current ending state of the match, while the `deltaTime` variable is used to measure the time elapsed since the match ended.\n\nThe `IsOverAll` property returns a boolean value indicating whether the match has ended or not.\n\nThe `OnMatchEnd` method is called when the match ends and takes a `code` parameter. It updates the `ending` variable based on the value of the `code` parameter and plays the appropriate audio based on the ending state. It also clears the vote and sets all player statuses to waiting.\n\nThe `OnGUI` method is responsible for displaying the end image on the screen. It checks if the GUI is enabled and if the match has ended. If both conditions are met, it sets the GUI skin, depth, and enables GUI interaction. It then draws the end image at the center of the screen using the `TextureUtil.DrawTexture` method.\n\nThe `Update` method is called every frame and checks if the match has ended and if the level is not currently being loaded. If both conditions are met, it increments the `deltaTime` variable by the time since the last frame. If the `deltaTime` exceeds the `wait` time and the game is not being shut down, it loads the next level specified by the `loadLevel` variable using the `Application.LoadLevel` method.\n\nOverall, the `MatchEnder` class provides functionality for handling the end of a match, displaying end images, and loading the next level. It is an important component in the larger Brick-Force project as it contributes to the overall gameplay experience and progression.\n## Questions: \n 1. What is the purpose of the `MatchEnder` class?\n- The `MatchEnder` class is responsible for handling the end of a match and displaying the appropriate end image.\n\n2. What is the significance of the `ending` variable?\n- The `ending` variable is used to determine the outcome of the match. It is set based on the `code` parameter passed to the `OnMatchEnd` method.\n\n3. What is the purpose of the `OnGUI` method?\n- The `OnGUI` method is responsible for displaying the end image on the screen if the GUI is enabled and the match has ended.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\MatchEnder.md"}}],["301",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\MatchStarter.cs)\n\nThe `MatchStarter` class is responsible for managing the countdown and starting of a match in the Brick-Force project. It is a MonoBehaviour script in Unity, which means it can be attached to a game object in the scene and its methods will be automatically called by the engine.\n\nThe class has several fields and properties:\n- `guiDepth` is an enum that represents the depth of the GUI elements in the scene.\n- `countDigit` is an array of Texture2D objects that represent the digits used for the countdown.\n- `countDown` is a boolean flag that indicates whether the countdown is currently active.\n- `count` is an integer that represents the current count in the countdown.\n- `deltaTime` is a float that keeps track of the time elapsed since the last count change.\n- `waitBoxWidth` and `waitBoxHeight` are floats that determine the size of a GUI box used to display a waiting message.\n\nThe `Start` method is called when the script is first initialized. It sets the initial value of `count` to 0, and if the player is in the process of breaking into a room (`MyInfoManager.Instance.BreakingInto` is true), it sets `count` to the length of the `countDigit` array.\n\nThe `OnMatchCountDown` method is called when the server sends a match countdown event. It updates the `count` variable, sets the `countDown` flag based on whether the count is less than the length of the `countDigit` array, resets the `deltaTime` variable, and plays specific audio based on the count value.\n\nThe `OnGUI` method is responsible for rendering the GUI elements on the screen. It checks if the GUI is enabled (`MyInfoManager.Instance.isGuiOn` is true) and if the count is within the valid range of the `countDigit` array. If so, it sets the GUI skin, depth, and enables GUI interaction. It then checks if any BrickMan objects in the scene have a status of 2 or 3, and if so, it displays a waiting message in a GUI box. Otherwise, it displays the current count digit as a texture in the center of the screen.\n\nThe `Update` method is called every frame. It first checks if the local player is the master of the room (`RoomManager.Instance.Master == MyInfoManager.Instance.Seq`). If so, it checks if the countdown is active. If it is, it updates the `deltaTime` variable and increments the `count` every second. If the count reaches the length of the `countDigit` array, it stops the countdown, plays specific audio, and sends a network message to the server. If the count reaches the second-to-last digit, it also sends a network message to resume the room. If the countdown is not active and the count is less than or equal to 0, it checks if all BrickMan objects in the scene have a status of 2 or 3. If they do, it starts the countdown, plays specific audio, and sends a network message. If the local player is not the master and the count is at the second-to-last digit, it plays specific audio and stops the countdown.\n\nIn summary, the `MatchStarter` class manages the countdown and starting of a match in the Brick-Force project. It handles updating the count, displaying the countdown digits, playing audio, and sending network messages to synchronize the countdown across clients.\n## Questions: \n 1. What is the purpose of the `MatchStarter` class?\n- The `MatchStarter` class is responsible for managing the countdown and GUI display for starting a match in the game.\n\n2. What is the significance of the `countDigit` array?\n- The `countDigit` array contains a collection of textures representing the digits used for the countdown display.\n\n3. What triggers the countdown to start and stop?\n- The countdown starts when the `OnMatchCountDown` method is called with a non-zero count, and it stops when the count reaches the length of the `countDigit` array or when certain conditions are met in the `Update` method.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\MatchStarter.md"}}],["302",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Memo.cs)\n\nThe code provided is a class called `Memo` that represents a memo or message. It contains various properties and methods to store and manipulate memo data.\n\nThe class has several public properties, including `seq`, `sender`, `title`, `contents`, `attached`, `option`, and `check`. These properties store information about the memo, such as its sequence number, sender, title, contents, attachments, and options. The `check` property is a boolean value that can be used to mark the memo as checked or unchecked.\n\nThe class also has private properties, including `year`, `month`, `day`, `isRead`, and `sysFlag`. These properties store additional information about the memo, such as the date it was sent, whether it has been read, and system flags.\n\nThe class provides getter and setter methods for some of the properties. For example, the `IsRead` property is a boolean property that returns `true` if the memo has been read (i.e., `isRead` is equal to 1) and `false` otherwise. The `SysFlag` property allows getting and setting the system flag value.\n\nThe class also provides a `SendDate` property that returns a formatted string representation of the memo's send date, using the `year`, `month`, and `day` properties.\n\nThe class has a constructor that takes multiple parameters to initialize the memo object. These parameters include the sequence number, sender, title, contents, attachments, options, year, month, day, read status, and system flag.\n\nThe class provides two additional methods, `needReply()` and `needStringKey()`. The `needReply()` method checks if the memo requires a reply based on the system flag value. It returns `true` if the system flag does not have the second bit set (i.e., `(sysFlag & 2) == 0`) and `false` otherwise. The `needStringKey()` method checks if the memo requires a string key based on the system flag value. It returns `true` if the system flag has the first bit set (i.e., `(sysFlag & 1) != 0`) and `false` otherwise.\n\nOverall, this `Memo` class provides a data structure and methods to represent and manipulate memo objects within the larger Brick-Force project. It allows storing and retrieving memo information, checking memo properties, and performing operations based on the memo's system flag.\n## Questions: \n 1. What is the purpose of the `Memo` class?\n- The `Memo` class is used to represent a memo object, which contains various properties such as sender, title, contents, and attached files.\n\n2. What is the significance of the `isRead` property?\n- The `isRead` property is used to determine whether a memo has been read or not. It is represented as a `sbyte` value, where 1 indicates that the memo has been read and 0 indicates that it has not been read.\n\n3. What is the purpose of the `needReply()` and `needStringKey()` methods?\n- The `needReply()` method is used to determine whether a memo needs a reply or not, based on the value of the `sysFlag` property. The `needStringKey()` method is used to determine whether a memo needs a string key or not, also based on the value of the `sysFlag` property.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Memo.md"}}],["303",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\MemoManager.cs)\n\nThe `MemoManager` class is a singleton class that manages a collection of `Memo` objects. It provides methods to add, remove, and retrieve `Memo` objects from the collection. The purpose of this class is to provide a centralized location for managing and accessing `Memo` objects throughout the project.\n\nThe class has a private dictionary variable `dic` that stores `Memo` objects with a unique identifier (`long`) as the key. The `ToArray` method returns an array of all the `Memo` objects in the dictionary. The method iterates over the dictionary and adds each `Memo` object to a list. It then reverses the order of the list and converts it to an array before returning it.\n\nThe `GetOption` method takes a `long` parameter `seq` and returns the `option` value of the `Memo` object with the corresponding key in the dictionary. If the key is not found in the dictionary, it returns -1.\n\nThe `ClearPresent` method takes a `long` parameter `seq` and clears the `attached`, `option`, and `check` properties of the `Memo` object with the corresponding key in the dictionary.\n\nThe `Clear` method clears the dictionary by calling the `Clear` method on the dictionary object.\n\nThe `Add` method takes a `long` parameter `seq` and a `Memo` object `memo` and adds the `memo` object to the dictionary with the `seq` as the key. If the key already exists in the dictionary, it does not add the `memo` object.\n\nThe `Del` method takes a `long` parameter `seq` and removes the `Memo` object with the corresponding key from the dictionary.\n\nThe `HaveUnreadMemo` method checks if there are any `Memo` objects in the dictionary that have not been read. It iterates over the dictionary and returns `true` if it finds any unread `Memo` objects, otherwise it returns `false`.\n\nThe `GetUnreadMemoCount` method returns the count of unread `Memo` objects in the dictionary. It iterates over the dictionary and increments a counter for each unread `Memo` object.\n\nThe `GetMemoCountPercent` method returns the count of `Memo` objects in the dictionary as a percentage. If the dictionary is null, it returns 0.\n\nOverall, the `MemoManager` class provides a centralized way to manage and access `Memo` objects in the larger project. It allows for adding, removing, and retrieving `Memo` objects, as well as checking for unread `Memo` objects and getting the count of `Memo` objects in the dictionary.\n## Questions: \n 1. What is the purpose of the `MemoManager` class?\n- The `MemoManager` class is responsible for managing a collection of `Memo` objects.\n\n2. What is the significance of the `Instance` property?\n- The `Instance` property provides a way to access the singleton instance of the `MemoManager` class.\n\n3. What does the `ToArray` method do?\n- The `ToArray` method converts the collection of `Memo` objects into an array and returns it.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\MemoManager.md"}}],["304",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\MenuEx.cs)\n\nThe code provided is a class called `MenuEx` that extends the `Dialog` class. This class is used to create a menu dialog in the Brick-Force project. The purpose of this code is to handle the functionality and behavior of the menu dialog, including its size, buttons, and actions.\n\nThe `MenuEx` class has several member variables, including a `RenderTexture` called `thumbnail`, a `UserMapInfo` called `umi`, and a boolean called `copyRight`. The `thumbnail` variable is used to store a render texture, while the `umi` variable is used to store information about the user's map. The `copyRight` variable is a flag that determines whether the menu dialog should display certain buttons and options.\n\nThe class has several methods that are used to handle the behavior of the menu dialog. The `Start` method sets the `id` of the dialog to a specific value. The `OnPopup` method is called when the dialog is shown and recalculates the size of the dialog based on certain conditions. The `DoDialog` method is the main method that handles the rendering and functionality of the menu dialog. It checks for button clicks and performs actions based on the button clicked.\n\nThe `InitDialog` method initializes the dialog and checks if the escape key is pressed. The `IsTutorial` method checks if the current level is a tutorial level. The `GetCopyRight` method checks if the current room is a map editor room and if the user has the rights to edit the map. The `_BackConfirmDialog` and `_ExitConfirmDialog` methods are used to show confirmation dialogs when the user tries to go back or exit the room. The `_SelfRespawnDialog` method shows a confirmation dialog when the user tries to respawn themselves. The `ThumbnailToPNG` method converts the thumbnail render texture to a PNG byte array.\n\nThe `IsShowBanishMenu`, `IsShowAccusationMenu`, and `IsShowAccusationMapMenu` methods are used to determine whether certain buttons and options should be shown in the menu dialog based on various conditions.\n\nOverall, this code provides the functionality for the menu dialog in the Brick-Force project, allowing users to perform actions such as changing settings, reporting players, saving maps, and exiting the room or game.\n## Questions: \n 1. What is the purpose of the `RecalcSize()` method?\n- The `RecalcSize()` method is used to calculate and set the size of the dialog window based on certain conditions and variables.\n\n2. What is the significance of the `copyRight` variable?\n- The `copyRight` variable is used to determine whether the dialog window should display certain buttons and options related to saving and registering user-created maps.\n\n3. What is the purpose of the `ThumbnailToPNG()` method?\n- The `ThumbnailToPNG()` method is used to convert the `thumbnail` render texture into a PNG byte array, which can then be used for saving the thumbnail image.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\MenuEx.md"}}],["305",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\MessageBoxMgr.cs)\n\nThe `MessageBoxMgr` class is responsible for managing message boxes in the Brick-Force project. It provides methods to add, delete, and retrieve message boxes, as well as check for the presence of message boxes.\n\nThe class has a private list variable `msgBoxes` to store the message boxes. It also has a private static variable `_instance` to hold the instance of the `MessageBoxMgr` class.\n\nThe class has a public static property `Instance` that allows access to the instance of the `MessageBoxMgr` class. It uses a singleton pattern to ensure that only one instance of the class is created. If the `_instance` variable is null, it tries to find an existing instance of the `MessageBoxMgr` class using `Object.FindObjectOfType`. If no instance is found, it logs an error message. The `Instance` property is used to access the methods and properties of the `MessageBoxMgr` class throughout the project.\n\nThe `Awake` method initializes the `msgBoxes` list and ensures that the `MessageBoxMgr` object is not destroyed when a new scene is loaded using `Object.DontDestroyOnLoad`.\n\nThe `OnApplicationQuit` method sets the `_instance` variable to null when the application is quitting.\n\nThe `Update` method checks if the `openForcePointChargeDlg` flag is true. If it is, it retrieves a `Good` object from the `ShopManager` using a code string \"s80\". If the `Good` object is not found, it logs an error message. Otherwise, it initializes a `BuyTermDialog` dialog with the retrieved `Good` object using the `InitDialog` method. Finally, it sets the `openForcePointChargeDlg` flag to false.\n\nThe class provides several methods to manipulate the message boxes. The `GetNextItem` method returns the next message box in the list based on the given message box. The `HasNextItem` method checks if there is a next message box after the given message box. The `GetPrevItem` method returns the previous message box in the list based on the given message box. The `HasPrevItem` method checks if there is a previous message box before the given message box. The `DelMessage` method removes a message box from the list. The `HasMsg` method checks if there are any message boxes in the list. The `Clear` method clears all the message boxes from the list.\n\nThe class also provides methods to add different types of message boxes. The `AddMessage` method adds a warning type message box to the list. The `AddSelectMessage` method adds a select type message box to the list. The `AddForcePointChargeMessage` method adds a force point charge type message box to the list. The `AddQuitMesssge` method adds a quit type message box to the list. These methods create a new `MsgBox` object with the given message and add it to the `msgBoxes` list. They also initialize a `MsgBoxDialog` dialog with the created `MsgBox` object using the `InitDialog` method.\n\nOverall, the `MessageBoxMgr` class provides functionality to manage message boxes in the Brick-Force project. It allows adding, deleting, and retrieving message boxes, as well as checking for the presence of message boxes. It also handles the display of different types of message boxes using dialogs.\n## Questions: \n 1. What is the purpose of the `MessageBoxMgr` class?\n- The `MessageBoxMgr` class manages a list of message boxes and provides methods for adding, removing, and accessing message boxes.\n\n2. What is the significance of the `openForcePointChargeDlg` variable?\n- The `openForcePointChargeDlg` variable is a boolean flag that determines whether a force point charge dialog should be opened. If it is true, the code in the `Update()` method will execute.\n\n3. What is the purpose of the `AddQuitMesssge()` method?\n- The `AddQuitMesssge()` method adds a message box of type \"QUIT\" to the list of message boxes, clears the existing message boxes, and displays the new message box using the `MsgBoxDialog` class.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\MessageBoxMgr.md"}}],["306",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Messenger.cs)\n\nThe code provided is a class called \"Messenger\" that is used in the larger Brick-Force project. The purpose of this class is to handle the messaging functionality within the game. It manages the display of different chat channels, such as the main channel, friend channel, and clan channel.\n\nThe class has several member variables that store information about the chat interface, such as the background texture, the list of tab keys, the currently selected tab, and the scroll positions for each channel. It also has variables for storing the positions and sizes of various UI elements within the chat interface.\n\nThe class has a property called \"IsBriefing\" which can be used to set whether the chat interface is in briefing mode or not. When briefing mode is enabled, the position and size of the chat interface elements are adjusted to make room for a briefing popup.\n\nThe class has several methods for updating and rendering the chat interface. The \"Start\" method is empty and does not have any functionality. The \"UpdateChannelTab\" method updates the tab labels by retrieving them from a string manager.\n\nThe \"ToggleLeftTop\" method adjusts the positions of the chat interface elements based on whether briefing mode is enabled or not. If briefing mode is enabled, the positions are shifted to make room for the popup. If briefing mode is disabled, the positions are reset to their original values.\n\nThe \"Update\" method is called every frame and is responsible for updating the chat interface. It increments a timer variable and if the timer exceeds one second, it sends a request to the server to check for new messages. It also refreshes the list of users in the current channel.\n\nThe \"ChangeHeight\" method adjusts the height of the chat interface by modifying the position and height of the frame element. The height change is specified as a parameter to the method.\n\nThe \"OnGUI\" method is responsible for rendering the chat interface. It first renders the frame element using a GUI box. It then updates the tab labels and renders the selected tab using a selection grid. Depending on the selected tab, it retrieves the list of users for that channel and renders them using a scroll view. Each user is rendered with their badge, nickname, and a context menu that appears when right-clicked.\n\nOverall, this class provides the functionality for managing and displaying the chat interface in the Brick-Force game. It handles updating the chat tabs, retrieving and rendering the list of users for each channel, and handling user interactions such as right-clicking on a user to open a context menu.\n## Questions: \n 1. What is the purpose of the `Messenger` class?\n- The `Messenger` class is responsible for managing the messaging functionality in the game, including displaying chat channels and user lists.\n\n2. What does the `ToggleLeftTop()` method do?\n- The `ToggleLeftTop()` method adjusts the position of the chat window and user list based on whether the chat window is in briefing mode or not.\n\n3. What is the purpose of the `aPlayer()` method?\n- The `aPlayer()` method is responsible for displaying a player's information, including their badge, nickname, and options for interacting with the player.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Messenger.md"}}],["307",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\MIRROR_TYPE.cs)\n\nThe code provided is an enumeration called `MIRROR_TYPE`. An enumeration is a set of named values that represent a set of possible options or choices. In this case, the `MIRROR_TYPE` enumeration has two values: `BASE` and `SIMPLE`.\n\nThe purpose of this enumeration is to define the different types of mirrors that can be used in the larger Brick-Force project. Mirrors are objects that reflect or bounce off light or other objects. By defining the different types of mirrors as an enumeration, it allows for easy categorization and selection of the appropriate mirror type in the project.\n\nFor example, in the larger Brick-Force project, there may be a scenario where the user needs to select a mirror type. The `MIRROR_TYPE` enumeration can be used to present the available options to the user and allow them to make a selection. The selected mirror type can then be used in the project to determine the behavior or properties of the mirror.\n\nHere is an example of how the `MIRROR_TYPE` enumeration can be used in code:\n\n```java\nMIRROR_TYPE mirrorType = MIRROR_TYPE.SIMPLE;\n\nif (mirrorType == MIRROR_TYPE.BASE) {\n    // Do something for base mirror type\n} else if (mirrorType == MIRROR_TYPE.SIMPLE) {\n    // Do something for simple mirror type\n}\n```\n\nIn this example, the `mirrorType` variable is assigned the value `MIRROR_TYPE.SIMPLE`. The code then checks the value of `mirrorType` and performs different actions based on the selected mirror type.\n\nOverall, the `MIRROR_TYPE` enumeration provides a way to define and manage the different types of mirrors in the Brick-Force project. It allows for easy selection and categorization of mirror types, making it easier to work with mirrors in the larger project.\n## Questions: \n 1. What is the purpose of the `MIRROR_TYPE` enum?\n- The `MIRROR_TYPE` enum is used to define different types of mirrors, such as `BASE` and `SIMPLE`.\n\n2. Are there any other values that can be added to the `MIRROR_TYPE` enum?\n- No, the `MIRROR_TYPE` enum only has two values: `BASE` and `SIMPLE`.\n\n3. How is the `MIRROR_TYPE` enum used in the rest of the codebase?\n- Without further context, it is unclear how the `MIRROR_TYPE` enum is used in the rest of the codebase.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\MIRROR_TYPE.md"}}],["308",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Mission.cs)\n\nThe code provided is a class called \"Mission\" that represents a mission or task in a game. It contains various properties and methods to manage and track the progress of the mission.\n\nThe class has several private fields, including \"index\" (an integer representing the mission's index), \"description\" (a string describing the mission), \"goal\" (an integer representing the target goal for the mission), \"atleast\" (an integer representing a minimum requirement for the mission), \"progress\" (an integer representing the current progress of the mission), and \"complete\" (a boolean indicating whether the mission is complete or not).\n\nThe class also has several public properties and methods to access and modify the mission's properties. \n\nThe \"Description\" property returns a formatted string that includes the mission's description and goal. If the \"atleast\" field is greater than 0, it appends a string indicating the minimum requirement for the mission.\n\nThe \"MiniDescription\" property returns a formatted string that includes only the mission's description and goal.\n\nThe \"ProgressString\" property returns a string indicating the progress of the mission. If the mission is complete, it returns a string indicating that the mission is complete. Otherwise, it returns a string showing the current progress and the goal.\n\nThe \"Progress\" property returns a float value representing the progress of the mission as a percentage. If the mission is complete or the progress is equal to or greater than the goal, it returns 1. Otherwise, it returns the ratio of the progress to the goal.\n\nThe \"CanComplete\" property returns a boolean indicating whether the mission can be completed. It returns true if the progress is equal to or greater than the goal and the mission is not already complete.\n\nThe \"Completed\" property returns a boolean indicating whether the mission is completed. It returns true if the progress is equal to or greater than the goal and the mission is already complete.\n\nThe class also has a constructor that takes in parameters to initialize the mission's properties. It also has several methods to modify the mission's progress and completion status. The \"Complete\" method sets the mission as complete. The \"SetMission\" method allows setting the progress and completion status of the mission. The \"SetProgress\" method allows setting only the progress of the mission.\n\nOverall, this class provides a way to create and manage missions in a game, including tracking progress, checking completion status, and updating the mission's properties. It can be used in the larger project to handle mission-related logic and provide information to the player about their progress in completing missions.\n## Questions: \n 1. **What is the purpose of the Mission class?**\nThe Mission class represents a mission in the game and stores information such as the mission index, description, goal, progress, and completion status.\n\n2. **What is the significance of the \"atleast\" variable?**\nThe \"atleast\" variable represents a secondary condition for the mission. It is used to specify an additional requirement that needs to be met in order to complete the mission.\n\n3. **What is the purpose of the Complete() method?**\nThe Complete() method is used to mark the mission as complete by setting the \"complete\" variable to true.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Mission.md"}}],["309",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\MissionDialog.cs)\n\nThe code provided is a class called \"MissionDialog\" that extends another class called \"Dialog\". This class is used to display a mission dialog in the game. \n\nThe \"MissionDialog\" class has several member variables that are used to store various textures, audio clips, and rectangles that define the positions and sizes of different UI elements in the dialog. These variables are used to display the mission dialog with the appropriate textures and positions.\n\nThe class also has several arrays and variables that store information about the mission rewards, such as whether they are points or coins, and the count of each reward. These variables are used to display the rewards in the dialog.\n\nThe class has several methods that are used to initialize and update the dialog, as well as handle user interactions with the dialog. The \"Start\" method is called when the dialog is first created and is used to set the ID of the dialog. The \"OnPopup\" method is called when the dialog is opened and is used to set the position of the dialog on the screen. The \"OnClose\" method is called when the dialog is closed and can be used to perform any necessary cleanup.\n\nThe \"Update\" method is called every frame and is used to update the stamp effects in the dialog. The \"InitDialog\" method is used to initialize the stamp effects for the completed missions. The \"Complete\" method is used to mark a certain number of missions as completed and start the stamp effects for those missions. The \"StampFxing\" method is used to check if any stamp effects are currently playing.\n\nThe \"DoDialog\" method is the main method that is called to display and handle user interactions with the dialog. It first sets the GUI skin to the appropriate skin for the dialog. It then calls several other methods to display different UI elements of the dialog, such as the title, incoming message, brick king, mission, and compensation. It also handles button clicks for accepting, completing, and giving up on missions.\n\nOverall, this code is responsible for displaying and handling user interactions with the mission dialog in the game. It uses various textures, audio clips, and UI elements to create an interactive and visually appealing dialog for the player.\n## Questions: \n 1. What is the purpose of the `Stamp` class and how is it used in the code?\n- The smart developer might ask about the purpose of the `Stamp` class and how it is used in the code. The `Stamp` class is used to handle the stamp animation for completing missions. It is used to track the progress and state of the stamp animation for each mission.\n\n2. How are the mission rewards determined and displayed in the UI?\n- The smart developer might ask how the mission rewards are determined and displayed in the UI. The mission rewards are determined based on the `rewardIsPoint` and `rewardCount` arrays. If `rewardIsPoint` is true for a specific mission and target, a point icon is displayed, otherwise a coin icon is displayed. The reward count is then displayed next to the icon.\n\n3. How is the progress of each mission displayed in the UI?\n- The smart developer might ask how the progress of each mission is displayed in the UI. The progress of each mission is displayed using a gauge bar. The width of the gauge bar is determined by the `Progress` property of each mission, and the progress string is displayed in the center of the gauge bar.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\MissionDialog.md"}}],["310",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\MissionLoadManager.cs)\n\nThe `MissionLoadManager` class is responsible for loading mission reward data from either a local file system or a web server. It also provides methods to change the reward values for specific missions.\n\nThe class has several private fields that store information about the rewards for each mission. These fields include arrays for storing whether each reward is in points or not (`reward1IsPoints`, `reward2IsPoints`, `reward3IsPoints`), and arrays for storing the counts of each reward (`reward1Counts`, `reward2Counts`, `reward3Counts`).\n\nThe class also has several public properties that allow access to these private fields.\n\nThe `Awake` method is called when the object is initialized and ensures that the object is not destroyed when a new scene is loaded.\n\nThe `Load` method is responsible for loading the mission reward data. It first checks if the game is running in a web player or not. If it is, it starts a coroutine called `LoadFromWWW` which loads the data from a web server. If it is not a web player, it calls the `LoadFromLocalFileSystem` method to load the data from a local file system.\n\nThe `LoadFromWWW` method uses the `WWW` class to download the mission reward data from a specified URL. It then uses a `MemoryStream` and a `BinaryReader` to read the downloaded data. The data is then parsed using a `CSVLoader` class, and the parsed values are stored in the appropriate fields.\n\nThe `LoadFromLocalFileSystem` method checks if the necessary directory for the resource files exists. If it does, it constructs the path to the mission reward file and uses the `CSVLoader` class to load and parse the data.\n\nThe `Parse` method takes a `CSVLoader` object as a parameter and uses it to parse the mission reward data. It iterates over each row in the data and extracts the values for each reward. The extracted values are then stored in the appropriate fields.\n\nThe `ChangeReward` method allows for changing the reward values for a specific mission. It takes three parameters: `step` (the mission step), `forcePoint` (the force point value), and `freeCoin` (the free coin value). It first checks if the target mission index is within the range of the reward arrays. If it is, it updates the corresponding reward values based on the provided parameters.\n\nOverall, the `MissionLoadManager` class is responsible for loading and managing the mission reward data for the game. It provides methods to load the data from either a local file system or a web server, and allows for changing the reward values for specific missions.\n## Questions: \n 1. What is the purpose of the `MissionLoadManager` class?\n- The `MissionLoadManager` class is responsible for loading mission reward data from either a web server or the local file system.\n\n2. How does the `MissionLoadManager` class handle loading mission reward data from a web server?\n- The `LoadFromWWW` method uses a `WWW` object to download the mission reward data from a specified URL and then parses the data using a `CSVLoader` object.\n\n3. How does the `MissionLoadManager` class handle loading mission reward data from the local file system?\n- The `LoadFromLocalFileSystem` method checks if the necessary directory and file exist, and if so, it loads the data using a `CSVLoader` object. If the data is not found or fails to load, it logs an error message.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\MissionLoadManager.md"}}],["311",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\MissionLog.cs)\n\nThe `MissionLog` class is a script that is used to display mission logs in the game. It is a part of the larger Brick-Force project. \n\nThe purpose of this code is to handle the display of mission logs, including the progress, title, subtitle, and text of the mission. It also handles the display of weapon icons and their corresponding names and explanations. \n\nThe class has several private variables, including `progress`, `title`, `sub`, `text`, `fmtType`, `guiDepth`, `missionBg`, `wpnicons`, `iconidx`, `titley`, `titleh`, `suby`, `subh`, `drawWeaponIcon`, `wpnNames`, and `wpnEXpls`. These variables store the necessary information for displaying the mission logs.\n\nThe `SetMission` method is used to set the mission details, including the progress, title, subtitle, and text. It also determines the `fmtType` based on the `fmt` parameter. The `fmtType` is used to determine the format of the text displayed in the mission log.\n\nThe `needPicture` method is used to indicate that a weapon icon needs to be displayed. It sets the `drawWeaponIcon` variable to true and increments the `iconidx` variable.\n\nThe `Start` method is called when the script starts and initializes some variables.\n\nThe `calcTitleBoxHeight` method calculates the height of the title box based on the length of the title and subtitle. It uses the `CalcHeight` method of the `GUIStyle` class to determine the height of the text.\n\nThe `checkStringFormat` method checks the `fmtType` and formats the `text` variable accordingly. It uses the `string.Format` method to replace placeholders in the text with the corresponding input keys.\n\nThe `OnGUI` method is called every frame to handle the GUI rendering. It sets the GUI skin and depth, and enables GUI interaction if there are no modal dialogs. It then calculates the height of the title box and displays the mission log elements, including the progress, title, subtitle, and text. If a weapon icon needs to be displayed, it also displays the icon, name, and explanation.\n\nIn summary, this code is responsible for displaying mission logs in the game. It sets the mission details, formats the text based on the mission type, and renders the mission log elements on the screen. It also handles the display of weapon icons and their corresponding names and explanations.\n## Questions: \n 1. What is the purpose of the `SetMission` method and how is it used?\n- The `SetMission` method is used to set the values of the `progress`, `title`, `sub`, `text`, and `drawWeaponIcon` variables. It is likely used to update the mission information displayed in the UI.\n\n2. What is the purpose of the `needPicture` method and when is it called?\n- The `needPicture` method is called to indicate that a weapon icon should be drawn in the UI. It sets the `drawWeaponIcon` variable to true and increments the `iconidx` variable.\n\n3. What is the purpose of the `checkStringFormat` method and when is it called?\n- The `checkStringFormat` method is called to format the `text` variable based on the value of the `fmtType` variable. It uses custom_inputs.Instance.InputKey to replace placeholders in the `text` string with corresponding key values.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\MissionLog.md"}}],["312",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\MissionManager.cs)\n\nThe `MissionManager` class is a component in the Brick-Force project that manages missions for the player. It keeps track of a dictionary of missions, where each mission is represented by an instance of the `Mission` class. The `MissionManager` class provides methods to update and manipulate the missions.\n\nThe `MissionManager` class has several properties and methods that are used to interact with the missions. \n\nThe `HaveMission` property returns a boolean value indicating whether there are any missions currently active. It checks if the count of missions in the `dicMission` dictionary is greater than zero.\n\nThe `CanReceiveMission` property returns a boolean value indicating whether the player can receive a new mission. It checks if the `wait` variable is less than zero and the count of missions in the `dicMission` dictionary is less than or equal to zero.\n\nThe `CanCompleteMission` property returns a boolean value indicating whether there are any missions that can be completed. It iterates through each mission in the `dicMission` dictionary and checks if the `CanComplete` property of the mission is true.\n\nThe `Instance` property is a singleton implementation that returns the instance of the `MissionManager` class. It ensures that there is only one instance of the `MissionManager` class in the project.\n\nThe `Awake` method initializes the `dicMission` dictionary and ensures that the `MissionManager` object is not destroyed when a new scene is loaded.\n\nThe `Start` method initializes the `wait` variable to -1 and the `deltaTime` variable to 0.\n\nThe `Update` method is called every frame and updates the `deltaTime` variable. If the `deltaTime` is greater than 1 second, it decreases the `wait` variable by 1 if it is greater than or equal to 0.\n\nThe `Progress` method updates the progress of a specific mission. It takes in the mission index and the progress value and sets the progress of the corresponding mission in the `dicMission` dictionary.\n\nThe `UpdateAlways` method updates the progress and completion status of a mission. If the mission already exists in the `dicMission` dictionary, it updates the progress and completion status of the mission. If the mission does not exist, it creates a new mission and adds it to the `dicMission` dictionary.\n\nThe `SetMissionWait` method sets the `wait` variable to a specified value.\n\nThe `Del` method removes a mission from the `dicMission` dictionary based on its index.\n\nThe `Clear` method clears all missions from the `dicMission` dictionary.\n\nThe `CompletedCount` method returns the number of completed missions in the `dicMission` dictionary.\n\nThe `ToArray` method converts the missions in the `dicMission` dictionary to an array and returns it. The missions are sorted by their index using a `SortedList` before being converted to an array.\n\nThe `Complete` method completes missions based on a specified count. If the count is greater than or equal to 3, it clears all missions. Otherwise, it completes missions that can be completed.\n\nOverall, the `MissionManager` class provides functionality to manage missions in the Brick-Force project. It allows for the creation, updating, and completion of missions, as well as providing information about the current state of the missions.\n## Questions: \n 1. **What is the purpose of the MissionManager class?**\nThe MissionManager class is responsible for managing missions in the game. It keeps track of active missions, their progress, and allows for completing missions.\n\n2. **What is the significance of the `wait` variable?**\nThe `wait` variable is used to determine if the MissionManager can receive new missions. If `wait` is less than 0, it means that the MissionManager can receive new missions. If `wait` is greater than or equal to 0, it means that the MissionManager is currently waiting and cannot receive new missions.\n\n3. **What is the purpose of the `UpdateAlways` method?**\nThe `UpdateAlways` method is used to update the progress and completion status of a mission. If the mission with the specified index already exists in the `dicMission` dictionary, its progress and completion status are updated. If the mission does not exist, a new mission is added to the dictionary with the specified parameters.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\MissionManager.md"}}],["313",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\MissleInfo.cs)\n\nThe code provided defines a class called \"MissleInfo\" that is used to store information about a missile object in the larger Brick-Force project. \n\nThe class has several properties and fields:\n- \"obj\" is a reference to the missile's GameObject in the Unity engine.\n- \"uniq\" is an integer that represents a unique identifier for the missile.\n- \"prepos\" is a Vector3 that represents the previous position of the missile.\n- \"elapsed\" is a float that represents the amount of time that has passed since the missile was created.\n- \"elapsedP2P\" is a float that represents the amount of time that has passed since the missile was last updated.\n\nThe class also has two properties, \"Elapsed\" and \"ElapsedP2P\", that provide access to the \"elapsed\" and \"elapsedP2P\" fields respectively. These properties allow other parts of the code to read and modify these values.\n\nThe purpose of this class is to store and manage information about a missile object. It provides a way to access and update the elapsed time values for the missile, as well as store references to the missile's GameObject and its unique identifier.\n\nThis class can be used in the larger Brick-Force project to track and manage missiles. For example, it could be used in a missile manager class that creates and updates missile objects. The \"MissleInfo\" objects could be created when a missile is spawned and then updated each frame to keep track of the missile's position and elapsed time. Other parts of the code could then access the \"MissleInfo\" objects to retrieve information about the missiles.\n\nHere is an example of how this class could be used in code:\n\n```csharp\nMissleInfo missile = new MissleInfo();\nmissile.obj = missileGameObject;\nmissile.uniq = missileId;\n\n// Update the elapsed time values\nmissile.Elapsed += Time.deltaTime;\nmissile.ElapsedP2P += Time.deltaTime;\n\n// Get the current elapsed time\nfloat elapsed = missile.Elapsed;\n\n// Get the previous position of the missile\nVector3 previousPosition = missile.prepos;\n```\n\nIn this example, a new \"MissleInfo\" object is created and assigned the missile's GameObject and unique identifier. The elapsed time values are then updated each frame using the \"Time.deltaTime\" value. The current elapsed time and previous position of the missile can then be accessed using the properties and fields of the \"MissleInfo\" object.\n## Questions: \n 1. What is the purpose of the `MissleInfo` class?\n- The `MissleInfo` class is used to store information about a missile, including its game object, unique identifier, previous position, and elapsed time.\n\n2. What is the significance of the `Elapsed` and `ElapsedP2P` properties?\n- The `Elapsed` property represents the elapsed time since the missile was created, while the `ElapsedP2P` property represents the elapsed time for a point-to-point missile.\n\n3. What is the purpose of the `prepos` variable?\n- The `prepos` variable is used to store the previous position of the missile.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\MissleInfo.md"}}],["314",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\MonController.cs)\n\nThe code provided is a part of the Brick-Force project and is contained in a file called \"MonController.cs\". This file defines a class called \"MonController\" that inherits from the \"MonoBehaviour\" class provided by the Unity game engine.\n\nThe purpose of this code is to control the behavior and animation of a monster character in the game. The \"MonController\" class has several private variables, including an \"Animation\" object called \"bipAnimation\", a \"MonProperty\" object called \"monProperty\", a \"MonAI\" object called \"monAI\", a float variable called \"deltaTime\", a boolean variable called \"bDie\", and a string variable called \"dieStr\". It also has several public boolean variables, including \"bSleep\", \"bImmediateBoom\", and \"bBigBoom\", as well as public float variables \"timerBoomTimeMax\" and \"monTblID\".\n\nThe code starts with a private method called \"InitializeAnimation()\" which initializes the animation for the monster character. It gets the \"MonProperty\" component attached to the game object and then gets all the \"Animation\" components attached to its child objects. It assigns the first \"Animation\" component found to the \"bipAnimation\" variable and adds the name of its clip to the \"clipNameMgr\" object. If no \"Animation\" component is found, it logs an error. Finally, it calls the \"SetIdle()\" method.\n\nThe \"Reset()\" method sets the \"bSleep\" and \"bDie\" variables to false and calls the \"SetIdle()\" method.\n\nThe \"SetIdle()\" method sets the animation of the monster character to \"walk\" and sets the wrap mode to \"Loop\". It also sets the \"deltaTime\" variable to 0.\n\nThe \"Start()\" method is called when the script is enabled and calls the \"InitializeAnimation()\" method.\n\nThe \"Update()\" method is called every frame and handles the behavior of the monster character. If the monster is not sleeping, it checks if it is dead. If it is dead, it increments the \"deltaTime\" variable and checks if it is time to instantiate an explosion effect. If the \"bBigBoom\" variable is true, it instantiates a larger explosion effect, otherwise it instantiates a regular explosion effect. It also calls the \"LastCommand()\" method of the \"monAI\" object and removes the monster character from the game. If the monster is not dead, it increments the \"deltaTime\" variable and checks if its experience points are less than or equal to 0. If so, it sets the \"bDie\" and \"bImmediateBoom\" variables to true, gets the \"monAI\" object from the \"MonManager\" instance, and performs various actions based on the monster's properties. Finally, it calls the \"Die()\" method of the \"monAI\" object.\n\nThe \"HitAnimation()\" method plays the \"hit\" animation if it exists in the \"clipNameMgr\" object.\n\nOverall, this code controls the animation and behavior of a monster character in the game. It initializes the animation, handles the monster's state and actions, and plays the appropriate animations based on the monster's state.\n## Questions: \n 1. What is the purpose of the `InitializeAnimation` method?\n- The `InitializeAnimation` method is responsible for setting up the animation component for the `MonController` object. It finds the animation component and sets the initial animation state.\n\n2. What does the `Reset` method do?\n- The `Reset` method resets the state of the `MonController` object. It sets the `bSleep` and `bDie` variables to false and calls the `SetIdle` method.\n\n3. What is the purpose of the `HitAnimation` method?\n- The `HitAnimation` method plays the \"hit\" animation if it exists in the animation clips.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\MonController.md"}}],["315",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\MonDesc.cs)\n\nThe code provided is a class called `MonDesc` that represents a monster description in the Brick-Force project. This class contains various properties and methods that are used to manage and track information about a monster.\n\nThe purpose of this class is to store and manipulate data related to a monster's attributes, such as its movement speed, attack damage, experience points, and damage logs. It also includes methods for initializing and updating the monster's data.\n\nHere is a breakdown of the important elements in the code:\n\n- Properties:\n  - `bP2P`: A boolean flag indicating whether the monster is a player-to-player monster.\n  - `timerRebirth`: A float value representing the time it takes for the monster to respawn.\n  - `atkedSeq`: An integer representing the sequence number of the monster that attacked.\n  - `moveSpeed`: A float value representing the movement speed of the monster.\n  - `shootDelay`: A float value representing the delay between monster's attacks.\n  - `typeID`: An integer representing the type ID of the monster.\n  - `tblID`: An integer representing the table ID of the monster.\n  - `dicDamageLog`: A dictionary that stores the damage inflicted on the monster by different attackers.\n  - `dicInflictedDamage`: A dictionary that stores the damage inflicted by the monster on different targets.\n  - `rigidity`: A float value representing the rigidity of the monster.\n  - `bRedTeam`: A boolean flag indicating whether the monster belongs to the red team.\n  - `Dp`: An integer representing the damage points of the monster.\n  - `seq`: An integer representing the sequence number of the monster.\n  - `bHalfDamage`: A boolean flag indicating whether the monster deals half damage.\n  - `max_xp`: An integer representing the maximum experience points of the monster.\n  - `xp`: An integer representing the current experience points of the monster.\n  - `aiAtkWho`: An integer representing the AI attacker of the monster.\n  - `deltaTimeInflictedDamage`: A float value representing the time since the last inflicted damage.\n  - `IsHit`: A boolean flag indicating whether the monster is hit.\n  - `colHit`: A boolean flag indicating whether the monster is hit by a collision.\n  - `coreToDmg`: An integer representing the damage to the monster's core.\n  - `Seq`: A read-only property that returns the sequence number of the monster.\n  - `Xp`: A property that gets or sets the experience points of the monster.\n  - `AiAtkWho`: A property that gets or sets the AI attacker of the monster.\n\n- Constructor:\n  - `MonDesc(int _tbl, int _typeID, int _seq, int _xp, bool _bP2P, int _dp)`: Initializes a new instance of the `MonDesc` class with the specified parameters. It sets the values of the properties based on the provided arguments.\n\n- Methods:\n  - `isSmoke()`: Checks if the monster is considered as \"smoke\" based on its current experience points and maximum experience points. It returns `true` if the monster's experience points are less than 30% of its maximum experience points, and `false` otherwise.\n  - `ResetGameStuff()`: Resets the game-related properties of the monster. This method does not have any implementation.\n  - `IsHostile()`: Determines if the monster is hostile. It always returns `true`.\n  - `InitLog()`: Initializes the damage log dictionaries (`dicDamageLog` and `dicInflictedDamage`) if they are null.\n  - `LogAttacker(int shooter, int damage)`: Logs the attacker and the damage inflicted by the attacker on the monster. It updates the damage log dictionaries with the new damage values.\n  - `ReportInflictedDamage()`: Reports the inflicted damage to the server. It sends the `dicInflictedDamage` dictionary to the server if it is not null and contains any entries. This method is called periodically to send the inflicted damage data to the server.\n  - `clearLog()`: Clears the damage log dictionaries (`dicDamageLog` and `dicInflictedDamage`).\n\nIn the larger Brick-Force project, this `MonDesc` class is likely used to manage and track the attributes and behavior of monsters. It provides methods for updating and reporting damage, initializing data structures, and managing game-related properties. Other classes in the project may interact with instances of this class to retrieve or modify monster data.\n## Questions: \n 1. What is the purpose of the `MonDesc` class?\n- The `MonDesc` class represents a description of a monster in the game. It stores various properties and methods related to the monster.\n\n2. What is the significance of the `seq` variable?\n- The `seq` variable represents the sequence number of the monster. It is used to determine if the monster belongs to the red team or not.\n\n3. What is the purpose of the `LogAttacker` method?\n- The `LogAttacker` method is used to log the damage inflicted by an attacker on the monster. It updates the `dicDamageLog` and `dicInflictedDamage` dictionaries with the damage information.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\MonDesc.md"}}],["316",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\MonProperty.cs)\n\nThe code provided is a part of the Brick-Force project and is contained within a file called \"MonProperty.cs\". This file defines a class called \"MonProperty\" that inherits from the \"MonoBehaviour\" class provided by the Unity game engine.\n\nThe purpose of this code is to represent a property of a monster in the game. The \"MonProperty\" class has a public field called \"Desc\" of type \"MonDesc\", which represents the description of the monster. The \"MonDesc\" class is not provided in the code snippet, but it can be assumed to contain information about the monster, such as its name, health, and attack power.\n\nThe \"MonProperty\" class also has a private field called \"invisiblePosition\" of type \"Vector3\". This field represents the position of the monster when it is invisible. The class provides a public property called \"InvisiblePosition\" that allows other classes to get and set the value of the \"invisiblePosition\" field.\n\nThe class also provides a public method called \"IsHostile()\" that returns a boolean value indicating whether the monster is hostile or not. This method checks if the \"Desc\" field is null and if it is, it returns false. Otherwise, it calls the \"IsHostile()\" method of the \"Desc\" object and returns its result. The purpose of this method is to determine if the monster should attack the player or not based on its description.\n\nThis code can be used in the larger Brick-Force project to create and manage monsters in the game. Other classes can create instances of the \"MonProperty\" class and set the \"Desc\" field to provide information about the monster. They can also get and set the \"InvisiblePosition\" property to control the position of the monster when it is invisible. The \"IsHostile()\" method can be used to determine if the monster should attack the player or not.\n\nExample usage:\n\n```csharp\nMonProperty monster = new MonProperty();\nmonster.Desc = new MonDesc(\"Goblin\", 100, 10);\nmonster.InvisiblePosition = new Vector3(0, 0, 0);\nbool isHostile = monster.IsHostile();\n```\n\nIn this example, a new instance of the \"MonProperty\" class is created and the \"Desc\" field is set with a new instance of the \"MonDesc\" class representing a goblin monster with 100 health and 10 attack power. The \"InvisiblePosition\" property is set to a new Vector3 representing the position (0, 0, 0). Finally, the \"IsHostile()\" method is called to determine if the monster is hostile or not, and the result is stored in the \"isHostile\" variable.\n## Questions: \n 1. **What is the purpose of the `MonDesc` variable?**\nThe `MonDesc` variable is used to store the description of a monster. \n\n2. **What is the significance of the `InvisiblePosition` property?**\nThe `InvisiblePosition` property allows access to the private `invisiblePosition` variable, which is used to store the position of an invisible object.\n\n3. **What does the `IsHostile()` method do?**\nThe `IsHostile()` method checks if the `Desc` variable is null and returns false if it is, otherwise it calls the `IsHostile()` method of the `Desc` object and returns its result.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\MonProperty.md"}}],["317",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\MonTable.cs)\n\nThe code provided defines a public class called `MonTable`. This class has several public fields, including `name`, `str`, `HP`, `MoveSpeed`, `toCoreDmg`, and `Dp`. \n\nThe purpose of this code is to define a data structure for storing information about a monster in the game. Each field represents a different attribute of the monster. \n\nFor example, the `name` field is a string that stores the name of the monster. The `str` field is also a string and may store additional information about the monster, such as its type or category. The `HP` field is an integer that represents the monster's health points, while the `MoveSpeed` field is a float that represents the monster's movement speed. The `toCoreDmg` field is an integer that represents the damage the monster can inflict on the game's core, and the `Dp` field is an integer that represents the monster's defense points.\n\nThis class can be used in the larger project to create and manage instances of monsters. For example, a developer could create a new instance of the `MonTable` class and set the values of its fields to define a specific monster. This instance could then be used in other parts of the project, such as in game logic or user interface elements, to display or interact with the monster.\n\nHere is an example of how this class could be used in code:\n\n```csharp\nMonTable monster = new MonTable();\nmonster.name = \"Goblin\";\nmonster.str = \"Small humanoid creature\";\nmonster.HP = 50;\nmonster.MoveSpeed = 2.5f;\nmonster.toCoreDmg = 10;\nmonster.Dp = 5;\n\n// Use the monster instance in the game logic or user interface\n```\n\nIn this example, a new instance of the `MonTable` class is created and its fields are set to define a goblin monster. The instance can then be used in other parts of the project to display information about the goblin or to calculate damage inflicted by the goblin on the game's core.\n## Questions: \n 1. **What is the purpose of this class?**\nThe smart developer might want to know what the intended use or functionality of this class is within the Brick-Force project.\n\n2. **Why are the variables `name` and `str` initialized as empty strings?**\nThe developer might be curious about why these variables are initialized as empty strings and if there is a specific reason for doing so.\n\n3. **What do the variables `HP`, `MoveSpeed`, `toCoreDmg`, and `Dp` represent?**\nThe developer might want to understand the meaning or significance of these variables and how they relate to the overall functionality of the class.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\MonTable.md"}}],["318",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\MouseUtil.cs)\n\nThe code provided is a utility class called `MouseUtil` that contains several static methods for handling mouse input in the context of a graphical user interface (GUI). \n\nThe `ScreenToPixelPoint` method takes a `Vector2` representing a point on the screen and converts it to a pixel point. It does this by creating a new `Vector2` object with the same x-coordinate as the input point, but with the y-coordinate adjusted to be the difference between the screen height and the y-coordinate of the input point. This method is useful for converting mouse positions from screen coordinates to pixel coordinates.\n\nThe `MouseOver` method takes a `Rect` object representing a rectangular area on the screen and checks if the mouse position is within that area. It does this by first converting the mouse position to a pixel point using the `ScreenToPixelPoint` method. It then checks if the x-coordinate of the pixel point is outside the range of the rectangle's x-coordinates or if the y-coordinate of the pixel point is outside the range of the rectangle's y-coordinates. If either of these conditions is true, it returns `false`, indicating that the mouse is not over the rectangle. Otherwise, it returns `true`.\n\nThe `ClickInside` method is similar to `MouseOver`, but it also checks if the left mouse button, right mouse button, or middle mouse button is being pressed. It does this by checking if `Input.GetMouseButtonDown` returns `true` for any of these buttons. If any of the buttons are being pressed, it converts the mouse position to a GUI point using the `PixelToGUIPoint` method and checks if it is inside the rectangle. If the mouse is over the rectangle and one of the buttons is being pressed, it returns `true`. Otherwise, it returns `false`.\n\nThe `ClickOutside` method is the opposite of `ClickInside`. It checks if any of the mouse buttons are being pressed and if the mouse position is outside the rectangle. If both conditions are true, it returns `true`, indicating that the mouse click is happening outside the rectangle. Otherwise, it returns `false`.\n\nThese methods can be used in the larger project to handle mouse input for GUI elements. For example, `MouseOver` can be used to determine if the mouse is hovering over a button or other interactive element, while `ClickInside` and `ClickOutside` can be used to handle mouse clicks inside or outside a specific area. By providing these utility methods, the `MouseUtil` class simplifies the process of handling mouse input in the project.\n## Questions: \n 1. **What does the `ScreenToPixelPoint` method do?**\nThe `ScreenToPixelPoint` method takes a screen point as input and returns a corresponding pixel point on the screen.\n\n2. **What is the purpose of the `MouseOver` method?**\nThe `MouseOver` method checks if the mouse position is within the bounds of a given rectangle (`rc`) and returns `true` if it is, otherwise `false`.\n\n3. **What is the difference between the `ClickInside` and `ClickOutside` methods?**\nThe `ClickInside` method checks if the left, right, or middle mouse buttons are pressed and if the mouse position is within the bounds of a given rectangle (`rc`), returning `true` if both conditions are met. On the other hand, the `ClickOutside` method checks if any mouse button is pressed and if the mouse position is outside the bounds of the given rectangle, returning `true` if both conditions are met.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\MouseUtil.md"}}],["319",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\MoveScreenFx.cs)\n\nThe `MoveScreenFx` class is a script that is used to create a visual effect on the screen during gameplay in the Brick-Force project. It is attached to a game object in the Unity game engine and is responsible for displaying a shield effect on the screen when a certain condition is met.\n\nThe class has several public and private variables that control the appearance and behavior of the effect. The `guiDepth` variable determines the layer at which the GUI elements will be rendered. The `shieldFx` variable holds the texture of the shield effect. The `clrFrom` and `clrTo` variables define the starting and ending colors of the shield effect. The `flickerFrom` and `flickerTo` variables determine the flickering effect of the shield. \n\nThe `VerifyLocalController` method is used to check if the `localController` variable is null and assigns it the value of the `LocalController` component attached to the same game object if it is null.\n\nThe `Start` method is called when the script is first initialized and it calls the `VerifyLocalController` method.\n\nThe `OnGUI` method is responsible for rendering the shield effect on the screen. It checks if the `localController` is not null, if the `SpeedUpEffect` property of the `localController` is true, and if the `showFx` variable is true. If these conditions are met, it sets the GUI skin, depth, and color, and then draws the shield texture on the screen using the `TextureUtil.DrawTexture` method. Finally, it resets the GUI color and enables GUI interaction.\n\nThe `ShowMoveScreenFx` method is used to control the visibility of the shield effect. It takes a boolean parameter `isVisible` and sets the `showFx` variable accordingly.\n\nThe `Update` method is called every frame and is responsible for updating the shield effect. It checks if the `localController` is not null and if the `SpeedUpEffect` property is true. If these conditions are met, it calculates the flicker value based on the `NormalizedSpeedTime` property of the `localController`. It then updates the `deltaTime` variable with the time since the last frame. If the `showFx` variable is true, it checks if the `deltaTime` is greater than the flicker value, and if so, it resets the `deltaTime` and sets the `showFx` variable to false. If the `showFx` variable is false, it checks if the `deltaTime` is greater than the `flickerTo` value, and if so, it resets the `deltaTime` and sets the `showFx` variable to true.\n\nIn summary, this script is used to create a shield effect on the screen during gameplay in the Brick-Force project. It provides methods to control the visibility of the effect and updates the effect based on the state of the `localController` component.\n## Questions: \n 1. What is the purpose of the `MoveScreenFx` class?\n- The `MoveScreenFx` class is responsible for displaying a shield effect on the screen when a speed-up effect is active in the game.\n\n2. What is the significance of the `shieldFx` variable?\n- The `shieldFx` variable holds the texture of the shield effect that will be displayed on the screen.\n\n3. What is the purpose of the `ShowMoveScreenFx` method?\n- The `ShowMoveScreenFx` method is used to control the visibility of the shield effect on the screen. It takes a boolean parameter `isVisible` to determine whether the effect should be shown or hidden.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\MoveScreenFx.md"}}],["320",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Msg2Handle.cs)\n\nThe code provided defines a class called `Msg2Handle`. This class has two public properties: `_id` of type `ushort` and `_msg` of type `MsgBody`. The class also has a constructor that takes two parameters: `id` of type `ushort` and `msg` of type `MsgBody`. \n\nThe purpose of this code is to create an object that represents a message to be handled. The `Msg2Handle` class encapsulates the message ID and the message body into a single object. This can be useful in scenarios where a message needs to be passed around and processed by different parts of the code.\n\nThe `Msg2Handle` class can be used in the larger project to facilitate communication between different components or modules. For example, if there is a messaging system in the project that handles different types of messages, the `Msg2Handle` class can be used to create instances of messages and pass them to the messaging system for processing.\n\nHere is an example of how the `Msg2Handle` class can be used:\n\n```csharp\n// Create a message body\nMsgBody msgBody = new MsgBody(\"Hello, world!\");\n\n// Create a message to be handled\nMsg2Handle msg2Handle = new Msg2Handle(1, msgBody);\n\n// Pass the message to a messaging system for processing\nMessagingSystem.ProcessMessage(msg2Handle);\n```\n\nIn this example, a `MsgBody` object is created with the message content \"Hello, world!\". Then, a `Msg2Handle` object is created with an ID of 1 and the `MsgBody` object. Finally, the `Msg2Handle` object is passed to a hypothetical `MessagingSystem` class for processing.\n\nOverall, the `Msg2Handle` class provides a convenient way to package a message ID and its corresponding body into a single object, making it easier to handle and process messages in the larger project.\n## Questions: \n 1. **What is the purpose of the `Msg2Handle` class?**\nThe `Msg2Handle` class appears to be a data structure that holds an ID and a message body. A smart developer might want to know how this class is used and what its purpose is within the larger project.\n\n2. **What is the significance of the `ushort` data type for the `_id` field?**\nA smart developer might question why the `_id` field is of type `ushort` and not another data type like `int` or `long`. Understanding the reason for this choice could provide insights into the design or requirements of the project.\n\n3. **What is the purpose of the `MsgBody` class and how is it related to the `Msg2Handle` class?**\nThe `Msg2Handle` class has a field named `_msg` of type `MsgBody`. A smart developer might want to know what the `MsgBody` class represents and how it is used in conjunction with the `Msg2Handle` class.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Msg2Handle.md"}}],["321",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Msg4Recv.cs)\n\nThe code provided is a class called `Msg4Recv` that is part of the Brick-Force project. This class is responsible for receiving and processing messages in the project.\n\nThe class has several private fields, including `_buffer`, `_io`, and `_hdr`. The `_buffer` field is a byte array that stores the received message data. The `_io` field is an integer that keeps track of the current position in the buffer. The `_hdr` field is an instance of the `MsgHdr` class, which represents the header of the message.\n\nThe class provides two constructors. The first constructor initializes the `_io` field to 0, creates a new instance of `MsgHdr`, and initializes the `_buffer` field with a byte array of size 4092. The second constructor does the same but also copies the contents of the `src` byte array into the `_buffer` field.\n\nThe class has a method called `ExpandBuffer()` that is used to increase the size of the `_buffer` field when it becomes full. This method creates a new byte array with double the size of the current `_buffer` array and copies the contents of the `_buffer` array into the new array.\n\nThe class also has a method called `GetStatus(byte recvKey)` that checks the status of the received message. This method first checks if the `_io` field is greater than or equal to the length of the `_buffer` array. If it is, the `ExpandBuffer()` method is called to increase the size of the buffer. Then, it checks if the `_io` field is less than 15. If it is, it returns `MsgStatus.INCOMPLETE`. Otherwise, it calls the `FromArray()` method of the `MsgHdr` instance to populate the `_hdr` field with data from the `_buffer` array. It then checks if the `_io` field is less than 15 plus the size of the message header. If it is, it returns `MsgStatus.INCOMPLETE`. Finally, if the `recvKey` parameter is equal to 255, it calculates the CRC (cyclic redundancy check) of the message data and compares it to the CRC stored in the message header. If they don't match, it logs an error and returns `MsgStatus.INVALID`. Otherwise, it returns `MsgStatus.COMPLETE`.\n\nThe class also provides methods to retrieve the ID and meta data from the message header, as well as a `Flush()` method that creates a new `MsgBody` instance from the message data starting at position 15 in the `_buffer` array. It then updates the `_io` field and shifts the remaining data in the `_buffer` array to the beginning.\n\nOverall, this class is responsible for receiving and processing messages in the Brick-Force project. It provides methods to check the status of received messages, retrieve message header information, and extract message data for further processing.\n## Questions: \n 1. What is the purpose of the `Msg4Recv` class?\n- The `Msg4Recv` class is used to receive and process messages.\n\n2. What does the `MsgStatus` enum represent?\n- The `MsgStatus` enum represents the status of a message, which can be `COMPLETE`, `INCOMPLETE`, `INVALID`, or `OVERFLOW`.\n\n3. What does the `Flush` method do?\n- The `Flush` method returns a `MsgBody` object containing the message data, and updates the internal state of the `Msg4Recv` object to remove the flushed message from the buffer.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Msg4Recv.md"}}],["322",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Msg4Send.cs)\n\nThe code provided is a class called `Msg4Send` that is used to create and manage messages for sending in the larger Brick-Force project. \n\nThe purpose of this code is to create a message that can be sent over a network connection. The message is constructed using various parameters such as an ID, metadata, source, message body, and a send key. The message is then serialized into a byte array and stored in the `_buffer` variable.\n\nThe `Msg4Send` class has a constructor that takes in the necessary parameters to create a message. Inside the constructor, the message body is processed based on the value of the `sendKey`. If the `sendKey` is 255, a checksum is calculated by XORing each byte of the message body. Otherwise, each byte of the message body is XORed with the `sendKey`. This process ensures that the message is secure and can be decrypted by the recipient.\n\nAfter processing the message body, the `_buffer` variable is initialized with a size of 15 plus the size of the message body. The message header is then serialized into a byte array and copied into the `_buffer`. Finally, the message body is copied into the `_buffer` starting from the end of the message header.\n\nThe `Msg4Send` class also has a method called `GetStatus()` which returns the status of the message. If the `_io` variable is greater than or equal to the length of the `_buffer`, it means that the entire message has been sent and the method returns `MsgStatus.COMPLETE`. Otherwise, it returns `MsgStatus.INCOMPLETE`, indicating that there is still more of the message to be sent.\n\nThis code is an essential part of the Brick-Force project as it provides a way to create and manage messages for sending over a network connection. It ensures the security and integrity of the messages by performing XOR operations on the message body and provides a way to check the status of the message.\n## Questions: \n 1. What is the purpose of the `Msg4Send` class?\n- The `Msg4Send` class is used to create and manage messages for sending in the Brick-Force project.\n\n2. What does the `Msg4Send` constructor do?\n- The `Msg4Send` constructor takes in various parameters and creates a message for sending by performing some calculations and copying data into the `_buffer` array.\n\n3. What does the `GetStatus` method do?\n- The `GetStatus` method checks if the `_io` variable is greater than or equal to the length of the `_buffer` array and returns the corresponding `MsgStatus` enum value to indicate if the message is complete or incomplete.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Msg4Send.md"}}],["323",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\MsgBody.cs)\n\nThe code provided is a class called `MsgBody` that is used for handling message bodies in the larger Brick-Force project. \n\nThe purpose of this class is to provide methods for reading and writing different data types to a byte array buffer. It allows for the serialization and deserialization of data, which is useful for sending and receiving messages over a network or storing data in a file.\n\nThe `MsgBody` class has a default buffer size of 8192 bytes and an offset property that keeps track of the current position in the buffer. The buffer is represented by a byte array.\n\nThe class provides several methods for writing different data types to the buffer, such as strings, integers, floats, booleans, and more. These methods create a `MemoryStream` and a `BinaryWriter` to write the data to the stream, and then the data is copied to the buffer using the `Copy` method. If the buffer is not large enough to hold the data, the `ExpandBuffer` method is called to increase the size of the buffer.\n\nHere is an example of how the `Write` method can be used to write a string to the buffer:\n\n```csharp\nMsgBody msgBody = new MsgBody();\nstring message = \"Hello, world!\";\nmsgBody.Write(message);\n```\n\nThe class also provides corresponding methods for reading data from the buffer. These methods create a `MemoryStream` and a `BinaryReader` to read the data from the stream, and then the data is copied to the appropriate data type. The offset is updated accordingly.\n\nHere is an example of how the `Read` method can be used to read a string from the buffer:\n\n```csharp\nMsgBody msgBody = new MsgBody();\nstring message;\nmsgBody.Read(out message);\n```\n\nAdditionally, the class provides a `Decrypt` method that XORs each byte in the buffer with a given key. This can be used to encrypt and decrypt the data in the buffer.\n\nOverall, the `MsgBody` class is a versatile utility class that allows for easy serialization and deserialization of data in the Brick-Force project. It provides methods for reading and writing various data types to a byte array buffer, making it useful for network communication and data storage.\n## Questions: \n 1. **What is the purpose of the `MsgBody` class?**\nThe `MsgBody` class is used to handle the creation, manipulation, reading, and writing of byte arrays that represent message bodies.\n\n2. **What is the significance of the `DEFAULT_BUFFER_SIZE` constant?**\nThe `DEFAULT_BUFFER_SIZE` constant determines the initial size of the byte array buffer used by the `MsgBody` class. It is set to 8192 bytes (8KB) by default.\n\n3. **What is the purpose of the `ExpandBuffer` method?**\nThe `ExpandBuffer` method is used to increase the size of the byte array buffer when it is not large enough to accommodate additional data. It doubles the size of the buffer by creating a new array and copying the existing data into it.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\MsgBody.md"}}],["324",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\MsgBox.cs)\n\nThe code provided defines a class called `MsgBox` that represents a message box in the Brick-Force project. The purpose of this class is to create message boxes with different types and messages.\n\nThe `MsgBox` class has an enumeration called `TYPE` that defines different types of message boxes. The available types are `ERROR`, `WARNING`, `SELECT`, `FORCE_POINT_CHARGE`, and `QUIT`. These types can be used to categorize and differentiate the message boxes based on their purpose or severity.\n\nThe class has two private fields: `msg` and `type`. The `msg` field stores the message content of the message box, while the `type` field stores the type of the message box.\n\nThe class provides two public properties: `Message` and `Type`. The `Message` property is a read-only property that returns the message content of the message box. The `Type` property is also a read-only property that returns the type of the message box.\n\nThe class also has a public method called `MsgColor` that returns the color associated with the message box type. If the type is `WARNING`, the method returns `Color.white`. Otherwise, it returns a custom color defined as `new Color(0.91f, 0.3f, 0f)`.\n\nLastly, the class has a constructor that takes two parameters: `_type` and `_msg`. These parameters are used to initialize the `type` and `msg` fields respectively.\n\nThis `MsgBox` class can be used in the larger Brick-Force project to create and display message boxes with different types and messages. Developers can create instances of the `MsgBox` class by providing the desired type and message, and then use the properties and methods of the class to access the message content, type, and associated color. For example:\n\n```csharp\nMsgBox errorBox = new MsgBox(MsgBox.TYPE.ERROR, \"An error occurred!\");\nstring errorMessage = errorBox.Message;\nMsgBox.TYPE errorType = errorBox.Type;\nColor errorColor = errorBox.MsgColor;\n```\n\nIn the above example, an instance of `MsgBox` is created with the type `ERROR` and the message \"An error occurred!\". The properties `Message`, `Type`, and `MsgColor` are then used to access the message content, type, and color associated with the message box.\n## Questions: \n 1. What is the purpose of the `MsgBox` class?\n- The `MsgBox` class is used to create message boxes with different types (such as error, warning, select, force point charge, and quit) and corresponding messages.\n\n2. How can the message and type of a `MsgBox` object be accessed?\n- The message can be accessed using the `Message` property, and the type can be accessed using the `Type` property of a `MsgBox` object.\n\n3. What color is returned for a `MsgBox` object of type `WARNING`?\n- The color white is returned for a `MsgBox` object of type `WARNING`.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\MsgBox.md"}}],["325",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\MsgBoxDialog.cs)\n\nThe code provided is a class called MsgBoxDialog that extends the Dialog class. This class is responsible for displaying a message box dialog in the game. The purpose of this code is to handle the logic and rendering of the message box dialog, including displaying the message, handling button clicks, and updating the dialog based on user input.\n\nThe Start() method sets the id of the dialog to a specific value from the DialogManager.DIALOG_INDEX enum. This id is used to identify and manage the dialog in the larger project.\n\nThe RecalcSize() method is used to recalculate the size and position of the dialog based on the current screen size. This ensures that the dialog is always centered on the screen.\n\nThe DoDialog() method is the main method that handles the rendering and logic of the dialog. It first sets the GUI depth and skin, and then sets the color of the GUI based on the message box's color. It then renders the message label using the GUI.Label() method, passing in the position and style for the label.\n\nThe method also checks the type of the message box and renders additional buttons based on the type. For example, if the message box type is MsgBox.TYPE.WARNING, it renders an \"OK\" button. If the type is MsgBox.TYPE.SELECT, it renders both an \"OK\" and a \"CANCEL\" button. The method also checks for button clicks and sets the result variable to true if a button is clicked.\n\nThe Update() method is called every frame and checks for the return or escape key press. If either key is pressed, it sets the returnOrEscapePressed variable to true.\n\nThe InitDialog() method is used to initialize the message box dialog with a specific message box object.\n\nThe OnPopup() method is called when the dialog is opened as a popup. It sets the returnOrEscapePressed variable to false.\n\nThe OnClose() method is called when the dialog is closed. It clears the message box manager.\n\nOverall, this code provides the functionality to display and interact with a message box dialog in the game. It handles rendering the dialog, displaying the message, and handling button clicks. This class can be used in the larger project to display important messages or prompts to the player.\n## Questions: \n 1. What is the purpose of the `MsgBoxDialog` class?\n- The `MsgBoxDialog` class is a subclass of the `Dialog` class and is used to display message box dialogs in the game.\n\n2. What is the significance of the `RecalcSize()` method?\n- The `RecalcSize()` method is used to recalculate the size and position of the message box dialog based on the current screen size.\n\n3. What is the purpose of the `Update()` method?\n- The `Update()` method is responsible for checking if the return key or escape key is pressed and setting the `returnOrEscapePressed` flag accordingly.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\MsgBoxDialog.md"}}],["326",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\MsgHdr.cs)\n\nThe code provided is a C# class called `MsgHdr` that represents a message header. This class is used to store and manipulate the header information of a message in the larger Brick-Force project.\n\nThe `MsgHdr` class has several public fields: `_size`, `_id`, `_crc`, `_meta`, and `_src`. These fields represent the size, ID, CRC (cyclic redundancy check), meta data, and source of the message header, respectively. The class also has two constructors: a default constructor that initializes all fields to zero, and a parameterized constructor that allows the caller to set the values of the fields.\n\nThe class provides two methods: `ToArray()` and `FromArray(byte[] src)`. The `ToArray()` method converts the header fields into a byte array representation. It creates a `MemoryStream` object and a `BinaryWriter` object to write the header fields to the stream. The method then returns the byte array representation of the header.\n\nHere is an example usage of the `ToArray()` method:\n\n```csharp\nMsgHdr header = new MsgHdr(15, 1, 0, 0, 0);\nbyte[] headerBytes = header.ToArray();\n```\n\nThe `FromArray(byte[] src)` method does the opposite of `ToArray()`. It takes a byte array as input and converts it back into the header fields. It creates a `MemoryStream` object and writes the byte array to the stream. Then, it creates a `BinaryReader` object to read the header fields from the stream and assigns them to the corresponding fields in the class.\n\nHere is an example usage of the `FromArray(byte[] src)` method:\n\n```csharp\nbyte[] headerBytes = GetHeaderBytesFromNetwork();\nMsgHdr header = new MsgHdr();\nheader.FromArray(headerBytes);\n```\n\nOverall, this `MsgHdr` class provides a convenient way to store and manipulate message header information in the Brick-Force project. It allows the project to easily convert the header fields to a byte array representation and vice versa. This can be useful for sending and receiving messages over a network or storing them in a file.\n## Questions: \n 1. What is the purpose of the `MsgHdr` class?\n- The `MsgHdr` class represents a message header and contains fields for size, ID, CRC, meta, and source.\n\n2. What is the purpose of the `ToArray` method?\n- The `ToArray` method converts the fields of the `MsgHdr` object into a byte array using a `MemoryStream` and `BinaryWriter`.\n\n3. What is the purpose of the `FromArray` method?\n- The `FromArray` method reads a byte array and populates the fields of the `MsgHdr` object using a `MemoryStream` and `BinaryReader`.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\MsgHdr.md"}}],["327",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\MyKillLog.cs)\n\nThe code provided is a part of the Brick-Force project and is contained within the `MyKillLog` class. This class is responsible for managing and displaying kill logs in the game.\n\nThe class contains several private variables, including an enumeration called `ALPHASTEP`, a queue of `KillInfo` objects called `logQ`, a `guiDepth` variable of type `GUIDepth.LAYER`, an `alphaStep` variable of type `ALPHASTEP`, and a `deltaNext` variable of type `float`.\n\nThe `Awake()` method is called when the object is initialized and it creates a new instance of the `logQ` queue.\n\nThe `OnKillLog(KillInfo log)` method is called whenever a new kill log is received. It checks if the `logQ` queue is not null and if the victim of the kill is not the same as the player's nickname, the killer is the player, and the weapon used is not 0. If these conditions are met, the kill log is added to the `logQ` queue and the `alphaStep` is set to `ALPHASTEP.NONE`. If the `logQ` queue has more than one item, the `alphaStep` is set to `ALPHASTEP.WAIT` and the `deltaNext` is set to 0.\n\nThe `DrawMyKill()` method is responsible for drawing the kill log on the screen. It iterates through each `KillInfo` item in the `logQ` queue and checks if the alpha value is greater than 0 and the dragY value is less than 36. If these conditions are met, it updates the alpha and dragY values based on the `alphaStep` and `Time.deltaTime`. It then draws the kill log using the `TextureUtil.DrawTexture()` and `LabelUtil.TextOut()` methods.\n\nThe `OnGUI()` method is called to draw the GUI elements on the screen. It checks if the GUI is enabled and if the `DialogManager` is not in a modal state. It then calls the `DrawMyKill()` method to draw the kill log.\n\nThe `Update()` method is called every frame to update the kill logs. It iterates through each `KillInfo` item in the `logQ` queue and calls the `Update()` method on each item. It also checks if the `alphaStep` is set to `ALPHASTEP.WAIT` and increments the `deltaNext` value. If the `deltaNext` value is greater than 1, the `alphaStep` is set to `ALPHASTEP.START`. It then checks if any kill logs in the `logQ` queue are no longer alive and removes them from the queue.\n\nOverall, this code manages the display of kill logs in the game by adding new kill logs to a queue, updating the alpha and dragY values of each kill log, and drawing the kill logs on the screen. It also handles the GUI elements and updates the kill logs based on the game's frame rate.\n## Questions: \n 1. What is the purpose of the `MyKillLog` class?\n- The `MyKillLog` class is responsible for managing and displaying kill logs in the game.\n\n2. What is the significance of the `ALPHASTEP` enum?\n- The `ALPHASTEP` enum is used to track the current step in the alpha animation of the kill log.\n\n3. What is the purpose of the `OnKillLog` method?\n- The `OnKillLog` method is called when a new kill log is received. It adds the log to the queue and updates the alpha step based on the number of logs in the queue.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\MyKillLog.md"}}],["328",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\MyMapFrame.cs)\n\nThe code provided is a class called `MyMapFrame` that is part of the larger Brick-Force project. This class is responsible for managing the user interface (UI) elements related to the map frame in the game.\n\nThe class has several public variables that define the position and size of different UI elements, such as `crdFrame`, `crdSubFrame`, and `crdTab`. These variables are of type `Rect` and are used to specify the position and size of GUI elements in Unity.\n\nThe class also has references to three other classes: `EditingMapFrame`, `MyRegMapFrame`, and `DownloadMapFrame`. These classes are responsible for handling the UI and logic related to editing maps, registering maps, and downloading maps, respectively.\n\nThe `Start()` method initializes the `tabs` array by retrieving localized strings from a `StringMgr` instance using the `tabKey` array. It then calls the `Start()` method of the `editMapFrm`, `myRegMapFrm`, and `downloadMapFrm` instances to initialize them.\n\nThe `OnGUI()` method is responsible for rendering the UI elements based on the current tab selected. It first checks if the GUI should be enabled or disabled based on the value of `bGuiEnable`. If `bGuiEnable` is false, the GUI is disabled using `GUI.enabled = false`. \n\nThen, based on the value of `currentTab`, it calls the `OnGUI()` method of the corresponding frame class (`editMapFrm`, `myRegMapFrm`, or `downloadMapFrm`). The `SelectedTab()` method is also called on `myRegMapFrm` and `downloadMapFrm` to set the mode tab.\n\nFinally, if `bGuiEnable` is false, the GUI is re-enabled using `GUI.enabled = true`.\n\nOverall, this code manages the UI elements related to the map frame in the Brick-Force game. It initializes the UI elements, handles user input, and renders the appropriate UI based on the selected tab. This class is likely used in conjunction with other classes and scripts to create a complete UI system for the game.\n## Questions: \n 1. What is the purpose of the `Start()` method in the `MyMapFrame` class?\n- The `Start()` method initializes the `tabs` array by retrieving values from the `tabKey` array and calls the `Start()` method of the `editMapFrm`, `myRegMapFrm`, and `downloadMapFrm` objects.\n\n2. What is the purpose of the `OnGUI()` method in the `MyMapFrame` class?\n- The `OnGUI()` method is responsible for rendering the GUI elements based on the current tab and mode selected.\n\n3. What is the significance of the `bGuiEnable` variable in the `MyMapFrame` class?\n- The `bGuiEnable` variable determines whether the GUI elements should be enabled or disabled. If it is set to `false`, the GUI elements will be disabled.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\MyMapFrame.md"}}],["329",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\NameCard.cs)\n\nThe code provided defines a class called `NameCard`. This class represents a player's name card in the larger Brick-Force project. \n\nThe `NameCard` class has several private fields: `seq`, `nickname`, `lv`, `rank`, and `svrId`. These fields store information about the player's sequence number, nickname, level, rank, and server ID, respectively. \n\nThe class also has several public properties that provide access to these private fields. The `Seq` property allows read-only access to the `seq` field. The `Nickname`, `Lv`, `Rank`, and `SvrId` properties allow both read and write access to their respective fields. \n\nThe `IsConnected` property is a read-only property that returns a boolean value indicating whether the player is connected to a server. It does this by checking if the `svrId` field is greater than 0. If it is, then the player is considered connected. \n\nThe class also has a constructor that takes in the values for the `seq`, `nickname`, `lv`, `svrId`, and `rank` fields and initializes them accordingly. This constructor allows for the creation of a `NameCard` object with the necessary information about a player's name card. \n\nOverall, this code provides a blueprint for creating and managing player name cards in the Brick-Force project. It allows for the storage and retrieval of information such as the player's nickname, level, rank, and server ID. The `IsConnected` property can be used to check if a player is currently connected to a server. This class can be used in conjunction with other classes and components in the Brick-Force project to provide functionality related to player name cards. \n\nExample usage:\n\n```csharp\n// Create a new NameCard object\nNameCard playerCard = new NameCard(1, \"Player1\", 10, 1234, 5);\n\n// Get the player's nickname\nstring nickname = playerCard.Nickname;\n\n// Set the player's level\nplayerCard.Lv = 15;\n\n// Check if the player is connected\nbool isConnected = playerCard.IsConnected;\n```\n## Questions: \n 1. What is the purpose of the `NameCard` class?\n- The `NameCard` class represents a player's name card and stores information such as sequence number, nickname, level, server ID, and rank.\n\n2. What is the significance of the `IsConnected` property?\n- The `IsConnected` property returns a boolean value indicating whether the player is connected to a server, based on the value of the `svrId` property.\n\n3. How are the properties `Nickname`, `Lv`, `Rank`, and `SvrId` used in the code?\n- These properties are used to get and set the corresponding values of the private fields `nickname`, `lv`, `rank`, and `svrId`. They provide controlled access to these fields outside of the class.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\NameCard.md"}}],["330",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\NMCrypt_Manager.cs)\n\nThe code provided is a part of the Brick-Force project and is contained in the `NMCrypt_Manager` class. This class is responsible for managing encryption and decryption operations related to cookies and clipboard data.\n\nThe `NMCrypt_Manager` class is a MonoBehaviour, which means it can be attached to a GameObject in the Unity game engine. It contains a static instance of itself, `_instance`, which allows other scripts to access its functionality.\n\nThe class has a public byte array variable called `cookie` with a size of 2048 bytes. This array is used to store the encrypted cookie data.\n\nThe class also contains several methods that are declared as `DllImport` functions. These functions are used to call external functions from a native library called \"NMCrypt\". The library is likely written in a language like C or C++ and provides low-level encryption and decryption operations.\n\nThe `Getint5` function is declared to return an integer and is used to retrieve an integer value from the \"NMCrypt\" library.\n\nThe `GetCookie`, `GetCookieKey`, `GetClipBoard`, and `SetClipBoard` functions are declared to take byte arrays as parameters and are used to retrieve and set cookie and clipboard data using the \"NMCrypt\" library.\n\nThe `Awake` method is a Unity lifecycle method that is called when the script is first initialized. It checks if the game is being built for the Netmarble platform and if so, retrieves a command line argument and converts it to a byte array. This byte array is then passed to the `GetCookieKey` function to set the `cookie` variable.\n\nFinally, the `DontDestroyOnLoad` method is called to ensure that the `NMCrypt_Manager` object persists between scene changes in the Unity game.\n\nIn the larger Brick-Force project, the `NMCrypt_Manager` class is likely used to handle encryption and decryption of sensitive data, such as cookies and clipboard data. It provides a convenient interface for other scripts to access these encryption and decryption operations. Other scripts can access the `NMCrypt_Manager` instance through the `Instance` property and use the provided methods to interact with the \"NMCrypt\" library.\n## Questions: \n 1. What is the purpose of the `NMCrypt_Manager` class?\n- The `NMCrypt_Manager` class is responsible for managing encryption and decryption operations.\n\n2. What is the significance of the `Getint5` method?\n- The `Getint5` method is a function imported from the `NMCrypt` library, but its purpose is not clear from the provided code.\n\n3. How does the `Awake` method interact with the `BuildOption` class?\n- The `Awake` method checks if the `BuildOption` instance is set to `IsNetmarble` and if so, it retrieves a command line argument and uses it to generate a cookie key.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\NMCrypt_Manager.md"}}],["331",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\NmSecure.cs)\n\nThe code provided is a part of the Brick-Force project and is contained in the `NmSecure` class. The purpose of this code is to provide a secure way to handle and manipulate sensitive data within the project. It achieves this by using external functions from a native library called \"nmsv\" through the use of platform invocation services.\n\nThe `NmSecure` class is a singleton, meaning that there can only be one instance of it in the project. The `Instance` property provides access to this instance. If there is no existing instance, it tries to find one using `Object.FindObjectOfType`. If it fails to find an instance, it logs an error message.\n\nThe class also contains a number of external function declarations using the `DllImport` attribute. These functions are used to interact with the native library and perform various operations on the sensitive data. Some of the operations include setting and getting values of different types (integer, long, float, double), as well as adding and subtracting values.\n\nThe class also includes a callback function called `FalsificationNotifyCallback`, which is used to handle cases where the data is falsified. In this case, it logs an error message and calls the `HardExit` method from the `BuildOption` class.\n\nThe `Awake` method is called when the script instance is being loaded. It checks if the platform is Windows and if so, it sets the falsification notify callback using the `setntcb` function.\n\nThe `Main` method is a static method that is called when the script is run. It sets the falsification notify callback, creates multiple handles using the `ctsvar` function, sets the values of these handles, and performs various operations on them. Finally, it logs the results of these operations.\n\nOverall, this code provides a secure way to handle sensitive data within the Brick-Force project by using external functions from a native library. It ensures that the data is not falsified and provides methods to manipulate and retrieve the data as needed.\n## Questions: \n 1. What is the purpose of the `NmSecure` class?\n- The `NmSecure` class is responsible for handling secure data and preventing falsification.\n\n2. What is the purpose of the `setntcb` method and how is it used?\n- The `setntcb` method is used to set a callback function that will be called when data falsification is detected. It is used to notify the program when secure data has been tampered with.\n\n3. What is the purpose of the `ctsvar` method and how is it used?\n- The `ctsvar` method is used to create a secure variable of a specified type. It returns a handle that can be used to access and manipulate the secure variable.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\NmSecure.md"}}],["332",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\NM_SECURE_VAR_TYPE.cs)\n\nThe code provided is an internal enum called `NM_SECURE_VAR_TYPE`. This enum is used to define different types of secure variables that can be used in the larger Brick-Force project. \n\nThe purpose of this enum is to provide a set of options for the type of secure variables that can be used in the project. Each option represents a different data type, such as byte, short, int, long, etc. By using this enum, the project can ensure that only specific types of secure variables are used, which can help with data integrity and security.\n\nFor example, if a certain part of the project requires a secure variable of type int, the code can use the `NM_SECURE_VAR_TYPE.S_INT` option to specify that type. This helps to make the code more readable and maintainable, as it clearly indicates the intended type of the secure variable.\n\nHere is an example of how this enum could be used in the larger project:\n\n```csharp\ninternal class SecureData\n{\n    private NM_SECURE_VAR_TYPE dataType;\n    private object value;\n\n    public SecureData(NM_SECURE_VAR_TYPE dataType, object value)\n    {\n        this.dataType = dataType;\n        this.value = value;\n    }\n\n    public void SetValue(object value)\n    {\n        // Check if the provided value matches the expected data type\n        if (value.GetType() != GetDataType())\n        {\n            throw new ArgumentException(\"Invalid data type\");\n        }\n\n        this.value = value;\n    }\n\n    public Type GetDataType()\n    {\n        switch (dataType)\n        {\n            case NM_SECURE_VAR_TYPE.S_BYTE:\n                return typeof(byte);\n            case NM_SECURE_VAR_TYPE.S_SHORT:\n                return typeof(short);\n            case NM_SECURE_VAR_TYPE.S_INT:\n                return typeof(int);\n            // ... other cases for different data types\n            default:\n                throw new InvalidOperationException(\"Invalid data type\");\n        }\n    }\n}\n```\n\nIn this example, the `SecureData` class uses the `NM_SECURE_VAR_TYPE` enum to define the type of secure variable it can hold. The `SetValue` method checks if the provided value matches the expected data type, and the `GetDataType` method returns the actual data type based on the enum value.\n\nOverall, this enum plays a crucial role in defining and managing the different types of secure variables used in the Brick-Force project. It helps to ensure data integrity and security by enforcing specific data types for secure variables.\n## Questions: \n 1. **What is the purpose of this enum?**\nThe enum `NM_SECURE_VAR_TYPE` is used to define different types of secure variables, such as byte, short, int, long, etc. It is likely used in the codebase to handle secure data storage or transmission.\n\n2. **Where is this enum used in the codebase?**\nTo understand the full context and usage of this enum, a developer might want to know where it is used in the codebase. This information would provide insights into how the different secure variable types are utilized within the project.\n\n3. **Are there any other related enums or data structures associated with this enum?**\nTo fully understand the implementation and usage of this enum, a developer might want to know if there are any other related enums or data structures that work in conjunction with `NM_SECURE_VAR_TYPE`. This information would provide a more comprehensive understanding of the secure variable system in the project.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\NM_SECURE_VAR_TYPE.md"}}],["333",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ObscuredFloatTest.cs)\n\nThe code provided is a part of the Brick-Force project and it demonstrates the usage of the ObscuredFloat class from the CodeStage.AntiCheat.ObscuredTypes namespace. The purpose of this code is to showcase how to use the ObscuredFloat class to protect sensitive float values from being easily manipulated or cheated in a game.\n\nThe ObscuredFloatTest class inherits from MonoBehaviour and contains several variables and methods. Let's go through them one by one:\n\n1. `healthBar` is a regular float variable that represents the health bar value. It is initially set to 11.4f.\n\n2. `obscuredHealthBar` is an ObscuredFloat variable that also represents the health bar value. It is initially set to 11.4f. The ObscuredFloat class provides additional security measures to protect the value from being easily accessed or modified.\n\n3. `useRegular` is a boolean variable that determines whether to use the regular float or the obscured float for manipulating the health bar value.\n\n4. `cheatingDetected` is a boolean variable that is used to track if cheating has been detected.\n\nThe Start() method is called when the script is first initialized. It sets the crypto key for the ObscuredFloat class to 404, which is used for encryption and decryption of the obscured float values. It then sets the `healthBar` variable to 99.9f and assigns its value to `obscuredHealthBar`. The encrypted value of `obscuredHealthBar` is then logged to the console.\n\nThe OnCheatingDetected() method is a callback function that is called when cheating is detected. In this case, it simply sets the `cheatingDetected` variable to true.\n\nThe UseRegular() method is called when the regular float is being used. It sets the `useRegular` variable to true and modifies the `healthBar` value by adding a random range between -10f and 50f. It also sets the `obscuredHealthBar` to 11f and logs the modified `healthBar` value to the console.\n\nThe UseObscured() method is called when the obscured float is being used. It sets the `useRegular` variable to false and modifies the `obscuredHealthBar` value by adding a random range between -10f and 50f. It also sets the `healthBar` to 11f and logs the modified `obscuredHealthBar` value to the console.\n\nOverall, this code demonstrates how to use the ObscuredFloat class to protect sensitive float values in a game. By using the ObscuredFloat class, the values are encrypted and stored in memory in an obscured form, making it difficult for cheaters to manipulate them. The code provides examples of how to use both the regular float and the obscured float for manipulating the health bar value, and it also showcases the detection of cheating through the OnCheatingDetected() callback function.\n## Questions: \n 1. What is the purpose of the ObscuredFloat class and how does it work?\n- The ObscuredFloat class is used to store sensitive float values in memory in an obscured manner. It encrypts the float value using a crypto key and provides methods for performing arithmetic operations on the obscured value.\n\n2. How does the code detect cheating and what happens when cheating is detected?\n- The code detects cheating by setting the `onCheatingDetected` delegate to the `OnCheatingDetected` method. When cheating is detected, the `cheatingDetected` variable is set to true.\n\n3. What is the difference between using the regular float (`healthBar`) and the obscured float (`obscuredHealthBar`) in this code?\n- The regular float (`healthBar`) is used for normal operations and can be directly modified. The obscured float (`obscuredHealthBar`) is used to store the obscured version of the health bar value and is modified using the ObscuredFloat class methods.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ObscuredFloatTest.md"}}],["334",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ObscuredIntTest.cs)\n\nThe code provided is a part of the Brick-Force project and is a script called \"ObscuredIntTest\". This script is responsible for testing and demonstrating the usage of the ObscuredInt class from the CodeStage.AntiCheat.ObscuredTypes namespace.\n\nThe ObscuredInt class is a data type that provides a way to store and manipulate integer values in an obscured manner, making it difficult for cheaters to modify the values during runtime. It achieves this by encrypting the integer value and storing it in memory.\n\nThe script starts by setting the initial value of the \"cleanLivesCount\" variable to 11 and the \"obscuredLivesCount\" variable to an obscured version of 11. It then logs the original lives count and how the obscured lives count is stored in memory.\n\nThe script then demonstrates the usage of various methods provided by the ObscuredInt class. It sets a new crypto key using the SetNewCryptoKey method, which is used to encrypt and decrypt the integer values. It performs several arithmetic operations on an ObscuredInt variable named \"value\", such as subtracting 10, adding 100, and dividing by 10. It also increments and decrements the value using the ++ and -- operators.\n\nThe script also sets different crypto keys before performing the increment and decrement operations, showcasing the ability to change the encryption key at runtime. This adds an extra layer of security against cheaters who may try to reverse engineer the encryption algorithm.\n\nThe script also demonstrates the usage of a callback function named \"OnCheatingDetected\", which is invoked when cheating is detected. In this case, it simply logs a message and sets the \"cheatingDetected\" variable to true.\n\nFinally, the script provides two public methods: \"UseRegular\" and \"UseObscured\". These methods allow the user to choose between using the regular integer variable \"cleanLivesCount\" or the obscured integer variable \"obscuredLivesCount\". They also modify the values by adding a random range between -10 and 50. The purpose of these methods is to show the difference in behavior between regular and obscured integer variables when attempting to modify them.\n\nIn summary, this script serves as a demonstration of the ObscuredInt class and its usage in the Brick-Force project. It showcases the ability to store and manipulate integer values in an obscured manner, providing an extra layer of security against cheating.\n## Questions: \n 1. What is the purpose of the ObscuredInt class and how does it work?\n- The ObscuredInt class is used to store an integer value in an encrypted form in memory. It provides methods to perform arithmetic operations on the encrypted value.\n\n2. How does the code detect cheating and what happens when cheating is detected?\n- The code detects cheating by calling the OnCheatingDetected method, which sets the cheatingDetected variable to true. It then logs a message indicating that cheating has been detected.\n\n3. What is the difference between using the regular integer variable cleanLivesCount and the obscured integer variable obscuredLivesCount?\n- The regular integer variable cleanLivesCount is not encrypted and can be easily modified in memory. The obscured integer variable obscuredLivesCount is encrypted and provides a level of protection against memory manipulation.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ObscuredIntTest.md"}}],["335",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ObscuredPrefsTest.cs)\n\nThe code provided is a part of the Brick-Force project and is responsible for saving and reading game data using PlayerPrefs and ObscuredPrefs. \n\nThe `OnApplicationQuit` method is called when the application is about to quit. It deletes the keys for \"money\", \"lifeBar\", \"playerName\", \"gameComplete\", \"demoLong\", \"demoDouble\", \"demoByteArray\", and \"demoVector3\" from both PlayerPrefs and ObscuredPrefs. This ensures that the saved data is cleared when the game is closed.\n\nThe `Awake` method is called when the script instance is being loaded. It sets a new encryption key for ObscuredPrefs using the value provided in the `encryptionKey` variable. This encryption key is used to encrypt and decrypt the saved data, making it more secure than using PlayerPrefs.\n\nThe `SaveGame` method is responsible for saving the game data. It takes a boolean parameter `obscured` which determines whether to use ObscuredPrefs or PlayerPrefs for saving the data. If `obscured` is true, it saves the data using ObscuredPrefs by calling various methods like `SetInt`, `SetFloat`, `SetString`, etc. These methods store the data with encryption using the provided encryption key. If `obscured` is false, it saves the data using PlayerPrefs by calling methods like `SetInt`, `SetFloat`, `SetString`, etc. These methods store the data without encryption.\n\nThe `ReadSavedGame` method is responsible for reading the saved game data. It takes a boolean parameter `obscured` which determines whether to use ObscuredPrefs or PlayerPrefs for reading the data. If `obscured` is true, it reads the data using ObscuredPrefs by calling various methods like `GetInt`, `GetFloat`, `GetString`, etc. These methods retrieve the encrypted data and decrypt it using the encryption key. If `obscured` is false, it reads the data using PlayerPrefs by calling methods like `GetInt`, `GetFloat`, `GetString`, etc. These methods retrieve the data without decryption.\n\nThe retrieved data is then stored in the `gameData` variable, which can be accessed by other parts of the project. The format of the stored data is different depending on whether ObscuredPrefs or PlayerPrefs were used.\n\nOverall, this code provides a way to save and read game data securely using encryption with ObscuredPrefs or without encryption with PlayerPrefs. It allows for the protection of sensitive game data from being easily tampered with by external sources.\n## Questions: \n 1. What is the purpose of ObscuredPrefs and how does it differ from regular PlayerPrefs?\n- ObscuredPrefs is a class that provides a way to securely store and retrieve player preferences in Unity. It differs from regular PlayerPrefs by encrypting the data to prevent easy tampering.\n\n2. What happens when the game is saved with the `obscured` parameter set to true?\n- When the game is saved with `obscured` set to true, the game data is saved using ObscuredPrefs, which encrypts the data before storing it.\n\n3. How can the saved game data be accessed and displayed?\n- The saved game data can be accessed and displayed by calling the `ReadSavedGame` method and passing in the `obscured` parameter. The method retrieves the saved data using either ObscuredPrefs or regular PlayerPrefs, depending on the value of `obscured`.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ObscuredPrefsTest.md"}}],["336",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ObscuredStringTest.cs)\n\nThe code provided is a part of the Brick-Force project and is a script called \"ObscuredStringTest\". This script is used to demonstrate the functionality of the \"ObscuredString\" class from the \"CodeStage.AntiCheat.ObscuredTypes\" namespace.\n\nThe purpose of this code is to showcase how the \"ObscuredString\" class can be used to store sensitive string data in a more secure manner. It provides two methods, \"UseRegular()\" and \"UseObscured()\", which demonstrate the difference between using a regular string and an obscured string.\n\nIn the \"Start()\" method, the script sets a new crypto key for the \"ObscuredString\" class using the \"SetNewCryptoKey()\" method. It then assigns a value to the \"cleanString\" variable and logs the original string to the console. The \"cleanString\" is then assigned to the \"obscuredString\" variable, which automatically obscures the string using the assigned crypto key. Finally, both the \"cleanString\" and \"obscuredString\" variables are set to empty strings.\n\nThe \"UseRegular()\" method sets the \"useRegular\" flag to true and assigns a value to the \"cleanString\" variable. It also sets the \"obscuredString\" to an empty string. This method demonstrates that the value of the \"cleanString\" can be easily changed in memory.\n\nThe \"UseObscured()\" method sets the \"useRegular\" flag to false and assigns a value to the \"obscuredString\" variable. It also sets the \"cleanString\" to an empty string. This method demonstrates that the value of the \"obscuredString\" cannot be easily changed in memory.\n\nOverall, this code is used to showcase the functionality of the \"ObscuredString\" class and how it can be used to store sensitive string data securely. It demonstrates the difference between using a regular string and an obscured string, highlighting the benefits of using the \"ObscuredString\" class in terms of data security.\n## Questions: \n 1. What is the purpose of the ObscuredString class and how does it work?\n- The ObscuredString class is used to store strings in an obscured form in memory. It uses a crypto key to encrypt and decrypt the string.\n\n2. How does the UseRegular() method differ from the UseObscured() method?\n- The UseRegular() method sets the useRegular variable to true and allows the cleanString to be easily changed in memory. The UseObscured() method sets the useRegular variable to false and prevents the obscuredString from being changed in memory.\n\n3. What is the significance of the SetNewCryptoKey() method and how is it used?\n- The SetNewCryptoKey() method is used to set a new crypto key for the ObscuredString class. It is called in the Start() method to set the crypto key to \"I LOVE MY GIRL\".","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ObscuredStringTest.md"}}],["337",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ObscuredVector3Test.cs)\n\nThe code provided is a part of the Brick-Force project and is a demonstration of how to use the ObscuredVector3 class from the CodeStage.AntiCheat.ObscuredTypes namespace. \n\nThe purpose of this code is to showcase the functionality of the ObscuredVector3 class, which is a secure way to store and manipulate Vector3 positions in memory. It provides a layer of encryption to prevent cheating or tampering with the position data.\n\nThe code begins by importing the necessary namespaces and defining two Vector3 variables: playerPosition and obscuredPlayerPosition. The playerPosition variable is a regular Vector3, while the obscuredPlayerPosition variable is an instance of the ObscuredVector3 class.\n\nIn the Start() method, a new crypto key is set using the ObscuredVector3.SetNewCryptoKey() method. This key is used to encrypt and decrypt the position data. The playerPosition is then updated with a new Vector3 value and assigned to the obscuredPlayerPosition variable. The encrypted position data is retrieved using the GetEncrypted() method and logged to the console.\n\nThe UseRegular() and UseObscured() methods demonstrate how to manipulate the position data using both regular Vector3 and ObscuredVector3. In the UseRegular() method, the playerPosition is updated with a random Vector3 value and the obscuredPlayerPosition is set to a fixed Vector3 value. In the UseObscured() method, the obscuredPlayerPosition is updated with a random Vector3 value and the playerPosition is set to a fixed Vector3 value. The updated position data is then logged to the console.\n\nOverall, this code demonstrates how to use the ObscuredVector3 class to securely store and manipulate Vector3 positions in memory. It provides a way to protect sensitive position data from cheating or tampering in the larger Brick-Force project.\n## Questions: \n 1. What is the purpose of the ObscuredVector3 class and how does it differ from the regular Vector3 class?\n- The ObscuredVector3 class is used to store and manipulate Vector3 positions in an obscured manner, making it harder for hackers to modify the values. It differs from the regular Vector3 class by providing encryption and decryption methods for the position values.\n\n2. How is the position stored in memory when it is obscured?\n- The position is stored in memory as an encrypted Vector3 using the GetEncrypted() method of the ObscuredVector3 class. The encrypted values are then displayed using the Debug.Log() method.\n\n3. How does the UseRegular() and UseObscured() methods affect the playerPosition and obscuredPlayerPosition variables?\n- The UseRegular() method sets the useRegular variable to true and modifies the playerPosition by adding a random Vector3. It also sets the obscuredPlayerPosition to a fixed Vector3. The UseObscured() method sets the useRegular variable to false and modifies the obscuredPlayerPosition by adding a random Vector3. It also sets the playerPosition to a fixed Vector3.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ObscuredVector3Test.md"}}],["338",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\OfficialMapOnly.cs)\n\nThe code provided is a class called `OfficialMapOnly` that extends the `Dialog` class. This class is responsible for displaying a dialog box with a message and options to the user. \n\nThe class has several private variables that define the position and size of the dialog box and its elements. These variables are of type `Rect` and are used to position and size the GUI elements in the Unity game engine.\n\nThe `DontShowThisMessageAgain` property is a public getter for the private `dontShowThisMessageAgain` variable. This property allows other classes to access the value of `dontShowThisMessageAgain` without directly modifying it.\n\nThe `Start` method is an override of the `Start` method from the `Dialog` class. It sets the `id` variable of the dialog to a specific value from an enum called `DIALOG_INDEX`. This method is likely called when the dialog is first created.\n\nThe `OnPopup` method is another override from the `Dialog` class. It sets the `rc` variable, which is of type `Rect`, to position the dialog box in the center of the screen. This method is likely called when the dialog is about to be displayed.\n\nThe `InitDialog` method is empty and does not have any functionality. It is likely a placeholder for any initialization code that may be added in the future.\n\nThe `DoDialog` method is the main method that displays the dialog box and handles user interaction. It first sets the `skin` variable to the GUI skin used by the game. It then draws a box with a blue outline using the `GUI.Box` method. The message to be displayed is retrieved from a `StringMgr` instance and displayed using the `GUI.Label` method. \n\nThe `dontShowThisMessageAgain` variable is used to create a toggle button using the `GUI.Toggle` method. This allows the user to choose whether they want to see the message again in the future.\n\nIf the user clicks the \"OK\" button, the `dontShowThisMessageAgain` variable is checked. If it is true, a `MyInfoManager` instance is used to save a specific option. Finally, the method returns `true` to indicate that the dialog has been completed.\n\nIf the dialog is not currently being displayed, the `WindowUtil.EatEvent` method is called to prevent any further input events from being processed.\n\nOverall, this code provides the functionality to display a dialog box with a message and options to the user. It can be used in the larger project to show important messages or prompts to the player.\n## Questions: \n 1. What is the purpose of the `OfficialMapOnly` class?\n- The `OfficialMapOnly` class is a subclass of `Dialog` and represents a dialog box that displays a message about official maps.\n\n2. What is the significance of the `DontShowThisMessageAgain` property?\n- The `DontShowThisMessageAgain` property is a boolean that determines whether the user has selected the option to not show the message again.\n\n3. What is the purpose of the `DoDialog` method?\n- The `DoDialog` method is responsible for rendering the dialog box and handling user interactions, such as clicking the \"OK\" button. It returns a boolean indicating whether the dialog should be closed.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\OfficialMapOnly.md"}}],["339",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\P2PMsg2Handle.cs)\n\nThe code provided defines a class called `P2PMsg2Handle`. This class is used to represent a message that is sent between peers in a peer-to-peer network. The purpose of this class is to encapsulate all the necessary information about a message, such as its ID, body, source and destination addresses, and metadata.\n\nThe class has several properties:\n- `_id`: This property represents the ID of the message. It is of type `ushort`, which is an unsigned 16-bit integer.\n- `_msg`: This property represents the body of the message. It is of type `P2PMsgBody`, which is a custom class that is not provided in the code snippet.\n- `_recvFrom`: This property represents the source address from which the message was received. It is of type `IPEndPoint`, which is a class provided by the `System.Net` namespace in .NET.\n- `_meta`: This property represents the metadata associated with the message. It is of type `ushort`.\n- `_src`: This property represents the source address of the message. It is of type `byte`.\n- `_dst`: This property represents the destination address of the message. It is also of type `byte`.\n\nThe class also has a constructor that takes in all the necessary parameters to initialize the properties of the class. This allows for easy creation of `P2PMsg2Handle` objects with the required information.\n\nThis class can be used in the larger project to handle and process messages in a peer-to-peer network. For example, when a peer receives a message, it can create a `P2PMsg2Handle` object with the received message and its associated information. This object can then be passed to other parts of the project for further processing or handling.\n\nHere is an example of how this class can be used:\n\n```csharp\n// Create a new P2PMsgBody object\nP2PMsgBody msgBody = new P2PMsgBody();\n\n// Create a new IPEndPoint object for the source address\nIPEndPoint sourceAddress = new IPEndPoint(IPAddress.Parse(\"192.168.0.1\"), 1234);\n\n// Create a new P2PMsg2Handle object\nP2PMsg2Handle msgHandle = new P2PMsg2Handle(1, msgBody, sourceAddress, 0, 1, 2);\n```\n\nIn this example, a new `P2PMsgBody` object is created and an `IPEndPoint` object is created for the source address. Then, a new `P2PMsg2Handle` object is created with the ID set to 1, the message body set to `msgBody`, the source address set to `sourceAddress`, and the metadata, source, and destination addresses set to 0, 1, and 2 respectively.\n## Questions: \n 1. What is the purpose of the `P2PMsg2Handle` class?\n- The `P2PMsg2Handle` class is used to handle peer-to-peer messages, storing information such as the message ID, body, source and destination addresses, and metadata.\n\n2. What is the significance of the `IPEndPoint` class?\n- The `IPEndPoint` class is used to represent an IP address and port number combination. In this code, it is used to store the source address and port from which the message was received.\n\n3. What is the purpose of the constructor in the `P2PMsg2Handle` class?\n- The constructor is used to initialize the instance variables of the `P2PMsg2Handle` class with the provided values.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\P2PMsg2Handle.md"}}],["340",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\P2PMsg4Recv.cs)\n\nThe code provided is a class called `P2PMsg4Recv` that is part of the Brick-Force project. This class is responsible for receiving and processing messages in a peer-to-peer network communication system.\n\nThe class has several private fields, including `_buffer`, `_io`, and `_hdr`. The `_buffer` field is an array of bytes that stores the received message data. The `_io` field keeps track of the current position in the buffer, and the `_hdr` field is an instance of the `P2PMsgHdr` class, which represents the message header.\n\nThe class provides two constructors. The first constructor initializes the `_io` field to 0, creates a new instance of `P2PMsgHdr`, and initializes the `_buffer` field with a fixed size of 4096 bytes. The second constructor does the same but also copies the content of the `src` byte array into the `_buffer` field.\n\nThe class has a method called `ExpandBuffer()` that doubles the size of the `_buffer` array when it becomes full. This method is called when the `_io` field reaches the length of the `_buffer` array.\n\nThe `GetStatus(byte recvKey)` method is used to check the status of the received message. It first checks if the buffer is full and expands it if necessary. Then, it checks if the `_io` field is less than 8, which indicates an incomplete message. If the message is complete, it calls the `FromArray()` method of the `_hdr` field to populate the header from the buffer. It then checks if the `_io` field is less than 8 plus the size of the message body. If it is, the message is still incomplete. If the `recvKey` parameter is equal to 255, it performs a CRC check on the message body to ensure data integrity. If the CRC check fails, it logs an error and returns an `INVALID` status. Otherwise, it returns a `COMPLETE` status.\n\nThe class also provides several getter methods (`GetId()`, `GetMeta()`, `GetSrc()`, `GetDst()`) to retrieve information from the message header.\n\nThe `Flush()` method is used to extract the message body from the buffer and create a new instance of the `P2PMsgBody` class. It then updates the `_io` field and shifts the remaining data in the buffer to the beginning.\n\nOverall, this class is an essential component of the Brick-Force project's peer-to-peer network communication system. It handles the receiving and processing of messages, including checking their integrity and extracting the message body for further processing.\n## Questions: \n 1. What is the purpose of the `P2PMsg4Recv` class?\n- The `P2PMsg4Recv` class is used to receive and process messages in a peer-to-peer communication system.\n\n2. What does the `MsgStatus` enum represent?\n- The `MsgStatus` enum represents the status of a received message, such as whether it is complete, incomplete, invalid, or overflowing.\n\n3. What does the `Flush` method do?\n- The `Flush` method extracts the message body from the buffer, updates the internal state of the object, and returns the extracted message body.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\P2PMsg4Recv.md"}}],["341",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\P2PMsg4Send.cs)\n\nThe code provided is a class called `P2PMsg4Send` that is part of the Brick-Force project. This class is responsible for creating and managing messages that will be sent peer-to-peer (P2P) within the project.\n\nThe class has several private fields: `_buffer`, `_io`, and `_meta`. The `_buffer` field is an array of bytes that will store the message data. The `_io` field is an integer that keeps track of the current position within the `_buffer` array. The `_meta` field is a ushort (unsigned short) that represents metadata associated with the message.\n\nThe class has a public property called `Buffer` that allows external code to access the `_buffer` field. It also has a public property called `Meta` that allows external code to access the `_meta` field.\n\nThe class has a constructor that takes several parameters: `id`, `meta`, `src`, `dst`, `msgBody`, and `sendKey`. The constructor is responsible for creating the message and populating the `_buffer` field. It does this by performing some bitwise operations on the `msgBody` and `sendKey` parameters, and then copying the resulting data into the `_buffer` field.\n\nThe class has a method called `GetStatus()` that returns the status of the message. If the `_io` field is greater than or equal to the length of the `_buffer` array, it means that the entire message has been sent and the method returns `MsgStatus.COMPLETE`. Otherwise, it returns `MsgStatus.INCOMPLETE`.\n\nOverall, this class provides functionality for creating and managing P2P messages within the Brick-Force project. It allows for the creation of messages with specific metadata and data payloads, and provides a way to check the status of a message to determine if it has been fully sent. This class can be used in the larger project to facilitate communication between different components or entities.\n## Questions: \n 1. What is the purpose of the `P2PMsg4Send` class?\n- The `P2PMsg4Send` class is used to create and manage messages for sending in a peer-to-peer communication system.\n\n2. What does the `P2PMsg4Send` constructor do?\n- The `P2PMsg4Send` constructor takes in various parameters and creates a message for sending, including calculating a checksum and encrypting the message if necessary.\n\n3. What does the `GetStatus` method do?\n- The `GetStatus` method checks if the message has been fully sent or if there is still more data to be sent, and returns the status of the message as either `COMPLETE` or `INCOMPLETE`.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\P2PMsg4Send.md"}}],["342",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\P2PMsgBody.cs)\n\nThe `P2PMsgBody` class in the `Brick-Force` project is responsible for handling the body of a peer-to-peer message. It provides methods for reading and writing different data types to and from a byte buffer.\n\nThe class has two private fields: `_offset` and `_buffer`. `_offset` keeps track of the current position in the buffer, while `_buffer` is an array of bytes that stores the message data.\n\nThe class provides several constructors. The default constructor initializes the `_offset` to 0 and creates a new byte array with a default size of 1024. Another constructor takes a source byte array, an offset, and a length as parameters. It copies the specified portion of the source array into the `_buffer` array.\n\nThe `ExpandBuffer` method is a private helper method that doubles the size of the `_buffer` array when it becomes full. It creates a new array with twice the length of the current buffer, copies the contents of the current buffer into the new array, and assigns the new array to `_buffer`.\n\nThe `Decrypt` method takes a key as a parameter and performs a bitwise XOR operation on each byte in the `_buffer` array with the key. This method is used to decrypt the message data.\n\nThe `Copy` method is another private helper method that copies a byte array into the `_buffer` array. If the length of the source array plus the current offset exceeds the length of the `_buffer` array, the `ExpandBuffer` method is called to increase the size of the buffer. The method then copies the source array into the `_buffer` array at the current offset and updates the offset accordingly.\n\nThe class also provides several `Write` methods for writing different data types to the buffer. These methods take a value of the respective data type as a parameter, convert it to a byte array using `BinaryWriter`, and then call the `Copy` method to copy the byte array into the `_buffer` array.\n\nSimilarly, the class provides several `Read` methods for reading different data types from the buffer. These methods read the respective number of bytes from the buffer using `BinaryReader` and update the offset accordingly. The read data is then converted to the respective data type and returned as an out parameter.\n\nFinally, the `GetFullPacketBuffer` method is used to construct a complete packet buffer for the message. It calculates a checksum byte by performing a bitwise XOR operation on each byte in the buffer, creates a new byte array with the appropriate size, and copies the message header and the buffer contents into the new array.\n\nOverall, the `P2PMsgBody` class provides functionality for handling the body of a peer-to-peer message, including encryption, reading and writing different data types, and constructing a complete packet buffer. It is likely used in the larger `Brick-Force` project for communication between peers.\n## Questions: \n 1. What is the purpose of the `P2PMsgBody` class?\n- The `P2PMsgBody` class is used to handle the body of a peer-to-peer message.\n\n2. What is the purpose of the `ExpandBuffer` method?\n- The `ExpandBuffer` method is used to increase the size of the `_buffer` array when it becomes full.\n\n3. What is the purpose of the `GetFullPacketBuffer` method?\n- The `GetFullPacketBuffer` method is used to construct a full packet buffer by combining the header and body of a peer-to-peer message.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\P2PMsgBody.md"}}],["343",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\P2PMsgHdr.cs)\n\nThe code provided defines a class called `P2PMsgHdr` which represents a header for a peer-to-peer message. This class is used to store and manipulate the various fields of the message header.\n\nThe `P2PMsgHdr` class has several public fields: `_size`, `_id`, `_crc`, `_meta`, `_src`, and `_dst`. These fields represent the size, ID, CRC (cyclic redundancy check), meta data, source, and destination of the message header, respectively. The `Size` field is a constant that represents the size of the header, which is 8 bytes.\n\nThe class provides two constructors: a default constructor that initializes all the fields to zero, and a parameterized constructor that allows the caller to specify the values for each field.\n\nThe class also provides two methods: `ToArray()` and `FromArray(byte[] src)`. The `ToArray()` method converts the values of the fields into a byte array representation of the header. It creates a `MemoryStream` object and a `BinaryWriter` object to write the field values into the stream. The method then returns the byte array representation of the header.\n\nThe `FromArray(byte[] src)` method does the opposite of `ToArray()`. It takes a byte array as input and converts it back into the field values of the header. It creates a `MemoryStream` object and writes the byte array into the stream. Then, it creates a `BinaryReader` object to read the field values from the stream and assigns them to the corresponding fields of the header.\n\nIn the larger project, this `P2PMsgHdr` class can be used to create and manipulate peer-to-peer message headers. It provides a convenient way to convert the header into a byte array and vice versa, which can be useful for sending and receiving messages over a network. For example, if the project involves a peer-to-peer communication protocol, this class can be used to create message headers and serialize/deserialize them for transmission.\n## Questions: \n 1. What is the purpose of the P2PMsgHdr class?\n- The P2PMsgHdr class is used to represent a header for peer-to-peer messages.\n\n2. What is the purpose of the ToArray() method?\n- The ToArray() method converts the P2PMsgHdr object into a byte array.\n\n3. What is the purpose of the FromArray() method?\n- The FromArray() method converts a byte array into a P2PMsgHdr object.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\P2PMsgHdr.md"}}],["344",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\PainSnd.cs)\n\nThe `PainSnd` class is responsible for playing audio clips in response to certain events in the game. It is a part of the larger Brick-Force project, which is a game developed using the Unity game engine.\n\nThe class has several private variables, including arrays of strings that represent different audio clips for death, crying, and hitting sounds. These arrays are populated with specific audio clip names.\n\nThe class also has a public boolean variable `isThirdPerson`, which determines whether the audio should be played in third person or not. There are also two private float variables `damageVoiceTimeout` and `deltaTime`, which are used to control the timing of playing the audio clips.\n\nThe class has several private methods, including `Start()`, `ResetDamageVoiceTimeout()`, `Update()`, `OnDeath(int manID)`, `OnHitSnd(int brickManBy)`, and `OnHitByUnknown(int hitMan)`.\n\nThe `Start()` method is called when the game starts and initializes the `audioSource` variable by getting the `AudioSource` component attached to the game object. If the `audioSource` is null, it logs an error message.\n\nThe `ResetDamageVoiceTimeout()` method resets the `deltaTime` variable to 0 and sets the `damageVoiceTimeout` to a random value between 0.7 and 1.5.\n\nThe `Update()` method is called every frame and updates the `deltaTime` variable by adding the time since the last frame.\n\nThe `OnDeath(int manID)` method is called when a character dies. It stops the currently playing audio clip if there is one. Then, it selects a random audio clip from the `deathVoc` array based on the value of `isThirdPerson` and whether the character is Yang or not. If a valid audio clip is found, it plays it using the `audioSource.PlayOneShot()` method and resets the `damageVoiceTimeout`.\n\nThe `OnHitSnd(int brickManBy)` method is called when a character is hit. It checks if enough time has passed since the last audio clip was played by comparing `deltaTime` with `damageVoiceTimeout`. If enough time has passed, it selects a random audio clip from the `hitVoc` array based on the value of `isThirdPerson` and whether the character is Yang or not. If a valid audio clip is found, it plays it using the `audioSource.PlayOneShot()` method and resets the `damageVoiceTimeout`.\n\nThe `OnHitByUnknown(int hitMan)` method is similar to `OnHitSnd(int brickManBy)`, but it is called when the character is hit by an unknown source. It selects a random audio clip from the `cryVoc` array instead of the `hitVoc` array.\n\nIn summary, this code is responsible for playing different audio clips in response to character death, hitting, and being hit events in the game. The specific audio clips played depend on various conditions such as the character's state, whether it is in third person or not, and whether it is Yang or not.\n## Questions: \n 1. What is the purpose of the `PainSnd` class?\n- The `PainSnd` class is responsible for playing audio clips for different events such as death, hit, and unknown hit.\n\n2. What is the significance of the `isThirdPerson` variable?\n- The `isThirdPerson` variable determines whether the audio clips should be played for a third-person perspective or not.\n\n3. What is the purpose of the `ResetDamageVoiceTimeout` method?\n- The `ResetDamageVoiceTimeout` method is used to reset the timeout for playing damage voice audio clips.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\PainSnd.md"}}],["345",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ParentFollow.cs)\n\nThe code provided is a script called \"ParentFollow\" that is written in C# and is a part of the larger Brick-Force project. This script is responsible for handling the behavior of a game object that follows its parent object. \n\nThe script contains several private variables, including \"hitParent\", \"Elapsedtime\", \"forceDead\", \"parentSeq\", and \"isHuman\". These variables are used to store information about the parent object, the elapsed time, whether the object is dead or not, the sequence number of the parent object, and whether the parent object is a human or not.\n\nThe script also contains three public properties: \"HitParent\", \"ParentSeq\", and \"IsHuman\". These properties allow other scripts or components to access and modify the private variables \"hitParent\", \"parentSeq\", and \"isHuman\" respectively.\n\nThe script has two methods: \"Start()\" and \"Update()\". The \"Start()\" method is empty and does not contain any code. The \"Update()\" method is called every frame and contains the main logic of the script.\n\nIn the \"Update()\" method, the script first checks if the \"forceDead\" variable is true. If it is true, the script increments the \"Elapsedtime\" variable by the time since the last frame. If the \"Elapsedtime\" is greater than 1 second, the script destroys the game object.\n\nNext, the script checks if the \"hitParent\" variable is not null. If it is not null, the script checks if the object is a human or not. If it is a human, the script retrieves the \"BrickManDesc\" object associated with the \"parentSeq\" from the \"BrickManManager\" and checks if its HP (health points) is less than or equal to 0. If it is, the script sets the \"forceDead\" variable to true.\n\nIf the object is not a human, the script retrieves the \"MonDesc\" object associated with the \"parentSeq\" from the \"MonManager\" and checks if its XP (experience points) is less than or equal to 0. If it is, the script sets the \"forceDead\" variable to true.\n\nFinally, the script sets the parent of the game object to the \"hitParent\" object.\n\nIn summary, this script allows a game object to follow its parent object and checks if the parent object is dead based on its HP or XP. If the parent object is dead, the script destroys the game object. This script is likely used in the larger Brick-Force project to handle the behavior of game objects that need to follow and interact with other objects in the game world.\n## Questions: \n 1. What is the purpose of the `ParentFollow` class?\n- The `ParentFollow` class is responsible for following a parent object and destroying itself after a certain amount of time.\n\n2. What is the significance of the `isHuman` variable?\n- The `isHuman` variable determines whether the parent object is a human or a monster.\n\n3. What is the purpose of the `forceDead` variable?\n- The `forceDead` variable is used to indicate whether the object should be destroyed.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ParentFollow.md"}}],["346",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\PCBangBenefit.cs)\n\nThe code provided defines a class called `PCBangBenefit` that is used to represent a benefit in a PC bang (a type of internet cafe popular in South Korea). The class is marked with the `[Serializable]` attribute, indicating that its instances can be serialized and deserialized.\n\nThe `PCBangBenefit` class has two properties:\n1. `texImage` of type `Texture2D`: This property represents the image associated with the benefit. It is of type `Texture2D`, which is a class in Unity that represents a 2D image. This property can be assigned an image to be displayed as the benefit's visual representation.\n2. `textKey` of type `string`: This property represents the key used to retrieve the localized text for the benefit. It is of type `string`, which is a sequence of characters. This property can be assigned a key that corresponds to the localized text for the benefit.\n\nThe purpose of this code is to provide a data structure to store information about a PC bang benefit. This class can be used in the larger project to define and manage different benefits that can be offered to PC bang users. For example, the `PCBangBenefit` instances can be used to populate a UI screen that displays the available benefits and their associated images and localized text.\n\nHere is an example of how this class can be used in code:\n\n```csharp\nPCBangBenefit benefit = new PCBangBenefit();\nbenefit.texImage = Resources.Load<Texture2D>(\"benefit_image\");\nbenefit.textKey = \"benefit_text_key\";\n```\n\nIn this example, a new `PCBangBenefit` instance is created and its `texImage` property is assigned a `Texture2D` object loaded from the \"benefit_image\" resource. The `textKey` property is assigned the key \"benefit_text_key\" that can be used to retrieve the localized text for the benefit.\n\nOverall, this code provides a simple and reusable data structure for representing PC bang benefits in the larger Brick-Force project.\n## Questions: \n 1. **What is the purpose of the `PCBangBenefit` class?**\nThe `PCBangBenefit` class appears to be a serializable class that represents a benefit for a PC bang (a type of internet cafe). It contains a texture image and a text key.\n\n2. **What type of data does the `texImage` variable store?**\nThe `texImage` variable is of type `Texture2D`, which suggests that it stores a 2D texture image.\n\n3. **What is the purpose of the `textKey` variable?**\nThe `textKey` variable is of type `string` and likely serves as a key to retrieve localized text for the benefit.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\PCBangBenefit.md"}}],["347",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\PCBangDialog.cs)\n\nThe code provided is a class called `PCBangDialog` that extends the `Dialog` class. This class is used to create a dialog box in the Brick-Force project. The purpose of this dialog box is to display information about benefits related to a PC Bang (a type of internet cafe in South Korea) to the user.\n\nThe class has several public variables that are used to reference UI elements in the dialog box, such as `imgList`, `labelList`, `exit`, `scrollView`, `outLine`, `iconOutLine`, `itemIcon`, and `itemText`. These variables are assigned in the Unity editor and are used to display images, labels, and buttons in the dialog box.\n\nThe class also has an array of `PCBangBenefit` objects called `benefitArray` and a private list of `PCBangBenefit` objects called `benefitList`. The `benefitArray` is used to store the initial benefits related to the PC Bang, while the `benefitList` is used to store the current list of benefits that will be displayed in the dialog box.\n\nThe `Start()` method is called when the dialog box is first created. It sets the `id` of the dialog box, adds UI elements to the `scrollView`, and calls the `ResetBenerfitList()` method.\n\nThe `OnPopup()` method is called when the dialog box is shown on the screen. It calculates the position of the dialog box based on the screen size.\n\nThe `InitDialog()` method is used to reset the list of PC Bang benefits. It calls the `ResetPcbangItems()` method of the `PremiumItemManager` class.\n\nThe `DoDialog()` method is called every frame to update and draw the dialog box. It first sets the GUI skin to the one obtained from `GUISkinFinder`, then it draws the image list, label list, and exit button. It then sets the count of the `scrollView` to the number of benefits in the `benefitList` and begins the scroll view. It iterates over each benefit in the `benefitList`, sets the image and text of the item in the scroll view, and draws the scroll view. Finally, it checks if there is no active popup menu and calls `WindowUtil.EatEvent()` to prevent further input events from being processed. It then restores the original GUI skin and returns the result.\n\nThe `ResetBenerfitList()` method is used to reset the `benefitList` based on the `benefitArray` and an optional array of `PCBangBenefit` objects. It first clears the `benefitList` and adds all the benefits from the `benefitArray`. If an additional array is provided, it adds all the benefits from that array as well.\n\nOverall, this code is responsible for creating and managing a dialog box that displays PC Bang benefits to the user in the Brick-Force project.\n## Questions: \n 1. What is the purpose of the `PCBangDialog` class?\n- The `PCBangDialog` class is a subclass of `Dialog` and represents a dialog box in the game.\n\n2. What is the purpose of the `Start()` method?\n- The `Start()` method is called when the dialog is first created and initializes the dialog by setting its ID and adding UI elements to the scroll view.\n\n3. What is the purpose of the `ResetBenerfitList()` method?\n- The `ResetBenerfitList()` method clears the `benefitList` and adds elements from the `benefitArray`. It also allows additional elements to be added from an input array if provided.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\PCBangDialog.md"}}],["348",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Peer.cs)\n\nThe code provided is a class called \"Peer\" that represents a peer in a networked game. It contains various properties and methods to manage the peer's status and connections with other peers.\n\nThe class has several private fields, including \"seq\" (an integer representing the sequence number of the peer), \"deltaTime\" (a float representing the time elapsed since the last update), \"localIp\" and \"localPort\" (strings representing the local IP address and port number), \"remoteIp\" and \"remotePort\" (strings representing the remote IP address and port number), \"playerFlag\" (a byte representing the player's flag), \"p2pStatus\" (an enum representing the peer-to-peer status), \"sendPingCount\" (an integer representing the number of ping messages sent), \"dicLinked\" (a dictionary that maps peer IDs to their P2P status), and \"pingTime\" (a float representing the ping time).\n\nThe class has several public properties that allow access to the private fields, such as \"Seq\" (read-only property for the sequence number), \"HolePunchingTimeout\" (read-only property that returns true if the hole punching timeout has been exceeded), \"LocalIp\" and \"LocalPort\" (properties for the local IP address and port number), \"RemoteIp\" and \"RemotePort\" (properties for the remote IP address and port number), \"PlayerFlag\" (read-only property for the player's flag), \"P2pStatus\" (property for the peer-to-peer status), \"SendPingCount\" (property for the number of ping messages sent), and \"PingTime\" (property for the ping time).\n\nThe class has a constructor that initializes the private fields with the provided values. It also initializes the \"dicLinked\" dictionary and sets the \"p2pStatus\" to \"P2P_STATUS.NONE\".\n\nThe class has several methods, including \"IsWebPlayer()\" which returns true if the player flag indicates that the peer is a web player, \"IsGM()\" which returns true if the player flag indicates that the peer is a game master, \"ForceToRelay()\" which sets the peer-to-peer status to \"P2P_STATUS.RELAY\", \"IsLinked(int with)\" which checks if the peer is linked with another peer specified by the ID, \"UpdateLink(int with, P2P_STATUS p2pStatus)\" which updates the peer's link status with another peer, and \"Update()\" which updates the peer's status and increments the delta time if the peer-to-peer status is \"P2P_STATUS.NONE\". Finally, there is an \"EndSession()\" method that clears the linked peers dictionary and resets the peer-to-peer status, delta time, and ping time.\n\nThis class is likely used in the larger project to manage the networked gameplay and communication between peers. It provides methods to check the peer's status, update the peer's connections, and handle the end of a session. Other classes in the project may interact with this class to establish and maintain peer-to-peer connections, exchange data, and manage the game state.\n## Questions: \n 1. What is the purpose of the `Peer` class?\n- The `Peer` class represents a peer in a network connection and manages its properties and status.\n\n2. What is the significance of the `P2P_STATUS` enum?\n- The `P2P_STATUS` enum represents the status of the peer in a peer-to-peer network connection, such as whether it is private, public, or using relay.\n\n3. What does the `Update()` method do?\n- The `Update()` method updates the `deltaTime` property of the `Peer` class if the `p2pStatus` is set to `P2P_STATUS.NONE`.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Peer.md"}}],["349",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\PIMP.cs)\n\nThe code provided is an enumeration called `PIMP` that defines a set of properties for a game called Brick-Force. Each property is represented by a constant value, which is an integer. \n\nThe purpose of this code is to provide a standardized set of properties that can be used throughout the game. These properties define various attributes and characteristics of different game elements, such as weapons, ammunition, and bonuses. \n\nBy using an enumeration, the code ensures that only valid property values are used in the game. It also makes the code more readable and maintainable, as developers can easily understand and reference the properties by their names instead of using raw integer values.\n\nHere is an example of how this enumeration can be used in the larger project:\n\n```java\npublic class Weapon {\n    private PIMP attackPower;\n    private PIMP accuracy;\n    private PIMP recoil;\n    // ...\n    \n    public Weapon(PIMP attackPower, PIMP accuracy, PIMP recoil) {\n        this.attackPower = attackPower;\n        this.accuracy = accuracy;\n        this.recoil = recoil;\n    }\n    \n    // ...\n}\n```\n\nIn this example, the `Weapon` class has properties for attack power, accuracy, and recoil, which are all defined using the `PIMP` enumeration. By using the enumeration, the code ensures that only valid property values are used when creating a new weapon object.\n\nOverall, this code plays a crucial role in the Brick-Force project by providing a standardized set of properties that can be used to define various attributes and characteristics of game elements. It promotes code readability, maintainability, and helps prevent errors by enforcing the use of valid property values.\n## Questions: \n 1. **What is the purpose of this code?**\nThe code defines an enum called `PIMP` which appears to represent different properties or attributes for a game object in the Brick-Force project.\n\n2. **What do the values assigned to each enum member represent?**\nThe values assigned to each enum member likely represent specific properties or attributes of the game object, such as attack power, accuracy, recoil, etc.\n\n3. **What is the significance of the `PROP_MAX` member?**\nThe `PROP_MAX` member likely represents the maximum number of properties or attributes that can be assigned to the game object.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\PIMP.md"}}],["350",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\PimpManager.cs)\n\nThe `PimpManager` class in the Brick-Force project is responsible for managing and storing data related to the \"pimp\" values of various categories, properties, and levels. The purpose of this code is to load and parse a CSV file containing the pimp values and store them in a multi-dimensional array.\n\nThe `PimpManager` class is a singleton, meaning that there can only be one instance of it in the project. The `Instance` property ensures that only one instance of the `PimpManager` class is created and provides a way to access that instance from other parts of the project.\n\nThe `Start` method initializes the `pimpVals` array with a size of 13x13x10 and then calls the `Load` method to load the pimp values from a file.\n\nThe `Load` method checks if the `loadShopTxt` flag is set to true in the `BuildOption` class. If it is true, it checks if the game is running in a web player or not. If it is running in a web player, it starts a coroutine called `LoadFromWWW` to download the pimp values from a specified URL. If it is not running in a web player, it calls the `LoadFromLocalFileSystem` method to load the pimp values from a local file.\n\nThe `LoadFromWWW` method uses the `WWW` class to download the pimp values file from a specified URL. It then reads the downloaded file using a `BinaryReader` and passes it to a `CSVLoader` class to parse the CSV data. If the parsing is successful, it calls the `ParsePimp` method to update the `pimpVals` array with the parsed values.\n\nThe `LoadFromLocalFileSystem` method checks if the \"Resources\" directory exists in the project's data path. If it does not exist, it returns false. It then constructs the path to the pimp values file and uses a `CSVLoader` class to load and parse the CSV data. If the loading is successful, it saves the parsed data to the same file in a secured format. Finally, it calls the `ParsePimp` method to update the `pimpVals` array with the parsed values.\n\nThe `ParsePimp` method iterates over each row in the parsed CSV data and extracts the category, property, level, and value information. It trims and converts the extracted values to the appropriate data types and then calls the `updateValue` method to update the corresponding element in the `pimpVals` array.\n\nOverall, the `PimpManager` class provides functionality to load and store pimp values from a CSV file. It can be used in the larger Brick-Force project to manage and access these values for various game mechanics and systems. For example, it could be used to determine the strength or effectiveness of certain items or abilities based on their pimp values.\n## Questions: \n 1. What is the purpose of the `PimpManager` class?\n- The `PimpManager` class is responsible for managing and updating values related to a pimp system.\n\n2. What is the significance of the `Load()` method?\n- The `Load()` method is responsible for loading data from a file or a web server, depending on the configuration.\n\n3. What is the purpose of the `ParsePimp()` method?\n- The `ParsePimp()` method is responsible for parsing the loaded data and updating the values in the `pimpVals` array.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\PimpManager.md"}}],["351",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\PlayerInfoMain.cs)\n\nThe code provided is a part of the Brick-Force project and is contained within the `PlayerInfoMain` class. This class is responsible for managing the player's information, specifically their nickname. \n\nThe code begins by declaring several variables to store the GUI elements' positions and properties. These variables include `guiDepth`, `crdGuide`, `crdNickname`, and `crdOk`. The `guiDepth` variable determines the layer of the GUI elements, while the `crdGuide`, `crdNickname`, and `crdOk` variables define the positions and sizes of the guide, nickname, and OK button GUI elements, respectively.\n\nThe `maxNickname` and `minNickname` variables store the maximum and minimum lengths of the player's nickname, respectively. The `nickName` variable is used to store the player's entered nickname.\n\nThe `areYouSure` variable is an instance of the `AreYouSure` class, which is used to display a confirmation dialog. The `IsCreating` property is a setter that sets the value of the `Yes` property of the `areYouSure` instance.\n\nThe `Start` method initializes the `areYouSure` variable to null.\n\nThe `CheckInput` method is responsible for validating the player's entered nickname. It trims any leading or trailing whitespace from the nickname and checks its length. If the nickname is empty or shorter than the minimum length, an error message is displayed using the `MessageBoxMgr` class. Additionally, the method checks if the nickname contains any bad words using the `WordFilter` class. If a bad word is detected, an error message is displayed.\n\nThe `OnGUI` method is called to render the GUI elements on the screen. It sets the GUI depth, skin, and enables the GUI elements if there are no modal dialogs displayed. It then renders a GUI box that covers the entire screen. The GUI elements are rendered within a group that is centered on the screen. The guide text is displayed using the `GUI.Label` method, and the player's nickname is entered using the `GUI.TextField` method. The entered nickname is then processed to remove any special characters if the game is built with the Axeso5 option enabled. Finally, when the OK button is clicked, the `CheckInput` method is called to validate the nickname, and if the validation passes, a confirmation dialog is displayed using the `DialogManager` class.\n\nThe `Update` method is empty and does not contain any code.\n\nThe `RemoveSpecialCharacters` method is a helper method that removes any special characters from the input string. It iterates over each character in the input string and checks if it is a digit or a letter. If it is, the character is appended to a `StringBuilder`. The method then returns the resulting string with the special characters removed.\n\nOverall, this code manages the player's nickname input and validation, and displays the necessary GUI elements to allow the player to enter their nickname. It also handles the removal of special characters from the nickname if the game is built with the Axeso5 option enabled.\n## Questions: \n 1. What is the purpose of the `PlayerInfoMain` class?\n- The `PlayerInfoMain` class is responsible for handling player information and input related to creating a character.\n\n2. What is the significance of the `crdGuide`, `crdNickname`, and `crdOk` variables?\n- These variables represent the coordinates and dimensions of GUI elements used for displaying a guide, entering a nickname, and confirming the input, respectively.\n\n3. What is the purpose of the `CheckInput` method?\n- The `CheckInput` method validates the entered nickname and displays error messages if the input is empty, too short, or contains a bad word.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\PlayerInfoMain.md"}}],["352",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\PlayerList4BungeeFrame.cs)\n\nThe code provided is a class called \"PlayerList4BungeeFrame\" that is used in the larger Brick-Force project. This class is responsible for managing and displaying the player list in a game room. \n\nThe class contains various variables that define the positions and sizes of different UI elements, such as player portraits, badges, clan marks, and player names. These variables are used to position and display the UI elements correctly on the screen.\n\nThe class has several methods that perform different actions. The \"Start\" method is called when the player list is initialized. It creates a new instance of the \"BrickManDesc\" class, which represents a player's information, such as their nickname, status, clan information, and rank. It then checks if the player's information is already present in the \"BrickManManager\" class, which manages all the players in the game. If the player's information is not present, it adds the player to the manager.\n\nThe \"Close\" method is called when the player list is closed. It removes the player's information from the \"BrickManManager\" class.\n\nThe \"ResetMyPlayerStyle\" method is called when the player wants to reset their player style. It removes the player's information from the \"BrickManManager\" class and creates a new instance of the \"BrickManDesc\" class with the updated player information. It then adds the player to the manager again.\n\nThe \"OnGUI\" method is responsible for rendering the player list UI on the screen. It first retrieves the current game room from the \"RoomManager\" class and displays the room title using the \"LabelUtil.TextOut\" method. It then retrieves an array of \"BrickManDesc\" objects from the \"BrickManManager\" class and iterates over them to display each player's information using the \"aPlayer\" method.\n\nThe \"aPlayer\" method is responsible for rendering a single player's information on the screen. It takes a rectangle representing the position and size of the player's UI element, a \"BrickManDesc\" object representing the player's information, and a boolean indicating whether the player is on the red team or not. It then renders various UI elements such as the player's status, clan mark, badge, nickname, and clan name using the \"LabelUtil.TextOut\" and \"TextureUtil.DrawTexture\" methods.\n\nOverall, this code manages the player list UI in a game room and displays the information of each player in the room. It interacts with other classes such as the \"BrickManManager\", \"RoomManager\", and \"ClanMarkManager\" to retrieve and update player information.\n## Questions: \n 1. What is the purpose of the `Start()` method in the `PlayerList4BungeeFrame` class?\n- The `Start()` method initializes the `myDesc` variable with information from `MyInfoManager.Instance` and adds a `BrickMan` to `BrickManManager.Instance` if it doesn't already exist.\n\n2. What does the `Close()` method do in the `PlayerList4BungeeFrame` class?\n- The `Close()` method removes the `BrickMan` with the same sequence as `MyInfoManager.Instance.Seq` from `BrickManManager.Instance`.\n\n3. What is the purpose of the `aPlayer()` method in the `PlayerList4BungeeFrame` class?\n- The `aPlayer()` method is responsible for rendering the UI elements for a player, including their status, nickname, clan information, and portrait.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\PlayerList4BungeeFrame.md"}}],["353",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\PlayerList4DefenseFrame.cs)\n\nThe code provided is a class called \"PlayerList4DefenseFrame\" that is used in the larger Brick-Force project. This class is responsible for displaying and managing the player list for a defense frame in the game.\n\nThe class contains various variables that define the positions and sizes of different UI elements, such as player icons, buttons, and labels. These variables are used to calculate the positions and sizes of these elements on the screen.\n\nThe class has several methods that perform different actions. The \"Start\" method is called when the player list is initialized. It creates a new instance of the \"BrickManDesc\" class, which represents a player's description, using information from the \"MyInfoManager\" class. It then checks if the player's instance exists in the game and adds it if it doesn't.\n\nThe \"Close\" method is called when the player list is closed. It removes the player's instance from the game.\n\nThe \"ResetMyPlayerStyle\" method is called when the player's style needs to be reset. It removes the player's instance from the game and creates a new instance of the \"BrickManDesc\" class using updated information from the \"MyInfoManager\" class. It then adds the new instance to the game.\n\nThe \"OnGUI\" method is responsible for rendering the player list UI. It first draws a vertical line using the \"GUI.Box\" method. It then retrieves the current room information from the \"RoomManager\" class and displays it as a label using the \"LabelUtil.TextOut\" method.\n\nNext, it retrieves an array of \"BrickManDesc\" instances from the \"BrickManManager\" class and iterates over them. For each instance, it calculates the position of the player's icon based on the player's slot and whether they are on the blue or red team. It then calls the \"aPlayer\" method to render the player's icon and other UI elements.\n\nThe \"aPlayer\" method is responsible for rendering a single player's icon and other UI elements. It first checks if the player is the master of the room and sets a flag accordingly. It then checks if the player is the current player and updates their status if necessary.\n\nIt then checks if the player is the master and if the right mouse button is clicked. If both conditions are met, it sends a kick request to the server using the \"CSNetManager\" class.\n\nNext, it checks if the player's icon is clicked and if the right mouse button is clicked. If both conditions are met, it opens a context menu using the \"ContextMenuManager\" class.\n\nIt then renders the player's status label based on their status using the \"LabelUtil.TextOut\" method. It also renders the player's clan mark, badge, nickname, and clan name using the appropriate methods and classes.\n\nFinally, it checks if the player is the master and renders a tiny master icon if they are.\n\nIn summary, this code is responsible for rendering and managing the player list UI for a defense frame in the Brick-Force game. It retrieves player information, calculates the positions of UI elements, and handles user interactions such as clicking on player icons and context menus.\n## Questions: \n 1. What is the purpose of the `Start()` method?\n- The `Start()` method initializes the `myDesc` variable with information from `MyInfoManager.Instance` and adds a `BrickMan` to the `BrickManManager` if it doesn't already exist.\n\n2. What does the `Close()` method do?\n- The `Close()` method removes the `BrickMan` with the same sequence as `MyInfoManager.Instance` from the `BrickManManager`.\n\n3. What is the purpose of the `OnGUI()` method?\n- The `OnGUI()` method is responsible for rendering the player list UI, including buttons, labels, and textures for each player in the room.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\PlayerList4DefenseFrame.md"}}],["354",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\PlayerList4IndividualFrame.cs)\n\nThe code provided is a class called \"PlayerList4IndividualFrame\" that is part of the Brick-Force project. This class is responsible for managing and displaying the player list for an individual frame in the game.\n\nThe class contains several member variables that store various textures, vectors, and rectangles used for positioning and rendering the player list elements. These variables include textures for different weapon types, a locked texture, and various vectors and rectangles for positioning different elements within the player list.\n\nThe class also has a reference to a BrickManDesc object called \"myDesc\" and a Start() method that initializes this object with information about the player. The Start() method retrieves the player's information from the MyInfoManager.Instance and creates a BrickManDesc object with that information. It then checks if the player's GameObject exists in the BrickManManager.Instance and adds it if it doesn't.\n\nThe class also has a ResetMyPlayerStyle() method that removes the player's information from the BrickManManager.Instance and creates a new BrickManDesc object with updated information from the MyInfoManager.Instance. It then adds the new BrickManDesc object to the BrickManManager.Instance.\n\nThe class also has an OnGUI() method that is responsible for rendering the player list on the screen. It first retrieves the current room from the RoomManager.Instance and displays the room title using the LabelUtil.TextOut() method. It then retrieves an array of BrickManDesc objects from the BrickManManager.Instance and iterates over them to render each player's information using the aPlayer() method.\n\nThe aPlayer() method is responsible for rendering an individual player's information. It takes a Rect object and a BrickManDesc object as parameters. It first checks if the player is the master of the room and sets a flag accordingly. It then renders a box with the player's information using the GUI.Box() method. It displays the player's status, nickname, clan name, clan mark, and portrait using various LabelUtil.TextOut() and TextureUtil.DrawTexture() methods. It also handles button clicks for kicking a player or opening a context menu for a player.\n\nOverall, this class manages the rendering and interaction of the player list for an individual frame in the game. It retrieves player information from the MyInfoManager.Instance and uses it to create and update BrickManDesc objects in the BrickManManager.Instance. It then renders the player list on the screen using the OnGUI() method.\n## Questions: \n 1. What is the purpose of the `Start()` method in the `PlayerList4IndividualFrame` class?\n- The `Start()` method initializes a `BrickManDesc` object with information from `MyInfoManager.Instance` and adds it to the `BrickManManager` if it doesn't already exist.\n\n2. What is the purpose of the `OnGUI()` method in the `PlayerList4IndividualFrame` class?\n- The `OnGUI()` method is responsible for rendering the GUI elements for each player in the game, including their status, nickname, clan information, and portrait.\n\n3. What is the purpose of the `ResetMyPlayerStyle()` method in the `PlayerList4IndividualFrame` class?\n- The `ResetMyPlayerStyle()` method removes the current player's `BrickManDesc` from the `BrickManManager`, creates a new `BrickManDesc` object with updated information from `MyInfoManager.Instance`, and adds it back to the `BrickManManager`.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\PlayerList4IndividualFrame.md"}}],["355",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\PlayerList4TeamFrame.cs)\n\nThe code provided is a class called PlayerList4TeamFrame. This class is responsible for managing and displaying the player list for a team in the game. It contains various properties and methods that handle the logic for displaying and interacting with the player list.\n\nThe class has several properties of type Texture2D that represent different icons and images used in the player list. These include icons for the team master, different types of weapons, and a locked icon. There are also several Vector2 and Rect variables that define the positions and sizes of various elements in the player list.\n\nThe class has a Start() method that is called when the player list is initialized. It creates a new BrickManDesc object, which represents a player in the game, using information from the MyInfoManager class. It then checks if the player is already in the BrickManManager, which manages all the players in the game. If the player is not found, it adds the player to the BrickManManager.\n\nThe class also has a ResetMyPlayerStyle() method that is called when the player's style needs to be reset. It removes the player from the BrickManManager and creates a new BrickManDesc object with updated information from the MyInfoManager. It then adds the player back to the BrickManManager.\n\nThe Close() method is called when the player list is closed. It removes the player from the BrickManManager.\n\nThe OnGUI() method is responsible for drawing the player list on the screen. It first sets the main text color to a specific color. It then gets the current room from the RoomManager and displays the room title using the LabelUtil.TextOut() method. \n\nNext, it gets an array of BrickManDesc objects from the BrickManManager and iterates over them to display each player in the player list. It checks if the player is in the current team and if the player is the current player. If so, it displays a selected button for the player. It then displays the player's status, clan mark, nickname, and clan name using the LabelUtil.TextOut() method. It also displays the player's portrait using the BrickManManager and the player's level badge using the XpManager.\n\nThe class also has a few helper methods, such as DrawClanMark() and aPlayer(), that are used to draw specific elements of the player list.\n\nOverall, this class is an important component of the Brick-Force project as it manages and displays the player list for a team in the game. It handles the logic for adding, removing, and updating players in the player list, as well as displaying their information and allowing interaction with the players.\n## Questions: \n 1. What is the purpose of the `Start()` method in the `PlayerList4TeamFrame` class?\n- The `Start()` method initializes a `BrickManDesc` object and adds it to the `BrickManManager` if it doesn't already exist.\n\n2. What does the `ResetMyPlayerStyle()` method do?\n- The `ResetMyPlayerStyle()` method removes the current `BrickManDesc` object from the `BrickManManager`, creates a new `BrickManDesc` object with updated information, and adds it back to the `BrickManManager`.\n\n3. What is the purpose of the `DrawClanMark()` method?\n- The `DrawClanMark()` method is responsible for drawing the clan mark of a player on the GUI using the provided `Rect` and mark index.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\PlayerList4TeamFrame.md"}}],["356",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\PlayerProperty.cs)\n\nThe code provided is a part of the Brick-Force project and is contained within the `PlayerProperty` class. This class is responsible for managing the properties and behavior of a player in the game.\n\nThe `PlayerProperty` class has a public property called `Desc` of type `BrickManDesc`. This property represents the description of the player and is used to store information about the player's characteristics, such as their name, health, and abilities.\n\nThe class also has a private field called `invisiblePosition` of type `Vector3`. This field is used to store the position of the player when they are invisible. The `InvisiblePosition` property provides access to this field, allowing other classes to get and set the invisible position of the player.\n\nThe class has a public method called `IsHostile()`, which returns a boolean value indicating whether the player is hostile or not. This method checks if the `Desc` property is null and if not, it calls the `IsHostile()` method of the `BrickManDesc` class to determine the hostility status of the player. If the `Desc` property is null, it returns false.\n\nThis code is likely used in the larger Brick-Force project to manage the properties and behavior of players in the game. It allows other classes to access and modify the player's description and invisible position, as well as check if the player is hostile. For example, other classes may use the `IsHostile()` method to determine if a player should be targeted or avoided in combat scenarios.\n\nHere is an example of how this code might be used in the larger project:\n\n```csharp\nPlayerProperty player = new PlayerProperty();\nplayer.Desc = new BrickManDesc(\"John\", 100, Abilities.None);\nplayer.InvisiblePosition = new Vector3(0, 0, 0);\n\nbool isHostile = player.IsHostile(); // Returns false\n\nplayer.Desc = null;\n\nisHostile = player.IsHostile(); // Returns false\n```\n\nIn this example, a new `PlayerProperty` object is created and assigned a `BrickManDesc` object representing a player named \"John\" with 100 health and no abilities. The invisible position of the player is set to (0, 0, 0). The `IsHostile()` method is then called to check if the player is hostile, which returns false. Finally, the `Desc` property is set to null and the `IsHostile()` method is called again, still returning false.\n## Questions: \n 1. **What is the purpose of the `BrickManDesc` class and how is it related to the `PlayerProperty` class?**\nThe `BrickManDesc` class is likely a class that contains properties and methods specific to a brick man character. The `Desc` property in the `PlayerProperty` class is of type `BrickManDesc` and is used to store an instance of this class.\n\n2. **What is the significance of the `InvisiblePosition` property and how is it used?**\nThe `InvisiblePosition` property is used to get and set the position of the player when they are invisible. It is likely used to control the behavior or appearance of the player when they are in an invisible state.\n\n3. **What does the `IsHostile()` method do and how is it determined if the player is hostile?**\nThe `IsHostile()` method likely checks if the player is in a hostile state. It returns `true` if the `Desc` property is not null and the `IsHostile()` method of the `Desc` object returns `true`, otherwise it returns `false`. The specific logic for determining if the player is hostile would be implemented in the `IsHostile()` method of the `BrickManDesc` class.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\PlayerProperty.md"}}],["357",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\PlaySound.cs)\n\nThe code provided is a class called `PlaySound` that extends the `ScriptCmd` class. This class is responsible for playing a sound in the larger Brick-Force project. \n\nThe `PlaySound` class has a private integer variable called `index`, which represents the index of the sound to be played. It also has a public property called `Index` that allows getting and setting the value of the `index` variable.\n\nThe `PlaySound` class overrides several methods from the `ScriptCmd` class. \n\nThe `GetDescription` method returns a string that describes the action of playing a sound. It concatenates the string \"playsound\" with the first element of the `ArgDelimeters` array (which is a delimiter used for separating arguments in the script) and the value of the `index` variable converted to a string.\n\nThe `GetIconIndex` method returns an integer representing the index of the icon associated with the `PlaySound` command. In this case, it always returns 2.\n\nThe `GetDefaultDescription` method returns a string that describes the default action of playing a sound. It concatenates the string \"playsound\" with the first element of the `ArgDelimeters` array and the string \"-1\".\n\nThe `GetName` method returns a string representing the name of the command, which is \"PlaySound\".\n\nOverall, this code provides a way to play a sound in the Brick-Force project. It allows specifying the index of the sound to be played and provides methods to get the description, icon index, default description, and name of the command. This class can be used in the larger project to handle sound-related functionality, such as triggering sound effects during gameplay or in response to certain events.\n## Questions: \n 1. What is the purpose of the `PlaySound` class?\n- The `PlaySound` class is a subclass of `ScriptCmd` and is used to represent a command to play a sound.\n\n2. What is the significance of the `Index` property?\n- The `Index` property is used to get or set the index of the sound to be played.\n\n3. What is the purpose of the `GetDefaultDescription` method?\n- The `GetDefaultDescription` method returns a default description for the `PlaySound` command, which includes the command name and a default index value.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\PlaySound.md"}}],["358",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\PoisonInfo.cs)\n\nThe code provided defines a struct called `PoisonInfo` that is used to store information about a poison effect in the Brick-Force project. The struct is marked as `[Serializable]`, which means that its data can be converted into a format that can be stored or transmitted, such as JSON or binary.\n\nThe `PoisonInfo` struct has two fields:\n1. `timer` - a float value that represents the duration of the poison effect.\n2. `pos` - a Vector3 value that represents the position of the poison effect in the game world.\n\nThis struct is likely used in the larger Brick-Force project to keep track of poison effects applied to game objects or characters. For example, when a character is poisoned, an instance of `PoisonInfo` can be created and assigned to the character. The `timer` field can be used to determine how long the poison effect should last, and the `pos` field can be used to store the position of the poison effect in the game world.\n\nHere's an example of how this struct might be used in code:\n\n```csharp\npublic class Character : MonoBehaviour\n{\n    public PoisonInfo poisonEffect;\n\n    public void ApplyPoison(Vector3 position, float duration)\n    {\n        poisonEffect = new PoisonInfo\n        {\n            timer = duration,\n            pos = position\n        };\n\n        // Apply poison effect to character\n    }\n}\n```\n\nIn this example, the `Character` class has a `poisonEffect` field of type `PoisonInfo`. The `ApplyPoison` method takes a position and duration as parameters and creates a new `PoisonInfo` instance with the provided values. The `poisonEffect` field is then assigned this new instance, allowing the character to be affected by the poison effect.\n\nOverall, the `PoisonInfo` struct provides a convenient way to store and manage information about poison effects in the Brick-Force project.\n## Questions: \n 1. **What is the purpose of the `PoisonInfo` struct?**\nThe `PoisonInfo` struct is used to store information about poison, including a timer and a position in 3D space.\n\n2. **What is the significance of the `[Serializable]` attribute?**\nThe `[Serializable]` attribute indicates that the `PoisonInfo` struct can be serialized and deserialized, allowing it to be easily stored or transmitted.\n\n3. **What is the purpose of the `using UnityEngine;` statement?**\nThe `using UnityEngine;` statement imports the `UnityEngine` namespace, which provides access to various Unity-specific classes and functions that may be used in the code.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\PoisonInfo.md"}}],["359",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\PostEffectSwitch.cs)\n\nThe code provided is a part of the Brick-Force project and is responsible for controlling a post-processing effect called \"BloomAndFlares\" in the Unity game engine. \n\nThe `PostEffectSwitch` class is a MonoBehaviour script that is attached to a game object in the scene. It contains two methods: `Start()` and `Update()`. \n\nIn the `Start()` method, the script attempts to get the `BloomAndFlares` component attached to the same game object. If the component is found, it enables or disables the component based on the current quality level set in the Unity editor. \n\nThe `GetComponent<BloomAndFlares>()` method is used to retrieve the `BloomAndFlares` component from the game object. If the component is found, it is assigned to the `component` variable. \n\nThe `QualitySettings.GetQualityLevel()` method is then called to get the current quality level set in the Unity editor. The `>= 3` comparison checks if the quality level is greater than or equal to 3. If it is, the `enabled` property of the `BloomAndFlares` component is set to `true`, enabling the post-processing effect. If the quality level is less than 3, the `enabled` property is set to `false`, disabling the effect. \n\nThe `Update()` method is empty and does not contain any code. It is likely left empty intentionally, as there is no need for any continuous updates or calculations in this script. \n\nOverall, this script is responsible for enabling or disabling the \"BloomAndFlares\" post-processing effect based on the quality level set in the Unity editor. It is likely used in the larger Brick-Force project to control the visual effects of the game and provide different levels of graphical fidelity based on the user's hardware capabilities.\n## Questions: \n 1. **What does the `BloomAndFlares` component do?**\nThe smart developer might want to know the purpose and functionality of the `BloomAndFlares` component in order to understand its role in the code.\n\n2. **What is the significance of `QualitySettings.GetQualityLevel() >= 3`?**\nThe developer might be curious about why the code is checking if the quality level is greater than or equal to 3 and how it affects the `enabled` property of the `BloomAndFlares` component.\n\n3. **Why is the `Update()` method empty?**\nThe developer might wonder why the `Update()` method is present but does not contain any code, as it is a common method used for updating game logic.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\PostEffectSwitch.md"}}],["360",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\PremiumItemManager.cs)\n\nThe `PremiumItemManager` class is responsible for managing premium items and PCBang items in the larger Brick-Force project. It provides methods to set, reset, and retrieve these items.\n\nThe class has several member variables:\n- `premiumItems` and `pcbangItems` are arrays of strings that store the codes of premium and PCBang items, respectively.\n- `FakePremiumItems` and `FakePcbangItems` are arrays of `Item` objects that represent the fake premium and PCBang items created in the game.\n- `StartItemIndex` is a long integer that represents the starting index for creating fake items.\n- `_instance` is a static instance of the `PremiumItemManager` class, used for accessing the manager from other parts of the project.\n\nThe class has a public static property `Instance` that provides a singleton instance of the `PremiumItemManager`. This ensures that there is only one instance of the manager throughout the project.\n\nThe `Awake` method is called when the object is initialized and ensures that the manager is not destroyed when a new scene is loaded.\n\nThe `SetPremiumItems` and `SetPCBangItems` methods are used to set the premium and PCBang items, respectively. These methods take an array of strings as input and update the corresponding member variables. They also call the `ResetPremiumItems` and `ResetPcbangItems` methods to reset the fake items.\n\nThe `ResetPremiumItems` and `ResetPcbangItems` methods are responsible for creating and resetting the fake premium and PCBang items. They first check if there are any existing fake items and erase them. Then, based on the player's account status (premium or not) and PCBang buff status, they create new fake items using the codes provided in the `premiumItems` and `pcbangItems` arrays. These fake items are stored in the `FakePremiumItems` and `FakePcbangItems` arrays, respectively.\n\nThe `GetPremiumItems` and `GetPcbangItems` methods return the fake premium and PCBang items, respectively. If the fake items have not been created yet, these methods call the corresponding reset methods to create them.\n\nThe `IsPremiumItem` method checks if a given item code is a premium item. It iterates through the `premiumItems` array and returns true if a match is found.\n\nOverall, the `PremiumItemManager` class provides functionality to manage premium and PCBang items in the Brick-Force project. It allows for setting, resetting, and retrieving these items, as well as checking if a given item code is a premium item.\n## Questions: \n **Question 1:** What is the purpose of the `Awake()` and `Start()` methods in the `PremiumItemManager` class?\n    \n**Answer:** The `Awake()` method is used to prevent the `PremiumItemManager` object from being destroyed when a new scene is loaded. The `Start()` method is currently empty and does not have any functionality.\n\n**Question 2:** What is the purpose of the `ResetPremiumItems()` and `ResetPcbangItems()` methods?\n    \n**Answer:** The `ResetPremiumItems()` method is used to reset the `FakePremiumItems` array based on the `premiumItems` array. It also updates the `MyInfoManager` with the new items. The `ResetPcbangItems()` method performs a similar function for the `FakePcbangItems` array and updates the `MyInfoManager` accordingly.\n\n**Question 3:** What is the purpose of the `IsPremiumItem()` method?\n    \n**Answer:** The `IsPremiumItem()` method checks if a given item code is present in the `premiumItems` array and returns a boolean value indicating whether it is a premium item or not.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\PremiumItemManager.md"}}],["361",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\PresentConfirmDialog.cs)\n\nThe code provided is a class called \"PresentConfirmDialog\" that extends the \"Dialog\" class. This class is used to create a dialog box for confirming the purchase and presentation of a gift item in the larger Brick-Force project.\n\nThe class has several private variables including \"good\", \"tItem\", \"buyHow\", \"selected\", \"receiver\", \"title\", \"contents\", \"fpIcon\", \"bpIcon\", \"crdTitle\", \"crdCloseBtn\", \"crdOutline\", \"crdMoneyIcon\", \"crdPresent\", \"autoChargeConfirm\", and \"crdSure\". These variables are used to store information about the gift item, the purchase method, the selected option, the receiver, the title and contents of the gift, and various coordinates and textures used for rendering the dialog box.\n\nThe class has a method called \"ShowPresent()\" which is responsible for rendering the gift item and its details inside the dialog box. It uses the \"GUI\" class to draw various textures and labels on the screen based on the stored information.\n\nThe class also overrides several methods from the base \"Dialog\" class. The \"Start()\" method sets the ID of the dialog box, and the \"OnPopup()\" method sets the position of the dialog box on the screen. The \"DoDialog()\" method is responsible for rendering the entire dialog box and handling user interactions. It uses the \"GUI\" class to draw labels, buttons, and other UI elements on the screen. It also sends a network request to present the gift item when the \"PRESENT\" button is clicked.\n\nThe class also has two \"InitDialog()\" methods that are used to initialize the variables of the class with the provided values.\n\nOverall, this class is an important component of the Brick-Force project as it provides a user interface for confirming the purchase and presentation of gift items. It handles rendering the dialog box and sending network requests to complete the transaction.\n## Questions: \n 1. What is the purpose of the `PresentConfirmDialog` class?\n- The `PresentConfirmDialog` class is a subclass of the `Dialog` class and is used to display a confirmation dialog for presenting an item to another player in the game.\n\n2. What are the parameters of the `InitDialog` method and how are they used?\n- The `InitDialog` method has parameters for a `Good` object, a `Good.BUY_HOW` enum value, an integer for selection, strings for receiver, title, and contents, and an optional string for extra confirmation. These parameters are used to initialize the dialog with the necessary information for presenting an item.\n\n3. What happens when the `PRESENT` button is clicked?\n- When the `PRESENT` button is clicked, the `CSNetManager.Instance.Sock.SendCS_PRESENT_ITEM_REQ` method is called to send a request to the server to present the selected item to the specified receiver. The method returns `true` to indicate that the dialog should be closed.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\PresentConfirmDialog.md"}}],["362",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\PriceTag.cs)\n\nThe code provided is for a class called `PriceTag` in the Brick-Force project. This class represents a price tag for a particular item or option in the game. It contains various properties and methods to handle the pricing and availability of the item.\n\nThe `PriceTag` class has several private variables, including `option`, `point`, `cash`, `cashBack`, `brick`, `pointDiscount`, `brickDiscount`, `cashDiscount`, `dscntStart`, `dscntEnd`, `vsblStart`, and `vsblEnd`. These variables store information about the pricing and availability of the item.\n\nThe class has several public properties that provide access to these private variables. For example, the `IsVisible` property returns a boolean value indicating whether the item is currently visible or not. The `IsDiscount` property returns a boolean value indicating whether the item is currently on discount or not. The `Point`, `Cash`, and `Brick` properties return the respective prices of the item, taking into account any discounts that may be applicable.\n\nThe class also has several methods to check if the item can be purchased. The `CanBuy` method takes a parameter `buyHow` of type `Good.BUY_HOW` and returns a boolean value indicating whether the item can be purchased using the specified method. There is an overloaded version of this method that takes an additional `rebuy` parameter, which is used to check if the item can be repurchased.\n\nThe `OnEverySec` method is called periodically and updates the start and end times for discounts and visibility of the item.\n\nThe `GetOptionString` method returns a string representation of the item's options, including the remaining quantity and the unit of measurement. The `GetRemainString` method returns a string representation of the remaining quantity of the item.\n\nThe `GetPriceString` method returns a string representation of the price of the item, taking into account any discounts. The `GetPrice` method returns the price of the item, taking into account any discounts and a specified percentage.\n\nOverall, the `PriceTag` class provides functionality to handle the pricing, availability, and purchasing of items in the Brick-Force game. It allows for checking if an item can be purchased, getting the price and remaining quantity of an item, and handling discounts and visibility.\n## Questions: \n 1. **Question:** What is the purpose of the `PriceTag` class?\n   - **Answer:** The `PriceTag` class represents a price tag for a specific item or option, and it contains information about the original price, discounts, visibility, and availability for purchase.\n\n2. **Question:** How does the `CanBuy` method determine if an item can be purchased?\n   - **Answer:** The `CanBuy` method checks the `IsVisible` property and the quantity of the item (Point, Brick, or Cash) to determine if it is available for purchase. It also checks if the `option` value is less than 1000000 when the `rebuy` parameter is true.\n\n3. **Question:** What is the purpose of the `GetOptionString` method?\n   - **Answer:** The `GetOptionString` method returns a string representation of the remaining quantity of an item (Point, Brick, or Cash) after applying a discount percentage. It also includes the unit of measurement (e.g., \"POINT\", \"BRICK_POINT\", or the token string).","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\PriceTag.md"}}],["363",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\PrjFlashBang.cs)\n\nThe code provided is a class called `PrjFlashBang` that inherits from the `Projectile` class. This class represents a flashbang projectile in the larger Brick-Force project. \n\nThe `Update` method is responsible for updating the state of the flashbang projectile every frame. It first increments the `deltaTime` variable by the time since the last frame. Then, it increments the `DetonatorTime` variable by the time since the last frame. If the `DetonatorTime` exceeds the `explosionTime`, it triggers the explosion by instantiating an explosion object at the current position of the projectile. It also calls a method in the `GlobalVars` class to switch on the flashbang effect and sends a network message using the `P2PManager` class to notify other players about the explosion. If there is a `projectileAlert` object, it removes the mine associated with the projectile. Finally, it destroys the game object of the projectile.\n\nIf the `DetonatorTime` does not exceed the `explosionTime`, the code checks if the `deltaTime` exceeds the `SendRate` property from the `BuildOption` class. If it does, it resets the `deltaTime` to 0 and sends a network message using the `P2PManager` class to update the position and rotation of the projectile. If there is a `projectileAlert` object, it tracks the mine associated with the projectile.\n\nThe `FixedUpdate` method is responsible for applying a torque force to the projectile's rigidbody component. This causes the projectile to rotate around the right axis.\n\nThe `Start` method is called when the projectile is first created. It checks if the `useUskWeaponTex` property from the `BuildOption` class is true. If it is, it retrieves all the `MeshRenderer` components attached to the projectile and checks if their main texture is not null and exists in the `UskManager` class. If it does, it replaces the main texture with the corresponding texture from the `UskManager`.\n\nOverall, this code manages the behavior of a flashbang projectile in the Brick-Force project. It handles the detonation, updating position and rotation, and texture management.\n## Questions: \n 1. What is the purpose of the `PrjFlashBang` class and how does it relate to the rest of the project? \n- The `PrjFlashBang` class is a subclass of the `Projectile` class and is used to handle the behavior of a flashbang projectile. It is likely used in the game's weapon system.\n\n2. What is the significance of the `weaponBY` variable and how is it used in the code? \n- The `weaponBY` variable is of type `Weapon.BY` and is likely used to determine the type or category of the weapon associated with the flashbang projectile. It is used in the `projectileAlert.TrackMine()` method call.\n\n3. What is the purpose of the `FixedUpdate()` method and how does it affect the behavior of the flashbang projectile? \n- The `FixedUpdate()` method is used to apply a torque force to the flashbang projectile's rigidbody component, causing it to rotate. This may be used to simulate a spinning motion for the projectile.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\PrjFlashBang.md"}}],["364",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\PrjGrenade.cs)\n\nThe code provided is a class called `PrjGrenade` that extends the `Projectile` class. This class represents a grenade projectile in the game. \n\nThe `PrjGrenade` class has several private fields including `radius`, `atkPow`, `rigidity`, `weaponBy`, `weaponByForChild`, `durability`, and `durabilityMax`. These fields store various properties of the grenade such as its explosion radius, attack power, rigidity, and durability.\n\nThe class also has several public properties that allow setting the values of these fields. These properties include `Radius`, `AtkPow`, `Rigidity`, `WeaponBy`, `WeaponByForChild`, `Durability`, and `DurabilityMax`. These properties provide a way to set the values of the private fields from outside the class.\n\nThe class has several private methods that perform different checks and actions related to the grenade. \n\nThe `CalcPowFrom` method calculates the attack power of the grenade based on its distance from a given position. It uses the `atkPow` field and the `radius` field to calculate the attack power.\n\nThe `CheckMyself` method checks if the grenade has hit the player who threw it. It uses a layer mask to determine which game objects to check for collision with the grenade. It then checks if the distance between the player and the grenade is less than the grenade's radius. If it is, it calculates the damage to apply to the player based on the distance and the attack power of the grenade.\n\nThe `CheckBoxmen` method checks if the grenade has hit any enemy players or brick objects. It uses the `ExplosionUtil` class to check for collision with enemy players and brick objects within the grenade's radius. It then calculates the damage to apply to the enemy players and brick objects based on the distance and the attack power of the grenade.\n\nThe `CheckMonster` method checks if the grenade has hit any enemy monsters. It uses the `ExplosionUtil` class to check for collision with enemy monsters within the grenade's radius. It then calculates the damage to apply to the enemy monsters based on the distance and the attack power of the grenade.\n\nThe `CheckDestructibles` method checks if the grenade has hit any destructible brick objects. It uses the `ExplosionUtil` class to check for collision with destructible brick objects within the grenade's radius. It then applies damage to the destructible brick objects based on the distance and the attack power of the grenade. If the hit point of a destructible brick object reaches zero, it sends a network request to destroy the brick object.\n\nThe `Start` method is called when the grenade is instantiated. It checks if a certain build option is enabled and if so, it replaces the main texture of the grenade's mesh renderer with a texture from a manager.\n\nThe `Kaboom` method is called when the grenade detonates. It instantiates an explosion effect at the grenade's position. It then calls the various check methods to apply damage to players, monsters, and destructible brick objects within the grenade's radius. Finally, it destroys the grenade game object.\n\nThe `Update` method is called every frame. It checks if the grenade is still in motion and if enough time has passed for the grenade to detonate. If so, it calls the `Kaboom` method. Otherwise, it sends a network request to update the position and rotation of the grenade.\n\nThe `FixedUpdate` method is called at a fixed interval. It adds torque to the grenade's rigidbody to make it spin.\n\nIn summary, this code represents a grenade projectile in the game. It handles the detonation of the grenade, calculates the damage to apply to players, monsters, and destructible brick objects within the grenade's radius, and updates the position and rotation of the grenade. This code is likely used in the larger project to handle the gameplay mechanics of grenades and their interactions with other game objects.\n## Questions: \n 1. What is the purpose of the `CheckMyself()` method?\n- The `CheckMyself()` method is responsible for checking if the projectile has hit the player character and applying damage to the player if necessary.\n\n2. What does the `Kaboom()` method do?\n- The `Kaboom()` method is responsible for triggering the explosion effect of the projectile, as well as checking for collisions with other objects such as enemies, destructible objects, and the player character.\n\n3. What is the significance of the `Durability` and `DurabilityMax` properties?\n- The `Durability` and `DurabilityMax` properties are used to track the current and maximum durability of the projectile. They are used in calculations for applying damage to objects and players.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\PrjGrenade.md"}}],["365",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\PrjPosionBomb.cs)\n\nThe code provided is a class called `PrjPosionBomb` that extends the `Projectile` class. This class represents a poison bomb projectile in the larger Brick-Force project. \n\nThe `PrjPosionBomb` class has several properties and methods that define the behavior of the poison bomb projectile. \n\nThe properties include:\n- `smoke`: a reference to a smoke GameObject that will be instantiated when the bomb explodes.\n- `tail`: a reference to a tail GameObject that will be updated with the position of the bomb.\n- `radius`: the radius of the bomb's explosion.\n- `atkPow`: the attack power of the bomb.\n- `rigidity`: the rigidity of the bomb.\n- `weaponBy`: the weapon type of the bomb.\n- `weaponByForChild`: the weapon type for child bombs.\n- `durability`: the current durability of the bomb.\n- `durabilityMax`: the maximum durability of the bomb.\n- `colPoint`: the collision point of the bomb.\n\nThe methods in the class include:\n- `TailUpdate(Vector3 pos)`: updates the position of the tail GameObject to the specified position.\n- `CalcPowFrom(Vector3 position)`: calculates the attack power of the bomb based on its position relative to the target position.\n- `CheckMyself()`: checks if the bomb has hit the player and applies damage if necessary.\n- `CheckBoxmen()`: checks if the bomb has hit any boxmen (non-player characters) and applies damage if necessary.\n- `CheckMonster()`: checks if the bomb has hit any monsters and applies damage if necessary.\n- `CheckDestructibles()`: checks if the bomb has hit any destructible objects (bricks) and applies damage if necessary.\n- `Start()`: called when the bomb is instantiated, it sets the main texture of the bomb's mesh renderer to a texture from the UskManager if available.\n- `Kaboom()`: handles the explosion of the bomb, instantiating explosion and smoke GameObjects, applying damage to nearby objects, and destroying the bomb.\n- `Update()`: called every frame, it tracks the bomb's movement and sends updates to the server.\n- `FixedUpdate()`: called every fixed frame, it adds torque to the bomb's rigidbody to simulate rotation.\n- `OnCollisionEnter(Collision col)`: called when the bomb collides with another object, it handles the explosion of the bomb.\n\nOverall, this code defines the behavior of a poison bomb projectile in the Brick-Force project. It handles the movement, collision, and explosion of the bomb, as well as applying damage to nearby objects such as players, boxmen, monsters, and destructible objects.\n## Questions: \n 1. What is the purpose of the `CheckMyself()` method?\n- The `CheckMyself()` method is used to check if the projectile has hit the player character and apply damage if necessary.\n\n2. What does the `CheckBoxmen()` method do?\n- The `CheckBoxmen()` method checks for any nearby enemy players or objects and applies damage to them if necessary.\n\n3. What is the purpose of the `CheckDestructibles()` method?\n- The `CheckDestructibles()` method checks for any nearby destructible objects and applies damage to them if necessary.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\PrjPosionBomb.md"}}],["366",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\PrjSenseBomb.cs)\n\nThe code provided is a part of the Brick-Force project and is a class called `PrjSenseBomb` that extends the `Projectile` class. This class is responsible for handling the behavior of a specific type of projectile called a \"Sense Bomb\" in the game.\n\nThe `Update()` method is called every frame and is responsible for updating the state of the projectile. It first increments the `deltaTime` variable by the time it took to render the last frame using `Time.deltaTime`. Then, it increments the `DetonatorTime` variable of the base `Projectile` class by the same amount of time. \n\nThe code then checks if the `DetonatorTime` has exceeded the `explosionTime`. If it has, it proceeds to check if the game option `useUskMuzzleEff` is set to false or if the `ApplyUsk` flag of the base `Projectile` class is false. If either of these conditions is true, it checks if the `explosion` object is not null. If it is not null, it instantiates the `explosion` object at the current position of the projectile.\n\nIf the `useUskMuzzleEff` option is true and the `ApplyUsk` flag is true, it checks if the `explosionUsk` object in the `GlobalVars` class is not null. If it is not null, it instantiates the `explosionUsk` object at the current position of the projectile.\n\nAfter the explosion has been instantiated, the code sends a message to the `P2PManager` class to notify it of the explosion, passing in the sequence number and index of the projectile. Finally, it destroys the game object associated with the projectile.\n\nThe `Start()` method is called when the projectile is first created. It checks if the game option `useUskWeaponTex` is true. If it is, it retrieves all the `MeshRenderer` components attached to the projectile and iterates over them. For each `MeshRenderer`, it checks if the `mainTexture` of its material is not null and if the texture name exists in the `UskManager` class. If both conditions are true, it replaces the `mainTexture` with the corresponding texture from the `UskManager`.\n\nIn summary, this code handles the behavior of the \"Sense Bomb\" projectile in the Brick-Force game. It updates the state of the projectile and triggers an explosion when the detonation time is reached. It also handles the replacement of textures on the projectile's mesh renderers if the game option is enabled.\n## Questions: \n 1. What is the purpose of the `Update()` method in the `PrjSenseBomb` class?\n- The `Update()` method is responsible for updating the detonation time of the projectile and triggering the explosion when the detonation time exceeds the explosion time.\n\n2. What is the significance of the condition `!BuildOption.Instance.Props.useUskMuzzleEff || !base.ApplyUsk` in the `Update()` method?\n- This condition checks if the `useUskMuzzleEff` property in the `BuildOption` instance is false or if the `ApplyUsk` property in the base class is false. If either of these conditions is true, it will instantiate the `explosion` object at the position of the projectile.\n\n3. What is the purpose of the `Start()` method in the `PrjSenseBomb` class?\n- The `Start()` method is responsible for checking if the `useUskWeaponTex` property in the `BuildOption` instance is true. If it is true, it will update the main texture of the mesh renderers in the projectile with a texture obtained from the `UskManager` instance.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\PrjSenseBomb.md"}}],["367",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\PrjSmoke.cs)\n\nThe code provided is a part of the Brick-Force project and is a script for a projectile called \"PrjSmoke\". This script is responsible for the behavior and functionality of the smoke projectile in the game.\n\nThe `Start()` method is called when the projectile is instantiated. It checks a build option flag called `useUskWeaponTex` from the `BuildOption` class. If this flag is true, it retrieves all the `MeshRenderer` components attached to the projectile and iterates through them. For each `MeshRenderer`, it checks if the main texture of the material is not null and if the texture name exists in the `UskManager` instance. If both conditions are met, it replaces the main texture with the corresponding texture from the `UskManager`.\n\nThe `Update()` method is called every frame. It first checks if the projectile has a `Rigidbody` component and if it is not kinematic. If these conditions are met, it updates the `deltaTime` variable with the time since the last frame and increments the `DetonatorTime` variable by the same amount. If the `DetonatorTime` exceeds a predefined `explosionTime`, it instantiates an explosion object at the projectile's position and destroys the projectile object. Before instantiating the explosion, it modifies the energy values of any `ParticleEmitter` components attached to the explosion object by adding the `PersistTime` value from the base class.\n\nIf the `DetonatorTime` is not greater than the `explosionTime`, it checks if the `deltaTime` is greater than the `SendRate` value from the `BuildOption` class. If it is, it resets the `deltaTime` to 0 and sends a network message using the `P2PManager` class to inform other players about the projectile's position and rotation.\n\nThe `FixedUpdate()` method is called at a fixed interval and is responsible for applying a torque force to the projectile's `Rigidbody` component. It adds a torque force in the direction of the right vector multiplied by a constant value of 1000f.\n\nOverall, this script handles the initialization, movement, detonation, and network synchronization of the smoke projectile in the Brick-Force game.\n## Questions: \n 1. What is the purpose of the `Start()` method in the `PrjSmoke` class?\n- The `Start()` method is used to check if a specific build option is enabled and modify the main texture of the mesh renderers accordingly.\n\n2. What does the `Update()` method in the `PrjSmoke` class do?\n- The `Update()` method is responsible for handling the detonation and destruction of the projectile, as well as sending network messages related to the projectile's movement.\n\n3. What is the purpose of the `FixedUpdate()` method in the `PrjSmoke` class?\n- The `FixedUpdate()` method is used to apply a torque force to the projectile's rigidbody component, causing it to rotate around the right axis.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\PrjSmoke.md"}}],["368",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\PrjXmasBomb.cs)\n\nThe code provided is a class called `PrjXmasBomb` that extends the `Projectile` class. This class represents a specific type of projectile in the larger Brick-Force project. \n\nThe purpose of this code is to handle the behavior and interactions of the Xmas Bomb projectile. It contains various properties and methods that control the damage, collision detection, and destruction caused by the Xmas Bomb.\n\nThe `PrjXmasBomb` class has several properties that can be set externally. These properties include the radius of the explosion (`Radius`), the attack power of the bomb (`AtkPow`), the rigidity of the bomb (`Rigidity`), the type of weapon that fired the bomb (`WeaponBy`), the type of weapon for child objects (`WeaponByForChild`), the durability of the bomb (`Durability`), and the maximum durability of the bomb (`DurabilityMax`).\n\nThe class also has a method called `TailUpdate` that updates the position of the tail object attached to the bomb. This method is called externally and is used to visually update the position of the tail as the bomb moves.\n\nThe `PrjXmasBomb` class has several private methods that handle different aspects of the bomb's behavior. The `CalcPowFrom` method calculates the damage power of the bomb based on its distance from a given position. The `CheckMyself` method checks if the bomb has hit the player who fired it and applies damage to the player if they are within the bomb's radius. The `CheckBoxmen` method checks for any enemy players within the bomb's radius and applies damage to them. The `CheckMonster` method checks for any enemy monsters within the bomb's radius and applies damage to them. The `CheckDestructibles` method checks for any destructible objects within the bomb's radius and applies damage to them.\n\nThe `Start` method is called when the bomb is instantiated and is used to set the main texture of the bomb's mesh renderer to a specific texture if the `useUskWeaponTex` option is enabled.\n\nThe `Kaboom` method is called when the bomb detonates. It instantiates explosion and smoke effects at the bomb's position and sends network messages to update the game state based on the bomb's detonation. It also calls the various check methods to apply damage to players, enemies, and destructible objects within the bomb's radius.\n\nThe `Update` method is called every frame and is responsible for updating the bomb's position and sending network messages to update the bomb's position and radius. It also checks if the bomb has reached its detonation time and calls the `Kaboom` method if it has.\n\nThe `FixedUpdate` method is called at a fixed interval and is responsible for adding torque to the bomb's rigidbody to make it spin.\n\nThe `OnCollisionEnter` method is called when the bomb collides with another object. It retrieves the contact point of the collision and calls the `Kaboom` method to detonate the bomb.\n\nIn summary, this code represents the behavior and interactions of the Xmas Bomb projectile in the Brick-Force project. It handles the damage calculation, collision detection, and destruction caused by the bomb, as well as the visual effects and network updates associated with its detonation.\n## Questions: \n 1. What is the purpose of the `CheckMyself()` method?\n- The `CheckMyself()` method is used to check if the projectile has hit the player character and apply damage to the player if it is within the explosion radius.\n\n2. What does the `CheckBoxmen()` method do?\n- The `CheckBoxmen()` method is used to check if the projectile has hit any enemy players or characters within the explosion radius and apply damage to them.\n\n3. What is the purpose of the `CheckDestructibles()` method?\n- The `CheckDestructibles()` method is used to check if the projectile has hit any destructible objects within the explosion radius and apply damage to them.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\PrjXmasBomb.md"}}],["369",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Procurios.Public\\JSON.cs)\n\nThe code provided is a C# implementation of a JSON (JavaScript Object Notation) parser and serializer. JSON is a lightweight data interchange format that is commonly used for transmitting data between a server and a web application. This code allows for the conversion of JSON strings to objects and vice versa.\n\nThe `JSON` class contains several constants that represent different types of JSON tokens, such as curly braces, square brackets, colons, commas, strings, numbers, booleans, and null values. These constants are used throughout the code to identify and handle different parts of a JSON string.\n\nThe `JsonDecode` method is used to parse a JSON string and convert it into an object. It takes a JSON string as input and returns an object representation of the JSON data. The method uses a recursive approach to parse the JSON string, starting with the `ParseValue` method. The `ParseValue` method determines the type of the JSON value (string, number, object, array, boolean, or null) and calls the appropriate parsing method to handle that type.\n\nThe `JsonEncode` method is used to serialize an object into a JSON string. It takes an object as input and returns a JSON string representation of the object. The method uses a `StringBuilder` to build the JSON string, calling the `SerializeValue` method to handle each value in the object.\n\nThe code also includes several helper methods, such as `ParseObject`, `ParseArray`, `ParseString`, and `ParseNumber`, which are used by the parsing methods to handle specific types of JSON values. Similarly, the `SerializeObject`, `SerializeArray`, `SerializeString`, and `SerializeNumber` methods are used by the `SerializeValue` method to handle specific types of object values.\n\nOverall, this code provides a basic implementation of a JSON parser and serializer in C#. It can be used in the larger project to handle JSON data, such as parsing JSON responses from API calls or serializing objects to JSON for storage or transmission. Here are some examples of how this code can be used:\n\n```csharp\nstring json = \"{\\\"name\\\":\\\"John\\\",\\\"age\\\":30,\\\"city\\\":\\\"New York\\\"}\";\n\n// Parsing a JSON string into an object\nobject obj = JSON.JsonDecode(json);\nConsole.WriteLine(obj); // Output: { name = John, age = 30, city = New York }\n\n// Serializing an object into a JSON string\nHashtable hashtable = new Hashtable();\nhashtable[\"name\"] = \"John\";\nhashtable[\"age\"] = 30;\nhashtable[\"city\"] = \"New York\";\nstring jsonString = JSON.JsonEncode(hashtable);\nConsole.WriteLine(jsonString); // Output: {\"name\":\"John\",\"age\":30,\"city\":\"New York\"}\n```\n\nIn the larger project, this code can be used to handle JSON data, such as parsing API responses, serializing objects for storage or transmission, or converting JSON data into a more usable format within the application.\n## Questions: \n 1. What is the purpose of the `JsonDecode` method?\nThe `JsonDecode` method is used to decode a JSON string and convert it into an object representation.\n\n2. What does the `ParseObject` method do?\nThe `ParseObject` method is responsible for parsing a JSON object from a character array and returning it as a Hashtable.\n\n3. What is the purpose of the `SerializeValue` method?\nThe `SerializeValue` method is used to serialize a value (object, string, number, etc.) into a JSON string representation.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Procurios.Public\\JSON.md"}}],["370",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/.autodoc\\docs\\json\\Assembly-CSharp\\Procurios.Public)\n\nThe `JSON.cs` file in the `Procurios.Public` folder is a C# implementation of a JSON parser and serializer. It provides functionality to convert JSON strings to objects and vice versa, which is essential for data interchange between the server and the web application in the Brick-Force project.\n\nThe `JSON` class in this file contains constants representing different types of JSON tokens. These constants are used to identify and handle different parts of a JSON string.\n\nThe `JsonDecode` method is used to parse a JSON string and convert it into an object. It uses a recursive approach, starting with the `ParseValue` method, which determines the type of the JSON value and calls the appropriate parsing method.\n\nThe `JsonEncode` method is used to serialize an object into a JSON string. It uses a `StringBuilder` to build the JSON string, calling the `SerializeValue` method to handle each value in the object.\n\nThere are also several helper methods for parsing and serializing specific types of JSON values. For example, `ParseObject`, `ParseArray`, `ParseString`, and `ParseNumber` are used by the parsing methods, while `SerializeObject`, `SerializeArray`, `SerializeString`, and `SerializeNumber` are used by the `SerializeValue` method.\n\nHere's an example of how this code can be used:\n\n```csharp\nstring json = \"{\\\"name\\\":\\\"John\\\",\\\"age\\\":30,\\\"city\\\":\\\"New York\\\"}\";\n\n// Parsing a JSON string into an object\nobject obj = JSON.JsonDecode(json);\nConsole.WriteLine(obj); // Output: { name = John, age = 30, city = New York }\n\n// Serializing an object into a JSON string\nHashtable hashtable = new Hashtable();\nhashtable[\"name\"] = \"John\";\nhashtable[\"age\"] = 30;\nhashtable[\"city\"] = \"New York\";\nstring jsonString = JSON.JsonEncode(hashtable);\nConsole.WriteLine(jsonString); // Output: {\"name\":\"John\",\"age\":30,\"city\":\"New York\"}\n```\n\nIn the Brick-Force project, this code can be used to parse API responses, serialize objects for storage or transmission, or convert JSON data into a more usable format within the application.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Procurios.Public\\summary.md"}}],["371",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Projectile.cs)\n\nThe code provided is a class called \"Projectile\" that is a part of the larger Brick-Force project. This class is responsible for managing the behavior of a projectile in the game. \n\nThe class has several properties and fields that control various aspects of the projectile. The \"explosionTime\" field determines how long the projectile will take to explode after being launched. The \"detonatorTime\" field determines the time it takes for the projectile to activate its detonator. The \"persistTime\" field determines how long the projectile will persist in the game world before being destroyed. The \"index\" field is used to keep track of the projectile's index in a collection or array. The \"applyUsk\" field is a boolean value that determines whether or not the projectile should apply the \"Usk\" effect.\n\nThe class also has a \"projectileAlert\" field of type \"ProjectileAlert\". This field is used to store a reference to a \"ProjectileAlert\" component attached to a game object named \"Me\". The \"Start\" method is responsible for finding the \"Me\" game object and getting its \"ProjectileAlert\" component. If the \"Me\" game object is found and it has a \"ProjectileAlert\" component, the reference is stored in the \"projectileAlert\" field.\n\nThe purpose of this class is to provide a way to control the behavior of projectiles in the game. It allows for customization of various properties such as explosion time, detonator time, persist time, and the application of the \"Usk\" effect. The \"projectileAlert\" field and the \"Start\" method suggest that the class may be used to handle alerts or notifications related to projectiles.\n\nHere is an example of how this class could be used in the larger Brick-Force project:\n\n```csharp\nProjectile projectile = new Projectile();\nprojectile.ExplosionTime = 5f;\nprojectile.DetonatorTime = 2f;\nprojectile.PersistTime = 10f;\nprojectile.Index = 1;\nprojectile.ApplyUsk = true;\n\n// Use the projectile in the game\n```\n\nIn this example, a new instance of the \"Projectile\" class is created and its properties are set. The projectile is then used in the game, possibly by launching it and observing its behavior based on the set properties.\n## Questions: \n 1. What is the purpose of the `explosion` GameObject and how is it used in the code?\n- The `explosion` GameObject is likely used to represent the visual effect of an explosion. It is not used directly in the provided code, but it may be used in other parts of the project.\n\n2. What is the significance of the `explosionTime` variable and how is it used?\n- The `explosionTime` variable represents the duration of the explosion effect. It is used as a property to get or set the value of `explosionTime`.\n\n3. What is the purpose of the `projectileAlert` variable and how is it initialized?\n- The `projectileAlert` variable is likely used to reference a component called `ProjectileAlert` attached to the \"Me\" GameObject. It is initialized in the `Start()` method by finding the \"Me\" GameObject and getting its `ProjectileAlert` component.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Projectile.md"}}],["372",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ProjectileAlert.cs)\n\nThe `ProjectileAlert` class is responsible for tracking and displaying projectiles in the game. It is a part of the larger Brick-Force project and is used to provide a radar-like functionality to the player.\n\nThe class has a private `Texture2D` variable `dirImage` which represents the direction image that will be displayed on the radar. It also has a private `CameraController` variable `cameraController` which is used to get the position of the camera.\n\nThe class has a private `Dictionary<int, PTT>` variable `mine` which stores information about the tracked projectiles. The `PTT` class is not provided in the code snippet, but it is assumed to store information about a tracked projectile, such as its weapon type, position, and range.\n\nThe `Start` method is called when the game starts. It finds the main camera in the scene and assigns it to the `cameraController` variable. If the camera cannot be found or the `CameraController` component cannot be obtained, an error message is logged.\n\nThe `Update` method is empty and does not contain any code.\n\nThe `RemoveMine` method is used to remove a tracked projectile from the `mine` dictionary. It takes an `index` parameter which represents the index of the projectile to be removed. If the `mine` dictionary is not null and contains the specified index, the projectile is removed from the dictionary.\n\nThe `TrackMine` method is used to track a projectile. It takes parameters such as the `index` of the projectile, the `weapon` type, the `pos` (position) of the projectile, and its `range`. If the `mine` dictionary is null, it is initialized. If the `mine` dictionary does not contain the specified index, a new `PTT` object is created and added to the dictionary. If the dictionary already contains the index, the position and range of the existing `PTT` object are updated.\n\nThe `Draw` method is responsible for drawing a tracked projectile on the radar. It takes parameters such as the `weapon` type, the `pos` (position) of the projectile, and its `range`. It uses the `weapon` type to get the corresponding `Texture2D` image from the `TItemManager` class. If the image is not null, it calculates the angle between the camera's forward direction and the direction towards the projectile. It then calculates the position and size of the image on the screen based on the angle and other factors. Finally, it draws the image, the direction image, and a label showing the distance to the projectile.\n\nThe `OnGUI` method is called every frame and is responsible for drawing the tracked projectiles on the radar. It iterates over the `mine` dictionary and calls the `Draw` method for each tracked projectile. It also iterates over the game objects in the scene and checks if they are hostile. If a hostile game object has components such as `GdgtGrenade`, `GdgtFlashBang`, or `GdgtXmasBomb`, it gets the weapon type and projectile information from these components and calls the `Draw` method for each projectile.\n\nIn summary, the `ProjectileAlert` class is used to track and display projectiles on the radar in the Brick-Force game. It provides methods to add and remove tracked projectiles, and it uses the `Draw` method to draw the projectiles on the screen. The class interacts with other game objects and components to obtain information about the projectiles and their positions.\n## Questions: \n 1. What is the purpose of the `ProjectileAlert` class?\n- The `ProjectileAlert` class is responsible for tracking and drawing projectiles on the radar.\n\n2. What is the purpose of the `TrackMine` method?\n- The `TrackMine` method is used to add or update a projectile's information in the `mine` dictionary.\n\n3. What is the purpose of the `Draw` method?\n- The `Draw` method is responsible for drawing a projectile on the radar based on its weapon, position, and range.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ProjectileAlert.md"}}],["373",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ProjectileWrap.cs)\n\nThe code provided is a class called `ProjectileWrap` that is used to control the movement and behavior of a projectile in the game. \n\nThe class has several public variables and methods that allow for the manipulation of the projectile's position, rotation, and range. \n\nThe `ProjectileWrap` class has the following public variables:\n- `targetPos`: a Vector3 that represents the target position of the projectile.\n- `targetRot`: a Vector3 that represents the target rotation of the projectile.\n- `projectile`: a reference to the GameObject that represents the projectile.\n- `range`: a float that represents the range of the projectile.\n\nThe class also has a private variable `Elapsed` that keeps track of the elapsed time.\n\nThe constructor of the `ProjectileWrap` class takes a GameObject as a parameter and initializes the `targetPos` and `targetRot` variables with the position and rotation of the GameObject. It also sets the `projectile` variable to the passed GameObject and initializes the `range` variable to 0.\n\nThe `Fly` method is used to move the projectile towards its target position and rotation. It uses the `Lerp` function from the Unity engine to smoothly interpolate the position and rotation of the projectile towards the target position and rotation. The interpolation is done at a speed of 10 units per second multiplied by the time since the last frame.\n\nThe `Fly2` method is similar to the `Fly` method but also includes a check for the elapsed time. If the elapsed time is greater than 5 seconds, it sets the `overTime` variable to true. This method is likely used to handle projectiles that have a limited lifespan or behavior after a certain amount of time.\n\nThe `GetPos` method simply returns the current position of the projectile.\n\nOverall, this code provides a way to control the movement and behavior of projectiles in the game. It allows for smooth interpolation of position and rotation, as well as handling of time-based behavior. This class can be used in the larger project to create and control various types of projectiles with different movement patterns and behaviors.\n## Questions: \n 1. What is the purpose of the `Fly()` method?\n- The `Fly()` method is responsible for moving the projectile towards its target position and rotating it towards its target rotation.\n\n2. What is the purpose of the `Fly2()` method?\n- The `Fly2()` method is similar to the `Fly()` method, but it also checks if a certain amount of time has elapsed and sets the `overTime` variable to true if it has.\n\n3. What does the `GetPos()` method do?\n- The `GetPos()` method returns the current position of the projectile.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ProjectileWrap.md"}}],["374",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Properties\\AssemblyInfo.cs)\n\nThe code provided is a C# file that contains some assembly-level attributes. These attributes provide instructions to the compiler and runtime environment about how to handle certain aspects of the code.\n\nThe first attribute, `[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]`, instructs the runtime environment to wrap non-exception throws in a runtime exception. This means that if a method in the code throws a non-exception object, it will be wrapped in an exception object before being thrown. This can be useful for debugging and error handling purposes, as it ensures that all thrown objects are exceptions.\n\nThe second attribute, `[assembly: AssemblyVersion(\"0.0.0.0\")]`, specifies the version number of the assembly. In this case, the version number is set to \"0.0.0.0\". The version number is used to uniquely identify different versions of the assembly. It can be used for compatibility checks, dependency management, and tracking changes in the codebase.\n\nThese assembly-level attributes are important for the larger project because they provide instructions and metadata that affect how the code is compiled and executed. The `[assembly: RuntimeCompatibility]` attribute ensures that non-exception throws are handled in a specific way, which can help with debugging and error handling. The `[assembly: AssemblyVersion]` attribute sets the version number of the assembly, which is important for tracking changes and managing dependencies.\n\nHere is an example of how these attributes can be used in a larger project:\n\n```csharp\nusing System;\n\nnamespace MyProject\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            try\n            {\n                // Code that may throw non-exception objects\n            }\n            catch (Exception ex)\n            {\n                // Handle the exception\n            }\n        }\n    }\n}\n```\n\nIn this example, the `[assembly: RuntimeCompatibility]` attribute ensures that any non-exception objects thrown in the `try` block are wrapped in an exception object before being caught in the `catch` block. This allows for consistent error handling throughout the project.\n\nThe `[assembly: AssemblyVersion]` attribute can be used to track changes in the codebase. Each time the code is updated, the version number can be incremented to reflect the changes. This can be useful for managing dependencies and ensuring compatibility between different versions of the assembly.\n## Questions: \n 1. What is the purpose of the `RuntimeCompatibility` attribute with the `WrapNonExceptionThrows` property set to true? \n   - The `RuntimeCompatibility` attribute with the `WrapNonExceptionThrows` property set to true ensures that non-exception throw statements are wrapped in a try-catch block.\n\n2. What is the significance of the `AssemblyVersion` attribute with the value \"0.0.0.0\"? \n   - The `AssemblyVersion` attribute with the value \"0.0.0.0\" indicates that the assembly does not have a specific version number assigned to it.\n\n3. Are there any other attributes or settings that are commonly used in this project but not included in this code snippet? \n   - It is possible that there are other attributes or settings commonly used in this project, but without further information, it is not possible to determine what those might be.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Properties\\AssemblyInfo.md"}}],["375",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/.autodoc\\docs\\json\\Assembly-CSharp\\Properties)\n\nThe `AssemblyInfo.cs` file in the `Properties` folder of the `Assembly-CSharp` directory contains assembly-level attributes that provide instructions to the compiler and runtime environment. These attributes are crucial for the overall project as they dictate how the code is compiled and executed.\n\nThe first attribute, `[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]`, instructs the runtime environment to wrap non-exception throws in a runtime exception. This is beneficial for debugging and error handling, as it ensures that all thrown objects are exceptions. For instance, in a larger project, this attribute ensures that any non-exception objects thrown in a `try` block are wrapped in an exception object before being caught in the `catch` block. This allows for consistent error handling throughout the project.\n\n```csharp\nusing System;\n\nnamespace MyProject\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            try\n            {\n                // Code that may throw non-exception objects\n            }\n            catch (Exception ex)\n            {\n                // Handle the exception\n            }\n        }\n    }\n}\n```\n\nThe second attribute, `[assembly: AssemblyVersion(\"0.0.0.0\")]`, specifies the version number of the assembly. This version number is used to uniquely identify different versions of the assembly, which is important for tracking changes and managing dependencies. For example, each time the code is updated, the version number can be incremented to reflect the changes. This can be useful for managing dependencies and ensuring compatibility between different versions of the assembly.\n\nThese assembly-level attributes are integral to the larger project as they provide instructions and metadata that affect how the code is compiled and executed. They ensure consistent error handling and version tracking, which are crucial for a large-scale project like Brick-Force.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Properties\\summary.md"}}],["376",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Property.cs)\n\nThe code provided is a class called \"Property\" that contains a set of properties and methods related to various settings and options in the larger Brick-Force project. \n\nThe purpose of this class is to store and manage the configuration settings for the game. It includes properties for various settings such as server URLs, language options, sound settings, match modes, and more. These properties can be accessed and modified by other parts of the project to customize the game behavior.\n\nFor example, the \"GetTokensURL\" property stores the URL for retrieving tokens, the \"TokenType\" property specifies the type of token, and the \"PswdRequestURL\" property stores the URL for password requests. These properties can be used by other parts of the project to make API calls or perform specific actions.\n\nThe class also includes methods such as \"GetRoundRobinServer\" and \"GetResourceServer\" that retrieve the server URLs from player preferences if the \"ReadServerFromPreference\" property is set to true. These methods provide a way to dynamically update the server URLs based on player preferences.\n\nAdditionally, there are methods like \"IsSupportMode\" that check if a specific game mode is supported based on the current configuration settings. This can be used to enable or disable certain features or game modes based on the configuration.\n\nOverall, this class serves as a central repository for storing and managing the configuration settings for the Brick-Force game. It provides a way to customize various aspects of the game and control its behavior based on the configuration options set. Other parts of the project can access and modify these settings as needed to create a personalized gaming experience.\n## Questions: \n 1. **What is the purpose of the `Property` class?**\nThe `Property` class is used to store various properties and settings for the Brick-Force project.\n\n2. **What is the significance of the `XTRAP_TARGET` enum?**\nThe `XTRAP_TARGET` enum represents different XTrap targets that can be used in the project, such as NETMARBLE, INFERNUM, WAVE, AXESO5, and TEST_SERVER.\n\n3. **What is the purpose of the `Awake()` method in the `Property` class?**\nThe `Awake()` method initializes the `supportMode` array and counts the number of `true` values in the array to determine the number of supported modes in the project.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Property.md"}}],["377",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\PTT.cs)\n\nThe code provided defines a class called `PTT` which stands for \"Player Targeting Template\". This class is used to store information about a player's target in the game. \n\nThe `PTT` class has three public properties: `weapon`, `pos`, and `range`. \n\n- The `weapon` property is of type `Weapon.BY`, which suggests that it represents the type of weapon the player is using to target the enemy. However, without further information about the `Weapon` class, it is difficult to determine the exact purpose and functionality of this property.\n\n- The `pos` property is of type `Vector3`, which is a Unity-specific class representing a 3D position in space. This property is used to store the position of the player's target.\n\n- The `range` property is of type `float` and is used to store the range at which the player can target the enemy.\n\nThe `PTT` class also has a constructor that takes in three parameters: `w`, `p`, and `r`. These parameters are used to initialize the `weapon`, `pos`, and `range` properties respectively. This constructor allows for easy creation of `PTT` objects with the necessary information about the player's target.\n\nThe purpose of this code is to provide a template for storing and managing information about a player's target in the game. By creating instances of the `PTT` class and setting the appropriate values for the `weapon`, `pos`, and `range` properties, the game can keep track of the player's current target and use this information for various gameplay mechanics.\n\nFor example, the `PTT` objects could be used by the game's AI system to determine which enemies the player is targeting and adjust their behavior accordingly. The `pos` property could be used to calculate the distance between the player and their target, allowing for range-based interactions such as attacking or interacting with objects within a certain distance.\n\nOverall, this code provides a simple and reusable template for storing and managing player target information in the larger Brick-Force project.\n## Questions: \n 1. **What is the purpose of the `PTT` class?**\nThe `PTT` class appears to be a data structure that represents a player's weapon, position, and range in the game. \n\n2. **What is the significance of the `Weapon.BY` type used in the `weapon` field?**\nThe `Weapon.BY` type suggests that there is a separate `Weapon` class with a nested `BY` enum, and the `weapon` field is used to store a specific type of weapon.\n\n3. **What is the visibility scope of the `PTT` class?**\nThe `internal` keyword before the `class` declaration indicates that the `PTT` class is only accessible within the same assembly or project.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\PTT.md"}}],["378",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\PurcharseItems.cs)\n\nThe code provided defines a class called `PurchaseItems`. This class is likely used in the Brick-Force project to represent items that can be purchased within the game. \n\nThe `PurchaseItems` class has several public properties, including `Slot`, `Price`, `BuyUnit`, `incAtkSpeed`, `incMoveSpeed`, and `continuesTime`. These properties are used to store information about the item, such as its slot number, price, and various attributes that the item may affect, such as attack speed and movement speed.\n\nThe `Slot` property is of type `int` and is used to store the slot number of the item. This can be used to determine the position of the item within the game's inventory or store.\n\nThe `Price` property is also of type `int` and is used to store the price of the item. This can be used to determine the cost of purchasing the item within the game.\n\nThe `BuyUnit` property is of type `int` and is used to store the number of units of the item that can be purchased at once. This can be used to determine the quantity of the item that the player can buy in a single transaction.\n\nThe `incAtkSpeed` property is of type `float` and is used to store the amount by which the item increases the attack speed of the player. This can be used to modify the player's attack speed when the item is equipped.\n\nThe `incMoveSpeed` property is also of type `float` and is used to store the amount by which the item increases the movement speed of the player. This can be used to modify the player's movement speed when the item is equipped.\n\nThe `continuesTime` property is of type `float` and is used to store the duration for which the item's effect lasts. This can be used to determine how long the item's effects will be active after it is used or equipped.\n\nOverall, the `PurchaseItems` class provides a way to represent and store information about items that can be purchased within the Brick-Force game. This information can be used to determine the properties and effects of the items, as well as their cost and availability.\n## Questions: \n 1. What is the purpose of the `PurchaseItems` class? - The `PurchaseItems` class appears to represent items that can be purchased, but it is unclear what specific functionality or behavior it provides.\n2. What do the variables `Slot`, `Price`, `BuyUnit`, `incAtkSpeed`, `incMoveSpeed`, and `continuesTime` represent? - It is unclear what these variables represent and how they are used within the `PurchaseItems` class.\n3. Are there any methods or functions associated with the `PurchaseItems` class? - The code provided only shows the class definition, so it is unclear if there are any methods or functions associated with the `PurchaseItems` class.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\PurcharseItems.md"}}],["379",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\QuickJoinDialog.cs)\n\nThe code provided is a class called QuickJoinDialog, which is a subclass of the Dialog class. This class represents a dialog box that allows the user to quickly join a game in the larger Brick-Force project.\n\nThe QuickJoinDialog class has several member variables that define the layout and appearance of the dialog box, such as the position and size of various elements, colors, and textures. It also has several lists that store information about the available game modes and their corresponding icons.\n\nThe Start() method is called when the dialog box is first created. It initializes the member variables and populates the lists with the available game modes. It also sets the initial values for the checkboxes that allow the user to select the game modes they want to join.\n\nThe OnPopup() method is called when the dialog box is displayed on the screen. It sets the position and size of the dialog box based on the screen size.\n\nThe InitDialog() method is called to initialize the dialog box with the user's previous selections. It checks the user's previous selections for game modes and official maps and sets the corresponding checkboxes and variables accordingly.\n\nThe CheckMask() method is called to check the user's current selections and update the corresponding variables that store the selected game modes and official maps. It returns a boolean value indicating whether any game modes have been selected.\n\nThe DoDialog() method is called to display the dialog box and handle user interactions. It uses the GUI class to draw the various elements of the dialog box, such as labels, checkboxes, and buttons. It also handles button clicks and updates the selected game modes and official maps based on the user's interactions.\n\nOverall, the QuickJoinDialog class provides a user interface for quickly joining a game in the Brick-Force project. It allows the user to select the game modes they want to join and the type of maps they want to play on. The class also handles sending a request to join the selected game modes to the server when the user clicks the \"Enter\" button.\n## Questions: \n 1. What is the purpose of the `InitDialog()` method?\n- The `InitDialog()` method is used to initialize the dialog by setting the values of various variables based on the current state of the game.\n\n2. What does the `CheckMask()` method do?\n- The `CheckMask()` method checks the values of the `chkMatchs` array and the `isOffimap`, `isUsermap`, and `isAllmap` variables to determine the values of the `MyInfoManager.Instance.qjModeMask` and `MyInfoManager.Instance.qjOfficialMask` variables.\n\n3. What is the purpose of the `DoDialog()` method?\n- The `DoDialog()` method is responsible for rendering the dialog and handling user interactions with the dialog. It returns a boolean value indicating whether the dialog should be closed or not.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\QuickJoinDialog.md"}}],["380",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\RadioMenu.cs)\n\nThe `RadioMenu` class is a script that handles the radio communication functionality in the larger Brick-Force project. It is responsible for managing the different radio modes (ASK, CMD, REPLY), handling user input for sending radio messages, and playing corresponding audio clips.\n\nThe class has several public and private variables. The `guiDepth` variable determines the layer at which the radio menu GUI will be displayed. The `radioAskKeys`, `radioCmdKeys`, and `radioReplyKeys` arrays store the keys for the different radio messages in each mode. The `radioCancelKey` stores the key for canceling the radio menu. The `sndRadioAsks`, `sndRadioCmds`, and `sndRadioReplys` arrays store the names of the audio clips that will be played when a radio message is sent. The `offset` variable determines the vertical spacing between radio messages in the GUI. The `battleChat` variable is a reference to the `BattleChat` component, which handles the chat functionality in the game. The `audioSource` variable is a reference to the `AudioSource` component, which is responsible for playing audio clips. The `localController` variable is a reference to the `LocalController` component, which controls the player's character.\n\nThe `Start` method is called when the script is initialized. It retrieves references to the `BattleChat`, `AudioSource`, and `LocalController` components. The `CheckShortcut` method is called in the `Update` method to check if a radio message shortcut key has been pressed. If a shortcut key is pressed, it sends a radio message using the `CSNetManager` class.\n\nThe `GetString` method takes a `RadioSignal` object as a parameter and returns the corresponding string message based on the signal's category and message index. The `OnRadioMsg` method is called when a radio message is received. It checks if the sender is the player's character and sets the radio mode to NONE if it is. Otherwise, it retrieves the corresponding audio clip name based on the signal's category and message index and plays the audio clip using the `VoiceManager` class.\n\nThe `GetHeight` method calculates the height of the radio menu GUI based on the current radio mode. The `OnGUI` method is responsible for drawing the radio menu GUI using the Unity GUI system. It displays the radio messages and their corresponding shortcut keys in a box on the screen.\n\nThe `CheckOnOff` method checks if the radio sound mute button has been pressed and toggles the radio sound mute setting accordingly. The `Update` method is called every frame and handles user input for activating the different radio modes and checking for shortcut key presses.\n\nIn summary, the `RadioMenu` class manages the radio communication functionality in the Brick-Force project. It handles user input for sending radio messages, plays corresponding audio clips, and displays the radio menu GUI on the screen.\n## Questions: \n 1. What is the purpose of the `RadioMenu` class?\n- The `RadioMenu` class is responsible for managing radio communication in the game. It allows players to send and receive radio messages.\n\n2. What are the different modes of the `RadioMenu` class?\n- The `RadioMenu` class has three modes: `ASK`, `CMD`, and `REPLY`. These modes determine the type of radio message being sent or received.\n\n3. How does the `RadioMenu` class handle user input for sending radio messages?\n- The `RadioMenu` class checks for specific key inputs (e.g., `Alpha1`, `Alpha2`, etc.) and sends the corresponding radio message based on the current mode.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\RadioMenu.md"}}],["381",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\RadioSenderMark.cs)\n\nThe code provided is a class called `RadioSenderMark` that is used to track the signal strength of a radio sender in the larger Brick-Force project. \n\nThe `RadioSenderMark` class has the following properties and methods:\n\n- `Seq`: An integer property that represents the sequence number of the radio sender.\n- `deltaTime`: A float property that represents the time elapsed since the last update of the radio sender.\n\n- `RadioSenderMark(int seq)`: A constructor method that initializes a new instance of the `RadioSenderMark` class with the given sequence number. It also sets the `deltaTime` property to 0.\n\n- `Reset()`: A method that resets the `deltaTime` property to 0.\n\n- `Update()`: A method that updates the `deltaTime` property by adding the current frame's delta time (Time.deltaTime) to it.\n\n- `GetSignalStrength()`: A method that calculates and returns the signal strength of the radio sender based on the `deltaTime` property. If the `deltaTime` is greater than 3 seconds, it returns float.NegativeInfinity. Otherwise, it returns a value between 0 and 1, representing the signal strength as a fraction of the maximum strength. The signal strength decreases linearly over time, starting from 1 at 0 seconds and reaching 0 at 3 seconds.\n\nThis class can be used in the larger Brick-Force project to track and manage the signal strength of radio senders. It allows for easy initialization of new radio senders with a sequence number, updating their signal strength over time, and retrieving the current signal strength. This information can be used for various purposes in the project, such as determining the range or effectiveness of radio communication between different entities or objects. \n\nHere is an example usage of the `RadioSenderMark` class:\n\n```csharp\nRadioSenderMark sender = new RadioSenderMark(1); // Create a new radio sender with sequence number 1\n\nsender.Update(); // Update the sender's signal strength\n\nfloat signalStrength = sender.GetSignalStrength(); // Get the current signal strength of the sender\n```\n\nOverall, this code provides a useful tool for managing and monitoring the signal strength of radio senders in the Brick-Force project.\n## Questions: \n 1. **What is the purpose of the `RadioSenderMark` class?**\nThe `RadioSenderMark` class appears to be a class that represents a radio sender. It has methods for updating the sender's time and calculating the signal strength based on the time.\n\n2. **What does the `Seq` variable represent?**\nThe `Seq` variable is an integer that is likely used to keep track of the sequence or order of the radio sender.\n\n3. **What is the significance of the `Reset` method?**\nThe `Reset` method sets the `deltaTime` variable back to 0, which suggests that it is used to reset the time for the radio sender.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\RadioSenderMark.md"}}],["382",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\RadioSignal.cs)\n\nThe code provided defines a class called `RadioSignal`. This class represents a radio signal and has three properties: `Sender`, `Category`, and `Message`, all of which are of type `int`. The class also has a constructor that takes in three parameters: `sender`, `category`, and `message`, and assigns them to the corresponding properties.\n\nThe purpose of this code is to provide a data structure for representing radio signals within the larger Brick-Force project. Radio signals are a means of communication within the project, and this class allows for the creation and manipulation of these signals.\n\nBy creating an instance of the `RadioSignal` class, developers can create and send radio signals with specific sender, category, and message values. For example, the following code creates a new `RadioSignal` object with a sender ID of 1, a category ID of 2, and a message ID of 3:\n\n```csharp\nRadioSignal signal = new RadioSignal(1, 2, 3);\n```\n\nThis object can then be used to send the radio signal within the project, allowing other parts of the system to receive and process the signal based on its properties.\n\nOverall, this code provides a simple and straightforward way to represent radio signals within the Brick-Force project. It allows for the creation and manipulation of radio signals, enabling communication between different components of the project.\n## Questions: \n 1. **What is the purpose of the `RadioSignal` class?**\nThe `RadioSignal` class appears to represent a radio signal and contains three properties: `Sender`, `Category`, and `Message`. It is unclear what the purpose of this class is and how it is used within the project.\n\n2. **What are the possible values for the `Sender`, `Category`, and `Message` properties?**\nWithout further information, it is unclear what range of values are valid for the `Sender`, `Category`, and `Message` properties. Understanding the possible values would provide more context for how this class is used.\n\n3. **Are there any constraints or validations on the input parameters of the `RadioSignal` constructor?**\nThe `RadioSignal` constructor takes three integer parameters: `sender`, `category`, and `message`. It is unclear if there are any constraints or validations on these parameters, such as minimum or maximum values, or if they can be null. Understanding any constraints or validations would help ensure proper usage of the `RadioSignal` class.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\RadioSignal.md"}}],["383",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\RandomboxItemManager.cs)\n\nThe `RandomboxItemManager` class is responsible for managing random box items in the Brick-Force project. It provides methods for loading and accessing random box items, as well as parsing and storing the data associated with each item.\n\nThe class has several private fields, including `c_Gachapons`, which is an array of `c_Gachapon` objects, and `dic`, which is a dictionary that maps item codes to `c_Gachapon` objects. It also has a public field `icons`, which is an array of `Texture2D` objects representing icons for the items.\n\nThe class has a static instance property `Instance` that returns the singleton instance of the `RandomboxItemManager`. The instance is lazily initialized and retrieved using the `FindObjectOfType` method. If the instance is not found, an error message is logged.\n\nThe class has a public property `IsLoaded` that indicates whether the random box items have been loaded. It is set to `true` when the items are successfully loaded.\n\nThe class provides several methods for loading and accessing random box items. The `LoadAll` method is responsible for loading the items. It first checks if the game is running in a web player environment and calls the `LoadAllFromWWW` method if it is. Otherwise, it calls the `c_LoadGachaponFromLocalFileSystem` method. The `LoadAllFromWWW` method uses a `WWW` object to download a binary file containing the item data from a specified URL. It then uses a `CSVLoader` object to parse the data and calls the `c_ParseGachapon` method to populate the `c_Gachapons` array and the `dic` dictionary. If the download fails, an error message is logged. The `c_LoadGachaponFromLocalFileSystem` method loads the item data from a local file using a `CSVLoader` object. If the file does not exist or fails to load, an error message is logged.\n\nThe `c_ParseGachapon` method is responsible for parsing the item data and populating the `c_Gachapons` array and the `dic` dictionary. It iterates over the rows of the CSV data and creates a new `c_Gachapon` object for each row. It then reads the values from each column of the row and assigns them to the corresponding properties of the `c_Gachapon` object. The `Add` method is called to add the `c_Gachapon` object to the `dic` dictionary.\n\nThe class also provides methods for accessing individual random box items. The `c_GetGachapon` method returns the `c_Gachapon` object with the specified ID. The `GetGachaponByCode` method returns the `c_Gachapon` object with the specified code. The `GetGachaponsByCat` method returns an array of `c_Gachapon` objects that belong to the specified category.\n\nThe class also includes some utility methods, such as `FindIcon`, which searches for an icon with the specified name in the `icons` array, and `String2Type`, which converts a string representation of an item type to its corresponding integer value.\n\nOverall, the `RandomboxItemManager` class provides functionality for loading, accessing, and managing random box items in the Brick-Force project. It is an important component of the project's item system and is used to handle the generation and distribution of random box items.\n## Questions: \n 1. **Question:** What is the purpose of the `RandomboxItemManager` class?\n   - **Answer:** The `RandomboxItemManager` class is responsible for managing random box items, including loading them from a local file system or a web server, parsing the data, and providing access to the items.\n\n2. **Question:** How are the random box items loaded from a web server?\n   - **Answer:** The `LoadAllFromWWW` method uses a `WWW` object to download a binary file from a specified URL, then uses a `CSVLoader` object to parse the downloaded data and populate the `c_Gachapons` array.\n\n3. **Question:** How are the random box items loaded from a local file system?\n   - **Answer:** The `c_LoadGachaponFromLocalFileSystem` method checks if the necessary directory and file exist, then uses a `CSVLoader` object to load and parse the data from the file. If the file doesn't exist or fails to load, it attempts to save the data in a secured format.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\RandomboxItemManager.md"}}],["384",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\RandomBoxSureDialog.cs)\n\nThe code provided is a class called `RandomBoxSureDialog` that extends the `Dialog` class. This class represents a dialog box that is used to confirm the opening of a random treasure chest in the game. \n\nThe class has several public properties that define the position and size of various elements in the dialog box, such as the icon, comment, and buttons. These properties are of type `Rect` and are used to position and size the elements on the screen.\n\nThe class also has private fields `chest`, `index`, and `token` which store the values of the chest, index, and token that are passed to the dialog box when it is initialized.\n\nThe `Start` method is overridden from the base `Dialog` class and sets the `id` property of the dialog box to a specific value from an enum called `DIALOG_INDEX`.\n\nThe `OnPopup` method is also overridden from the base `Dialog` class and sets the position of the dialog box on the screen based on the size of the screen and the size of the dialog box.\n\nThe `InitDialog` method is a public method that is used to initialize the values of the `chest`, `index`, and `token` fields.\n\nThe `DoTitle` method is a private method that displays the title of the dialog box at the top center of the screen.\n\nThe `DoDialog` method is overridden from the base `Dialog` class and is responsible for rendering the dialog box on the screen and handling user input. It first sets the GUI skin to a specific skin obtained from a `GUISkinFinder` instance. It then calls the `DoTitle` method to display the title of the dialog box. It then displays a box element using the `GUI.Box` method to create a border around the comment section of the dialog box. The content of the comment section is determined by the value of the `token` field. If `token` is less than or equal to 0, it displays a specific string using the `GUI.Label` method. Otherwise, it displays a formatted string using the `String.Format` method. It then displays two buttons using the `GlobalVars.Instance.MyButton` method, one for confirming the opening of the treasure chest and one for canceling. If the confirm button is clicked, it sends a request to open the treasure chest using the `CSNetManager.Instance.Sock.SendCS_TC_OPEN_PRIZE_TAG_REQ` method. If the cancel button is clicked, it sets the `result` variable to true. Finally, it checks if the dialog box is no longer being displayed and if so, it calls the `WindowUtil.EatEvent` method to consume any remaining input events.\n\nIn summary, this code represents a dialog box that is used to confirm the opening of a random treasure chest in the game. It displays the title, a comment section with different messages depending on the value of the `token` field, and two buttons for confirming or canceling the opening of the chest.\n## Questions: \n 1. What is the purpose of the `InitDialog` method and how is it used?\n- The `InitDialog` method is used to initialize the values of the `chest`, `index`, and `token` variables. It is likely used to set the values of these variables before the dialog is displayed.\n\n2. What is the significance of the `DoTitle` method and when is it called?\n- The `DoTitle` method is responsible for displaying the title of the dialog. It is likely called within the `DoDialog` method to ensure that the title is displayed whenever the dialog is shown.\n\n3. What is the purpose of the `OnPopup` method and when is it called?\n- The `OnPopup` method is responsible for setting the position and size of the dialog window. It is likely called when the dialog is first shown or when the window needs to be repositioned.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\RandomBoxSureDialog.md"}}],["385",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\RandomBoxSureNetmarble.cs)\n\nThe code provided is a class called \"RandomBoxSureNetmarble\" that extends the \"Dialog\" class. This class is used to create a dialog box for a random box in the Brick-Force project. \n\nThe class has several public variables, including \"imgList\" and \"labelList\" which are both lists of UI elements, \"warningText\" which is a UILabel, and \"ruleNotice\", \"ok\", and \"cancel\" which are all UIMyButton elements. These variables are used to store references to the UI elements that will be displayed in the dialog box.\n\nThe class also has private variables \"chest\", \"index\", and \"token\" which are used to store information about the random box. These variables are set using the \"InitDialog\" method.\n\nThe class overrides the \"Start\" method from the base \"Dialog\" class, and sets the \"id\" variable to a specific value from an enum called \"DIALOG_INDEX\".\n\nThe class also overrides the \"OnPopup\" method, which is called when the dialog box is displayed. In this method, a \"Rect\" variable \"rc\" is set to position the dialog box in the center of the screen.\n\nThe class overrides the \"DoDialog\" method, which is called to update and draw the dialog box. In this method, the UI elements are drawn on the screen using their respective \"Draw\" methods. If the \"cancel\" button is clicked or the escape key is pressed, the method returns true, indicating that the dialog box should be closed. If the \"ok\" button is clicked or the return key is pressed, a network request is sent to open the random box. If the \"ruleNotice\" button is clicked, a URL is opened based on the value of a variable called \"SiteCode\".\n\nThe class also has a private method called \"GetText\" which returns a string based on the value of the \"token\" variable. If the token is less than or equal to 0, the method returns a specific string from a string manager. Otherwise, it returns a formatted string that includes the value of the \"token\" variable and a string from a token manager.\n\nOverall, this class is responsible for creating and managing a dialog box for a random box in the Brick-Force project. It handles user input and sends network requests based on the user's actions.\n## Questions: \n 1. What is the purpose of the `InitDialog` method?\n- The `InitDialog` method is used to initialize the values of the `chest`, `index`, and `token` variables.\n\n2. What is the purpose of the `DoDialog` method?\n- The `DoDialog` method is responsible for drawing the UI elements and handling user interactions, such as button clicks.\n\n3. What is the purpose of the `GetText` method?\n- The `GetText` method returns a string based on the value of the `token` variable. If `token` is less than or equal to 0, it returns a specific string, otherwise it returns a formatted string using the `token` value.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\RandomBoxSureNetmarble.md"}}],["386",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\RandomPackSlot.cs)\n\nThe code provided defines a class called `RandomPackSlot` that is used to represent a slot in a random pack. This class is marked as `[Serializable]`, which means that its instances can be serialized and deserialized, allowing them to be stored and transferred between different parts of the program.\n\nThe `RandomPackSlot` class has several public fields of type `Texture2D` and arrays of `Texture2D`. These fields represent different textures that can be associated with a random pack slot. The `bg` field represents the background texture, the `fx` array represents special effects textures, the `itemBg` field represents the texture for the item background, and the `random`, `weapon`, and `cloth` arrays represent textures for different types of items.\n\nThe class also has a method called `GetTexture2D` that takes four integer parameters: `tab`, `x`, `y`, and `status`. This method is used to retrieve the appropriate texture based on the given parameters. If the `status` parameter is equal to 4, the method returns the `itemBg` texture. If the `x` and `y` parameters are both equal to 0, the method returns the texture from the `random` array at the index specified by the `status` parameter. If the `tab` parameter is equal to 0, the method returns the texture from the `weapon` array at the index specified by the `status` parameter. Otherwise, the method returns the texture from the `cloth` array at the index specified by the `status` parameter.\n\nThis code is likely part of a larger project that involves random packs, where each pack contains multiple slots. Each slot can have different textures associated with it, depending on its type and status. The `RandomPackSlot` class provides a convenient way to store and retrieve these textures for each slot. Other parts of the project can use instances of this class to access the textures and display them in the appropriate slots.\n\nExample usage:\n\n```csharp\nRandomPackSlot slot = new RandomPackSlot();\nTexture2D texture = slot.GetTexture2D(1, 0, 0, 2);\n```\n\nIn this example, a new `RandomPackSlot` instance is created, and the `GetTexture2D` method is called with the parameters `1`, `0`, `0`, and `2`. This will return the texture from the `cloth` array at index 2, since the `tab` parameter is not equal to 0. The returned texture can then be used for further processing or display.\n## Questions: \n 1. What is the purpose of the `RandomPackSlot` class?\n- The `RandomPackSlot` class is used to store information about textures for different slots in a random pack.\n\n2. What are the parameters `tab`, `x`, `y`, and `status` used for in the `GetTexture2D` method?\n- The `tab` parameter is used to determine the type of slot, `x` and `y` are used to determine the position of the slot, and `status` is used to determine the status of the slot.\n\n3. What is the purpose of the `GetTexture2D` method?\n- The `GetTexture2D` method is used to retrieve the appropriate texture based on the given parameters. It returns different textures depending on the values of `tab`, `x`, `y`, and `status`.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\RandomPackSlot.md"}}],["387",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\RandomRotator.cs)\n\nThe code provided is for a class called \"RandomRotator\" which is a script that can be attached to a game object in the Unity game engine. The purpose of this script is to rotate the game object randomly in three dimensions.\n\nThe class has three public variables: speedMax, speedMin, and three private variables: xSpeed, ySpeed, and zSpeed. The speedMax and speedMin variables determine the range of random speeds that the game object can rotate at. The xSpeed, ySpeed, and zSpeed variables store the randomly generated speeds for each axis.\n\nThe Start() method is called when the game object is first created. In this method, the xSpeed, ySpeed, and zSpeed variables are assigned random values within the range specified by speedMin and speedMax. This ensures that each game object with this script attached will have different rotation speeds.\n\nThe Update() method is called every frame of the game. In this method, the game object's transform is rotated using the Rotate() method. The xSpeed, ySpeed, and zSpeed variables are multiplied by Time.deltaTime to ensure that the rotation is smooth and frame rate independent. This means that the rotation speed will be the same regardless of the frame rate of the game.\n\nThis script can be used in the larger project to add random rotation to game objects. For example, it can be attached to collectible items in a game to make them spin in a random direction. It can also be used to add visual interest to background objects or obstacles. By adjusting the speedMin and speedMax variables, the rotation speed can be customized for different objects or gameplay situations.\n\nExample usage:\n\n```csharp\n// Attach the RandomRotator script to a game object\nGameObject cube = GameObject.CreatePrimitive(PrimitiveType.Cube);\nRandomRotator randomRotator = cube.AddComponent<RandomRotator>();\n\n// Customize the rotation speed range\nrandomRotator.speedMin = 256f;\nrandomRotator.speedMax = 512f;\n```\n## Questions: \n 1. What does this code do?\n- This code is a script for a game object in Unity that randomly rotates the object around its x, y, and z axes at different speeds.\n\n2. What is the purpose of the `Start()` method?\n- The `Start()` method is used to initialize the xSpeed, ySpeed, and zSpeed variables with random values within the specified speed range.\n\n3. How does the rotation speed of the object change over time?\n- The rotation speed of the object is determined by the xSpeed, ySpeed, and zSpeed variables, which are multiplied by `Time.deltaTime` in the `Update()` method. This ensures that the rotation speed is consistent regardless of the frame rate.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\RandomRotator.md"}}],["388",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\RankMap.cs)\n\nThe code provided defines a class called `RankMap`. This class represents a mapping of ranks in a larger project called Brick-Force. \n\nThe `RankMap` class has four private instance variables: `rowNo`, `rank`, `rankChg`, and `regMap`. These variables store information about the rank mapping. \n\nThe `rowNo` variable represents the row number of the rank mapping. The `rank` variable represents the rank value. The `rankChg` variable represents the change in rank. The `regMap` variable represents a reference to an instance of the `RegMap` class.\n\nThe `RankMap` class also has five public properties: `RowNo`, `Rank`, `RankChg`, `OrgMap`, and `IsLatest`. These properties provide read-only access to the private instance variables.\n\nThe `RowNo` property returns the value of the `rowNo` variable. The `Rank` property returns the value of the `rank` variable. The `RankChg` property returns the value of the `rankChg` variable. The `OrgMap` property returns the reference to the `regMap` variable. The `IsLatest` property returns the value of the `IsLatest` property of the `regMap` instance.\n\nThe `RankMap` class also has a constructor that takes four parameters: `rn`, `rk`, `rc`, and `mp`. These parameters are used to initialize the private instance variables. The `rn` parameter is assigned to the `rowNo` variable, the `rk` parameter is assigned to the `rank` variable, the `rc` parameter is assigned to the `rankChg` variable, and the `mp` parameter is assigned to the `regMap` variable.\n\nIn the larger Brick-Force project, the `RankMap` class is likely used to represent and manage rank mappings. It provides a way to store and access information about a specific rank mapping, such as the row number, rank value, and change in rank. Other parts of the project can create instances of the `RankMap` class and use its properties to retrieve the stored information. For example:\n\n```csharp\nRankMap rankMap = new RankMap(1, 5, -2, regMapInstance);\nint rowNumber = rankMap.RowNo; // returns 1\nint rankValue = rankMap.Rank; // returns 5\nint rankChange = rankMap.RankChg; // returns -2\nRegMap orgMap = rankMap.OrgMap; // returns the reference to the regMapInstance\nbool isLatest = rankMap.IsLatest; // returns the value of the IsLatest property of the regMapInstance\n```\n\nOverall, the `RankMap` class provides a way to represent and manage rank mappings in the Brick-Force project.\n## Questions: \n 1. What is the purpose of the `RankMap` class?\n- The `RankMap` class is used to store information about a rank, including the row number, rank value, rank change, and a reference to a `RegMap` object.\n\n2. What is the significance of the `RowNo`, `Rank`, `RankChg`, `OrgMap`, and `IsLatest` properties?\n- The `RowNo` property returns the row number of the rank. The `Rank` property returns the rank value. The `RankChg` property returns the rank change. The `OrgMap` property returns the reference to the `RegMap` object. The `IsLatest` property returns a boolean value indicating if the `RegMap` object is the latest version.\n\n3. What parameters are required to create an instance of the `RankMap` class?\n- To create an instance of the `RankMap` class, the constructor requires an integer value for the row number, rank, rank change, and a `RegMap` object.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\RankMap.md"}}],["389",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\RareFx.cs)\n\nThe code provided is a class called `RareFx` that is part of the larger Brick-Force project. This class is responsible for managing and updating a rare special effect that occurs in the game. \n\nThe `RareFx` class has several private variables that store information about the current state of the effect, such as the current step of the effect (`rareFxStep`), the maximum duration for each step (`sizeUpMax`, `flyMax`, `bounceMax`), and the start and end positions of the effect (`start`, `end`). \n\nThe class also has a public property called `Delta` that calculates the progress of the effect based on the current step and the elapsed time (`deltaTime`). This property is used to determine how much the effect should be scaled, moved, or animated at any given moment.\n\nThe class has a constructor that takes in the start and end positions of the effect and initializes the variables accordingly. The start and end positions are randomly adjusted by a small amount to add variation to the effect.\n\nThe class also has an `Update` method that is called every frame to update the state of the effect. This method increments the `deltaTime` variable by the time that has passed since the last frame. It then checks the current step of the effect and determines if it should transition to the next step based on the elapsed time. If the maximum duration for a step is reached, the `deltaTime` is reset and the effect transitions to the next step.\n\nOverall, this class provides a way to manage and animate a rare special effect in the game. It can be used in the larger Brick-Force project to create visually appealing and dynamic effects that enhance the gameplay experience.\n## Questions: \n 1. What is the purpose of the `RareFx` class?\n- The `RareFx` class is responsible for managing the animation steps of a rare effect, such as size up, fly, bounce, and done.\n\n2. What are the possible values for the `RAREFX_STEP` enum?\n- The possible values for the `RAREFX_STEP` enum are `SIZE_UP`, `FLY`, `BOUNCE`, and `DONE`.\n\n3. How is the `Delta` property calculated and what does it represent?\n- The `Delta` property is calculated based on the current `rareFxStep` and the elapsed time (`deltaTime`). It represents the progress of the current animation step, ranging from 0 to 1.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\RareFx.md"}}],["390",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\RareStuff.cs)\n\nThe code provided is a part of the Brick-Force project and is contained within the \"RareStuff\" class. The purpose of this code is to create and manage a collection of \"RareFx\" objects, which represent rare effects or animations in the game.\n\nThe \"RareStuff\" class has a private array of \"RareFx\" objects called \"stars\". The size of this array is determined by a random number between \"starRandomMin\" and \"starRandomMax\". The \"starRandomMin\" and \"starRandomMax\" variables represent the minimum and maximum number of \"RareFx\" objects that can be created.\n\nThe constructor of the \"RareStuff\" class takes in two Vector2 parameters, \"src\" and \"dst\". It initializes the \"stars\" array by creating a new \"RareFx\" object for each element in the array, passing in the \"src\" and \"dst\" vectors as parameters.\n\nThe \"Update\" method iterates through each \"RareFx\" object in the \"stars\" array and calls its own \"Update\" method. This allows each \"RareFx\" object to update its state or perform any necessary calculations or animations.\n\nThe \"ToArray\" method converts the \"stars\" array into a List of \"RareFx\" objects and returns it as an array. This method can be useful if the \"RareStuff\" object needs to be passed to another part of the code that expects an array of \"RareFx\" objects.\n\nThe \"Alive\" property is a boolean value that indicates whether any of the \"RareFx\" objects in the \"stars\" array are still active or in progress. It checks the \"RareFxStep\" property of each \"RareFx\" object and returns true if any of them are not in the \"DONE\" state. Otherwise, it returns false.\n\nOverall, this code provides a way to create and manage a collection of \"RareFx\" objects within the larger Brick-Force project. These objects represent rare effects or animations and can be updated and checked for their status. The \"RareStuff\" class encapsulates this functionality and provides methods to interact with the collection of \"RareFx\" objects.\n## Questions: \n 1. What is the purpose of the `RareStuff` class?\n- The `RareStuff` class represents a collection of `RareFx` objects and provides methods to check if any of the `RareFx` objects are still active, update them, and convert them to an array.\n\n2. What is the significance of the `starRandomMin` and `starRandomMax` variables?\n- These variables determine the range of values that will be used to generate a random number, which will be used to determine the number of `RareFx` objects to create in the `RareStuff` constructor.\n\n3. What does the `Update` method do?\n- The `Update` method calls the `Update` method of each `RareFx` object in the `stars` array, allowing them to perform any necessary updates or actions.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\RareStuff.md"}}],["391",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Recursively.cs)\n\nThe code provided is a utility class called \"Recursively\" that contains three static methods: \"SetLayer\", \"ChangeLayer\", and \"GetAllComponents\". These methods are designed to perform recursive operations on a given parent object and its children.\n\nThe \"SetLayer\" method takes a Transform object and an integer representing a layer, and sets the layer of the parent object and all of its children to the specified layer. It uses a foreach loop to iterate through each child of the parent object and recursively calls the \"SetLayer\" method on each child. This method can be used to easily change the layer of a group of objects in a scene.\n\n```csharp\nTransform parentObject = // get reference to parent object\nint layer = // specify the layer to set\nRecursively.SetLayer(parentObject, layer);\n```\n\nThe \"ChangeLayer\" method is similar to the \"SetLayer\" method, but it takes two additional parameters: \"fromLayer\" and \"toLayer\". It checks if the layer of the parent object matches the \"fromLayer\" parameter, and if so, it changes the layer to the \"toLayer\" parameter. Like the \"SetLayer\" method, it also recursively calls itself on each child of the parent object. This method can be used to selectively change the layer of specific objects in a scene.\n\n```csharp\nTransform parentObject = // get reference to parent object\nint fromLayer = // specify the layer to change from\nint toLayer = // specify the layer to change to\nRecursively.ChangeLayer(parentObject, fromLayer, toLayer);\n```\n\nThe \"GetAllComponents\" method takes a Transform object and a boolean parameter \"includeInactive\". It uses recursion to traverse up the parent hierarchy until it reaches the root object. Then, it calls the \"GetComponentsInChildren\" method on the root object, passing in the \"includeInactive\" parameter. This method returns an array of components of type T, where T is a generic type that extends the Component class. This method can be used to easily retrieve all components of a specific type from a parent object and its children.\n\n```csharp\nTransform parentObject = // get reference to parent object\nbool includeInactive = // specify whether to include inactive objects\nComponent[] components = Recursively.GetAllComponents<Component>(parentObject, includeInactive);\n```\n\nOverall, this utility class provides convenient methods for performing recursive operations on a parent object and its children, such as setting the layer of objects, changing the layer of specific objects, and retrieving components of a specific type. These methods can be used in various scenarios within the larger Brick-Force project, such as managing object layers, modifying object properties, and accessing components for gameplay or rendering purposes.\n## Questions: \n 1. **What does the `SetLayer` method do?**\nThe `SetLayer` method sets the layer of a given `Transform` and all of its child `Transforms` to a specified layer.\n\n2. **What does the `ChangeLayer` method do?**\nThe `ChangeLayer` method changes the layer of a given `Transform` and all of its child `Transforms` from one layer to another.\n\n3. **What does the `GetAllComponents` method do?**\nThe `GetAllComponents` method returns an array of all components of type `T` attached to a given `Transform` and its child `Transforms`, including inactive components if specified.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Recursively.md"}}],["392",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\RecvMemoDialog.cs)\n\nThe code provided is a class called \"RecvMemoDialog\" that extends the \"Dialog\" class. This class is used to display a dialog box for receiving memos in the larger Brick-Force project.\n\nThe class has several member variables, including a reference to a Memo object, a reference to a MemoDialog object, and various Rect and Vector2 variables that define the positions and sizes of different elements within the dialog box. It also has a Texture2D variable for an icon.\n\nThe class has several private methods that are responsible for showing different elements within the dialog box. The \"ShowClanInvitation\" method displays a clan invitation if the memo is not null, has an attachment value of \"000\", and has a non-negative option value. The \"ShowPresent\" method displays an attached item if the memo is not null and has a non-\"000\" attachment value. The \"IsInvitation\" method checks if the memo is a clan invitation. The \"HaveAttachedItem\" method checks if the memo has an attached item.\n\nThe class overrides several methods from the base \"Dialog\" class. The \"Start\" method sets the id of the dialog. The \"OnPopup\" method sets the position of the dialog box. The \"DoDialog\" method is responsible for rendering and handling user interactions with the dialog box. It displays the sender, memo title, and contents of the memo, as well as any attached item or clan invitation. It also handles button clicks for replying to the memo or deleting it.\n\nThe class also has a public \"InitDialog\" method that initializes the dialog with a given position, memo, and parent MemoDialog object. It sets the memo and parent references, resets the scroll position, and sends a request to mark the memo as read if it hasn't been read before.\n\nOverall, this code provides the functionality for displaying and interacting with received memos in the Brick-Force project.\n## Questions: \n 1. What is the purpose of the `RecvMemoDialog` class?\n- The `RecvMemoDialog` class is a subclass of the `Dialog` class and is used to display and interact with received memos in the game.\n\n2. What are the different coordinates and rectangles used in this code?\n- The code defines various coordinates and rectangles (`Rect`) for positioning and sizing GUI elements such as icons, labels, buttons, and boxes.\n\n3. What are the conditions for showing the clan invitation and present sections?\n- The `ShowClanInvitation` method shows the clan invitation section if the memo is not attached and has a non-negative option value. The `ShowPresent` method shows the present section if the memo is attached and the attached item has a valid icon.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\RecvMemoDialog.md"}}],["393",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\RedBlueFlag.cs)\n\nThe code provided is a part of the Brick-Force project and is contained within the `RedBlueFlag` class. This class is responsible for managing the appearance of a flag in the game. The flag can be either red or blue, and the code ensures that the flag's material is set correctly based on the team the player is on.\n\nThe class has two public fields: `redFlag` and `blueFlag`, which are both of type `Material`. These fields hold the materials that will be used for the red and blue flags, respectively.\n\nThe class also has a private field called `smr`, which is of type `SkinnedMeshRenderer`. This field is used to reference the skinned mesh renderer component attached to the game object that the `RedBlueFlag` script is attached to.\n\nThe class has three methods: `SetTeam`, `Start`, and `OnChangeTeam`.\n\nThe `SetTeam` method takes a boolean parameter `red` and sets the material of the `smr` object based on the value of `red`. If `red` is true, it checks if the current material of `smr` is not equal to `redFlag`, and if so, it sets the material to `redFlag`. If `red` is false, it checks if the current material of `smr` is not equal to `blueFlag`, and if so, it sets the material to `blueFlag`.\n\nThe `Start` method is called when the script is first initialized. It first gets the `SkinnedMeshRenderer` component attached to the game object and assigns it to the `smr` field. If `smr` is null, it logs an error message. Then, it determines the value of `num` based on the current room type. If the current room type is `MISSION`, `num` is set to 4, otherwise it is set to 8. Finally, it calls the `SetTeam` method with the condition `MyInfoManager.Instance.Slot < num`.\n\nThe `OnChangeTeam` method is called when the player changes teams. It follows the same logic as the `Start` method, determining the value of `num` based on the current room type and calling the `SetTeam` method with the condition `MyInfoManager.Instance.Slot < num`.\n\nIn summary, this code manages the appearance of a flag in the game based on the team the player is on. It sets the material of the flag's skinned mesh renderer component to either the red or blue flag material, depending on the team. The `Start` and `OnChangeTeam` methods ensure that the flag's material is updated correctly when the game starts or when the player changes teams.\n## Questions: \n 1. What is the purpose of the `SetTeam` method?\n- The `SetTeam` method is used to change the material of the SkinnedMeshRenderer component based on the team color (red or blue).\n\n2. What does the `Start` method do?\n- The `Start` method is called when the script is enabled and it initializes the SkinnedMeshRenderer component, checks if it is null, and sets the team color based on the current room type and the player's slot number.\n\n3. When is the `OnChangeTeam` method called?\n- The `OnChangeTeam` method is called when there is a change in the player's team and it updates the team color based on the current room type and the player's slot number.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\RedBlueFlag.md"}}],["394",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\RegMap.cs)\n\nThe code provided is a class called `RegMap` that represents a registered map in the Brick-Force project. This class is responsible for storing and managing various properties and behaviors of a map.\n\nThe `RegMap` class has several private fields, including `latestFileVer`, `ver`, `map`, `developer`, `alias`, `regDate`, `modeMask`, `release`, `latestRelease`, `Rank`, `RankChg`, `tagMask`, `thumbnail`, `clanMatchable`, `officialMap`, `blocked`, `likes`, `disLikes`, `downloadCount`, and `downloadFee`. These fields store information such as the map's version, developer, release information, thumbnail image, and various statistics.\n\nThe class provides public properties and methods to access and modify these fields. For example, the `Developer` property allows getting and setting the developer's name, the `Thumbnail` property returns the map's thumbnail image, and the `IsPlayableAt` method checks if the map is playable in a specific room type and channel mode.\n\nThe class also includes methods for saving and loading map data to and from a file. The `Save` method writes the map's properties to a binary file, including the map's version, developer, alias, release date, thumbnail image, and other relevant information. The `Load` method reads the map's properties from a file and initializes the corresponding fields.\n\nAdditionally, the class includes a `IsAbuseMap` method that checks if the map has the abuse tag set.\n\nOverall, the `RegMap` class provides a way to store and manage information about registered maps in the Brick-Force project. It allows developers to access and modify map properties, save and load map data, and perform various checks and operations related to map functionality.\n## Questions: \n 1. **Question:** What is the purpose of the `RegMap` class?\n   - **Answer:** The `RegMap` class represents a registered map in the Brick-Force project and stores various properties and methods related to the map.\n\n2. **Question:** How are the `likes`, `disLikes`, `downloadCount`, and `downloadFee` properties used in the code?\n   - **Answer:** These properties are used to keep track of the number of likes, dislikes, download count, and download fee associated with the map. They can be accessed and modified through their respective getter and setter methods.\n\n3. **Question:** What is the purpose of the `Save` and `Load` methods in the `RegMap` class?\n   - **Answer:** The `Save` method is used to save the `RegMap` object to a file, while the `Load` method is used to load a `RegMap` object from a file. These methods allow for persistence of map data.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\RegMap.md"}}],["395",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\RegMapManager.cs)\n\nThe `RegMapManager` class is responsible for managing a collection of `RegMap` objects. It provides methods for adding, removing, and retrieving `RegMap` objects, as well as performing various operations on them.\n\nThe `RegMapManager` class has several private member variables, including three dictionaries: `dicRegMap`, `dicDownloaded`, and `dicDeleted`. These dictionaries store `RegMap` objects, with the keys being integers representing the map IDs. There is also a static instance of the `RegMapManager` class, `_instance`, which is used to access the singleton instance of the class.\n\nThe `RegMapManager` class provides several public methods for working with `RegMap` objects. The `ToArray` method returns an array of `RegMap` objects that are playable in a given room type, or with a given channel mode. The `IsDownloaded` and `IsDeleted` methods check if a map is present in the `dicDownloaded` or `dicDeleted` dictionaries, respectively. The `Clear` method clears all the dictionaries, and the `DownloadedClear` method clears only the `dicDownloaded` and `dicDeleted` dictionaries.\n\nThe `RegMapManager` class also provides methods for setting and getting various properties of `RegMap` objects. The `SetDownloadFirst` method sets a specific map as the first downloaded map, and the `SetDownload` method sets a map as downloaded or not downloaded. The `GetAlways` method retrieves a `RegMap` object with the specified map ID and sets its properties. The `SetThumbnail` method sets the thumbnail image for a specific map.\n\nThe `RegMapManager` class also includes some utility methods, such as `RequestRegMap`, which sends a request for map information to the server, and `Start`, which loads `RegMap` objects from cache files.\n\nOverall, the `RegMapManager` class provides a centralized way to manage and manipulate `RegMap` objects in the larger Brick-Force project. It handles adding, removing, and retrieving `RegMap` objects, as well as performing operations on them, such as setting properties and requesting map information from the server.\n## Questions: \n 1. What is the purpose of the `RegMapManager` class?\n- The `RegMapManager` class is responsible for managing and manipulating dictionaries of `RegMap` objects.\n\n2. What is the significance of the `ToArray` methods?\n- The `ToArray` methods convert the `dicDownloaded` dictionary into an array of `RegMap` objects based on different criteria such as `roomType`, `page`, and `channelMode`.\n\n3. What is the purpose of the `SetDownloadFirst` method?\n- The `SetDownloadFirst` method sets a specific `RegMap` as the first element in the `dicDownloaded` dictionary, while moving the other elements down by one position.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\RegMapManager.md"}}],["396",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\RenameMapDlg.cs)\n\nThe code provided is a class called \"RenameMapDlg\" that extends the \"Dialog\" class. This class is responsible for displaying a dialog box that allows the user to rename a map. \n\nThe class has several member variables, including \"maxAlias\" which represents the maximum length of the new map alias, \"userMap\" which represents the current map being renamed, and \"newMapAlias\" which represents the new name for the map. \n\nThe class also has several Rect and Vector2 variables that define the positions and sizes of various GUI elements within the dialog box, such as the outline, current alias label, new alias label, and the OK button. \n\nThe class overrides the \"Start\" and \"OnPopup\" methods from the base \"Dialog\" class. The \"Start\" method sets the ID of the dialog to \"RENAME_MAP\", and the \"OnPopup\" method calculates the position of the dialog box based on the screen size. \n\nThe class also has a method called \"InitDialog\" which initializes the \"userMap\" and \"newMapAlias\" variables. \n\nThe class has a private method called \"CheckAlias\" which checks if the new map alias is valid. It trims any leading or trailing whitespace from the alias, and then checks if the length is greater than 0 and greater than 2. If the alias is not valid, it displays an error message using the \"MessageBoxMgr\" class and returns false. \n\nThe class overrides the \"DoDialog\" method from the base \"Dialog\" class. This method is responsible for rendering the dialog box and handling user input. It first checks if the \"userMap\" variable is null, and if so, it returns true. It then sets the GUI skin to a custom skin using the \"GUISkinFinder\" class. \n\nThe method then renders various GUI elements, such as the outline, title, current alias label, and new alias label, using the \"LabelUtil\" class. It also renders the current alias using the \"GUI.Label\" method, and the new alias using the \"GUI.TextField\" method. \n\nThe method checks if the OK button is pressed and if the alias is valid using the \"GlobalVars\" and \"CheckAlias\" methods. If so, it sends a request to change the map alias using the \"CSNetManager\" class, and sets the \"result\" variable to true. \n\nThe method also checks if the close button is pressed or the escape key is pressed, and sets the \"result\" variable to true in those cases as well. \n\nFinally, the method sets the focus to the alias input field and eats any events if the context menu is not open. It then restores the GUI skin and returns the \"result\" variable. \n\nIn the larger project, this class would be used to allow the user to rename their maps. It would be called when the user selects the option to rename a map, and would display a dialog box where the user can enter a new name for the map. The class would handle validating the new name and sending a request to change the map alias.\n## Questions: \n 1. What is the purpose of the `RenameMapDlg` class?\n- The `RenameMapDlg` class is a dialog class that allows the user to rename a map.\n\n2. What is the significance of the `maxAlias` variable?\n- The `maxAlias` variable determines the maximum length of the new map alias that the user can input.\n\n3. What does the `DoDialog` method do?\n- The `DoDialog` method handles the rendering and functionality of the dialog, including displaying labels, text fields, buttons, and checking the validity of the new map alias before sending a request to change the user map alias.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\RenameMapDlg.md"}}],["397",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ReplaceDstDialog.cs)\n\nThe code provided is a class called \"ReplaceDstDialog\" that extends the \"Dialog\" class. This class is responsible for displaying a dialog box that allows the user to select a replacement brick for a specific brick in the game. \n\nThe class has several member variables, including arrays for different categories of bricks (general, colorbox, accessory, functional), arrays for the corresponding brick icons, and various Rect and Vector2 variables for positioning and scrolling within the dialog box. \n\nThe class also has a reference to a \"ReplaceToolDialog\" object, which is passed in through the \"InitDialog\" method. This reference is used to update the \"Next\" brick in the \"ReplaceToolDialog\" object when the user selects a replacement brick.\n\nThe \"Start\" method sets the \"id\" variable of the dialog to a specific value from the \"DialogManager\" class.\n\nThe \"OnPopup\" method sets the position of the dialog box based on the screen size.\n\nThe \"InitDialog\" method initializes the \"replaceToolDlg\" reference and populates the \"brickTab\" array with localized strings obtained from the \"brickTabKey\" array. It also initializes the arrays for the different categories of bricks and their corresponding icons using methods from the \"BrickManager\" class.\n\nThe \"DoDialog\" method is responsible for rendering the dialog box and handling user input. It first sets the GUI skin to a specific skin obtained from the \"GUISkinFinder\" class. It then renders the title of the dialog box using the \"LabelUtil.TextOut\" method. Next, it calls the \"DoSilo\" method to render the brick selection area. Finally, it renders an \"OK\" button and a close button, and handles their click events.\n\nThe \"DoSilo\" method is responsible for rendering the brick selection area. It first begins a GUI group and renders a background box for the selection area. It then renders a tab bar at the top of the selection area, allowing the user to switch between different categories of bricks. The currently selected category is stored in the \"currentSilo\" variable. Depending on the selected category, the method renders a scrollable grid of brick icons for that category. The user can click on a brick icon to select it as the replacement brick. The currently selected brick is stored in the \"currentBrick\" variable. If a brick is selected, a box is rendered around its icon to indicate the selection. \n\nOverall, this code provides the functionality for displaying a dialog box that allows the user to select a replacement brick for a specific brick in the game. It handles rendering the dialog box, populating the brick selection area with different categories of bricks, and handling user input to select a replacement brick.\n## Questions: \n **Question 1:** What is the purpose of the `ReplaceDstDialog` class?\n\n**Answer:** The `ReplaceDstDialog` class is a subclass of the `Dialog` class and is used to create a dialog box for replacing bricks in the game.\n\n**Question 2:** What are the different categories of bricks that can be replaced?\n\n**Answer:** The different categories of bricks that can be replaced are general, colorbox, accessory, and functional.\n\n**Question 3:** How does the `DoSilo` method work?\n\n**Answer:** The `DoSilo` method is responsible for displaying the different categories of bricks in a scrollable grid format and allowing the user to select a brick to replace.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ReplaceDstDialog.md"}}],["398",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ReplaceTool.cs)\n\nThe code provided is a class called `ReplaceTool` that extends the `EditorTool` class. It is part of the larger Brick-Force project and is used as a tool within the game's editor.\n\nThe purpose of this code is to define the behavior of the `ReplaceTool` in the editor. The `ReplaceTool` is used to replace certain items or objects in the game world. It has a constructor that takes in an `EditorToolScript` object, an `Item` object, and a `BattleChat` object. These objects are used to initialize the `ReplaceTool` instance.\n\nThe `ReplaceTool` class overrides two methods from the `EditorTool` class: `IsEnable()` and `Update()`. \n\nThe `IsEnable()` method checks if the `item` object is not null and if it has enough quantity to be consumed. It returns a boolean value indicating whether the tool is enabled or not.\n\nThe `Update()` method is called every frame and handles the logic for using the `ReplaceTool`. It first checks if the `battleChat` is not currently active and if the input key for the tool is pressed down. If these conditions are met and the tool is enabled, it sets the `active` flag to true and returns true.\n\nIf the tool is not enabled, it finds the game object with the name \"Me\" and checks if it exists. If it does, it gets the `LocalController` component attached to it and adds a status message indicating that the item cannot be used. It then returns false.\n\nIf none of the conditions are met, the method returns false.\n\nOverall, this code defines the behavior of the `ReplaceTool` in the Brick-Force editor. It checks if the tool is enabled and handles the logic for using the tool, including displaying status messages when the tool cannot be used.\n## Questions: \n 1. What is the purpose of the `ReplaceTool` class?\n- The `ReplaceTool` class is a subclass of `EditorTool` and is used to handle the functionality of a specific tool in the game.\n\n2. What conditions need to be met for the `IsEnable()` method to return true?\n- The `IsEnable()` method will return true if the `item` variable is not null and if the `item` has enough quantity to be consumed.\n\n3. What happens when the `Update()` method returns false?\n- When the `Update()` method returns false, it means that the tool is not active and no action needs to be taken.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ReplaceTool.md"}}],["399",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ReplaceToolDialog.cs)\n\nThe code provided is a class called `ReplaceToolDialog` that extends the `Dialog` class. This class is used to create a dialog box for a specific tool in the larger Brick-Force project. The purpose of this dialog box is to allow the user to replace bricks in the game world with other bricks.\n\nThe class has several member variables, including `gaugeFrame`, `gauge`, `progressing`, `prev`, `next`, `todo`, `doneCount`, `item`, and several `Rect` and `Vector2` variables. These variables are used to store information about the current state of the dialog box and the bricks being replaced.\n\nThe class has several properties, including `Prev` and `Next`, which are used to get and set the previous and next bricks to be replaced, respectively.\n\nThe class has several methods, including `Start()`, `OnPopup()`, `InitDialog()`, `DoDialog()`, `CheckCount()`, `MoveFirst()`, and `MoveNext()`. These methods are used to initialize the dialog box, handle user input, and perform the actual replacement of bricks.\n\nThe `Start()` method sets the ID of the dialog box and is called when the dialog box is first created.\n\nThe `OnPopup()` method sets the position of the dialog box on the screen and is called when the dialog box is displayed.\n\nThe `InitDialog()` method initializes the dialog box with the source and destination bricks for the replacement. It also retrieves information about the replace tool item from the game's item manager.\n\nThe `DoDialog()` method is called every frame to update and draw the dialog box. It handles user input and updates the progress of the replacement operation.\n\nThe `CheckCount()` method checks if the number of instances of a specific brick type in the game world exceeds the maximum allowed limit. If it does, it displays an error message.\n\nThe `MoveFirst()` method is called when the user clicks the \"START\" button in the dialog box. It initiates the replacement of the first brick in the queue by sending a network request to the server.\n\nThe `MoveNext()` method is called when the server responds to the replacement request. It updates the progress of the replacement operation and initiates the replacement of the next brick in the queue if there are any remaining.\n\nOverall, this code provides the functionality for the replace tool dialog box in the Brick-Force project. It allows the user to select a source and destination brick and replace all instances of the source brick with the destination brick in the game world.\n## Questions: \n 1. **Question:** What is the purpose of the `ReplaceToolDialog` class?\n   - **Answer:** The `ReplaceToolDialog` class is a dialog class that handles the replacement of bricks in the game.\n\n2. **Question:** How does the replacement process work in the `ReplaceToolDialog` class?\n   - **Answer:** The replacement process involves iterating through a queue of `BrickInst` objects and sending a replace brick request to the server for each brick instance.\n\n3. **Question:** What conditions are checked before initiating the replacement process?\n   - **Answer:** The code checks if the `item` and `prev` variables are not null, and if the `dst` brick is valid for replacement.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ReplaceToolDialog.md"}}],["400",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Respawner.cs)\n\nThe `Respawner` class is responsible for handling the respawn functionality of a player in the game. It is a part of the larger Brick-Force project.\n\nThe class has several member variables, including `guiDepth`, `gaugeFrame`, `gaugeBar`, `gaugeText`, `respawnTimeSecure`, `outOnce`, `resTime`, `localController`, and `changedRespawnTime`. These variables are used to store various data related to the respawn process.\n\nThe `Awake()` method is called when the object is initialized. It first finds the \"Me\" game object and retrieves the `LocalController` component attached to it. If the `LocalController` component is not found, an error message is logged. If the `LocalController` component is found, it checks if the player has any respawn items and adjusts the respawn time accordingly. The respawn time is then initialized using the `respawnTimeSecure` variable. The `NoCheat` instance is also synchronized with the respawn time.\n\nThe `OnDestroy()` method is called when the object is destroyed. It releases the `respawnTimeSecure` variable.\n\nThe `Resurrect2()` method is used to resurrect the player. It checks if the `localController` is not null and if the player's hit points are greater than 0. If these conditions are met, it initializes the `respawnTimeSecure` variable to a value of 0.5f, sets the `DeltaFromDeath` property of the `localController` to 0.05f, and sets the `changedRespawnTime` flag to true.\n\nThe `Resurrect()` method is similar to `Resurrect2()`, but it does not set the `DeltaFromDeath` property and uses the `respawnTime` value instead.\n\nThe `DoSpawn()` method is responsible for spawning the player. It first checks if the `localController` is not null. If the `changedRespawnTime` flag is set, it initializes the `respawnTimeSecure` variable to the initial respawn time. The `respawnTimeSecure` variable is then reset. If a `spawner` object is provided, the `localController` is spawned at the specified position and rotation. Otherwise, a random spawn position and rotation are used.\n\nThe `CheckJustRespawn()` method checks if the player has just respawned. It finds the \"Main\" game object and retrieves the `ShooterTools` component attached to it. If the component is not null and it contains the \"just_respawn\" string, it returns true. Otherwise, it returns false.\n\nThe `OnGUI()` method is responsible for displaying the respawn progress bar on the screen. It first checks if the `localController` is not null and if the player's hit points are less than or equal to 0. If these conditions are met, it calculates the progress of the respawn based on the `DeltaFromDeath` and `respawnTime` values. If the progress is greater than or equal to 1, it checks the current room type and performs the appropriate actions for each room type. If the room type is \"Tutor\", it calls the `DoSpawn()` method with a specific spawner. Otherwise, it checks the room type and performs the appropriate actions based on the room type. The `outOnce` flag is used to ensure that certain actions are only performed once. If the room type is \"Explosion\", the flag is set to true. Otherwise, it is set to false.\n\nThe `Update()` method is called every frame. It calls the `KillCheater()` method of the `NoCheat` instance to check for any cheating attempts related to the respawn time.\n\nIn summary, the `Respawner` class handles the respawn functionality of a player in the game. It initializes the respawn time, handles the resurrection process, spawns the player, displays the respawn progress bar, and checks for cheating attempts related to the respawn time.\n## Questions: \n 1. What is the purpose of the `Respawner` class?\n- The `Respawner` class is responsible for handling the respawn functionality of a player in the game.\n\n2. What is the significance of the `resTime` variable?\n- The `resTime` variable represents the time it takes for a player to respawn after dying.\n\n3. What is the purpose of the `OnGUI` method?\n- The `OnGUI` method is responsible for displaying the respawn gauge and text on the game screen when the player's hit points are zero.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Respawner.md"}}],["401",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ResultUnit.cs)\n\nThe code provided defines a class called `ResultUnit`. This class represents a unit of result data for a player in the Brick-Force project. It contains various properties that store information about the player's performance in a game, such as their nickname, kill count, death count, assist count, score, experience points (xp), and mission progress.\n\nThe class has a constructor that takes in all the necessary parameters to initialize the properties of a `ResultUnit` object. The constructor assigns the parameter values to the corresponding properties.\n\nAdditionally, the class has a method called `Compare` that takes in another `ResultUnit` object as a parameter. This method is used to compare two `ResultUnit` objects based on their scores, kills, and deaths. It returns an integer value that indicates the comparison result.\n\nThe comparison logic in the `Compare` method first checks if the scores of the two `ResultUnit` objects are equal. If they are, it then checks if the kill counts are equal. If the kill counts are also equal, it compares the death counts. The method uses the `CompareTo` method to perform the comparisons and returns the result accordingly.\n\nThis `ResultUnit` class can be used in the larger Brick-Force project to store and compare player performance data. It provides a convenient way to encapsulate and organize the result data for each player. The `Compare` method can be used, for example, to sort a list of `ResultUnit` objects based on their performance, allowing for ranking or leaderboard functionality in the game.\n\nHere's an example of how the `ResultUnit` class can be used:\n\n```csharp\nResultUnit player1 = new ResultUnit(true, 1, \"Player1\", 10, 5, 3, 100, 50, 500, 2, 400, 600, 123456789);\nResultUnit player2 = new ResultUnit(false, 2, \"Player2\", 8, 3, 2, 80, 40, 400, 1, 300, 500, 987654321);\n\nint comparisonResult = player1.Compare(player2);\nif (comparisonResult > 0)\n{\n    Console.WriteLine(\"Player1 has a better performance than Player2.\");\n}\nelse if (comparisonResult < 0)\n{\n    Console.WriteLine(\"Player2 has a better performance than Player1.\");\n}\nelse\n{\n    Console.WriteLine(\"Player1 and Player2 have the same performance.\");\n}\n```\n\nIn this example, two `ResultUnit` objects are created for two players. The `Compare` method is then used to compare their performances, and the result is printed based on the comparison result.\n## Questions: \n 1. What is the purpose of the `Compare` method in the `ResultUnit` class?\n- The `Compare` method is used to compare two `ResultUnit` objects based on their `score`, `kill`, and `death` properties.\n\n2. What does the `buff` property represent in the `ResultUnit` class?\n- The `buff` property is a long integer that represents a buff associated with the `ResultUnit` object. It is not clear what this buff represents without further context.\n\n3. What is the significance of the `red` property in the `ResultUnit` class?\n- The `red` property is a boolean that indicates whether the `ResultUnit` object is associated with the red team. It is not clear what this property is used for without further context.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ResultUnit.md"}}],["402",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ResultUnitEscape.cs)\n\nThe code provided is a class called `ResultUnitEscape` that extends another class called `ResultUnit`. This class is likely a part of the larger Brick-Force project and is used to represent a result unit for an escape scenario.\n\nThe `ResultUnitEscape` class has a public integer field called `param` and a constructor that takes in several parameters. These parameters include a boolean value `_red`, an integer `_seq`, a string `_nickname`, and several other integer values `_kill`, `_death`, `_assist`, `_score`, `_point`, `_xp`, `_mission`, `_prevXp`, `_nextXp`, and a long `_buff`. The constructor initializes the fields of the `ResultUnit` class using the `base` keyword and assigns the value of `_param` to the `param` field of the `ResultUnitEscape` class.\n\nThe `ResultUnitEscape` class also has a method called `Compare` that takes in a `ResultUnitEscape` object `ru` as a parameter and returns an integer. This method is likely used to compare two `ResultUnitEscape` objects based on their `kill`, `score`, and `seq` fields. The method first checks if the `kill` field of the current object is equal to the `kill` field of the `ru` object. If they are equal, it then checks if the `score` field of the current object is equal to the `score` field of the `ru` object. If they are also equal, it returns the result of comparing the `seq` field of the current object with the `seq` field of the `ru` object using the `CompareTo` method. If the `kill` and `score` fields are not equal, it returns the result of comparing the `kill` field of the current object with the `kill` field of the `ru` object using the `CompareTo` method.\n\nThis class is likely used in the larger Brick-Force project to represent and compare result units for escape scenarios. The `param` field may be used to store additional information specific to the escape scenario. The `Compare` method may be used to sort and rank the result units based on their kill, score, and seq values.\n## Questions: \n 1. What is the purpose of the `ResultUnitEscape` class?\n- The `ResultUnitEscape` class is a subclass of `ResultUnit` and represents a specific type of result unit in the Brick-Force project.\n\n2. What does the `param` variable represent and how is it used?\n- The `param` variable is an integer that is set in the constructor of `ResultUnitEscape` and can be accessed and used within the class.\n\n3. What is the purpose of the `Compare` method and how does it work?\n- The `Compare` method is used to compare two `ResultUnitEscape` objects based on their `kill`, `score`, and `seq` properties. It returns a negative value if the current object is considered \"less\" than the passed object, and a positive value if it is considered \"greater\".","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ResultUnitEscape.md"}}],["403",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ResultUnitEx.cs)\n\nThe code provided is a class called `ResultUnitEx` that extends another class called `ResultUnit`. This class is used to represent a result unit in the larger Brick-Force project.\n\nThe `ResultUnitEx` class has a public integer field called `param`, which is used to store a parameter value. This field is set through the constructor of the class.\n\nThe constructor of the `ResultUnitEx` class takes in several parameters, including a boolean value `_red`, an integer value `_seq`, a string value `_nickname`, and several other integer and long values. These parameters are used to initialize the fields of the base class `ResultUnit` through the `base` keyword. The `param` field of the `ResultUnitEx` class is also initialized with the `_param` parameter.\n\nThe `ResultUnitEx` class also has a method called `Compare`, which takes in another `ResultUnitEx` object `ru` as a parameter. This method is used to compare two `ResultUnitEx` objects based on their `score`, `kill`, and `death` fields. The method returns an integer value based on the comparison result.\n\nIf the `score` field of the current `ResultUnitEx` object is equal to the `score` field of the `ru` object, the method checks if the `kill` field is equal. If they are equal, the method compares the `death` fields of the two objects using the `CompareTo` method and returns the result.\n\nIf the `kill` field is not equal, the method compares the `kill` fields of the two objects using the `CompareTo` method and returns the negation of the result.\n\nIf the `score` field is not equal, the method compares the `score` fields of the two objects using the `CompareTo` method and returns the negation of the result.\n\nThis `Compare` method is likely used in the larger Brick-Force project to sort and compare `ResultUnitEx` objects based on their scores, kills, and deaths. It provides a way to determine the relative ranking of different result units.\n## Questions: \n 1. What is the purpose of the `ResultUnitEx` class and how does it differ from the `ResultUnit` class it inherits from?\n- The `ResultUnitEx` class is a subclass of `ResultUnit` and adds an additional `param` property. It likely extends the functionality of the `ResultUnit` class by including this extra parameter.\n\n2. What is the purpose of the `Compare` method in the `ResultUnitEx` class?\n- The `Compare` method is used to compare two `ResultUnitEx` objects based on their `score`, `kill`, and `death` properties. It returns a negative value if the current object is considered \"less than\" the passed object, a positive value if it is considered \"greater than\", and zero if they are considered equal.\n\n3. What are the parameters being passed to the constructor of the `ResultUnitEx` class and how are they used?\n- The constructor of the `ResultUnitEx` class takes in multiple parameters representing various statistics such as `red`, `seq`, `nickname`, `kill`, `death`, `assist`, `score`, `point`, `xp`, `mission`, `prevXp`, `nextXp`, `buff`, and `param`. These parameters are used to initialize the corresponding properties of the `ResultUnitEx` object.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ResultUnitEx.md"}}],["404",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ResultUnitZombie.cs)\n\nThe code provided is a class called `ResultUnitZombie` that extends another class called `ResultUnit`. This class represents a specific type of result unit for a zombie in the larger Brick-Force project.\n\nThe `ResultUnitZombie` class has a public integer variable called `winCount`, which represents the total number of wins for the zombie. This variable is initialized in the constructor of the class by adding the values of `_kill` and `_death` parameters.\n\nThe class also has a method called `Compare`, which takes an instance of `ResultUnitZombie` as a parameter and returns an integer value. This method is used to compare two instances of `ResultUnitZombie` based on their scores, win counts, and sequence numbers.\n\nThe comparison logic in the `Compare` method is as follows:\n- If the scores of the two instances are equal, it compares their win counts.\n- If the win counts are also equal, it compares their sequence numbers.\n- If the scores are not equal, it compares their scores.\n\nThe comparison is done using the `CompareTo` method, which returns a negative value if the current instance is less than the parameter instance, a positive value if it is greater, and zero if they are equal.\n\nThis class is likely used in the larger Brick-Force project to represent and compare the results of zombie units in the game. It provides a way to sort and rank the zombie units based on their scores, win counts, and sequence numbers. This information can be used for various purposes, such as determining the leaderboard or calculating rewards for the players.\n\nExample usage:\n```csharp\nResultUnitZombie zombie1 = new ResultUnitZombie(true, 1, \"Zombie1\", 10, 5, 3, 100, 50, 1000, 1, 900, 1100, 123456789);\nResultUnitZombie zombie2 = new ResultUnitZombie(true, 2, \"Zombie2\", 8, 7, 2, 90, 40, 900, 1, 800, 1000, 987654321);\n\nint comparisonResult = zombie1.Compare(zombie2);\nConsole.WriteLine(comparisonResult); // Output: 1 (zombie1 is ranked higher than zombie2)\n```\n## Questions: \n 1. What is the purpose of the `Compare` method in the `ResultUnitZombie` class?\n- The `Compare` method is used to compare two `ResultUnitZombie` objects based on their `score`, `winCount`, and `seq` properties.\n\n2. What does the `winCount` property represent in the `ResultUnitZombie` class?\n- The `winCount` property represents the total number of wins for a `ResultUnitZombie` object, which is calculated by adding the `kill` and `death` properties.\n\n3. What is the significance of the negative sign in the return statements of the `Compare` method?\n- The negative sign is used to indicate that the comparison result should be in descending order. So, a negative value means that the current object should be ranked higher than the compared object.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ResultUnitZombie.md"}}],["405",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Room.cs)\n\nThe code provided is a class called \"Room\" that is part of the Brick-Force project. This class represents a room in the game and contains various properties and methods related to the room.\n\nThe class starts by defining several enums. The \"COLUMN\" enum represents the different columns that can be used to sort the rooms. The \"ROOM_TYPE\" enum represents the different types of rooms that can be created. The \"MODE_MASK\" enum represents the different modes that can be applied to a room. The \"ROOM_STATUS\" enum represents the different statuses that a room can have.\n\nThe class also contains several arrays of strings and integers that map the enums to their corresponding values. These arrays are used for various purposes, such as converting enum values to strings.\n\nThe class then defines several properties, such as \"locked\", \"no\", \"title\", \"type\", \"status\", etc., which represent the different attributes of a room. These properties have both getter and setter methods.\n\nThe class also includes a constructor that allows the creation of a new room object with the specified attributes.\n\nThe class provides several methods for manipulating and retrieving information about rooms. For example, the \"IsPlayingScene\" method checks if the current scene is a playing scene. The \"ModeMask2String\" method converts a mode mask to a string representation. The \"Compare\" method compares two rooms based on a specified column and sorting order. The \"GetString\" methods retrieve the string representation of a specified column or the room itself. The \"Status2String\" and \"Type2String\" methods convert a status or type value to a string representation.\n\nOverall, this class provides a way to create, manipulate, and retrieve information about rooms in the Brick-Force game. It is an essential part of the larger project as it allows players to interact with and join different rooms in the game.\n## Questions: \n 1. What are the different types of rooms that can be created in Brick-Force?\n- The different types of rooms that can be created in Brick-Force are: Map Editor, Team Match, Individual, Capture the Flag, Explosion, Mission, BND, Bungee, Escape, and Zombie.\n\n2. What are the different status options for a room in Brick-Force?\n- The different status options for a room in Brick-Force are: Waiting, Pending, Playing, Matching, and Match End.\n\n3. How can the mode mask be converted into a string representation?\n- The mode mask can be converted into a string representation by using the `ModeMask2String` method, which takes in a mode mask as a parameter and returns a string representing the corresponding room types.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Room.md"}}],["406",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\RoomListFrame.cs)\n\nThe code provided is a class called `RoomListFrame` that is used to display a list of rooms in a graphical user interface (GUI) for the Brick-Force project. The purpose of this code is to create and manage the visual representation of the room list, including buttons, labels, and icons.\n\nThe `RoomListFrame` class contains various fields that define the positions and sizes of different GUI elements, such as buttons and labels. These fields are used to calculate the positions of the elements in the GUI.\n\nThe `Start` method initializes an array of `Texture2D` objects called `modeIcon` with references to different icons used for different room modes. It also finds the `StreamedLevelLoadibilityChecker` component attached to a game object named \"Main\" and assigns it to the `sll` field.\n\nThe `Update` method does not perform any actions and is empty.\n\nThe `OnGUI` method is responsible for rendering the GUI elements and handling user interactions. It starts by drawing a box using the `GUI.Box` method, which creates a rectangular area with a background texture.\n\nNext, it creates two buttons: \"QUICK_JOIN\" and \"CREATE_ROOM\". When the \"QUICK_JOIN\" button is clicked, it checks if the `sll` object is not null and if the streamed level can be loaded. If these conditions are met, it displays a message box with the text \"STREAMING_WAIT\". Otherwise, it sends a quick join request to the server. When the \"CREATE_ROOM\" button is clicked, it checks if the `sll` object is not null and if the streamed level can be loaded. If these conditions are met, it displays a message box with the text \"STREAMING_WAIT\". Otherwise, it opens a dialog box to create a new room.\n\nThe method then creates buttons for sorting the room list by different columns, such as room number, room map, room title, room type, room status, and number of players. When a button is clicked, it updates the `sortedBy` field and toggles the `ascending` field.\n\nAfter that, it creates a scrollable view using the `GUI.BeginScrollView` method. Inside the scroll view, it iterates over a list of rooms and renders the room information, such as room number, map alias, title, type, status, and number of players. It also checks if the room is locked and displays a lock icon if it is. When a room button is clicked, it sets the `num` variable to the room number.\n\nFinally, it ends the scroll view using the `GUI.EndScrollView` method. If the `num` variable is greater than or equal to 0, it checks if the streamed level can be loaded. If it can't, it displays a message box with the text \"STREAMING_WAIT\". Otherwise, it retrieves the room object with the corresponding room number and checks if it is locked. If it is, it opens a password dialog box. If it is not locked, it sends a join request to the server.\n\nIn summary, this code is responsible for creating and managing the visual representation of the room list in the Brick-Force project. It handles user interactions, such as clicking buttons and scrolling, and communicates with the server to perform actions like joining a room or creating a new room.\n## Questions: \n 1. What is the purpose of the `Start()` method and what does it do?\n- The `Start()` method initializes the `modeIcon` array with texture assets and assigns the `StreamedLevelLoadibilityChecker` component to the `sll` variable if it exists in the scene.\n\n2. What is the purpose of the `Update()` method and what does it do?\n- The `Update()` method currently does nothing as it only contains an `if` statement that is never true (`if (!once)`).\n\n3. What is the purpose of the `OnGUI()` method and what does it do?\n- The `OnGUI()` method is responsible for rendering the graphical user interface (GUI) elements for the room list. It creates buttons, labels, and textures based on the data stored in the `RoomListFrame` class.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\RoomListFrame.md"}}],["407",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\RoomPswdDialog.cs)\n\nThe code provided is a class called `RoomPswdDialog` that extends the `Dialog` class. This class represents a dialog box that allows the user to enter a password for a room. \n\nThe `RoomPswdDialog` class has several member variables. The `roomNo` variable stores the room number, the `roomPswd` variable stores the password entered by the user, and the `maxRoomPswd` variable sets the maximum length of the password. The `crdPswd` variable defines the position and size of the password input field in the dialog box.\n\nThe `Start` method sets the `id` of the dialog box to a specific value from the `DialogManager.DIALOG_INDEX` enum.\n\nThe `OnPopup` method sets the position of the dialog box to the center of the screen.\n\nThe `InitDialog` method initializes the `roomNo` and `roomPswd` variables.\n\nThe `DoDialog` method is the main method of the class and is responsible for rendering the dialog box and handling user input. It first sets the GUI skin to a specific skin obtained from `GUISkinFinder.Instance.GetGUISkin()`. It then renders a label with the text \"PASSWORD\" at the top of the dialog box. \n\nThe method then renders a password input field using the `GUI.PasswordField` method. The current value of `roomPswd` is displayed in the input field, and the user's input is stored in the `roomPswd` variable. The password is masked with asterisks.\n\nIf the length of the password exceeds the `maxRoomPswd` value, the password is reset to its previous value.\n\nThe method then renders an \"OK\" button. If the button is clicked, the method trims the password, checks if it is not empty, and sends a join request to the server using the `CSNetManager.Instance.Sock.SendCS_JOIN_REQ` method. If the request is successful, the `result` variable is set to true.\n\nThe method also renders a close button at the top right corner of the dialog box. If the close button is clicked or the escape key is pressed, the `result` variable is set to true.\n\nFinally, the method sets the focus to the password input field and handles the GUI events. The GUI skin is then reset to its original value, and the `result` variable is returned.\n\nIn the larger project, this code would be used to display a dialog box for entering a password for a room. The user can enter the password and click the \"OK\" button to join the room.\n## Questions: \n 1. What is the purpose of the `RoomPswdDialog` class?\n- The `RoomPswdDialog` class is a subclass of the `Dialog` class and is used to create a dialog box for entering a password for a room.\n\n2. What is the significance of the `InitDialog` method?\n- The `InitDialog` method is used to initialize the `roomNo` and `roomPswd` variables of the `RoomPswdDialog` class.\n\n3. What is the purpose of the `DoDialog` method?\n- The `DoDialog` method is responsible for rendering and handling user interactions with the dialog box. It returns a boolean value indicating whether the dialog should be closed or not.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\RoomPswdDialog.md"}}],["408",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Rot.cs)\n\nThe code provided is a part of the Brick-Force project and is contained in a file called \"Rot.cs\". The purpose of this code is to convert a byte value representing a rotation into a Quaternion object. \n\nThe class \"Rot\" contains a single static method called \"ToQuaternion\" which takes a byte parameter called \"rot\". This method uses a switch statement to determine the appropriate rotation value based on the input byte. \n\nThe switch statement checks the value of \"rot\" and returns a Quaternion object with the corresponding rotation. If \"rot\" is 0, the method returns a Quaternion with no rotation (0 degrees on all axes). If \"rot\" is 1, the method returns a Quaternion with a rotation of 90 degrees around the y-axis. If \"rot\" is 2, the method returns a Quaternion with a rotation of 180 degrees around the y-axis. If \"rot\" is 3, the method returns a Quaternion with a rotation of 270 degrees around the y-axis. If \"rot\" is any other value, the method returns a Quaternion with no rotation (0 degrees on all axes).\n\nThis code can be used in the larger Brick-Force project to convert rotation values stored as bytes into Quaternion objects. Quaternions are commonly used in computer graphics and game development to represent rotations in 3D space. By using this code, developers can easily convert rotation values from bytes to Quaternions, allowing for smooth and accurate rotations of game objects.\n\nHere is an example of how this code can be used:\n\n```csharp\nbyte rotationValue = 1;\nQuaternion rotationQuaternion = Rot.ToQuaternion(rotationValue);\n```\n\nIn this example, the variable \"rotationValue\" is set to 1. The \"ToQuaternion\" method is then called with \"rotationValue\" as the argument, and the resulting Quaternion object is stored in the variable \"rotationQuaternion\". This Quaternion can then be used to rotate a game object in the Brick-Force project.\n## Questions: \n 1. What does the `ToQuaternion` method do?\nThe `ToQuaternion` method takes in a byte parameter `rot` and returns a Quaternion representing a rotation based on the value of `rot`.\n\n2. What are the possible values for the `rot` parameter?\nThe possible values for the `rot` parameter are 0, 1, 2, and 3.\n\n3. What does the `Quaternion.Euler` method do?\nThe `Quaternion.Euler` method creates a Quaternion representing a rotation based on Euler angles.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Rot.md"}}],["409",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\RouletteEffect.cs)\n\nThe code provided is a class called \"RouletteEffect\" that extends the \"UIGroup\" class. This class is part of the larger Brick-Force project and is responsible for creating a roulette effect in the user interface.\n\nThe class contains several public variables that are used to reference various UI elements such as images, labels, and a scroll view. These variables are assigned in the Unity editor and represent the different components that make up the roulette effect.\n\nThe class also contains several private variables that are used for internal calculations and tracking the state of the roulette effect. These variables include the current speed of the roulette wheel, the destination position of the wheel, and a boolean flag to indicate if the roulette effect is in progress.\n\nThe class has several methods that are used to initialize and update the roulette effect. The \"start\" method is called to set up the initial state of the UI elements. The \"Update\" method is called every frame to update the position of the roulette wheel and check for any changes in the current index. The \"Draw\" method is responsible for rendering the UI elements on the screen.\n\nThe \"InitDialog\" method is called to initialize the roulette effect with the specified parameters. It sets the internal variables based on the input values and triggers the roulette effect to start. The \"InitItemList\" method is called to generate a list of items that will be displayed on the roulette wheel. The items are randomly selected from two arrays, one for rare items and one for normal items. The number of items is determined by the \"itemFixCount\" and \"itemAddCount\" variables.\n\nOnce the roulette effect is complete, the \"ShowResultWindow\" method is called to display a result window with the selected item. The method creates an instance of the \"TCResultItemDialog\" class and initializes it with the selected item's details. The method also plays a sound effect based on whether the selected item is rare or not.\n\nIn summary, the \"RouletteEffect\" class is responsible for creating a roulette effect in the user interface of the Brick-Force project. It allows the user to spin a wheel and randomly select an item. The class handles the animation of the wheel, the selection of the item, and the display of a result window.\n## Questions: \n 1. What is the purpose of the `RouletteEffect` class?\n- The `RouletteEffect` class is a subclass of `UIGroup` and is used to create a roulette effect in a UI group.\n\n2. What are the variables `itemFixCount` and `itemAddCount` used for?\n- `itemFixCount` is used to determine the fixed number of items in the roulette effect, while `itemAddCount` is used to determine the additional number of items that can be added randomly.\n\n3. What is the purpose of the `InitItemList` method?\n- The `InitItemList` method is used to initialize the list of items in the roulette effect. It randomly selects items from the rare and normal arrays based on the given rare percentage and adds them to the `tcTItemList` array.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\RouletteEffect.md"}}],["410",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\RoundScore.cs)\n\nThe code provided defines a class called `RoundScore`. This class has two public integer variables `_cur` and `_total`, which represent the current score and the total score for a round, respectively. The class also has a constructor that takes two integer parameters `cur` and `total` and assigns them to the corresponding variables.\n\nThe purpose of this code is to create an object that represents the score for a round in a game. By encapsulating the current and total scores within an object, it allows for easier manipulation and tracking of the scores throughout the game.\n\nThis `RoundScore` class can be used in the larger project to keep track of the scores for each round of the game. For example, if the game has multiple rounds and the scores need to be displayed to the player, an instance of the `RoundScore` class can be created for each round and the current and total scores can be updated accordingly.\n\nHere is an example of how this class can be used:\n\n```java\nRoundScore round1Score = new RoundScore(50, 100);\nSystem.out.println(\"Current score for round 1: \" + round1Score._cur);\nSystem.out.println(\"Total score for round 1: \" + round1Score._total);\n\n// Update the scores for round 1\nround1Score._cur += 10;\nround1Score._total += 10;\n\nSystem.out.println(\"Updated current score for round 1: \" + round1Score._cur);\nSystem.out.println(\"Updated total score for round 1: \" + round1Score._total);\n```\n\nIn this example, we create an instance of `RoundScore` called `round1Score` with an initial current score of 50 and a total score of 100. We then print out the current and total scores. After that, we update the scores by adding 10 to both the current and total scores and print out the updated scores.\n\nOverall, this code provides a simple and reusable way to represent and manipulate the scores for each round of a game in the larger project.\n## Questions: \n 1. **What is the purpose of the `RoundScore` class?**\nThe `RoundScore` class appears to be a representation of a score for a round in a game. It has two properties, `_cur` and `_total`, which likely represent the current score and the total score for the round.\n\n2. **What is the significance of the `public` access modifier for the `_cur` and `_total` properties?**\nThe `public` access modifier indicates that the `_cur` and `_total` properties can be accessed from outside the `RoundScore` class. This means that other classes or objects can read or modify these properties directly.\n\n3. **Why does the `RoundScore` class have a constructor that takes two integer parameters?**\nThe constructor allows the creation of a new `RoundScore` object with initial values for the `_cur` and `_total` properties. This allows for flexibility in initializing the object with specific values when needed.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\RoundScore.md"}}],["411",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\SceneLoadManager.cs)\n\nThe code provided is for a class called `SceneLoadManager` in the Brick-Force project. This class is responsible for managing the loading of scenes in the game. It contains methods and properties that allow for asynchronous loading of scenes and provide information about the loading progress.\n\nThe `SceneLoadManager` class has a public `autoFunctionMap` dictionary that maps integers to `SceneLoadManager` instances. This dictionary is not used in the provided code and its purpose is unclear.\n\nThe class also has a private static `_instance` variable, which is used to implement the Singleton design pattern. The `Instance` property is a getter that returns the `_instance` variable. If `_instance` is null, it tries to find an existing `SceneLoadManager` instance in the scene using `Object.FindObjectOfType`. If no instance is found, it logs an error message. This ensures that there is only one instance of `SceneLoadManager` in the game.\n\nThe `Awake` method is called when the script instance is being loaded. It uses `Object.DontDestroyOnLoad` to prevent the `SceneLoadManager` object from being destroyed when a new scene is loaded. This ensures that the `SceneLoadManager` persists throughout the game.\n\nThe `Update` method is empty and does not contain any code. It is not used in the provided code.\n\nThe `SceneLoadLevelAsync` method is a public method that starts the asynchronous loading of a scene. It takes a `level` parameter, which is the name of the scene to be loaded. It starts a coroutine called `LoadLevelAsync` with the `level` parameter.\n\nThe `LoadLevelAsync` coroutine is a private method that performs the actual asynchronous loading of the scene. It sets the `levelName` variable to the provided `level` parameter and uses `Application.LoadLevelAsync` to load the scene asynchronously. It yields the `async` operation, which means it waits for the loading to complete before continuing.\n\nThe `IsLoadedDone` method checks if the loading is done by checking if the `async` variable is not null and if `async.isDone` is true. If both conditions are met, it returns true, indicating that the loading is done.\n\nThe `IsLoadStart` method checks if the loading has started for a specific level. It takes a `level` parameter and compares it to the `levelName` variable. If they are equal, it returns true, indicating that the loading has started for that level.\n\nThe `GetProgressString` method returns a string representing the loading progress. If `async` is null, it returns \"Load Ready\". If `async.isDone` is true, it returns \"Load Complete\". Otherwise, it returns the loading progress as a percentage.\n\nOverall, the `SceneLoadManager` class provides a way to asynchronously load scenes in the game and retrieve information about the loading progress. It ensures that there is only one instance of the `SceneLoadManager` in the game and persists throughout the game.\n## Questions: \n 1. What is the purpose of the `SceneLoadManager` class?\n- The `SceneLoadManager` class is responsible for managing the loading of scenes in the game.\n\n2. What is the purpose of the `autoFunctionMap` dictionary?\n- The `autoFunctionMap` dictionary is used to store mappings between integers and `SceneLoadManager` instances.\n\n3. What is the purpose of the `async` variable?\n- The `async` variable is used to store the asynchronous operation for loading a scene.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\SceneLoadManager.md"}}],["412",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\SceneSwitch.cs)\n\nThe code provided is a script called \"SceneSwitch\" that is used in the Brick-Force project. This script is responsible for handling the switching of scenes within the game. It contains various methods and variables that control the flow of the scene switching process.\n\nThe script starts by defining an enumeration called \"STEP\" which represents the different steps in the scene switching process. The possible steps are \"DEPARTURE\", \"CHANGE_CHANNEL\", \"LOBBY\", and \"DESTINATION\". These steps are used to keep track of the current state of the scene switching process.\n\nThe script also defines several constants that represent different error codes that can occur during the scene switching process. These error codes are used to handle different failure scenarios.\n\nThe script contains a public variable called \"loadingImage\" of type Texture, which represents the loading image that is displayed during the scene switching process. It also contains a variable called \"logoSize\" of type Vector2, which represents the size of the logo image that is displayed alongside the loading image.\n\nThe script contains several private variables, including \"step\" of type STEP, which represents the current step in the scene switching process, and various other variables used for GUI rendering.\n\nThe script contains several methods that handle different events during the scene switching process. The \"OnGUI\" method is responsible for rendering the loading image and logo on the screen. The \"Start\" method initializes the \"step\" variable to \"DEPARTURE\". The \"OnJoin\" method is called when a player successfully joins a room and handles the logic for switching to the appropriate scene based on the type of the room. The \"OnRoamIn\" method is called when a player successfully roams into a room and handles the logic for verifying the player's equipped slots and switching to the lobby scene. The \"SendCS_JOIN_REQ\" method is responsible for sending a join request to the server. The \"UpdateJoinRoom\" method checks if a join request has been sent and returns a boolean value indicating whether the join request was successful. The \"OnLobby\" method is called when the player is in the lobby and handles the logic for switching to the appropriate scene based on the destination level. The \"OnSeed\" method is called when the player successfully seeds into a room and handles the logic for clearing the channel user manager and roaming into the room. The \"RoamIn\" method is responsible for clearing the room and squad managers and sending a roam in request to the server. The \"OnSuccess\" method is called when the scene switching process is successful and loads the specified level. The \"OnFail\" method is called when the scene switching process fails and displays an error message. The \"OnRoamOut\" method is called when the player successfully roams out of a room and handles the logic for closing the socket connection and switching to the appropriate scene. The \"Update\" method is called every frame and handles the logic for the scene switching process based on the current step.\n\nIn summary, this script is responsible for handling the scene switching process in the Brick-Force game. It handles different events and error scenarios during the scene switching process and controls the flow of the switching process.\n## Questions: \n 1. What is the purpose of the `OnGUI` method?\n- The `OnGUI` method is responsible for rendering the loading screen and logo on the screen.\n\n2. What does the `OnJoin` method do?\n- The `OnJoin` method is called when a player successfully joins a room. It checks the type of the room and performs actions accordingly.\n\n3. What is the purpose of the `UpdateJoinRoom` method?\n- The `UpdateJoinRoom` method checks if the player has successfully joined a room and returns a boolean value indicating the status.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\SceneSwitch.md"}}],["413",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Scope.cs)\n\nThe `Scope` class is a script that is used to handle the scope functionality in the Brick-Force project. It is attached to a game object in the scene and is responsible for managing the camera and crosshair when the player is aiming down the scope of a weapon.\n\nThe class has several public properties that can be accessed and modified by other scripts. These properties include `guiDepth`, `crossHair`, `blackOut`, `accuracy`, `fov`, `camSpeed`, `midstep`, `midfovs`, and `zoomKeep`. These properties control various aspects of the scope, such as the depth of the GUI, the crosshair texture, the blackout texture, the accuracy of the weapon, the field of view, the camera speed, and the zoom behavior.\n\nThe class also has several private variables that are used internally. These variables include `aiming`, `scoping`, `cam`, `fpCam`, `camCtrl`, and `cooldown`. These variables keep track of the current state of the scope, the camera objects in the scene, the camera controller, and the cooldown state.\n\nThe class has several methods that are used to handle different aspects of the scope functionality. These methods include `VerifyCamera()`, `DrawCrossHair()`, `Start()`, `Modify()`, `HandleFireEvent()`, `CalcDeflection()`, `Inaccurate()`, `Accurate()`, `SetAiming()`, `OnDisable()`, `ToggleScoping()`, `IsZooming()`, `ZoomIn()`, `ZoomOut()`, `SetupCamera()`, `OnGUI()`, and `Update()`.\n\nThe `VerifyCamera()` method is used to find and assign the camera objects in the scene. It returns true if the cameras are found and assigned successfully.\n\nThe `DrawCrossHair()` method is used to draw the crosshair texture on the screen when the player is aiming down the scope. It takes into account the position and size of the crosshair texture and the blackout texture.\n\nThe `Start()` method is called when the script is first initialized. It calls the `Modify()` method to modify the accuracy, field of view, and camera speed based on the weapon being used. It also initializes the cooldown, aiming, scoping, and accuracy.\n\nThe `Modify()` method is used to modify the accuracy, field of view, and camera speed based on the weapon being used. It retrieves the weapon function component and the weapon modifier component and updates the accuracy, field of view, and camera speed accordingly.\n\nThe `HandleFireEvent()` method is called when the player fires a weapon. It calls the `Inaccurate()` method to make the aim inaccurate and checks if the zoom should be kept or not. If the zoom should not be kept, it sets the cooldown to true and checks if the player is currently zooming. If the player is zooming, it sets the scoping to false, zooms out, and sets the aiming to true.\n\nThe `CalcDeflection()` method is used to calculate the deflection of the aim based on the current accuracy.\n\nThe `Inaccurate()` method is used to make the aim inaccurate. It takes a boolean parameter `aimAccurateMore` which determines if the aim should be made more accurate or not.\n\nThe `Accurate()` method is used to make the aim accurate. It takes a boolean parameter `aimAccurate` which determines if the aim should be made accurate or not.\n\nThe `SetAiming()` method is used to set the aiming state. It takes a boolean parameter `_aiming` which determines if the player is aiming or not.\n\nThe `OnDisable()` method is called when the script is disabled. If the player is currently zooming, it sets the scoping to false and zooms out.\n\nThe `ToggleScoping()` method is used to toggle the scoping state. It takes an optional boolean parameter `forceApply` which determines if the scoping state should be forced to apply. It checks if the midstep is greater than 0 and if the player is currently scoping or not. If the player is not scoping, it sets the current step to the midstep and returns true. If the player is scoping, it decreases the current step and checks if it is less than 0. If it is less than 0, it returns true. If the midstep is 0 or the flag is true or the forceApply parameter is true, it toggles the scoping state and calls the `SetupCamera()` method.\n\nThe `IsZooming()` method is used to check if the player is currently zooming. It returns true if the player is aiming and scoping.\n\nThe `ZoomIn()` method is used to zoom in the camera when the player is aiming and scoping. It sets the scope field of view of the camera based on the current step or the default field of view if the current step is 0. It disables the first-person camera and sets the camera speed factor.\n\nThe `ZoomOut()` method is used to zoom out the camera when the player is not aiming and scoping. It enables the first-person camera and resets the camera speed factor and scope field of view.\n\nThe `SetupCamera()` method is used to set up the camera based on the current scoping state. It verifies the camera objects, checks if the player is currently zooming, and calls the `ZoomIn()` or `ZoomOut()` method accordingly.\n\nThe `OnGUI()` method is used to draw the crosshair texture on the screen. It checks if the GUI is enabled and if the game is not in a modal state. It then calls the `DrawCrossHair()` method.\n\nThe `Update()` method is called every frame. It verifies the camera objects and checks if the cooldown is active. If the cooldown is active, it checks if the gun component is cooling down.\n## Questions: \n 1. **Question:** What is the purpose of the `VerifyCamera()` method?\n   - **Answer:** The `VerifyCamera()` method is used to find and assign the main camera and first-person camera objects in the scene, as well as the camera controller component. It ensures that these objects are not null before proceeding.\n\n2. **Question:** What does the `HandleFireEvent()` method do?\n   - **Answer:** The `HandleFireEvent()` method is responsible for handling the firing event. It calls the `Inaccurate()` method to make the aim inaccurate, and if `zoomKeep` is false, it sets `cooldown` to true and checks if the player is zooming. If the player is zooming, it sets `scoping` to false, zooms out, and sets the aiming state to true.\n\n3. **Question:** What is the purpose of the `ToggleScoping()` method?\n   - **Answer:** The `ToggleScoping()` method is used to toggle the scoping state. If `midstep` is greater than 0, it increments or decrements `curstep` based on the current scoping state. If `midstep` is 0 or the scoping state needs to be forced, it toggles the `scoping` state and calls the `SetupCamera()` method to update the camera settings accordingly. Finally, it returns the new scoping state.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Scope.md"}}],["414",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ScreenShot.cs)\n\nThe code provided is a script called \"ScreenShot\" that is a part of the larger Brick-Force project. This script is responsible for capturing and saving screenshots of the game.\n\nThe script starts by declaring a boolean variable called \"bSaving\" which is used to track whether a screenshot is currently being saved or not.\n\nThe \"CreateFolderIfNotExists\" method is responsible for creating a folder to store the screenshots if it does not already exist. It uses the \"ScreenShotFolderName\" method to determine the path of the folder. If the folder does not exist, it creates it using the \"Directory.CreateDirectory\" method.\n\nThe \"ScreenShotFolderName\" method returns the path of the folder where the screenshots will be saved. It uses the \"Application.dataPath\" property to get the path of the game's data folder and appends \"/../Screenshots\" to it.\n\nThe \"ScreenShotName\" method is responsible for generating a unique name for each screenshot. It takes the width and height of the screen as parameters and uses the current date and time to create a formatted string in the format \"Screenshot_yyyyMMdd_HHmmss.png\". It uses the \"ScreenShotFolderName\" method to determine the path of the folder where the screenshot will be saved.\n\nThe \"Update\" method is called every frame and checks if the \"K_SCREEN_SHOT\" button is pressed. If it is and a screenshot is not currently being saved, it sets \"bSaving\" to true and calls the \"MakeScreenshot\" method.\n\nThe \"MakeScreenshot\" method is responsible for actually capturing and saving the screenshot. It first calls the \"CreateFolderIfNotExists\" method to ensure that the folder for saving screenshots exists. It then starts a coroutine called \"ScreenshotEncode\".\n\nThe \"ScreenshotEncode\" coroutine waits for the end of the current frame using \"yield return new WaitForEndOfFrame()\". It then creates a new Texture2D object with the width and height of the screen and the RGB24 texture format. It uses the \"ReadPixels\" method to read the pixels from the screen into the texture. It applies the changes to the texture using the \"Apply\" method. It then encodes the texture into a PNG byte array using the \"EncodeToPNG\" method. It generates a unique name for the screenshot using the \"ScreenShotName\" method. It saves the byte array to a file using the \"File.WriteAllBytes\" method. It destroys the texture object using \"UnityEngine.Object.DestroyObject\". It shows a system message indicating that the screenshot has been saved using the \"SystemMsgManager.Instance.ShowMessage\" method. Finally, it sets \"bSaving\" to false.\n\nIn summary, this script allows the player to capture and save screenshots of the game by pressing a specific button. It creates a folder to store the screenshots if it does not already exist, captures the current frame as a texture, encodes it into a PNG byte array, and saves it to a file. It also provides a unique name for each screenshot based on the current date and time.\n## Questions: \n 1. What is the purpose of the `CreateFolderIfNotExists` method?\n- The `CreateFolderIfNotExists` method is used to create a folder for storing screenshots if it does not already exist.\n\n2. What is the purpose of the `MakeScreenshot` method?\n- The `MakeScreenshot` method is responsible for creating a folder for the screenshot if it does not exist and then starting the process of encoding and saving the screenshot.\n\n3. What is the purpose of the `ScreenshotEncode` coroutine?\n- The `ScreenshotEncode` coroutine is used to capture the screen, encode it into a PNG format, and save it as a file.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ScreenShot.md"}}],["415",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ScriptAlarm.cs)\n\nThe `ScriptAlarm` class is a script that is used to enable another script, `ScriptExecutor`, after a certain amount of time has passed. This script is likely used in the larger Brick-Force project to control the execution of certain scripts within the game.\n\nThe `ScriptAlarm` class has two private variables: `deltaTime` and `timer`. `deltaTime` is a float variable that represents the amount of time that needs to pass before enabling the `ScriptExecutor` component. `timer` is a float variable that keeps track of the time that has passed since the script started.\n\nThe class also has a public property called `DeltaTime` that allows other scripts to get and set the value of `deltaTime`.\n\nThe `Start` method is called when the script is first initialized. It sets the `timer` variable to 0.\n\nThe `Update` method is called every frame. It increments the `timer` variable by the time that has passed since the last frame using `Time.deltaTime`. It then checks if the `timer` is greater than the `deltaTime`. If it is, it retrieves the `ScriptExecutor` component attached to the same game object as the `ScriptAlarm` script. If the component is not null, it sets the `enabled` property of the component to true. Finally, it destroys the `ScriptAlarm` script itself using `Object.DestroyImmediate(this)`.\n\nThis script can be used in the larger Brick-Force project to enable certain scripts or behaviors after a specific amount of time has passed. For example, it could be used to activate a power-up or trigger an event after a certain delay. Other scripts in the project can set the `DeltaTime` property to control the amount of time needed before enabling the `ScriptExecutor` component.\n\nExample usage:\n\n```csharp\nScriptAlarm scriptAlarm = gameObject.AddComponent<ScriptAlarm>();\nscriptAlarm.DeltaTime = 5f; // Enable the ScriptExecutor component after 5 seconds\n```\n## Questions: \n 1. What is the purpose of the `ScriptAlarm` class?\n- The `ScriptAlarm` class is responsible for enabling a `ScriptExecutor` component after a certain amount of time has passed.\n\n2. What is the purpose of the `DeltaTime` property?\n- The `DeltaTime` property allows the developer to set and get the time interval after which the `ScriptExecutor` component should be enabled.\n\n3. What does the `Object.DestroyImmediate(this)` line do?\n- The `Object.DestroyImmediate(this)` line destroys the current instance of the `ScriptAlarm` script component.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ScriptAlarm.md"}}],["416",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ScriptCmd.cs)\n\nThe code provided defines a class called `ScriptCmd` which contains several static arrays and virtual methods. \n\nThe `ScriptCmd` class has two static arrays: `CmdDelimeters` and `ArgDelimeters`. These arrays are used to store delimiters that will be used to split strings into smaller parts. \n\nThe `CmdDelimeters` array contains two elements: `\")(*&\"` and `\"\\0\"`. These delimiters will be used to split a command string into separate commands. For example, if the command string is `\"command1)(*&command2\"`, using the `CmdDelimeters` delimiter, the string will be split into two commands: `\"command1\"` and `\"command2\"`.\n\nThe `ArgDelimeters` array also contains two elements: `\"!@#$\"` and `\"\\0\"`. These delimiters will be used to split a command argument string into separate arguments. For example, if the argument string is `\"arg1!@#$arg2\"`, using the `ArgDelimeters` delimiter, the string will be split into two arguments: `\"arg1\"` and `\"arg2\"`.\n\nThe `ScriptCmd` class also contains three virtual methods: `GetDescription()`, `GetIconIndex()`, and `GetName()`. These methods are meant to be overridden by subclasses of `ScriptCmd` to provide specific functionality.\n\nThe `GetDescription()` method returns a string that describes the command. By default, it returns the string `\"null\"`. Subclasses can override this method to provide a more meaningful description.\n\nThe `GetIconIndex()` method returns an integer that represents the index of the icon associated with the command. By default, it returns `-1`. Subclasses can override this method to provide a specific icon index.\n\nThe `GetName()` method returns a string that represents the name of the command. By default, it returns the string `\"null\"`. Subclasses can override this method to provide a specific name.\n\nOverall, this code provides a base class `ScriptCmd` that can be extended to create different types of commands for the larger Brick-Force project. Subclasses can override the virtual methods to provide specific functionality, such as descriptions, icons, and names, for each command.\n## Questions: \n 1. **What is the purpose of the `CmdDelimeters` and `ArgDelimeters` arrays?**\nThe `CmdDelimeters` array is used to store two delimiters that are used to separate commands in a script. The `ArgDelimeters` array is used to store two delimiters that are used to separate arguments within a command.\n   \n2. **What is the purpose of the `GetDescription()`, `GetIconIndex()`, and `GetName()` methods?**\nThese methods are virtual methods that can be overridden by subclasses of `ScriptCmd`. They are used to retrieve the description, icon index, and name of a script command, respectively.\n\n3. **Why does the `GetDescription()` method return \"null\" by default?**\nThe `GetDescription()` method returns \"null\" by default because it is a virtual method and is meant to be overridden by subclasses. If a subclass does not override this method, it will return \"null\" as a default value.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ScriptCmd.md"}}],["417",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ScriptCmdFactory.cs)\n\nThe code provided is a class called `ScriptCmdFactory` that contains two static methods: `CreateDefault` and `Create`. The purpose of this class is to create instances of different types of `ScriptCmd` objects based on the provided input.\n\nThe `CreateDefault` method takes an integer `index` as input and returns a `ScriptCmd` object. It uses a switch statement to determine the value of `text` based on the value of `index`. It then calls a corresponding static method on different classes (`EnableScript`, `ShowDialog`, `PlaySound`, etc.) to get the default description for that specific type of `ScriptCmd`. If the length of `text` is 0, it returns null. Otherwise, it calls the `Create` method with the obtained default description as input and returns the result.\n\nThe `Create` method takes a string `description` as input and returns a `ScriptCmd` object. It first splits the `description` string into an array of strings using the `ScriptCmd.ArgDelimeters` delimiter. It then checks if the array is not null and has a length greater than 0. If so, it trims each element of the array. It then converts the first element of the array to lowercase and assigns it to the `text` variable.\n\nBased on the value of `text`, the method creates an instance of a specific type of `ScriptCmd` object and assigns it to the `result` variable. It uses a switch statement to determine the type of `ScriptCmd` object to create based on the value of `text`. Each case in the switch statement corresponds to a different type of `ScriptCmd` object (`EnableScript`, `ShowDialog`, `PlaySound`, etc.). It initializes the properties of the created object based on the values in the `array` and assigns it to the `result` variable.\n\nFinally, the method returns the `result` variable, which is the created `ScriptCmd` object.\n\nThis code can be used in the larger project to create instances of different types of `ScriptCmd` objects based on the provided input. It provides a way to easily create different types of `ScriptCmd` objects without having to manually instantiate each one. This can be useful when working with a large number of `ScriptCmd` objects and needing to create them dynamically based on user input or other conditions.\n\nExample usage:\n\n```csharp\nScriptCmd cmd = ScriptCmdFactory.CreateDefault(0);\nif (cmd != null)\n{\n    // Use the created ScriptCmd object\n}\n```\n\n```csharp\nstring description = \"enablescript 1 true\";\nScriptCmd cmd = ScriptCmdFactory.Create(description);\nif (cmd != null)\n{\n    // Use the created ScriptCmd object\n}\n```\n## Questions: \n 1. What is the purpose of the `CreateDefault` method?\n- The `CreateDefault` method is used to create a default `ScriptCmd` object based on the given index. \n\n2. What is the purpose of the `Create` method?\n- The `Create` method is used to create a `ScriptCmd` object based on the given description.\n\n3. What are the different types of `ScriptCmd` objects that can be created?\n- The different types of `ScriptCmd` objects that can be created are `EnableScript`, `ShowDialog`, `PlaySound`, `Sleep`, `Exit`, `ShowScript`, `GiveWeapon`, `TakeAwayAll`, and `SetMission`.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ScriptCmdFactory.md"}}],["418",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ScriptCmdSelector.cs)\n\nThe code provided is a class called `ScriptCmdSelector` that extends the `Dialog` class. This class is responsible for displaying a dialog box that allows the user to select a script command from a grid of icons. The selected command is then added to a `ScriptEditor` object.\n\nThe `ScriptCmdSelector` class has several member variables. The `scriptEditor` variable is a reference to the `ScriptEditor` object that will receive the selected command. The `scrollPosition` variable is used to store the current scroll position of the grid. The `selected` variable stores the index of the currently selected command.\n\nThe `Start()` method sets the `id` variable of the dialog to a specific index value.\n\nThe `OnPopup()` method calculates the position of the dialog box based on the screen size.\n\nThe `DoDialog()` method is responsible for rendering the dialog box and handling user input. It first sets the GUI skin to a custom skin obtained from `GUISkinFinder`. It then calculates the number of rows and columns in the grid based on the number of command icons available. It creates a `Rect` object to define the size of the grid based on the width of the command icons. It then begins a scroll view using `GUI.BeginScrollView` and passes in the `scrollPosition` and `rect` variables. Inside the scroll view, it renders a selection grid using `GUI.SelectionGrid` and passes in the command icons and the number of columns. It ends the scroll view using `GUI.EndScrollView`. \n\nThe method then checks if the \"OK\" button is clicked. If it is, it adds the selected command to the `scriptEditor` object using `scriptEditor.AddCmd` and creates a default command using `ScriptCmdFactory.CreateDefault`. It sets the `result` variable to `true` to indicate that the dialog should be closed.\n\nThe method also checks if the \"CANCEL\" button is clicked. If it is, it sets the `result` variable to `true` to indicate that the dialog should be closed.\n\nFinally, the method checks if there is no other popup menu open and calls `WindowUtil.EatEvent()` to prevent further event handling.\n\nThe `InitDialog()` method is used to initialize the `scriptEditor`, `selected`, and `scrollPosition` variables.\n\nIn the larger project, this code is likely used to allow the user to select and add script commands to a script editor. The `ScriptCmdSelector` dialog box is displayed when the user wants to add a new command to the script. The user can select a command from the grid of icons and click the \"OK\" button to add it to the script editor. The dialog box can be closed by clicking the \"CANCEL\" button.\n## Questions: \n 1. What is the purpose of the `ScriptCmdSelector` class?\n- The `ScriptCmdSelector` class is a subclass of `Dialog` and is used to display a dialog box for selecting script commands.\n\n2. What is the significance of the `selected` variable?\n- The `selected` variable stores the index of the currently selected script command.\n\n3. What is the purpose of the `InitDialog` method?\n- The `InitDialog` method is used to initialize the `ScriptEditor` and set the initial values for the `selected` and `scrollPosition` variables.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ScriptCmdSelector.md"}}],["419",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ScriptDialog.cs)\n\nThe `ScriptDialog` class is a script that is used to display a dialog box in the game. It is a part of the larger Brick-Force project. \n\nThe purpose of this code is to handle the rendering and functionality of the dialog box. It contains properties for the speaker and the text of the dialog, as well as a constant for the lifetime of the dialog box. The `OnGUI` method is responsible for rendering the dialog box on the screen. It sets the GUI skin, depth, and color, and then uses the `LabelUtil.TextOut` method to display the text of the dialog in the center of the screen. The `Start` method is empty and does not have any functionality. The `CheckSkipButton` method checks if the player has pressed the skip button, which can be the Enter key, Escape key, or left mouse button.\n\nThis code can be used in the larger Brick-Force project to display dialog boxes during gameplay. The `ScriptDialog` class can be attached to a game object in the scene, and the speaker and text properties can be set to customize the dialog. The `OnGUI` method will be called every frame to render the dialog box on the screen. The `CheckSkipButton` method can be used to check if the player wants to skip the dialog and move on.\n\nHere is an example of how this code can be used in the larger project:\n\n```csharp\nScriptDialog dialog = gameObject.AddComponent<ScriptDialog>();\ndialog.Speaker = 1;\ndialog.Text = \"Hello, welcome to Brick-Force!\";\n```\n\nIn this example, a new `ScriptDialog` component is added to a game object in the scene. The speaker is set to 1 and the text is set to \"Hello, welcome to Brick-Force!\". When the game is running, the dialog box will be displayed on the screen with the specified text. The player can then press the skip button to move on to the next dialog or continue reading.\n## Questions: \n 1. What is the purpose of the `ScriptDialog` class?\n- The `ScriptDialog` class is used to display a dialog box with text on the screen.\n\n2. What is the significance of the `fmt` variable?\n- The `fmt` variable is used to determine if text formatting should be applied to the dialog text. If `fmt` is greater than 0, text formatting is applied.\n\n3. What is the purpose of the `CheckSkipButton` method?\n- The `CheckSkipButton` method checks if the user has pressed certain keys or mouse buttons that indicate they want to skip the dialog. It returns `true` if any of those keys or buttons are pressed.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ScriptDialog.md"}}],["420",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ScriptDialogBg.cs)\n\nThe code provided defines a class called `ScriptDialogBg` that is used to represent a background image for a dialog in the Brick-Force project. This class is marked with the `[Serializable]` attribute, which means that instances of this class can be serialized and deserialized, allowing them to be saved to and loaded from disk or transmitted over a network.\n\nThe `ScriptDialogBg` class has three public fields:\n- `alias`: a string that represents a unique identifier or name for the background image.\n- `bgIcon`: a `Texture2D` object that represents a small icon image that can be used to visually represent the background image.\n- `dialogBg`: a `Texture2D` object that represents the actual background image for the dialog.\n\nThese fields are public, which means that they can be accessed and modified from other parts of the code. This allows other classes or scripts in the Brick-Force project to set or retrieve the alias, bgIcon, and dialogBg values for a specific `ScriptDialogBg` instance.\n\nThe purpose of this code is to provide a way to define and manage different background images for dialogs in the Brick-Force project. By creating instances of the `ScriptDialogBg` class and setting the alias, bgIcon, and dialogBg values, developers can easily switch between different background images for different dialogs in the game.\n\nHere is an example of how this code might be used in the larger project:\n\n```csharp\n// Create a new ScriptDialogBg instance\nScriptDialogBg dialogBg = new ScriptDialogBg();\n\n// Set the alias, bgIcon, and dialogBg values\ndialogBg.alias = \"dialog1\";\ndialogBg.bgIcon = Resources.Load<Texture2D>(\"dialog1_icon\");\ndialogBg.dialogBg = Resources.Load<Texture2D>(\"dialog1_bg\");\n\n// Use the dialogBg instance in a dialog system\nDialogSystem.SetBackground(dialogBg);\n```\n\nIn this example, a new `ScriptDialogBg` instance is created and its fields are set to specific values. The `dialogBg` instance is then passed to a hypothetical `DialogSystem` class, which uses the background image for a specific dialog. By creating multiple instances of `ScriptDialogBg` with different values, developers can easily switch between different background images for different dialogs in the game without having to modify the code that uses the `ScriptDialogBg` instances.\n## Questions: \n 1. What is the purpose of the `[Serializable]` attribute on the `ScriptDialogBg` class?\n- The `[Serializable]` attribute indicates that instances of the `ScriptDialogBg` class can be serialized and deserialized, allowing them to be stored or transmitted as data.\n\n2. What is the significance of the `alias` property in the `ScriptDialogBg` class?\n- The `alias` property likely represents a unique identifier or name for a specific instance of the `ScriptDialogBg` class, which could be used for referencing or identifying different dialog backgrounds.\n\n3. How are the `bgIcon` and `dialogBg` properties used in the `ScriptDialogBg` class?\n- The `bgIcon` and `dialogBg` properties are likely used to store references to texture images that will be used as the background icon and dialog background, respectively, in the game or application.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ScriptDialogBg.md"}}],["421",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ScriptExecutor.cs)\n\nThe `ScriptExecutor` class is responsible for executing a sequence of script commands in the Brick-Force project. It contains a `Run` method that takes a `BfScript` object as a parameter and enqueues all the commands from the script into a `scriptCmdQueue`. \n\nThe `ExecuteCommand` method is called internally by the `Update` method and is responsible for executing each command in the queue. It checks the type of the command and calls the corresponding method to perform the desired action. For example, if the command is of type \"EnableScript\", it calls the `EnableScript` method with the appropriate parameters.\n\nThe class also contains several methods that correspond to the different types of commands that can be executed. These methods perform actions such as enabling or disabling scripts, showing dialogs, playing sounds, giving weapons to the player, and setting missions.\n\nFor example, the `GiveWeapon` method finds the player object in the scene and retrieves the `LocalController` component attached to it. It then calls the `PickupFromTemplate` method of the `LocalController` component to give the player a weapon based on the provided weapon code. It also handles some additional logic related to displaying tutorial help dialogs.\n\nThe `Update` method is called every frame and checks if there are any commands in the queue. If there are, it dequeues the next command and calls the `ExecuteCommand` method to execute it. If there are no more commands in the queue and there are no active script dialogs or alarms, the `Update` method destroys the `ScriptExecutor` object.\n\nOverall, the `ScriptExecutor` class provides a way to run a sequence of script commands in the Brick-Force project. It handles the execution of different types of commands and performs the necessary actions based on the command type. This class is likely used in the larger project to control scripted events, dialogues, and gameplay mechanics.\n## Questions: \n 1. What is the purpose of the `Run` method in the `ScriptExecutor` class?\n- The `Run` method initializes a queue of `ScriptCmd` objects and adds each `ScriptCmd` from the `CmdList` of the `BfScript` parameter to the queue.\n\n2. What is the purpose of the `GiveWeapon` method in the `ScriptExecutor` class?\n- The `GiveWeapon` method finds the game object with the name \"Me\" and retrieves the `LocalController` component from it. It then calls the `PickupFromTemplate` method of the `LocalController` component to give the player a weapon based on the `weaponCode` parameter.\n\n3. What is the purpose of the `SetMission` method in the `ScriptExecutor` class?\n- The `SetMission` method finds the game object with the name \"Main\" and retrieves the `MissionLog` component from it. It then calls the `SetMission` method of the `MissionLog` component to set the mission details based on the provided parameters.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ScriptExecutor.md"}}],["422",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ScriptResManager.cs)\n\nThe `ScriptResManager` class is a script that manages the resources used in the Brick-Force project. It contains various arrays and methods to retrieve specific resources such as audio clips, textures, and aliases.\n\nThe class has several public fields, including `Executor`, `DialogBg`, `sounds`, `CmdIcon`, and `sergeant`. These fields are used to store references to game objects, script dialog backgrounds, audio clips, textures, and a specific texture called \"sergeant\" respectively.\n\nThe class also has a private static instance of `ScriptResManager` called `_instance`. This instance is used to implement the Singleton design pattern, ensuring that only one instance of `ScriptResManager` exists throughout the project. The `Instance` property provides a way to access this instance.\n\nThe `Awake()` method is called when the script is initialized and it uses `Object.DontDestroyOnLoad(this)` to prevent the `ScriptResManager` object from being destroyed when a new scene is loaded.\n\nThe class provides several methods to retrieve specific resources. For example, the `GetAudioClip(int index)` method takes an index parameter and returns the audio clip at the specified index in the `sounds` array. Similarly, the `GetDialogBg(int index)` method returns the dialog background texture at the specified index in the `DialogBg` array.\n\nThe class also provides methods to retrieve arrays of textures and aliases. The `GetDlgIconArray()` method returns an array of dialog background icons by iterating over the `DialogBg` array and adding each `bgIcon` to a list. The same approach is used in the `GetDlgAliasArray()` method to retrieve an array of dialog aliases.\n\nSimilarly, the `GetSndIconArray()` and `GetSndAliasArray()` methods retrieve arrays of sound icons and aliases respectively by iterating over the `sounds` array.\n\nOverall, the `ScriptResManager` class serves as a central resource manager for the Brick-Force project. It provides methods to retrieve various resources such as audio clips, textures, and aliases, making it easier for other scripts and components to access and use these resources.\n## Questions: \n 1. **Question:** What is the purpose of the `ScriptResManager` class?\n   - **Answer:** The `ScriptResManager` class is responsible for managing various resources such as game objects, textures, and audio clips.\n\n2. **Question:** What is the significance of the `Executor` and `sergeant` variables?\n   - **Answer:** The `Executor` variable is a reference to a game object, and the `sergeant` variable is a reference to a texture. Their purpose and usage within the code are not clear from the provided code snippet.\n\n3. **Question:** What is the purpose of the `OnApplicationQuit()` and `Start()` methods?\n   - **Answer:** The `OnApplicationQuit()` method is currently empty and does not have any functionality. The purpose of the `Start()` method is also not clear from the provided code snippet.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ScriptResManager.md"}}],["423",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ScriptSnd.cs)\n\nThe code provided is a class called `ScriptSnd` that is used to store information about a sound in the Brick-Force project. This class is marked with the `[Serializable]` attribute, which means that its instances can be serialized and deserialized, allowing them to be saved and loaded from disk or transmitted over a network.\n\nThe `ScriptSnd` class has three public fields:\n- `alias` is a string that represents a unique identifier for the sound. This can be used to reference the sound in other parts of the project.\n- `audioClip` is an instance of the `AudioClip` class from the Unity engine. This field stores the actual audio data for the sound.\n- `audioIcon` is an instance of the `Texture2D` class from the Unity engine. This field stores an icon or image that represents the sound.\n\nBy using this class, the Brick-Force project can easily manage and organize its sound assets. For example, it can create an array or list of `ScriptSnd` instances to store all the sounds used in the game. Each `ScriptSnd` instance can have a unique `alias` to identify it, and the corresponding `audioClip` and `audioIcon` can be accessed and used as needed.\n\nHere is an example of how this class could be used in the larger project:\n\n```csharp\n// Create a new ScriptSnd instance for a gunshot sound\nScriptSnd gunshotSound = new ScriptSnd();\ngunshotSound.alias = \"gunshot\";\ngunshotSound.audioClip = Resources.Load<AudioClip>(\"gunshot\");\ngunshotSound.audioIcon = Resources.Load<Texture2D>(\"gunshot_icon\");\n\n// Play the gunshot sound\nAudioSource.PlayClipAtPoint(gunshotSound.audioClip, transform.position);\n\n// Display the gunshot sound's icon\nGUI.DrawTexture(new Rect(10, 10, 50, 50), gunshotSound.audioIcon);\n```\n\nIn this example, a new `ScriptSnd` instance is created to represent a gunshot sound. The `alias` field is set to \"gunshot\", and the `audioClip` and `audioIcon` fields are loaded from the project's resources. The gunshot sound can then be played using the `PlayClipAtPoint` method, and its icon can be displayed using the `DrawTexture` method.\n## Questions: \n 1. **What is the purpose of the `ScriptSnd` class?**\nThe `ScriptSnd` class appears to be a serializable class that holds information about a sound, including its alias, audio clip, and audio icon.\n\n2. **What is the purpose of the `alias` property?**\nThe `alias` property likely serves as a unique identifier or name for the sound, allowing it to be easily referenced or identified within the code.\n\n3. **What is the purpose of the `audioIcon` property?**\nThe `audioIcon` property likely holds a texture image that represents the sound, potentially for use in a user interface or visual representation of the sound.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ScriptSnd.md"}}],["424",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\SeasonTexture.cs)\n\nThe code provided is a part of the Brick-Force project and is contained within a file called \"SeasonTexture.cs\". This file defines a class called \"SeasonTexture\" that inherits from the \"MonoBehaviour\" class provided by the Unity game engine.\n\nThe purpose of this code is to define and store various textures and game objects related to different seasons in the game. The class has three public properties of type \"Texture2D\" named \"texScreenBg\", \"texLoginBg\", and \"texDoneTutorial\". These properties are used to store the textures for the background of the screen, the background of the login screen, and the texture for the completion of the tutorial, respectively.\n\nAdditionally, the class has a public property of type \"GameObject\" named \"objPreviewBg\". This property is used to store a reference to a game object that represents the background for a preview of the current season.\n\nThe class also contains two empty methods, \"Start()\" and \"Update()\". These methods are part of the Unity's MonoBehaviour lifecycle and are called automatically by the engine at specific times during the game. The \"Start()\" method is called once when the object is first created, and the \"Update()\" method is called every frame. These methods can be overridden and used to add custom logic or behavior to the game object.\n\nIn the larger project, this code can be used to manage and display different textures and game objects based on the current season in the game. For example, the \"texScreenBg\" texture can be used as the background for the main game screen, while the \"texLoginBg\" texture can be used as the background for the login screen. The \"texDoneTutorial\" texture can be used to indicate that the tutorial has been completed. The \"objPreviewBg\" game object can be used to display a preview of the current season's background.\n\nOverall, this code provides a way to manage and display different textures and game objects based on the current season in the Brick-Force game.\n## Questions: \n 1. **What is the purpose of the `Texture2D` variables `texScreenBg`, `texLoginBg`, and `texDoneTutorial`?**\n   These variables likely hold different textures that are used for different screens or backgrounds in the game.\n\n2. **What is the purpose of the `GameObject` variable `objPreviewBg`?**\n   This variable likely holds a reference to a game object that represents the background for a preview screen.\n\n3. **What functionality or behavior is expected to be implemented in the `Start()` and `Update()` methods?**\n   The `Start()` and `Update()` methods are currently empty, so a smart developer might wonder what functionality or behavior is intended to be implemented in these methods.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\SeasonTexture.md"}}],["425",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\SecureFloat.cs)\n\nThe code provided is a struct called `SecureFloat` that is used to securely store and manipulate floating-point values. It includes methods for getting, setting, adding, subtracting, initializing, releasing, and resetting the value of the `SecureFloat`.\n\nThe `SecureFloat` struct has two private fields: `key` and `webValue`. The `key` field is an integer used for encryption and decryption of the value, while the `webValue` field stores the actual floating-point value.\n\nThe `Get()` method is used to retrieve the value of the `SecureFloat`. It first checks if the build option is a Windows player or editor, and if so, it calls the `NmSecure.getfvl()` method passing in the `key` to retrieve the encrypted value. Otherwise, it divides the `webValue` by the modulo of the `key` with 15 plus 2 to get the decrypted value.\n\nThe `Set()` method is used to set the value of the `SecureFloat`. Similar to the `Get()` method, it checks the build option and calls the appropriate method to set the encrypted value if it is a Windows player or editor. Otherwise, it multiplies the `value` by the modulo of the `key` with 15 plus 2 and assigns it to the `webValue`.\n\nThe `Add()` and `Minus()` methods are used to add or subtract a value from the current value of the `SecureFloat`. They check the build option and call the appropriate method to perform the operation if it is a Windows player or editor. Otherwise, they call the `Set()` method passing in the current value of the `SecureFloat` plus or minus the `value`.\n\nThe `Init()` method is used to initialize the `SecureFloat` with a given value. It checks the build option and generates a random `key` using the `NmSecure.ctsvar()` method if it is a Windows player or editor. Otherwise, it sets the `key` to the current frame count plus a random number between 1 and 99999. It then calls the `Set()` method to set the value of the `SecureFloat`.\n\nThe `Release()` method is used to release the `SecureFloat` by calling the `NmSecure.rlsvar()` method passing in the `key` if it is a Windows player or editor.\n\nThe `Reset()` methods are used to reset the `SecureFloat` to its initial state. The first `Reset()` method retrieves the current value of the `SecureFloat`, releases it, and then initializes it with the retrieved value. The second `Reset()` method releases the `SecureFloat` and initializes it with a given value.\n\nOverall, this code provides a way to securely store and manipulate floating-point values by encrypting and decrypting them using a key. It can be used in various scenarios where data security is important, such as storing sensitive game data or user information.\n## Questions: \n 1. What is the purpose of the `SecureFloat` struct?\n- The `SecureFloat` struct is used to store and manipulate floating-point values in a secure manner, with different behavior depending on the platform.\n\n2. What is the significance of the `key` variable?\n- The `key` variable is used to encrypt and decrypt the floating-point value stored in the `SecureFloat` struct.\n\n3. What is the purpose of the `BuildOption.IsWindowsPlayerOrEditor()` method?\n- The `BuildOption.IsWindowsPlayerOrEditor()` method is used to determine if the code is running on a Windows player or editor, and it affects the behavior of the `SecureFloat` methods.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\SecureFloat.md"}}],["426",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\SecureInt.cs)\n\nThe code provided defines a struct called `SecureInt` that is used to store and manipulate integer values in a secure manner. The purpose of this code is to provide a way to protect sensitive integer data from being easily accessed or modified by unauthorized users.\n\nThe `SecureInt` struct has several methods that allow for getting, setting, adding, subtracting, initializing, releasing, and resetting the value of the secure integer.\n\nThe `Get()` method retrieves the value of the secure integer. If the build option is a Windows player or editor, it calls the `NmSecure.getnvl()` method passing in the `key` to retrieve the value. Otherwise, it performs some bitwise operations on the `webValue` and `key` to calculate and return the value.\n\nThe `Set()` method sets the value of the secure integer. If the build option is a Windows player or editor, it calls the `NmSecure.setnvl()` method passing in the `key` and the new value. Otherwise, it performs some bitwise operations on the `value`, `key`, and `webValue` to calculate and store the new value.\n\nThe `Add()` method adds a value to the secure integer. If the build option is a Windows player or editor, it calls the `NmSecure.nvlad()` method passing in the `key` and the value to add. Otherwise, it calls the `Get()` method to retrieve the current value, adds the value to it, and then calls the `Set()` method to update the secure integer.\n\nThe `Minus()` method subtracts a value from the secure integer. If the build option is a Windows player or editor, it calls the `NmSecure.nvlsu()` method passing in the `key` and the value to subtract. Otherwise, it calls the `Get()` method to retrieve the current value, subtracts the value from it, and then calls the `Set()` method to update the secure integer.\n\nThe `Init()` method initializes the secure integer with a given value. If the build option is a Windows player or editor, it calls the `NmSecure.ctsvar()` method passing in a constant value of 3 to generate a new key. Otherwise, it generates a key based on the current frame count and a random range. It then calls the `Set()` method to set the secure integer to the given value.\n\nThe `Release()` method releases the secure integer by calling the `NmSecure.rlsvar()` method passing in the `key`.\n\nThe `Reset()` method resets the secure integer to its initial value. It calls the `Get()` method to retrieve the current value, calls the `Release()` method to release the secure integer, and then calls the `Init()` method to initialize the secure integer with the retrieved value.\n\nThe `Reset(int value)` method is similar to the `Reset()` method, but it allows for resetting the secure integer to a specific value instead of the initial value.\n\nOverall, this code provides a way to store and manipulate integer values securely, protecting them from unauthorized access or modification. It can be used in the larger project to handle sensitive data that needs to be protected.\n## Questions: \n 1. What is the purpose of the `SecureInt` struct?\n- The `SecureInt` struct is used to store and manipulate integer values securely, with encryption and decryption methods.\n\n2. What is the significance of the `key` and `webValue` variables?\n- The `key` variable is used for encryption and decryption operations, while the `webValue` variable stores the encrypted value of the integer.\n\n3. What is the purpose of the `BuildOption.IsWindowsPlayerOrEditor()` method?\n- The `BuildOption.IsWindowsPlayerOrEditor()` method is used to check if the code is running on a Windows player or editor, and it determines whether to use encryption methods or not.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\SecureInt.md"}}],["427",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\SelectUserMapDlg.cs)\n\nThe code provided is a class called `SelectUserMapDlg` that extends the `Dialog` class. This class is responsible for displaying a dialog box that allows the user to select a user map. \n\nThe class has several member variables that store various textures, colors, and positions used for rendering the dialog box. These variables include `slotLock`, `nonAvailable`, `emptySlot`, `premiumIcon`, `slotEmpty`, and `selectedMapFrame`. \n\nThe `Start` method is overridden from the base `Dialog` class and sets the `id` of the dialog and the `txtMainClr` color variable. \n\nThe `OnPopup` method is also overridden and sets the position of the dialog box based on the screen size. \n\nThe `InitDialog` method initializes the dialog by setting the `item` variable and retrieving the user map information from the `UserMapInfoManager`. \n\nThe `DoDialog` method is the main method that is called to render the dialog box and handle user interactions. It returns a boolean value indicating whether the dialog should be closed or not. \n\nInside the `DoDialog` method, the `DoSlots` method is called to render the user map slots. The `DoSlots` method calculates the number of slots needed based on the number of user maps available and renders each slot accordingly. It also handles user interactions such as selecting a slot and clicking the OK button. \n\nOverall, this code provides the functionality to display a dialog box for selecting a user map and handles user interactions related to selecting and confirming the selection of a user map. This class is likely used in the larger project to allow the user to choose a user map for some specific purpose, such as resetting a map slot.\n## Questions: \n 1. What is the purpose of the `InitDialog` method?\n- The `InitDialog` method is used to initialize the dialog with the specified item and set the `umiSlot` to 0.\n\n2. What does the `DoSlots` method do?\n- The `DoSlots` method is responsible for rendering and handling the user map slots in the dialog.\n\n3. What is the significance of the `umiSlot` variable?\n- The `umiSlot` variable stores the slot number of the selected user map, which is used for further actions in the dialog.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\SelectUserMapDlg.md"}}],["428",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\SelfCollsion.cs)\n\nThe code provided is a script called \"SelfCollision\" that is part of the Brick-Force project. This script is responsible for handling collision events and triggering explosions in the game.\n\nThe script contains several variables and properties that are used to store information about the collision and the objects involved. \n\n- The \"bBoom\" variable is a boolean flag that determines if an explosion should occur.\n- The \"colPoint\" variable is a Vector3 that stores the point of contact during a collision.\n- The \"explosion\" variable is a reference to a GameObject that represents the explosion effect.\n- The \"bUse\" variable is a boolean flag that determines if the script should be used.\n- The \"collideEnter\" variable is a boolean flag that indicates if a collision has occurred.\n- The \"idBrick\" and \"idMon\" variables are integers that store the IDs of the brick and monster objects involved in the collision.\n\nThe script also contains several methods:\n\n- The \"IsCollideEnter\" method returns the value of the \"collideEnter\" flag.\n- The \"OnCollisionEnter\" method is called when a collision occurs. It sets the \"collideEnter\" flag to true and stores the contact point of the collision in the \"colPoint\" variable.\n- The \"NoUse\" method sets the \"bUse\" flag to false, indicating that the script should not be used.\n- The \"Explosion\" method triggers an explosion effect at a specified point and rotation. It first checks if the \"bUse\" flag is true and if the \"bBoom\" flag is false. If both conditions are met, it instantiates the explosion GameObject at the specified point and rotation. It also sets the \"brickID\" and \"monID\" properties of the explosion GameObject's \"CheckBrickDead\" and \"CheckMonDead\" components, respectively. Additionally, if the \"myself\" parameter is true, it sets the \"HitParent\" and \"ParentSeq\" properties of the explosion GameObject's \"ParentFollow\" component.\n\nIn the larger project, this script would be attached to objects that can collide with each other, such as bricks and monsters. When a collision occurs, the script handles the collision event and triggers an explosion effect if conditions are met. The explosion effect can be customized by assigning a GameObject to the \"explosion\" variable. The script also provides methods to check if a collision has occurred and to disable the script's functionality if needed.\n## Questions: \n 1. What is the purpose of the `SelfCollision` class?\n- The `SelfCollision` class is responsible for handling collisions and explosions in the game.\n\n2. What is the significance of the `bUse` variable?\n- The `bUse` variable determines whether the object can be used or not. If it is set to false, certain actions will be skipped.\n\n3. What is the purpose of the `Explosion` method?\n- The `Explosion` method creates an explosion effect at a specified point and rotation. It also assigns the `idBrick` and `idMon` values to components in the explosion GameObject, if they exist.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\SelfCollsion.md"}}],["429",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\SelfRespawnDialog.cs)\n\nThe code provided is a class called `SelfRespawnDialog` that extends the `Dialog` class. This class is responsible for displaying a dialog box that allows the player to respawn themselves in the game. \n\nThe `SelfRespawnDialog` class has several methods and variables that control the behavior and appearance of the dialog box. \n\nThe `Start()` method sets the `id` of the dialog box to a specific value from the `DialogManager.DIALOG_INDEX` enum. \n\nThe `OnPopup()` method sets the position and size of the dialog box based on the size of the screen. \n\nThe `InitDialog()` method is used to initialize the text that will be displayed in the dialog box. \n\nThe `DoDialog()` method is the main method that is called to display the dialog box and handle user interaction. \n\nInside the `DoDialog()` method, the text is displayed using the `LabelUtil.TextOut()` method, which takes in the position, text, font style, color, and alignment. \n\nThe method then checks if the player is able to respawn themselves based on a condition involving the `localCtrl` variable. If the condition is met, a countdown timer is displayed using the `LabelUtil.TextOut()` method. \n\nThe method then checks if the \"OK\" button is pressed using the `GlobalVars.Instance.MyButton()` method. If the button is pressed, the `BackToScene()` and `SelfRespawn()` methods are called. \n\nThe `BackToScene()` method sets some global variables, clears the vote in the room, and sets the `tutorFirstScriptOn` variable to true. \n\nThe `SelfRespawn()` method calls the `DropWeaponSkipSetting()` method, `GetHit()` method, and sets the `SelfRespawnReuseTime` variable of the `localCtrl` object. \n\nThe `verifyLocalController()` method checks if the `localCtrl` object is null and if so, finds the \"Me\" game object and gets the `LocalController` component from it. \n\nOverall, this code is responsible for displaying a dialog box that allows the player to respawn themselves in the game. It handles the display of text, countdown timer, and button interaction.\n## Questions: \n 1. What is the purpose of the `SelfRespawnDialog` class?\n- The `SelfRespawnDialog` class is a subclass of the `Dialog` class and is used to display a dialog box for self-respawning in the game.\n\n2. What is the significance of the `InitDialog` method?\n- The `InitDialog` method is used to initialize the `text` variable of the `SelfRespawnDialog` class with the provided `textMore` parameter.\n\n3. What does the `SelfRespawn` method do?\n- The `SelfRespawn` method is responsible for performing the self-respawn action in the game. It drops the weapon, applies damage to the player, and sets the self-respawn reuse time.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\SelfRespawnDialog.md"}}],["430",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\SendMemoDialog.cs)\n\nThe code provided is a class called \"SendMemoDialog\" that extends the \"Dialog\" class. This class represents a dialog box for sending a memo in the larger Brick-Force project. The purpose of this code is to handle the functionality and display of the send memo dialog box.\n\nThe class contains various fields and properties that define the behavior and appearance of the dialog box. These include properties such as \"maxId\", \"maxTitle\", and \"maxMemoLength\" which define the maximum length of the receiver ID, memo title, and memo contents respectively. There are also fields for storing the receiver ID, memo title, memo contents, and other related information.\n\nThe class also contains various Rect and Vector2 variables that define the position and size of different UI elements within the dialog box. These variables are used to position and size the different UI elements such as text fields, labels, and buttons.\n\nThe class overrides several methods from the base \"Dialog\" class. The \"Start\" method initializes the dialog by setting its ID and a flag indicating whether the dialog has been shown before. The \"OnPopup\" method positions the dialog box in the center of the screen.\n\nThe \"DoDialog\" method is the main method that handles the functionality and display of the dialog box. It uses GUI functions to draw and handle user input for the different UI elements such as text fields and buttons. It also calls other methods such as \"ShowPresent\" to display additional information related to the memo.\n\nThe class also provides several other methods for initializing the dialog with different parameters. For example, the \"InitDialog\" method is used to initialize the dialog with a specific good, buy how, and selected index. Another overload of the \"InitDialog\" method allows for an additional confirmation message to be passed.\n\nOverall, this code represents the implementation of a send memo dialog box in the Brick-Force project. It handles the display and functionality of the dialog box, allowing users to enter a receiver ID, memo title, and memo contents, and send the memo.\n## Questions: \n **Question 1:** What is the purpose of the `SendMemoDialog` class?\n    \n**Answer:** The `SendMemoDialog` class is a subclass of `Dialog` and represents a dialog box for sending memos. It contains various properties and methods for handling the dialog's functionality.\n\n**Question 2:** What is the purpose of the `InitDialog` method with three parameters?\n    \n**Answer:** The `InitDialog` method with three parameters initializes the dialog with the specified `Good`, `Good.BUY_HOW`, and selection index. It sets the `good`, `tItem`, `buyHow`, `selected`, `receiver`, `title`, `contents`, and `doDialogOnce` properties of the dialog.\n\n**Question 3:** What is the purpose of the `DoDialog` method?\n    \n**Answer:** The `DoDialog` method handles the rendering and interaction of the dialog. It displays the memo receiver, title, contents, and present information, and allows the user to input and send a memo. It returns a boolean value indicating whether the dialog should be closed.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\SendMemoDialog.md"}}],["431",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\SenseTrigger.cs)\n\nThe code provided is a part of the Brick-Force project and is located in the `SenseTrigger` class. This class extends the `Trigger` class and is responsible for detecting when a trigger collider is entered by another object in the game.\n\nThe `OnTriggerEnter` method is an event handler that is automatically called when a collider enters the trigger area. In this case, the method takes a `Collider` parameter named `other`, which represents the collider that entered the trigger.\n\nThe purpose of this code is to check if the game is not in the \"MapEditor\" scene and if the `SenseTrigger` component is enabled. If both conditions are met, the code proceeds to check if the collider's game object has a `LocalController` component attached to it. If it does not, it sets a boolean variable `immediateKillBrickTutor` in the `GlobalVars` class to true and calls the `RunScript` method.\n\nThe `LocalController` component is likely a script that is attached to player-controlled objects in the game. The purpose of checking for this component is to determine if the collider that entered the trigger is a player-controlled object or not. If it is not, the code assumes it is an enemy or non-player object and sets the `immediateKillBrickTutor` variable to true. This variable is likely used elsewhere in the game to trigger some specific behavior or event.\n\nThe `RunScript` method is not shown in the provided code, but it is likely a method defined in the `Trigger` class or one of its parent classes. This method is responsible for executing some specific behavior or event when the trigger is entered.\n\nOverall, this code is used to handle the logic for detecting when a trigger is entered by an object in the game, and based on certain conditions, it sets a variable and calls a method to trigger specific behavior or events in the game.\n## Questions: \n 1. **What is the purpose of the `SenseTrigger` class?**\nThe `SenseTrigger` class is a subclass of the `Trigger` class and is used to handle trigger events when a collider enters the trigger area.\n\n2. **What conditions need to be met for the code inside the `OnTriggerEnter` method to execute?**\nThe code inside the `OnTriggerEnter` method will execute if the current loaded level name does not contain \"MapEditor\" and the `SenseTrigger` component is enabled.\n\n3. **What does the code do if the `other` collider does not have a `LocalController` component?**\nIf the `other` collider does not have a `LocalController` component, the code sets the `immediateKillBrickTutor` variable in the `GlobalVars` instance to true and calls the `RunScript` method.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\SenseTrigger.md"}}],["432",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\SerialKill.cs)\n\nThe code provided is a script for a class called \"SerialKill\" in the Brick-Force project. This class is responsible for handling and displaying various kill actions in the game.\n\nThe class contains several variables and constants that are used to store and manipulate the necessary data for the kill actions. These include the GUI depth, timeout for serial kills, textures for serial images and backgrounds, an array of kill voiceover strings, and audio clips for goal-in actions.\n\nThe class has several methods that handle different kill actions. The \"HeadshotAction\" method is called when a headshot kill occurs. It sets the necessary variables and plays the appropriate voiceover. The \"GoalInAction\" method is called when a goal-in kill occurs. It also sets the necessary variables and plays the goal-in sound.\n\nThe \"SerialAction\" method is called when a serial kill occurs. It sets the necessary variables, sends a request to the server, plays the appropriate voiceover, and updates the background and image positions.\n\nThe \"Update\" method is called every frame and handles the animation of the kill actions. It updates the positions of the background and image based on the current action step.\n\nThe \"OnKillLog\" method is called when a kill log is received. It checks if the player is the killer and increments the serial kill count. If the serial action is not triggered, it calls the \"HeadshotAction\" method if the kill was a headshot.\n\nThe \"OnGUI\" method is responsible for drawing the kill action GUI elements on the screen. It checks if the GUI is enabled and if the action step is within the valid range. It then draws the background and image textures based on the current action index.\n\nOverall, this class provides the functionality to handle and display different kill actions in the game, such as headshots, goal-ins, and serial kills. It manages the animation and GUI elements associated with these actions. This code is an important part of the larger Brick-Force project as it enhances the gameplay experience by providing visual and audio feedback for successful kills.\n## Questions: \n 1. What is the purpose of the `SerialKill` class?\n- The `SerialKill` class is responsible for handling actions related to serial kills in the game, such as displaying images and playing sounds.\n\n2. What is the significance of the `serialKill` variable?\n- The `serialKill` variable keeps track of the number of consecutive kills made by the player.\n\n3. How does the `OnKillLog` method determine whether to perform a serial action or a headshot action?\n- The `OnKillLog` method checks if the kill log belongs to the player and if it was not a headshot. If these conditions are met, it increments the `serialKill` variable and calls the `SerialAction` method. If the `SerialAction` method returns false, it calls the `HeadshotAction` method.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\SerialKill.md"}}],["433",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\SetMission.cs)\n\nThe code provided is a class called `SetMission` that extends the `ScriptCmd` class. This class is likely a part of the larger Brick-Force project and is responsible for setting the mission details.\n\nThe `SetMission` class has several private instance variables: `progress`, `title`, `subTitle`, and `tag`. These variables are used to store the progress, title, subtitle, and tag of the mission, respectively.\n\nThe class also has public properties for each of these variables, allowing other classes to get and set their values. For example, the `Progress` property allows other classes to get and set the value of the `progress` variable.\n\nThe class overrides several methods from the `ScriptCmd` class. The `GetDescription()` method returns a string that represents the description of the mission. It concatenates the values of the `progress`, `title`, `subTitle`, and `tag` variables, separated by the `ArgDelimeters[0]` character from the `ScriptCmd` class.\n\nThe `GetIconIndex()` method returns an integer representing the index of the icon for the mission. In this case, it always returns 8.\n\nThe `GetDefaultDescription()` method returns a string representing the default description of the mission. It concatenates the string \"setmission\" with the `ArgDelimeters[0]` character.\n\nThe `GetName()` method returns a string representing the name of the mission. In this case, it always returns \"SetMission\".\n\nOverall, this code provides a class that can be used to set and retrieve the details of a mission in the Brick-Force project. Other classes can use the `SetMission` class to create and manage missions by setting the progress, title, subtitle, and tag, and retrieving the mission description, icon index, and name.\n## Questions: \n 1. What is the purpose of the `SetMission` class?\n- The `SetMission` class is a subclass of `ScriptCmd` and represents a command for setting a mission in the Brick-Force project.\n\n2. What are the properties of the `SetMission` class and what are they used for?\n- The `SetMission` class has properties for `Progress`, `Title`, `SubTitle`, and `Tag`. These properties are used to store and retrieve information related to the mission.\n\n3. What is the purpose of the `GetDescription()` method?\n- The `GetDescription()` method is used to generate a description string for the `SetMission` command, which includes the values of the `progress`, `title`, `subTitle`, and `tag` properties.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\SetMission.md"}}],["434",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\SettingChanger.cs)\n\nThe `SettingChanger` class in the `Brick-Force` project is responsible for changing and applying various settings related to the game's display and graphics quality. \n\nThe `OnSettingChange` method is called whenever a new setting is received. It takes a `SettingParam` object as a parameter, which contains the new settings. The method assigns the `SettingParam` object to the `sp` variable and then starts a coroutine called `ApplyChange`.\n\nThe `ApplyChange` coroutine is responsible for applying the new settings. It first checks if the width and height of the new settings are greater than or equal to the maximum width and height of the screen resolutions available. If they are, it sets the `fullscreen` variable to `true`. Then, it calls `Screen.SetResolution` to change the screen resolution to the new width, height, and fullscreen mode. It also saves the new width, height, and fullscreen mode to the player preferences using `PlayerPrefs.SetInt`.\n\nNext, it sets the quality level of the game using `QualitySettings.SetQualityLevel` based on the `qualityLevel` property of the `SettingParam` object. It also saves the new quality level to the player preferences.\n\nFinally, it sets the `sp` variable to `null` to indicate that the settings have been applied.\n\nThe `Start` and `Update` methods in this class are empty and do not have any functionality.\n\nOverall, this code is a part of the larger Brick-Force project and is responsible for changing and applying display and graphics settings in the game. It uses the `SettingParam` object to receive new settings and applies them by changing the screen resolution, fullscreen mode, and quality level. The applied settings are also saved to the player preferences for future use.\n## Questions: \n 1. What does the `SettingParam` class contain and how is it used in this code? The `SettingParam` class is used as a parameter in the `OnSettingChange` method and contains information about the desired screen resolution, fullscreen mode, and quality level.\n   \n2. What is the purpose of the `ApplyChange` coroutine? The `ApplyChange` coroutine sets the screen resolution, fullscreen mode, and quality level based on the values in the `SettingParam` object. It also saves these values to PlayerPrefs for future use.\n\n3. Why is the `Update` method empty? The `Update` method is empty and does not contain any code. This suggests that there is no need for any continuous update or logic in this script.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\SettingChanger.md"}}],["435",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\SettingParam.cs)\n\nThe code provided defines a class called `SettingParam`. This class is used to store and manage various settings parameters for a project called Brick-Force. \n\nThe `SettingParam` class has four public variables: `fullScreen`, `width`, `height`, and `qualityLevel`. These variables are used to store the values of different settings parameters. \n\nThe `fullScreen` variable is of type `bool` and is used to determine whether the project should be displayed in full screen mode or not. It can have two possible values: `true` if the project should be displayed in full screen mode, and `false` if it should not be displayed in full screen mode.\n\nThe `width` and `height` variables are of type `int` and are used to determine the dimensions of the project's display window. They store the width and height values in pixels.\n\nThe `qualityLevel` variable is also of type `int` and is used to determine the quality level of the project's graphics. It can have different values depending on the specific implementation of the project, with higher values indicating higher quality graphics.\n\nThe `SettingParam` class can be used in the larger Brick-Force project to manage and update the settings parameters. For example, it can be used to allow the user to change the display mode, window dimensions, and graphics quality level of the project. The class provides a convenient way to store and access these settings parameters in a structured manner.\n\nHere is an example of how the `SettingParam` class can be used in the Brick-Force project:\n\n```csharp\nSettingParam settings = new SettingParam();\n\n// Set the initial values of the settings parameters\nsettings.fullScreen = true;\nsettings.width = 1920;\nsettings.height = 1080;\nsettings.qualityLevel = 2;\n\n// Update the settings parameters based on user input\nsettings.fullScreen = false;\nsettings.width = 1280;\nsettings.height = 720;\nsettings.qualityLevel = 1;\n\n// Use the updated settings parameters in the project\nif (settings.fullScreen)\n{\n    // Display the project in full screen mode\n}\nelse\n{\n    // Display the project in windowed mode with the specified dimensions\n}\n\n// Adjust the graphics quality level based on the settings parameter\nswitch (settings.qualityLevel)\n{\n    case 0:\n        // Set the graphics quality to low\n        break;\n    case 1:\n        // Set the graphics quality to medium\n        break;\n    case 2:\n        // Set the graphics quality to high\n        break;\n    default:\n        // Set the graphics quality to a default value\n        break;\n}\n```\n\nIn this example, the `SettingParam` class is used to store and update the settings parameters for the Brick-Force project. The values of these parameters are then used to control the display mode, window dimensions, and graphics quality level of the project.\n## Questions: \n 1. **What is the purpose of the `SettingParam` class?**\nThe `SettingParam` class is likely used to store and manage various settings parameters for the Brick-Force project, such as fullscreen mode, width, height, and quality level.\n\n2. **What are the possible values for the `fullScreen` variable?**\nThe `fullScreen` variable is a boolean type, so it can have two possible values: `true` for fullscreen mode enabled, and `false` for fullscreen mode disabled.\n\n3. **What is the range of values for the `qualityLevel` variable?**\nWithout further information, it is not possible to determine the exact range of values for the `qualityLevel` variable. It could potentially represent a scale from low to high quality, or it could be a numerical value representing specific quality levels.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\SettingParam.md"}}],["436",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ShooterTool.cs)\n\nThe code provided is a class called \"ShooterTool\" that is part of the Brick-Force project. This class represents a tool that can be used by a player in the game. The purpose of this code is to define the behavior and functionality of the tool.\n\nThe class has several private variables, including \"coolTimeInst\" which represents the cooldown time for the tool, \"tools\" which represents the parent object that manages all the tools, \"desc\" which represents the description of the tool, \"item\" which represents the item associated with the tool, \"deltaTime\" which keeps track of the time passed since the last use of the tool, \"input\" which represents the input key for activating the tool, \"hotkey\" which represents the hotkey for the tool, \"active\" which determines if the tool is currently active, \"audio\" which represents the audio source for playing sounds, \"battleChat\" which represents the chat system in the game, and \"controller\" which represents the local controller of the player.\n\nThe class also has several properties such as \"Icon\" which returns the icon of the tool, \"Name\" which returns the name of the tool, \"Hotkey\" which returns the hotkey of the tool, \"IsActive\" which determines if the tool is currently active, \"CoolTime\" which returns the remaining cooldown time of the tool, and \"Amount\" which returns the amount of the tool item.\n\nThe class has a constructor that takes in various parameters to initialize the tool. It also has several methods such as \"ErrorSound\" which plays an error sound, \"Update\" which updates the state of the tool based on user input and game conditions, \"GetExternalCondition\" which checks if there are any external conditions that need to be met for the tool to be enabled, \"IsEnable\" which determines if the tool is currently enabled, \"StartCoolTime\" which starts the cooldown time for the tool, \"Use\" which is called when the tool is used, and various other methods for performing specific actions such as healing, respawning, charging ammo, and detecting heartbeats.\n\nOverall, this code defines the behavior and functionality of a tool in the Brick-Force game. It allows players to use the tool, perform various actions, and manage cooldown times and availability based on game conditions.\n## Questions: \n 1. **What is the purpose of the `ShooterTool` class?**\nThe `ShooterTool` class represents a tool that can be used by a player in the game. It contains various properties and methods related to the tool's functionality.\n\n2. **What is the significance of the `IsEnable()` method?**\nThe `IsEnable()` method determines whether the tool is currently enabled and can be used. It checks various conditions such as the availability of the tool, the cool-down time, and external conditions specific to each tool.\n\n3. **What is the purpose of the `Use()` method?**\nThe `Use()` method is called when the player wants to use the tool. It starts the cool-down time for the tool, sends a network request to use the tool, and plays an action sound if available.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ShooterTool.md"}}],["437",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ShowDialog.cs)\n\nThe code provided is a class called `ShowDialog` that extends the `ScriptCmd` class. This class is likely a part of the larger Brick-Force project and is used to handle and display dialogues in the game.\n\nThe `ShowDialog` class has two private fields: `speaker` and `dialog`. These fields represent the ID of the speaker and the actual dialogue text, respectively. The class also has corresponding public properties `Speaker` and `Dialog` that allow access to these fields.\n\nThe class overrides several methods from the `ScriptCmd` class. The `GetDescription()` method returns a string that represents the description of the `ShowDialog` command. It concatenates the string \"showdialog\" with the value of the `speaker` field and the `dialog` field, separated by the `ArgDelimeters` character from the `ScriptCmd` class.\n\nThe `GetIconIndex()` method returns an integer representing the index of the icon associated with the `ShowDialog` command. In this case, it always returns 1.\n\nThe `GetDefaultDescription()` method returns a string that represents the default description of the `ShowDialog` command. It concatenates the string \"showdialog\" with the value -1 (representing an invalid speaker ID) and the `ArgDelimeters` character.\n\nThe `GetName()` method returns a string representing the name of the `ShowDialog` command, which is \"ShowDialog\".\n\nOverall, this code defines a class that represents a dialogue command in the Brick-Force project. It allows for the setting and retrieval of the speaker ID and dialogue text, as well as provides methods for getting the description, icon index, default description, and name of the command. This class can be used in the larger project to handle and display dialogues between characters in the game.\n## Questions: \n 1. What is the purpose of the `ShowDialog` class?\n- The `ShowDialog` class is a subclass of `ScriptCmd` and is used to display a dialog in the Brick-Force project.\n\n2. What properties does the `ShowDialog` class have?\n- The `ShowDialog` class has two properties: `Speaker` (an integer) and `Dialog` (a string).\n\n3. What is the purpose of the `GetDescription` method?\n- The `GetDescription` method returns a string that represents the description of the `ShowDialog` command, including the speaker and dialog text.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ShowDialog.md"}}],["438",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ShowScript.cs)\n\nThe code provided is a class called `ShowScript` that extends the `ScriptCmd` class. This class represents a command to show a script in the larger Brick-Force project. \n\nThe `ShowScript` class has two private instance variables: `id` and `visible`. These variables are used to store the ID and visibility status of the script. The class also has corresponding public properties `Id` and `Visible` that allow access to these variables.\n\nThe `ShowScript` class overrides several methods from the `ScriptCmd` class. The `GetIconIndex` method returns the index of the icon associated with the `ShowScript` command. In this case, it always returns 5.\n\nThe `GetDescription` method returns a string representation of the `ShowScript` command. It concatenates the string \"showscript\" with the value of the `id` variable, followed by the value of the `visible` variable. The `ScriptCmd.ArgDelimeters[0]` is used as a delimiter between the different parts of the description.\n\nThe `GetDefaultDescription` method returns a default string representation of the `ShowScript` command. It is similar to the `GetDescription` method, but with default values for the `id` and `visible` variables.\n\nThe `GetName` method returns the name of the `ShowScript` command, which is simply \"ShowScript\".\n\nOverall, this code provides a way to create and manipulate `ShowScript` commands in the Brick-Force project. It allows users to set the ID and visibility of a script, retrieve the icon index, and get a string representation of the command. The `ShowScript` class can be used in conjunction with other classes and methods in the project to create and execute scripts.\n## Questions: \n 1. What is the purpose of the `ShowScript` class?\n- The `ShowScript` class is a subclass of `ScriptCmd` and represents a script command for showing a script.\n\n2. What is the significance of the `Id` and `Visible` properties?\n- The `Id` property represents the ID of the script, and the `Visible` property determines whether the script is visible or not.\n\n3. What is the purpose of the `GetDescription` and `GetDefaultDescription` methods?\n- The `GetDescription` method returns a string representation of the script command, including the ID and visibility. The `GetDefaultDescription` method returns a default string representation of the script command.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ShowScript.md"}}],["439",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ShrinkBrick.cs)\n\nThe code provided is for a class called \"ShrinkBrick\" in the Brick-Force project. This class is responsible for centering and resizing a shrink box in the game. \n\nThe class has two private member variables: \"center\" and \"size\", both of type Vector3. These variables store the center position and size of the shrink box, respectively. \n\nThe class also has a public method called \"CenterAndSize\" which takes in two Vector3 parameters: \"_center\" and \"_size\". This method is used to set the values of the \"center\" and \"size\" variables. \n\nIn the Start() method, the code finds a child object of the current game object with the name \"ShrinkBox\" using the Find() method. If the child object is found, the code sets its local position to the value of the \"center\" variable and its local scale to the value of the \"size\" variable. This effectively centers and resizes the shrink box in the game. \n\nThe Update() method is empty and does not contain any code. \n\nThis class can be used in the larger Brick-Force project to handle the logic for shrinking a specific box in the game. Other classes or scripts can call the public method \"CenterAndSize\" to set the center and size of the shrink box, and the Start() method will automatically update the position and scale of the \"ShrinkBox\" child object accordingly. \n\nHere is an example of how this class can be used:\n\n```csharp\nShrinkBrick shrinkBrick = new ShrinkBrick();\nVector3 center = new Vector3(0, 0, 0);\nVector3 size = new Vector3(2, 2, 2);\nshrinkBrick.CenterAndSize(center, size);\n```\n\nIn this example, a new instance of the ShrinkBrick class is created. The center and size of the shrink box are set to (0, 0, 0) and (2, 2, 2) respectively using the CenterAndSize() method. The Start() method will then update the position and scale of the \"ShrinkBox\" child object accordingly.\n## Questions: \n 1. What is the purpose of the `CenterAndSize` method?\n- The `CenterAndSize` method is used to set the center and size of the shrink box.\n\n2. What is the significance of the `ShrinkBox` object?\n- The `ShrinkBox` object is a child object of the current object and is used to visually represent the shrink box.\n\n3. Why is the `Update` method empty?\n- The `Update` method is empty, indicating that there is no specific functionality or behavior that needs to be executed continuously in this script.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ShrinkBrick.md"}}],["440",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Shutgun.cs)\n\nThe code provided is a class called \"Shutgun\" that inherits from a base class called \"Gun\". The purpose of this class is to define the behavior of a shotgun weapon in the larger project called Brick-Force.\n\nThe class has two public properties, \"MinBuckShot\" and \"MaxBuckShot\", which represent the minimum and maximum number of buckshots that can be fired by the shotgun. These properties have getter and setter methods that allow other parts of the code to access and modify their values.\n\nThe class overrides the \"Fire\" method from the base class. This method is responsible for handling the firing behavior of the shotgun. It first checks if the weapon is not on cooldown. If it is not on cooldown, it checks if the magazine is empty. If the magazine is empty, it checks if the weapon can be reloaded. If it can be reloaded, it checks if the game is set to use default auto-reload or if a specific component called \"auto_reload\" is being used. If either of these conditions is true, the weapon is automatically reloaded. If none of these conditions are met, the \"empty\" animation is played, a message is sent to the P2PManager to update the gun animation, and the \"EmptySound\" method is called.\n\nIf the magazine is not empty, the method proceeds to fire the shotgun. It synchronizes the current magazine state with the NoCheat instance, plays the fire animation, plays the \"fire\" animation, plays the fire sound, and sets the delta time to 0. It then generates a random number between the minimum and maximum buckshots and iterates over that number, creating muzzle fire and shooting. It also adjusts the camera pitch and yaw based on recoil, sets the aim accuracy based on the local controller's ability to aim accurately, and handles the fire event for the scope component if it exists.\n\nThe class also overrides the \"Modify\" method from the base class. This method is responsible for modifying the shotgun based on a weapon modifier. It retrieves the weapon modifier for the current weapon, and if it exists, it updates the minimum and maximum buckshot values based on the modifier.\n\nOverall, this code defines the behavior of the shotgun weapon in the Brick-Force project, including firing, reloading, and modifying the weapon based on a weapon modifier.\n## Questions: \n 1. What is the purpose of the `Shutgun` class and how does it relate to the `Gun` class it inherits from?\n- The `Shutgun` class is a subclass of the `Gun` class. A smart developer might want to know what specific functionality or behavior the `Shutgun` class adds or overrides from the `Gun` class.\n\n2. What is the purpose of the `Modify` method and when is it called?\n- The `Modify` method is called to modify the properties of the `Shutgun` object. A smart developer might want to know what specific modifications are made and when this method is called.\n\n3. What is the purpose of the `minBuckShot` and `maxBuckShot` variables, and how are they used in the code?\n- The `minBuckShot` and `maxBuckShot` variables determine the range of the number of shots fired by the shotgun. A smart developer might want to know how these variables are used and if they can be modified externally.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Shutgun.md"}}],["441",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\SizeChangeStep.cs)\n\nThe code provided defines a class called `SizeChangeStep`. This class is likely used in the larger Brick-Force project to handle size changes of certain objects or elements within the game. \n\nThe `SizeChangeStep` class has four public float variables: `startSize`, `endSize`, `stepTime`, and `speed`. These variables are used to define the starting size, ending size, duration of the size change, and the speed at which the size change occurs, respectively.\n\nBy using an instance of the `SizeChangeStep` class, the game can define a specific size change for an object or element. For example, if a player collects a power-up that increases their size, the game can create a `SizeChangeStep` instance and set the appropriate values for the `startSize`, `endSize`, `stepTime`, and `speed` variables. The game can then use these values to smoothly animate the size change over time.\n\nHere is an example of how the `SizeChangeStep` class could be used in the larger Brick-Force project:\n\n```csharp\nSizeChangeStep sizeChange = new SizeChangeStep();\nsizeChange.startSize = 1.0f;\nsizeChange.endSize = 2.0f;\nsizeChange.stepTime = 1.0f;\nsizeChange.speed = 0.5f;\n\n// Apply the size change to an object\nvoid ApplySizeChange(GameObject objectToResize)\n{\n    float elapsedTime = 0.0f;\n    float currentSize = sizeChange.startSize;\n\n    while (elapsedTime < sizeChange.stepTime)\n    {\n        // Calculate the new size based on the elapsed time and speed\n        float newSize = Mathf.Lerp(sizeChange.startSize, sizeChange.endSize, elapsedTime / sizeChange.stepTime);\n\n        // Apply the new size to the object\n        objectToResize.transform.localScale = new Vector3(newSize, newSize, newSize);\n\n        // Update the current size and elapsed time\n        currentSize = newSize;\n        elapsedTime += Time.deltaTime;\n\n        // Wait for the next frame\n        yield return null;\n    }\n}\n```\n\nIn this example, the `ApplySizeChange` function takes a `GameObject` as a parameter and applies the size change defined by the `SizeChangeStep` instance to that object. The function uses a `while` loop and the `Mathf.Lerp` function to smoothly interpolate between the starting and ending sizes over the specified duration. The size change is applied to the object's scale, resulting in a visual change in size.\n## Questions: \n 1. **What is the purpose of this class?**\nThe class is named `SizeChangeStep`, but it is not clear what it is used for or how it fits into the overall project.\n\n2. **What are the data types of the variables `startSize`, `endSize`, `stepTime`, and `speed`?**\nThe code does not specify the data types of these variables, so it is unclear what kind of values they are meant to hold.\n\n3. **What is the relationship between `stepTime` and `speed`?**\nThe code does not provide any information about how `stepTime` and `speed` are related or how they are used within the class.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\SizeChangeStep.md"}}],["442",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Sleep.cs)\n\nThe code provided is a class called \"Sleep\" that extends the \"ScriptCmd\" class. This class represents a command that can be executed in the larger Brick-Force project. \n\nThe purpose of this code is to define a sleep command that pauses the execution of the script for a specified amount of time. The sleep duration is determined by the \"howlong\" variable, which is a float value representing the number of seconds to sleep.\n\nThe class has a public property called \"Howlong\" that allows the sleep duration to be set and retrieved. The \"get\" accessor returns the current value of \"howlong\", while the \"set\" accessor allows the value to be updated.\n\nThe class overrides several methods from the base \"ScriptCmd\" class. The \"GetDescription\" method returns a string that describes the sleep command, including the sleep duration. The \"GetIconIndex\" method returns the index of the icon associated with the sleep command. The \"GetDefaultDescription\" method returns a default description for the sleep command, which is \"sleep\" followed by the sleep duration set to 0. The \"GetName\" method returns the name of the sleep command, which is \"Sleep\".\n\nOverall, this code provides the functionality to define and execute a sleep command in the Brick-Force project. This command can be used to introduce delays in the execution of scripts, allowing for more precise control over the timing of events. For example, it can be used to create animations or timed sequences of actions in the game.\n## Questions: \n 1. What does the `Sleep` class inherit from? \nA smart developer might want to know if there are any additional methods or properties inherited from a parent class that are not shown in this code snippet.\n\n2. What is the purpose of the `GetDescription` method? \nA smart developer might want to know how the `GetDescription` method is used and what it returns.\n\n3. What is the significance of the `GetIconIndex` method? \nA smart developer might want to know how the `GetIconIndex` method is used and what its return value represents in the context of the project.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Sleep.md"}}],["443",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\SlotAmmoDamage.cs)\n\nThe code provided defines a struct called `SlotAmmoDamage`. This struct is used to store information about a slot, ammo ID, and damage value. \n\nThe struct has three properties: `slot`, `ammoId`, and `damage`. Each property has a getter and a setter method. \n\nThe `slot` property represents the slot number and is stored in the lower 4 bits of the `bitvector1` field. The getter method returns the value of `bitvector1` masked with `0xF` to extract the lower 4 bits. The setter method sets the value of `bitvector1` by performing a bitwise OR operation between the current value of `bitvector1` and the new value of `slot`.\n\nThe `ammoId` property represents the ID of the ammo and is stored in the upper 12 bits of the `bitvector1` field. The getter method returns the value of `bitvector1` masked with `0xFFF0` and then divides the result by 16 to extract the upper 12 bits. The setter method sets the value of `bitvector1` by performing a bitwise OR operation between the current value of `bitvector1` and the new value of `ammoId` multiplied by 16.\n\nThe `damage` property represents the damage value and is stored in the remaining bits of the `bitvector1` field. The getter method returns the value of `bitvector1` converted to a signed integer, masked with `-65536`, and then divided by 65536 to extract the remaining bits. The setter method sets the value of `bitvector1` by performing a bitwise OR operation between the current value of `bitvector1` and the new value of `damage` multiplied by 65536.\n\nThis struct can be used to store and manipulate information about a slot, ammo ID, and damage value in the larger Brick-Force project. For example, it can be used in a game engine to represent the properties of a weapon or an item. The struct provides a convenient way to access and modify these properties using the getter and setter methods. \n\nHere is an example of how the `SlotAmmoDamage` struct can be used:\n\n```csharp\nSlotAmmoDamage slotAmmoDamage = new SlotAmmoDamage();\nslotAmmoDamage.slot = 2;\nslotAmmoDamage.ammoId = 123;\nslotAmmoDamage.damage = 500;\n\nConsole.WriteLine(slotAmmoDamage.slot);    // Output: 2\nConsole.WriteLine(slotAmmoDamage.ammoId);  // Output: 123\nConsole.WriteLine(slotAmmoDamage.damage);  // Output: 500\n```\n\nIn this example, we create a new `SlotAmmoDamage` object and set the values of the `slot`, `ammoId`, and `damage` properties. We then use the getter methods to retrieve and print the values of these properties.\n## Questions: \n 1. What is the purpose of the `bitvector1` field in the `SlotAmmoDamage` struct?\n- The `bitvector1` field is used to store multiple bit-level properties related to slot, ammoId, and damage.\n\n2. How is the `slot` property calculated and what does it represent?\n- The `slot` property is calculated by performing a bitwise AND operation between `bitvector1` and 0xF, and it represents a specific slot value.\n\n3. How is the `damage` property calculated and what does it represent?\n- The `damage` property is calculated by performing a bitwise AND operation between `bitvector1` and -65536, then dividing the result by 65536u. It represents a damage value.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\SlotAmmoDamage.md"}}],["444",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Smokee.cs)\n\nThe code provided is a script for a class called \"Smokee\" in the Brick-Force project. This class is responsible for managing the behavior of a smoke object in the game. \n\nThe class has several public and private variables that control the behavior of the smoke object. The \"smokeeTime\" variable determines how long the smoke object will emit smoke particles. The \"lifeTime\" variable determines how long the smoke object will exist before being destroyed. The \"ApplyDotDamage\" variable determines whether the smoke object will apply damage over time (DOT) to nearby objects. The \"weaponBy\" variable determines the type of weapon that caused the smoke object to be created. The \"dotDamage\" variable determines the amount of damage that will be applied over time.\n\nThe class has a \"Mine\" method that sets a boolean variable \"bOwn\" to true. This method is likely called when the smoke object is created by a player.\n\nThe \"Update\" method is called every frame and is responsible for updating the behavior of the smoke object. It first increments the \"deltaTime\" variable by the time since the last frame. If the \"deltaTime\" exceeds the \"lifeTime\" value, the smoke object is destroyed using the \"Destroy\" method from the Unity engine. If the \"deltaTime\" exceeds the \"smokeeTime\" value, the smoke particles emitted by the smoke object are turned off by setting the \"maxEmission\" and \"minEmission\" properties of the particle emitters to 0.\n\nIf the \"bOwn\" variable is true and the \"ApplyDotDamage\" variable is true, the code applies damage over time to nearby objects. It increments the \"deltaTimeDot\" variable by the time since the last frame. If the \"deltaTimeDot\" exceeds 1 second, the code calculates the maximum and minimum sizes of the particle emitters attached to the smoke object. It then checks the distance between the smoke object and the player object named \"Me\". If the distance is within a certain range determined by the particle emitter sizes, the player object is damaged using the \"GetHit\" method from the \"LocalController\" component. The same check is performed for all other player objects in the game, and if they are within range, they are damaged using the \"SendPEER_BOMBED\" method from the \"P2PManager\" component.\n\nOverall, this code manages the behavior of a smoke object in the game, including its lifetime, emission of smoke particles, and application of damage over time to nearby objects. It is likely used in the larger project to create a realistic smoke effect and provide gameplay mechanics related to smoke objects.\n## Questions: \n 1. What is the purpose of the `Mine()` method?\n- The `Mine()` method sets the `bOwn` variable to true.\n\n2. What does the `Update()` method do?\n- The `Update()` method updates the `deltaTime` and `deltaTimeDot` variables and performs various actions based on their values.\n\n3. What is the significance of the `ApplyDotDamage` and `weaponBy` variables?\n- The `ApplyDotDamage` variable determines whether dot damage should be applied, and the `weaponBy` variable represents the type of weapon used.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Smokee.md"}}],["445",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\SmokeGrenade.cs)\n\nThe code provided is a class called \"SmokeGrenade\" that inherits from the \"HandBomb\" class. This class represents a smoke grenade in the game. \n\nThe \"Start\" method is called when the object is first created. It checks if a certain build option is enabled and if a specific condition is met, it modifies the texture of the smoke grenade by replacing it with a texture from a manager. Then, it calls the \"Modify\" method, which modifies various properties of the smoke grenade based on the current room type and the weapon function component attached to the object. It also modifies the properties based on the upgrade level of the weapon and the item associated with it.\n\nThe \"OnGUI\" method is responsible for drawing the user interface elements related to the smoke grenade, such as the crosshair, ammo count, and detonating status.\n\nThe \"Update\" method is called every frame. It first checks if the brick manager is loaded, and if so, it performs various actions related to the smoke grenade. It checks for cheating attempts, updates the ammo time, verifies the camera and local controller, updates the cross effect, and checks if the smoke grenade can be thrown. If the conditions are met, it removes the safety clip, plays a throw animation, and sends a network message to throw the smoke grenade.\n\nThe \"Throw\" method is called when the smoke grenade is thrown. It checks if the smoke grenade is detonating, and if so, it performs various actions related to the throwing process. It uses the camera to calculate the throw direction, instantiates a smoke grenade object, applies a force to it, and sets various properties of the smoke grenade object. It also sends a network message to update the projectile state. Finally, it updates the detonating status, shows the smoke grenade without the body and clip, and disables the smoke grenade if there is no ammo left.\n\nOverall, this code represents the behavior of a smoke grenade in the game. It handles the initialization, modification, drawing, updating, and throwing of the smoke grenade. It interacts with other components and systems in the game, such as the build options, texture manager, weapon function component, upgrade manager, item manager, cheat detection system, camera, local controller, and network manager.\n## Questions: \n 1. What is the purpose of the `Modify()` method and when is it called?\n- The `Modify()` method is used to modify the properties of the SmokeGrenade object based on certain conditions. It is called during the `Start()` method of the SmokeGrenade class.\n\n2. What does the `Throw()` method do and when is it called?\n- The `Throw()` method is used to throw the SmokeGrenade object. It is called when the player triggers a throw action and the grenade is not detonating.\n\n3. What is the purpose of the `OnGUI()` method and when is it called?\n- The `OnGUI()` method is used to draw the graphical user interface (GUI) elements for the SmokeGrenade object. It is called during the rendering of the GUI.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\SmokeGrenade.md"}}],["446",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\SmokeItem.cs)\n\nThe code provided is a part of the Brick-Force project and is a class called \"SmokeItem\". This class inherits from the \"ActiveItemBase\" class, indicating that it is a specific type of active item within the game.\n\nThe purpose of this code is to handle the behavior of the \"SmokeItem\" when it is activated or used by a player. The main function responsible for this behavior is the \"StartItem()\" method, which is an overridden method from the base class.\n\nInside the \"StartItem()\" method, there is a conditional statement that checks if the current player is the one who activated the \"SmokeItem\" or if it was activated by another player. If the current player is the one who activated it, the code finds the game object with the name \"Me\" and retrieves the \"LocalController\" component attached to it. If the component exists, it calls the \"EquipSmokeBomb()\" method on it.\n\nIf the current player is not the one who activated the \"SmokeItem\", the code retrieves the game object associated with the \"useUserSeq\" variable from the \"BrickManManager\" instance. It then retrieves the \"LookCoordinator\" component attached to that game object and calls the \"EquipSmokeBomb()\" method on it.\n\nIn summary, this code is responsible for equipping a smoke bomb item to either the local player or another player, depending on who activated the item. This behavior is likely used in the larger Brick-Force project to provide players with the ability to use smoke bombs as a gameplay mechanic, such as obscuring vision or creating cover.\n## Questions: \n 1. What is the purpose of the `Awake()` and `Update()` methods in the `SmokeItem` class?\n- The smart developer might ask why these methods are empty and if they are meant to be overridden or if they serve a specific purpose in the code.\n\n2. What is the purpose of the `StartItem()` method and when is it called?\n- The smart developer might ask for clarification on when and how the `StartItem()` method is called, as it seems to be the main method of the `SmokeItem` class.\n\n3. What is the significance of the `IsMyItem()` method and how is it determined if the item belongs to the player or not?\n- The smart developer might ask for more information on the `IsMyItem()` method and how it determines if the item belongs to the player or not, as it affects the logic flow in the `StartItem()` method.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\SmokeItem.md"}}],["447",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Snipets.cs)\n\nThe code provided is a C# class called \"Snipets\" that is marked with the [Serializable] attribute. This attribute indicates that objects of this class can be serialized and deserialized, meaning they can be converted into a format that can be stored or transmitted and then reconstructed back into an object.\n\nThe \"Snipets\" class has four public properties: \"cmtSeq\", \"nickNameCmt\", \"cmt\", and \"likeOrDislike\". These properties represent the comment sequence, the nickname of the commenter, the comment itself, and whether the comment is liked or disliked, respectively.\n\nThe purpose of this class is to define the structure of a comment object that can be used in the larger Brick-Force project. This class can be instantiated to create individual comment objects, which can then be manipulated and used within the project.\n\nFor example, in the Brick-Force project, there may be a feature that allows users to leave comments on certain elements or sections of the project. The \"Snipets\" class can be used to represent these comments. Each comment object can store information such as the sequence of the comment, the nickname of the commenter, the comment text, and whether the comment is liked or disliked.\n\nHere is an example of how the \"Snipets\" class can be used in the Brick-Force project:\n\n```csharp\nSnipets comment = new Snipets();\ncomment.cmtSeq = 1;\ncomment.nickNameCmt = \"JohnDoe\";\ncomment.cmt = \"This is a great project!\";\ncomment.likeOrDislike = 1;\n\n// Serialize the comment object\nstring serializedComment = Serialize(comment);\n\n// Deserialize the comment object\nSnipets deserializedComment = Deserialize(serializedComment);\n```\n\nIn this example, a comment object is created and its properties are set. The comment object is then serialized into a string using a \"Serialize\" method, which converts the object into a format that can be stored or transmitted. The serialized comment can later be deserialized back into an object using a \"Deserialize\" method, allowing the comment to be reconstructed and used within the project.\n\nOverall, the \"Snipets\" class provides a structured way to represent comments in the Brick-Force project, allowing for easy manipulation and storage of comment data.\n## Questions: \n 1. **What is the purpose of the `Serializable` attribute on the `Snipets` class?**\nThe `Serializable` attribute indicates that instances of the `Snipets` class can be serialized and deserialized, allowing them to be easily stored or transmitted.\n\n2. **What do the different properties (`cmtSeq`, `nickNameCmt`, `cmt`, `likeOrDislike`) represent in the `Snipets` class?**\nThe `cmtSeq` property likely represents a sequence number for the comment, `nickNameCmt` represents the nickname of the commenter, `cmt` represents the comment text, and `likeOrDislike` represents a value indicating whether the comment was liked or disliked.\n\n3. **Are there any additional methods or functionality in the `Snipets` class?**\nBased on the provided code, it is not clear if there are any additional methods or functionality in the `Snipets` class.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Snipets.md"}}],["448",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\SpawnerDesc.cs)\n\nThe code provided defines a class called `SpawnerDesc` which represents a spawner in the Brick-Force project. The purpose of this class is to store information about a spawner, such as its sequence number, position, and rotation.\n\nThe `SpawnerDesc` class has three properties: `sequence`, `position`, and `rotation`. The `sequence` property is an integer that represents the order in which the spawner should be activated. The `position` property is a `Vector3` object that represents the position of the spawner in 3D space. The `rotation` property is a byte that represents the rotation of the spawner.\n\nThe class also has a constructor that takes in three parameters: `seq`, `pos`, and `rot`. These parameters are used to initialize the `sequence`, `position`, and `rotation` properties respectively. This constructor allows for easy creation of `SpawnerDesc` objects with the necessary information.\n\nThis code can be used in the larger Brick-Force project to create and manage spawners. For example, when designing a level in the game, the level designer can use instances of the `SpawnerDesc` class to define the properties of each spawner in the level. These instances can then be stored in a list or array to keep track of all the spawners in the level.\n\nHere is an example of how this code can be used:\n\n```csharp\n// Create a new spawner with sequence number 1, position (0, 0, 0), and rotation 0\nSpawnerDesc spawner = new SpawnerDesc(1, new Vector3(0, 0, 0), 0);\n\n// Access the properties of the spawner\nint sequence = spawner.sequence;\nVector3 position = spawner.position;\nbyte rotation = spawner.rotation;\n\n// Output the properties\nDebug.Log(\"Sequence: \" + sequence);\nDebug.Log(\"Position: \" + position);\nDebug.Log(\"Rotation: \" + rotation);\n```\n\nIn this example, a new `SpawnerDesc` object is created with the specified properties. The properties of the spawner are then accessed and outputted using `Debug.Log`. This allows for easy debugging and verification of the spawner properties.\n## Questions: \n 1. **What is the purpose of the SpawnerDesc class?**\nThe SpawnerDesc class is used to store information about a spawner, including its sequence number, position, and rotation.\n\n2. **What data types are used for the sequence, position, and rotation variables?**\nThe sequence variable is an integer, the position variable is a Vector3 (a 3D vector), and the rotation variable is a byte.\n\n3. **Are there any additional methods or properties in the SpawnerDesc class?**\nBased on the provided code, there are no additional methods or properties in the SpawnerDesc class.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\SpawnerDesc.md"}}],["449",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\SpectatorController.cs)\n\nThe code provided is for a class called \"SpectatorController\" in the Brick-Force project. This class is responsible for controlling the camera movement and behavior when the player is in spectator mode. \n\nThe class has several public and private variables that control various aspects of the camera movement. These variables include targetHeight, distance, maxDistance, minDistance, xSpeed, ySpeed, yMinLimit, yMaxLimit, zoomRate, rotationDampening, and zoomDampening. These variables determine the height, distance, speed, limits, and other properties of the camera movement.\n\nThe Start() method is called when the script is initialized. It sets the randomSpawnerTicketWhenTargetIsNull variable to a random value between 0 and 16. It also sets the initial values for the x and y rotation angles, currentDistance, desiredDistance, and correctedDistance. Additionally, it sets the collisionLayers variable to exclude certain layers from collision detection.\n\nThe LateUpdate() method is called once per frame. It first checks if the player is in spectator mode. If so, it retrieves the target transform from the SpectatorSwitch component attached to the same game object. If there is no target or the player's status is not 4, it retrieves a spawner transform from the BrickManager based on the player's rounding spawner type and the randomSpawnerTicketWhenTargetIsNull value. If no transform is found, the method returns.\n\nIf the player is holding down the left or right mouse button, the x and y rotation angles are updated based on the mouse movement and the xSpeed and ySpeed variables. The y angle is clamped between the yMinLimit and yMaxLimit values. \n\nA Quaternion rotation is created based on the x and y angles. The desiredDistance is updated based on the mouse scroll wheel input and the zoomRate variable. It is then clamped between the minDistance and maxDistance values. The correctedDistance is set to the desiredDistance.\n\nThe camera position is calculated based on the target transform, the rotation, the desiredDistance, and the targetHeight. A ray is cast from the target position to the camera position to check for any collisions with objects on the collisionLayers. If a collision is detected, the correctedDistance is updated to the distance between the target position and the collision point. The currentDistance is then updated to either the correctedDistance or a lerp between the currentDistance and the correctedDistance based on the zoomDampening variable.\n\nFinally, the camera rotation and position are set to the calculated values.\n\nIn summary, this code controls the camera movement and behavior when the player is in spectator mode. It allows the player to rotate the camera around a target object, zoom in and out, and avoids collisions with certain objects. This functionality is important for providing an immersive and flexible spectator experience in the Brick-Force game.\n## Questions: \n 1. What is the purpose of the `SpectatorController` class?\n- The `SpectatorController` class is responsible for controlling the camera movement and behavior for a spectator in the game.\n\n2. What is the significance of the `collisionLayers` variable?\n- The `collisionLayers` variable is used to define which layers should be considered for collision detection when calculating the camera position. It is set to exclude certain layers related to player, boxman, brain, and corebrain.\n\n3. What is the purpose of the `ClampAngle` method?\n- The `ClampAngle` method is used to restrict the angle value within a specified range. It ensures that the camera rotation angles stay within the defined minimum and maximum limits.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\SpectatorController.md"}}],["450",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\SpectatorSwitch.cs)\n\nThe code provided is a script called \"SpectatorSwitch\" that is part of the larger Brick-Force project. This script is responsible for managing the spectator mode in the game. \n\nThe script contains several variables and references to other classes and objects. Here is a breakdown of the important elements:\n\n- `guiDepth`: A variable that determines the depth of the GUI elements in the game.\n- `fpCam`: A reference to the first-person camera object.\n- `clrOutline` and `clrText`: Variables that store the colors for the outline and text of the spectator UI.\n- `curMode`: A variable that stores the current control mode of the player.\n- `target`: A reference to the current target player that the spectator is observing.\n- `localController` and `spectatorController`: References to the local and spectator controllers.\n- `deactivatedWeapons`: An array of references to deactivated weapons.\n- `deltaTime`: A variable that keeps track of the time since the last update.\n\nThe script contains several methods that handle different aspects of the spectator mode:\n\n- `Start()`: This method is empty and does not contain any code.\n- `OnGUI()`: This method is responsible for rendering the spectator UI on the screen. It checks if the GUI is enabled and if the BrickManager is loaded. If these conditions are met, it retrieves the GUI skin and sets the GUI depth. It then displays the target player's nickname on the screen using two different labels with different colors.\n- `OnRemoveBrickMan(GameObject obj)`: This method is called when a brick man (player) is removed from the game. If the removed player is the current target, it disables the ghost switch component and sets the target to the next player. If there are no more players, it sets the parent of the script's transform to null.\n- `VerifyLocalController()`: This method checks if the local controller is null and retrieves it if it is.\n- `VerifySpectatorController()`: This method checks if the spectator controller is null and retrieves it if it is.\n- `Update()`: This method is called every frame and handles various tasks related to the spectator mode. It checks if there is a target player and if the jump button is pressed or if the current target player is null or hidden. If any of these conditions are met, it sets the target to the next player. It also checks if the control mode has changed and calls the `ModeChange()` method accordingly. It then verifies the local and spectator controllers and updates the delta time. Finally, it sends a spectator command and logs the camera usage if the control mode is set to spectator mode.\n- `LookFriendlyOnly()`: This method returns a boolean value based on whether the control mode is spectator mode or not.\n- `VerifyTarget()`: This method is responsible for verifying the target player. If the player is a spectator and the target is null, it sets the target to a random player. If the target is not null, it checks if the target player is valid and sets the target to null if it is not.\n- `ModeChangeBruteforcely(MyInfoManager.CONTROL_MODE controlMode)`: This method changes the control mode forcefully and calls the `ModeChange()` method.\n- `ModeChange()`: This method handles the mode change logic. If the local controller, first-person camera, and spectator controller are not null, it checks the current control mode. If the control mode is spectator mode or playing spectator, it disables the local controller, deactivates the weapons, hides the first-person camera, and enables the spectator controller. If the control mode is not spectator mode, it enables the local controller, activates the weapons, shows the first-person camera, disables the spectator controller, and resets the target and parent.\n\nIn summary, this script manages the spectator mode in the game. It handles UI rendering, target player selection, control mode changes, and enables/disables relevant components based on the control mode.\n## Questions: \n 1. What is the purpose of the `OnGUI` method?\n- The `OnGUI` method is responsible for rendering the spectator UI elements on the screen when the GUI is enabled and the BrickManager is loaded.\n\n2. What does the `VerifyTarget` method do?\n- The `VerifyTarget` method checks if the current target of the spectator is still valid. If the target is null or the target's status is not 4, the target is set to null.\n\n3. What is the purpose of the `ModeChange` method?\n- The `ModeChange` method is called when the control mode of the spectator changes. It enables or disables the necessary components and weapons based on the new control mode.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\SpectatorSwitch.md"}}],["451",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\SpeedHackProtector.cs)\n\nThe code provided is a class called `SpeedHackProtector` that is a part of the larger Brick-Force project. This class is responsible for protecting against speed hacking in the game. \n\nThe class has two private variables: `breakinto` and `pvMov`. `breakinto` is a boolean variable that indicates whether a player is attempting to break into the game's code to gain an unfair advantage. `pvMov` is an unsigned integer that represents the packet variation movement.\n\nThe class also has two public properties: `Breakinto` and `PvMov`. These properties provide access to the private variables `breakinto` and `pvMov` respectively. The `get` accessor returns the value of the private variable, while the `set` accessor allows the value of the private variable to be modified.\n\nThe class has a method called `InitializePacketVariation()`. This method is responsible for initializing the `pvMov` and `breakinto` variables. It sets `pvMov` to 0 and `breakinto` to false. This method is likely called at the start of the game or when a new player joins to ensure that the variables are properly initialized.\n\nThe `SpeedHackProtector` class also has a `Start()` method, but it is empty and does not contain any code. It is possible that this method was left empty intentionally or it may be used for future development.\n\nIn the larger Brick-Force project, this `SpeedHackProtector` class is likely used to detect and prevent speed hacking in the game. Speed hacking refers to the act of manipulating the game's code or mechanics to move faster than intended. By monitoring the `breakinto` variable and the `pvMov` value, the game can detect if a player is attempting to cheat and take appropriate action.\n\nExample usage:\n```csharp\nSpeedHackProtector speedHackProtector = new SpeedHackProtector();\nspeedHackProtector.InitializePacketVariation();\n\nspeedHackProtector.Breakinto = true;\nbool isBreakinto = speedHackProtector.Breakinto; // true\n\nspeedHackProtector.PvMov = 10u;\nuint pvMovValue = speedHackProtector.PvMov; // 10\n```\n## Questions: \n 1. What is the purpose of the `SpeedHackProtector` class?\n- The `SpeedHackProtector` class is used to protect against speed hacking in the game.\n\n2. What is the significance of the `breakinto` variable?\n- The `breakinto` variable is a boolean flag that indicates whether a speed hack has been detected.\n\n3. What is the purpose of the `InitializePacketVariation` method?\n- The `InitializePacketVariation` method is used to reset the `pvMov` and `breakinto` variables to their initial values.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\SpeedHackProtector.md"}}],["452",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\SpeedUpTPEffect.cs)\n\nThe code provided is a part of the Brick-Force project and is a script called \"SpeedUpTPEffect\". This script is responsible for managing a speed-up effect for a TPController object in the game.\n\nThe script is written in C# and uses the Unity game engine. It includes a reference to the UnityEngine namespace, which provides access to various Unity classes and functions.\n\nThe SpeedUpTPEffect class inherits from the MonoBehaviour class, which is a base class for all Unity scripts. This allows the script to be attached to a GameObject in the game scene and receive callbacks for various events, such as Start and Update.\n\nThe class has a public TPController variable called \"owner\", which is used to reference the TPController object that this effect is associated with. The TPController class is not shown in the provided code, but it can be assumed that it is responsible for controlling the movement and behavior of a game character.\n\nThe Start method is empty and does not contain any code. This suggests that any initialization or setup for the effect is done elsewhere in the project.\n\nThe Update method is called once per frame by Unity and is used to check if the \"owner\" variable is not null and if the TPController object is not currently under a speed-up effect. If both conditions are true, the script destroys the GameObject that this script is attached to using the Object.DestroyImmediate method.\n\nThis script can be used in the larger Brick-Force project to create a temporary speed-up effect for the TPController object. For example, when the player collects a power-up item, this script can be attached to the player character to temporarily increase their movement speed. Once the effect is over, the script destroys itself to remove the speed-up effect.\n\nHere is an example of how this script can be used in the project:\n\n```csharp\n// Attach the SpeedUpTPEffect script to the TPController object\nTPController tpController = GetComponent<TPController>();\nSpeedUpTPEffect speedUpEffect = tpController.gameObject.AddComponent<SpeedUpTPEffect>();\n\n// Start the speed-up effect\nspeedUpEffect.owner = tpController;\n\n// After some time, the effect is over and the script destroys itself\nspeedUpEffect.owner = null;\n```\n\nIn summary, the SpeedUpTPEffect script is responsible for managing a temporary speed-up effect for a TPController object in the Brick-Force project. It checks if the effect is still active and destroys itself when the effect is over.\n## Questions: \n 1. What is the purpose of the `SpeedUpTPEffect` class?\n- The `SpeedUpTPEffect` class is responsible for managing a speed-up effect for a TPController object.\n\n2. What is the significance of the `owner` variable?\n- The `owner` variable is a reference to the TPController object that this effect is associated with.\n\n3. What triggers the destruction of the `SpeedUpTPEffect` object?\n- The `SpeedUpTPEffect` object is destroyed if the `owner` variable is not null and the `IsSpeedUp` property of the `owner` object is false.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\SpeedUpTPEffect.md"}}],["453",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Squad.cs)\n\nThe code provided is a class called `Squad` that represents a squad in the larger Brick-Force project. The purpose of this class is to store and manage information about a squad, such as its index, member count, maximum member count, win count, draw count, lose count, leader, team leader, and desired map and mode to play.\n\nThe class has several properties that allow access to these information fields. For example, the `Index` property returns the index of the squad, the `Name` property returns the name of the squad by concatenating the clan name with the index, and the `MemberCountString` property returns a string representation of the member count and maximum member count.\n\nThe class also has getter and setter methods for the member count, maximum member count, win count, draw count, lose count, team leader, leader, desired map, and desired mode. These methods allow other parts of the project to get and set these values as needed.\n\nAdditionally, the class has a `Record` property that returns a string representation of the win count, draw count, and lose count, concatenated with localized strings for \"WIN\", \"DRAW\", and \"LOSE\". This property is likely used to display the squad's record in a user interface.\n\nThe class has a constructor that takes in parameters for all the information fields and initializes them accordingly. This allows for easy creation of `Squad` objects with the necessary information.\n\nOverall, this `Squad` class provides a way to store and manage information about a squad in the Brick-Force project. It allows for easy access and manipulation of squad data, and can be used in various parts of the project to display and update squad information.\n## Questions: \n 1. What is the purpose of the `Squad` class?\n- The `Squad` class represents a squad in the Brick-Force project and stores information about the squad's index, member count, maximum member count, win count, draw count, lose count, leader sequence, and leader nickname.\n\n2. What is the significance of the `Index` property?\n- The `Index` property returns the index of the squad.\n\n3. What is the purpose of the `Record` property?\n- The `Record` property returns a string representation of the squad's win count, draw count, and lose count, along with localized strings for \"WIN\", \"DRAW\", and \"LOSE\".","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Squad.md"}}],["454",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\SquadingMain.cs)\n\nThe code provided is a script for the SquadingMain class in the Brick-Force project. This class is responsible for managing the main functionality of the Squading feature in the game. \n\nThe SquadingMain class has several public variables that reference other classes and components in the game, such as SquadListFrame, ClanMemberListFrame, LobbyChat, and SquadingTool. These variables are used to store references to instances of these classes, allowing the SquadingMain class to interact with them.\n\nThe Start() method is called when the script is first initialized. In this method, the deltaTime variable is set to 0, and the Start() method of the squadList, clanMemberList, lobbyChat, and squadingTool objects is called. Additionally, the SetChatStyle() method of the lobbyChat object is called, passing in a constant value representing the style of the chat.\n\nThe Update() method is called every frame. In this method, the Update() method of the squadList, clanMemberList, lobbyChat, and squadingTool objects is called. The deltaTime variable is incremented by the Time.deltaTime value, which represents the time in seconds since the last frame. If the deltaTime value exceeds 0.5 seconds, a check is performed to see if the player's clan sequence number is less than 0. If it is, the OnClanExiled() method is called.\n\nThe OnClanExiled() method is called when the player is exiled from their clan. In this method, several actions are performed. First, all open dialogs and context menus are closed. Then, a message is added to the message box indicating that the player has been exiled from their clan. The SendCS_LEAVE_SQUADING_REQ() method is called to send a request to leave the squad. The SquadManager is cleared, and the game is loaded back to the lobby scene.\n\nThe OnGUI() method is responsible for rendering the Squading UI on the screen. It begins by setting the GUI skin and enabling GUI functionality. It then draws a box on the screen using the crdSquading rectangle and the \"BoxPopupBg\" style. The TextOut() method is called to render the title label for the Squading UI. The OnGUI() methods of the squadList, clanMemberList, lobbyChat, and squadingTool objects are called to render their respective UI elements. Finally, the GUI functionality is enabled again, and the GUI rendering is ended.\n\nThe OnChat() method is called when a chat message is received. In this method, the chat message is enqueued in the lobbyChat object, which handles displaying the chat messages in the UI.\n\nOverall, this code manages the main functionality of the Squading feature in the game, including initializing and updating various components, handling events such as being exiled from a clan, rendering the Squading UI, and handling chat messages.\n## Questions: \n 1. What is the purpose of the `Start()` method and what does it do?\n- The `Start()` method initializes the `deltaTime` variable, starts the `squadList`, `clanMemberList`, `lobbyChat`, and `squadingTool`, and sets the chat style of `lobbyChat` to `CLANMATCH`.\n\n2. What is the purpose of the `Update()` method and what does it do?\n- The `Update()` method updates the `squadList`, `clanMemberList`, `lobbyChat`, and `squadingTool`, increments the `deltaTime` variable, and checks if the `MyInfoManager` instance's `ClanSeq` is less than 0, and if so, calls the `OnClanExiled()` method.\n\n3. What is the purpose of the `OnGUI()` method and what does it do?\n- The `OnGUI()` method is responsible for rendering the GUI elements on the screen, including the `squadList`, `clanMemberList`, `lobbyChat`, and `squadingTool`.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\SquadingMain.md"}}],["455",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\SquadingTool.cs)\n\nThe code provided is a class called \"SquadingTool\" that is used in the larger Brick-Force project. This class is responsible for handling the user interface and functionality related to squad management. \n\nThe class has several private variables of type Rect that define the position and size of different buttons on the screen. These variables are used to create the buttons for joining a squad, creating a squad, and going back to the lobby. \n\nThe class also has a public method called \"Start\" that takes a parameter of type \"SquadListFrame\". This method is used to initialize the \"squadList\" variable with the provided \"squadListFrame\" object. \n\nThe class has an \"Update\" method that is currently empty and does not have any functionality. \n\nThe most important method in this class is the \"OnGUI\" method. This method is called every frame and is responsible for rendering the user interface elements and handling user input. \n\nInside the \"OnGUI\" method, there are three if statements that check if a button is clicked. If the \"Join Squad\" button is clicked, it checks if a squad is selected and sends a request to join the selected squad. If the \"Create Squad\" button is clicked, it opens a dialog to create a new squad. If the \"Back\" button is clicked or the escape key is pressed, it sends a request to leave the squad and returns to the lobby. \n\nOverall, this class provides the functionality for managing squads in the Brick-Force project. It handles rendering the user interface elements and handling user input for joining or creating squads, as well as leaving the squad and returning to the lobby.\n## Questions: \n 1. What is the purpose of the `SquadListFrame` parameter in the `Start` method?\n- The `SquadListFrame` parameter is used to pass in an instance of the `SquadListFrame` class, which is then assigned to the `squadList` variable. This allows the `SquadingTool` class to access and manipulate the `squadList` object.\n\n2. What does the `Update` method do?\n- The `Update` method is currently empty and does not contain any code. It is unclear what its purpose is or if it is intended to be implemented later.\n\n3. What happens when the `crdBack` button is clicked?\n- When the `crdBack` button is clicked, the code sends a request to leave the squad and clears the squad manager. It then loads the \"Lobby\" level in the application.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\SquadingTool.md"}}],["456",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\SquadListFrame.cs)\n\nThe code provided is a class called `SquadListFrame` that is used to display a list of squads in a graphical user interface (GUI) in the larger Brick-Force project. The purpose of this code is to create and manage the visual representation of the squads in the game.\n\nThe `SquadListFrame` class contains various properties and methods that define the layout and behavior of the squad list GUI. The class includes several `Rect` and `Vector2` variables that specify the positions and sizes of different GUI elements, such as the outline of the squad list, the columns for squad information, and the positions of text labels.\n\nThe `Start()` and `Update()` methods are empty and do not contain any code. These methods are typically used in Unity projects to initialize and update game objects, but in this case, they are not being used.\n\nThe `GridOut()` method is a private helper method that takes a `Squad` object and a float value representing the current y-coordinate. This method uses the `LabelUtil.TextOut()` method to display various properties of the squad, such as the squad name, number of players, record, and team leader. It then returns the updated y-coordinate for the next squad.\n\nThe `OnGUI()` method is the main method of the class that is called to draw the GUI. It first creates and displays the background boxes and labels for the squad list using the `GUI.Box()` and `LabelUtil.TextOut()` methods. It then retrieves an array of `Squad` objects from the `SquadManager` class and creates an array of empty strings with the same length as the squad array.\n\nNext, it creates a `Rect` object that represents the scrollable area of the squad list and begins a scroll view using the `GUI.BeginScrollView()` method. It then uses the `GUI.SelectionGrid()` method to display a grid of selectable elements, where each element represents a squad. The selected squad is stored in the `curSquad` variable.\n\nFinally, it iterates over the squad array and calls the `GridOut()` method to display the squad information for each squad. If the current squad being iterated is the selected squad, it assigns the squad to the `selectedSquad` variable.\n\nThe `GUI.EndScrollView()` method is called to end the scroll view, and the GUI rendering is complete.\n\nOverall, this code provides the functionality to display a list of squads in a GUI and allows the user to select a squad from the list. The selected squad can then be used for further actions or interactions within the larger Brick-Force project.\n## Questions: \n 1. What is the purpose of the `Start()` and `Update()` methods in the `SquadListFrame` class?\n- The purpose of the `Start()` and `Update()` methods is not clear from the provided code. It would be helpful to know what functionality these methods provide.\n\n2. What is the purpose of the `GridOut()` method in the `SquadListFrame` class?\n- The `GridOut()` method appears to be responsible for displaying information about a `Squad` object on the GUI. It would be useful to know how this method is used and what information it displays.\n\n3. What is the significance of the `selectedSquad` variable and how is it used in the `OnGUI()` method?\n- The `selectedSquad` variable is assigned a value within the `OnGUI()` method, but its purpose and how it is used is not clear from the provided code. Understanding its significance would provide insight into the functionality of the `OnGUI()` method.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\SquadListFrame.md"}}],["457",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\SquadMain.cs)\n\nThe code provided is a script for the SquadMain class in the Brick-Force project. This class is responsible for managing the main functionality of the squad system in the game. It handles the display of squad information, updates the squad members list, and manages the squad matching process.\n\nThe class contains several public variables that reference other classes and components in the game, such as ClanMemberListFrame, LobbyChat, SquadMemberListFrame, SquadMode, and SquadTool. These variables are used to access and manipulate the corresponding components in the game.\n\nThe Start() method is called when the script is initialized. It initializes the deltaTime variable and calls the Start() method of the clanMemberList, lobbyChat, squadMemberList, squadMode, and squadTool components. It also sets the chat style of the lobbyChat component to CLANMATCH.\n\nThe Update() method is called every frame. It updates the clanMemberList, lobbyChat, squadMemberList, squadMode, and squadTool components. It also checks if a certain amount of time has passed (0.5 seconds in this case) and performs some actions if it has. These actions include updating the dotCount variable, checking if the player has been exiled from their clan, and performing some cleanup actions if they have.\n\nThe OnClanExiled() method is called when the player has been exiled from their clan. It closes all open dialogs and context menus, displays a message to the player, sends some network requests to leave the squad and squading, clears the squad data, and loads the Lobby scene.\n\nThe MatchingProgress() method is called when the squad is in the matching process. It displays a progress message with dots indicating the progress of the matching process. It also checks if the player is the leader of the squad and displays a cancel button if they are.\n\nThe OnGUI() method is responsible for rendering the GUI elements of the squad system. It sets the GUI skin, draws the background texture, and displays various squad information such as the squad name, member count, and record. It also calls the OnGUI() methods of the clanMemberList, lobbyChat, squadMemberList, squadMode, and squadTool components.\n\nThe OnChat() method is called when a chat message is received. It enqueues the chat message to the lobbyChat component for display.\n\nIn summary, this code manages the main functionality of the squad system in the game. It handles the display of squad information, updates the squad members list, manages the squad matching process, and handles chat messages. It interacts with various components in the game to achieve these functionalities.\n## Questions: \n 1. What is the purpose of the `Start()` method and what does it do?\n- The `Start()` method is called when the script is first enabled. It initializes various components and sets the chat style to \"CLANMATCH\".\n\n2. What is the purpose of the `Update()` method and what does it do?\n- The `Update()` method is called every frame. It updates various components and checks if the player has been exiled from their clan.\n\n3. What is the purpose of the `OnGUI()` method and what does it do?\n- The `OnGUI()` method is responsible for rendering the graphical user interface. It draws various UI elements such as boxes, labels, and textures.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\SquadMain.md"}}],["458",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\SquadManager.cs)\n\nThe `SquadManager` class is responsible for managing squads and squad members in the larger Brick-Force project. It contains various methods and properties to handle squad-related operations.\n\nThe class has several private fields, including `dicSquad`, `squad`, `dicMember`, and `isMatching`. `dicSquad` is a dictionary that stores squads, where the key is an integer index and the value is an instance of the `Squad` class. `squad` is an integer that represents the current squad index. `dicMember` is a dictionary that stores squad members, where the key is an integer sequence and the value is an instance of the `NameCard` class. `isMatching` is a boolean flag that indicates whether the squad is currently in a matching process.\n\nThe class also has a private static field `_instance` and a public static property `Instance`. These are used to implement the singleton pattern, ensuring that there is only one instance of the `SquadManager` class throughout the project.\n\nThe class provides various public methods to perform squad-related operations. For example, the `Join` method allows a player to join a squad by setting the `squad` field to the specified index. The `Clear` method clears all squads and the current squad. The `Leave` method removes all squad members and resets the `squad` field and `isMatching` flag.\n\nThe `UpdateAlways` method is used to update squad information. It takes various parameters such as clan, index, memberCount, maxMember, win, draw, lose, leaderSeq, and leaderNickname. It updates the corresponding squad in the `dicSquad` dictionary or adds a new squad if it doesn't exist.\n\nThe class also provides methods to add and remove squad members, get squads and squad members as arrays, and retrieve specific squad members by sequence.\n\nOverall, the `SquadManager` class serves as a central component for managing squads and squad members in the Brick-Force project. It provides methods to perform various squad-related operations and stores squad and member information in dictionaries for easy access and manipulation.\n## Questions: \n 1. What is the purpose of the `SquadManager` class?\n- The `SquadManager` class is responsible for managing squads and squad members in the game.\n\n2. What is the purpose of the `Join` method?\n- The `Join` method is used to join a squad by setting the `squad` variable to the specified index.\n\n3. What is the purpose of the `UpdateAlways` method?\n- The `UpdateAlways` method is used to update the information of a squad, such as member count, win count, lose count, etc. If the squad with the specified index doesn't exist, a new squad is created.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\SquadManager.md"}}],["459",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\SquadMemberListFrame.cs)\n\nThe code provided is a class called `SquadMemberListFrame` that is used to display a list of squad members in a graphical user interface (GUI) in the Brick-Force project. \n\nThe class contains several private variables that define the positions and sizes of various GUI elements, such as the outline of the member list, the member list itself, the position of the badge, the size of the badge, and the position of the nickname. \n\nThe class also has a public array `crdSquadMember` of type `Vector2[]`, which is used to store the positions of each squad member in the GUI. \n\nThe class has a public property `SelectedMember` of type `NameCard`, which returns the currently selected squad member. \n\nThe class has three methods: `Start()`, `Update()`, and `OnGUI()`. \n\nThe `Start()` and `Update()` methods are empty and do not contain any code. \n\nThe `OnGUI()` method is responsible for rendering the GUI elements and updating the selected member based on user input. \n\nIn the `OnGUI()` method, the `SquadManager` instance is used to retrieve an array of `NameCard` objects representing the squad members. \n\nA string array `array` is created with the same length as the squad member array. \n\nA GUI box is drawn using the `GUI.Box()` method to display the outline of the member list. \n\nThe number of rows in the member list is calculated based on the length of the squad member array. \n\nA `Rect` object `position` is created to define the position and size of the member list grid. \n\nA selection grid is drawn using the `GUI.SelectionGrid()` method to display the squad members in a grid format. The currently selected member is stored in the `curMember` variable. \n\nA loop is used to iterate through the squad member array and draw the badge and nickname for each member using the `aPlayer()` method. \n\nIf the current member being iterated is the selected member, the `selectedMember` variable is updated. \n\nOverall, this code is responsible for rendering and updating the squad member list in the GUI, allowing the user to select a member and retrieve information about them.\n## Questions: \n 1. What is the purpose of the `Start()` and `Update()` methods in the `SquadMemberListFrame` class?\n- The purpose of the `Start()` and `Update()` methods is not clear from the provided code. It would be helpful to know what functionality or actions these methods are responsible for.\n\n2. What is the significance of the `crdMemberListOutline` and `crdMemberList` variables?\n- It is not clear what these variables represent or how they are used in the code. Additional context or comments would be helpful to understand their purpose.\n\n3. What is the purpose of the `aPlayer()` method and how is it used in the `OnGUI()` method?\n- The `aPlayer()` method is called within the `OnGUI()` method, but its functionality and purpose are not clear from the provided code. Understanding its purpose and how it is used would provide more context for the code's functionality.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\SquadMemberListFrame.md"}}],["460",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\SquadTool.cs)\n\nThe code provided is a class called \"SquadTool\" that is used in the larger Brick-Force project. This class is responsible for handling the GUI (Graphical User Interface) interactions related to managing a squad in the game.\n\nThe class has several private variables of type \"Rect\" that define the positions and sizes of GUI elements on the screen. These variables are used to create and position buttons in the GUI.\n\nThe class has a public method called \"Start\" that takes a parameter of type \"SquadMemberListFrame\". This method is called to initialize the \"squadMemberList\" variable with the provided \"squadMemberListFrame\" object.\n\nThe class has a public method called \"Update\" that currently does nothing. This method is likely intended to be used for updating the state of the squad tool, but it is empty in the provided code.\n\nThe class has a public method called \"OnGUI\" that is responsible for rendering the GUI elements and handling user interactions. \n\nInside the \"OnGUI\" method, the code first checks if the current squad exists and if the player is the leader of the squad. If both conditions are true, it proceeds to check if a squad member is selected and if the selected member is not the player themselves. If these conditions are also true, it creates a button with the label \"EXILE\" at the position defined by the \"crdCreate\" variable. \n\nIf the \"EXILE\" button is clicked, it sends a request to kick the selected squad member using the \"CSNetManager\" class.\n\nAfter that, the code checks if the \"Back\" button is clicked or if the escape key is pressed. If either of these conditions is true, it sends a request to leave the squad using the \"CSNetManager\" class, leaves the squad using the \"SquadManager\" class, and loads the \"Squading\" scene using the \"Application\" class.\n\nIn summary, this code is responsible for rendering and handling GUI elements related to managing a squad in the Brick-Force game. It allows the player to kick squad members and leave the squad.\n## Questions: \n 1. What is the purpose of the `Start` method and what does it do?\n- The `Start` method initializes the `squadMemberList` variable with the provided `squadMemberListFrame` parameter.\n\n2. What is the purpose of the `Update` method and what does it do?\n- The `Update` method is currently empty and does not have any functionality. It might be used for updating the state of the `SquadTool` object in the future.\n\n3. What is the purpose of the `OnGUI` method and what does it do?\n- The `OnGUI` method handles the graphical user interface (GUI) for the `SquadTool` object. It checks if the current squad leader wants to kick a selected member and handles the button actions for leaving the squad.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\SquadTool.md"}}],["461",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Stamp.cs)\n\nThe code provided is for a class called \"Stamp\" in the Brick-Force project. The purpose of this class is to handle the animation and behavior of a stamp in a mission dialog. \n\nThe class has a private float variable called \"deltaTime\" and a private enum variable called \"step\" of type \"MissionDialog.STAMP_STEP\". The \"step\" variable represents the current step of the stamp animation, while the \"deltaTime\" variable keeps track of the time elapsed since the last frame.\n\nThe class has a constructor that takes a \"stampStep\" parameter and initializes the \"step\" variable with it. It also sets the \"deltaTime\" variable to 0.\n\nThe class has a public property called \"Step\" which returns the value of the \"step\" variable. This property allows other classes to access the current step of the stamp animation.\n\nThe class has a public method called \"IsDoing\" which returns a boolean value indicating whether the stamp is currently animating or not. It checks if the \"step\" variable is not equal to \"MissionDialog.STAMP_STEP.STAMP_NONE\".\n\nThe class has a public method called \"Update\" which takes an AudioClip parameter called \"kwang\". This method updates the stamp animation based on the current step. It first checks if the step is \"MissionDialog.STAMP_STEP.STAMP_NONE\" and returns false if it is. Otherwise, it increments the \"deltaTime\" variable by the time elapsed since the last frame.\n\nThe method then uses a switch statement to handle different steps of the stamp animation. For each step, it checks if the \"deltaTime\" has exceeded a certain threshold and performs the necessary actions. For example, if the step is \"MissionDialog.STAMP_STEP.STAMP_OUT\" and the \"deltaTime\" is greater than 0.3f, it sets the \"step\" to \"MissionDialog.STAMP_STEP.STAMP_IN\".\n\nThe method returns true at the end, indicating that the stamp animation is still ongoing.\n\nThe class also has two public methods called \"LerpSize\" and \"LerpOffset\" which calculate and return the size and offset of the stamp animation respectively. These methods use the current step and \"deltaTime\" to determine the values to return.\n\nOverall, this class provides the functionality to animate and control the behavior of a stamp in a mission dialog. Other classes can use this class to create and manage stamp animations in the larger Brick-Force project.\n## Questions: \n 1. What is the purpose of the `Stamp` class?\n- The `Stamp` class is used to control the animation and behavior of a stamp in the game.\n\n2. What is the significance of the `MissionDialog.STAMP_STEP` enum?\n- The `MissionDialog.STAMP_STEP` enum represents the different steps/states of the stamp animation, such as \"STAMP_BEGIN\", \"STAMP_OUT\", \"STAMP_IN\", \"STAMP_WAIT\", and \"STAMP_NONE\".\n\n3. What is the purpose of the `Update` method?\n- The `Update` method is responsible for updating the stamp animation based on the current step and the elapsed time. It returns a boolean value indicating whether the animation is still ongoing.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Stamp.md"}}],["462",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\SteamManager.cs)\n\nThe code provided is a part of the Brick-Force project and is contained in a file called \"SteamManager.cs\". This code is responsible for managing the integration of the Steam API into the project.\n\nThe `SteamManager` class is a MonoBehaviour, which means it can be attached to a GameObject in the Unity engine. It has a private boolean variable `_loaded` and a private static instance of the `SteamManager` class called `_instance`.\n\nThe purpose of the `SteamManager` class is to provide a way to access the SteamManager instance and to handle the initialization and shutdown of the Steam API. The `Instance` property is a getter that returns the `_instance` variable. If the `_instance` variable is null, it tries to find an existing instance of the `SteamManager` class using `Object.FindObjectOfType`. If it fails to find an instance, it logs an error message. This ensures that there is only one instance of the `SteamManager` class in the project.\n\nThe `Awake` method is called when the script instance is being loaded. It uses `Object.DontDestroyOnLoad` to prevent the `SteamManager` object from being destroyed when a new scene is loaded.\n\nThe `Start` and `Update` methods are empty and do not contain any code.\n\nThe `OnDestroy` method is called when the script instance is being destroyed. If the `_loaded` variable is true, it calls `SteamDLL.SteamAPI_Shutdown()` to shut down the Steam API and sets `_loaded` to false.\n\nThe `LoadSteamDll` method is responsible for loading the Steam DLL and initializing the Steam API. It first checks if the `UseSteam` property in the `BuildOption.Instance.Props` object is false. If it is false, it returns true, indicating that the Steam DLL is not needed. If `_loaded` is false, it calls `SteamDLL.SteamAPI_Init()` to initialize the Steam API and sets `_loaded` to true. It then returns the value of `_loaded`.\n\nIn summary, the `SteamManager` class provides a way to access the SteamManager instance and handles the initialization and shutdown of the Steam API. It ensures that there is only one instance of the `SteamManager` class in the project and provides a method to load the Steam DLL and initialize the Steam API. This code is an essential part of the Brick-Force project as it allows for integration with the Steam platform.\n## Questions: \n 1. What is the purpose of the SteamManager class?\n- The SteamManager class is responsible for managing the Steam API and initializing it.\n\n2. What is the purpose of the Awake() method?\n- The Awake() method is called when the script instance is being loaded, and it ensures that the SteamManager object is not destroyed when loading a new scene.\n\n3. What is the purpose of the LoadSteamDll() method?\n- The LoadSteamDll() method is used to load the Steam DLL and initialize the Steam API, if the BuildOption allows it.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\SteamManager.md"}}],["463",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\StreamedLevelLoadibilityChecker.cs)\n\nThe `StreamedLevelLoadibilityChecker` class is a script that checks if a set of levels can be streamed and loaded in the game. It is a part of the larger Brick-Force project and is used to ensure that the required levels are available and ready to be loaded.\n\nThe class has three public variables: `shouldBeStreamedLevel`, `outputDebugMessage`, and two empty methods `Start()` and `Update()`. \n\nThe `shouldBeStreamedLevel` variable is an array of strings that represents the names of the levels that should be streamed and loaded. These level names are provided by the developer and can be set in the Unity editor. \n\nThe `outputDebugMessage` variable is a boolean flag that determines whether debug messages should be displayed. If set to `true`, the script will log an error message using `Debug.LogError()` if a level cannot be loaded. \n\nThe `CanStreamedLevelBeLoaded()` method is the main functionality of the script. It iterates through each level name in the `shouldBeStreamedLevel` array and checks if the level can be loaded using `Application.CanStreamedLevelBeLoaded()` method. If a level cannot be loaded, it logs an error message if `outputDebugMessage` is set to `true` and returns `false`. If all levels can be loaded, it returns `true`.\n\nThis script can be used in the larger Brick-Force project to ensure that all required levels are available and ready to be loaded before the game progresses. It can be attached to a game object in the Unity editor and the required level names can be set in the `shouldBeStreamedLevel` array. The script can then be called at the appropriate time to check if the levels are ready to be loaded. If any level is missing or not yet streamed, an error message will be logged and the game can handle this situation accordingly.\n\nExample usage:\n\n```csharp\nStreamedLevelLoadibilityChecker levelChecker;\n\nvoid Start()\n{\n    levelChecker = GetComponent<StreamedLevelLoadibilityChecker>();\n    if (levelChecker.CanStreamedLevelBeLoaded())\n    {\n        // Load the levels\n    }\n    else\n    {\n        // Handle the error\n    }\n}\n```\n\nIn this example, the `CanStreamedLevelBeLoaded()` method is called to check if the levels are ready to be loaded. If they are, the levels can be loaded. Otherwise, an error is handled.\n## Questions: \n 1. **What is the purpose of the `shouldBeStreamedLevel` array?**\nThe `shouldBeStreamedLevel` array is used to store the names of the levels that should be streamed. \n\n2. **What does the `CanStreamedLevelBeLoaded` method do?**\nThe `CanStreamedLevelBeLoaded` method checks if all the levels in the `shouldBeStreamedLevel` array can be loaded. If any level cannot be loaded, it returns false. \n\n3. **What is the purpose of the `outputDebugMessage` variable?**\nThe `outputDebugMessage` variable determines whether or not debug messages should be printed when a level cannot be streamed.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\StreamedLevelLoadibilityChecker.md"}}],["464",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\StringMgr.cs)\n\nThe `StringMgr` class is responsible for managing and loading string data used in the Brick-Force project. It provides methods to load string data from either a web server or the local file system, and allows for updating and retrieving string values based on a given key.\n\nThe `StringMgr` class contains a private variable `_dicString`, which is an array of dictionaries. Each dictionary in the array represents a different language option, with a total of 12 language options available. The dictionaries store the string values, with the key being the string identifier and the value being the actual string.\n\nThe `Load` method is used to load the string data. If the project is running in a web player, the `LoadFromWWW` coroutine is started, which downloads the string data from a specified URL. If the project is not running in a web player, the `LoadFromLocalFileSystem` method is called, which loads the string data from a local file.\n\nThe `ParseData` method is responsible for parsing the loaded string data and populating the `_dicString` dictionaries. It creates a new dictionary for each language option and adds the string values to the corresponding dictionary.\n\nThe `UpdateStrings` method is used to update the string values for a given key in multiple languages. It calls the `UpdateString` method for each language option, passing in the key, language option, and new string value.\n\nThe `Get` methods are used to retrieve string values based on a given key. The `Get` method without any additional parameters returns the string value for the current language option. The `Get` method with a default value parameter returns the string value for the current language option, or the default value if the key is not found. The `Get` method with a language option parameter returns the string value for the specified language option.\n\nOverall, the `StringMgr` class provides a centralized way to manage and access string data in the Brick-Force project. It allows for loading string data from different sources, updating string values, and retrieving string values based on a given key and language option.\n## Questions: \n **Question 1:** What is the purpose of the `LoadFromWWW()` method and how does it work?\n- The `LoadFromWWW()` method is responsible for downloading a file from a specified URL and parsing its data. It uses the `WWW` class to make the request and the `CSVLoader` class to read and parse the data.\n\n**Question 2:** How are the string values stored and accessed in the code?\n- The string values are stored in a multidimensional dictionary called `_dicString`. Each dictionary within the array represents a different language option. The strings can be accessed using the `Get()` method, which takes a key and returns the corresponding value from the dictionary based on the current language option.\n\n**Question 3:** What is the purpose of the `UpdateStrings()` method and how is it used?\n- The `UpdateStrings()` method is used to update the string values for a specific key in multiple languages. It takes the key and the corresponding values for each language as parameters and updates the `_dicString` dictionary accordingly. This method is likely used for localization purposes, allowing the developer to easily update and manage the string values for different languages.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\StringMgr.md"}}],["465",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Stroking.cs)\n\nThe code provided defines a class called `Stroking`. This class is internal, which means it can only be accessed within the same assembly. The purpose of this class is to store and manage a single variable called `deltaTime`, which is of type `float`.\n\nThe `deltaTime` variable represents the time difference between two consecutive frames in a game or animation. It is commonly used in game development to calculate the speed of objects or to synchronize animations. By storing the time difference in this variable, it can be easily accessed and used throughout the codebase.\n\nThe `Stroking` class has a constructor method, which is called when an instance of the class is created. The constructor initializes the `deltaTime` variable to 0.0 by default. This ensures that the variable has a valid initial value before it is used in any calculations.\n\nHere is an example of how this class could be used in the larger project:\n\n```csharp\n// Create an instance of the Stroking class\nStroking stroking = new Stroking();\n\n// Update the deltaTime value based on the time difference between frames\nstroking.deltaTime = CalculateDeltaTime();\n\n// Use the deltaTime value to move an object\nfloat speed = 10f; // arbitrary speed value\nfloat distance = speed * stroking.deltaTime;\nMoveObject(distance);\n```\n\nIn this example, the `Stroking` class is used to calculate the time difference between frames and use it to move an object. The `CalculateDeltaTime` function would be responsible for calculating the time difference, and the `MoveObject` function would use the `deltaTime` value to determine the distance the object should move.\n\nOverall, the `Stroking` class provides a convenient way to store and manage the `deltaTime` value, which is essential for time-based calculations in game development or animation.\n## Questions: \n 1. **What is the purpose of the `Stroking` class?**\nThe purpose of the `Stroking` class is not clear from the provided code. It would be helpful to know what functionality or behavior this class is intended to provide.\n\n2. **Why is the `deltaTime` variable public?**\nThe code declares the `deltaTime` variable as public, which allows it to be accessed and modified from outside the class. It would be useful to understand the reasoning behind this design decision.\n\n3. **Why is the `deltaTime` variable initialized to 0f in the constructor?**\nThe code initializes the `deltaTime` variable to 0f in the constructor of the `Stroking` class. It would be interesting to know why this specific value is chosen and what significance it holds in the context of the class's functionality.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Stroking.md"}}],["466",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\SuggestBanishDialog.cs)\n\nThe code provided is a class called \"SuggestBanishDialog\" that extends the \"Dialog\" class. This class represents a dialog box that allows the user to suggest banishing a player from the game. The purpose of this code is to handle the functionality and behavior of the banish dialog box.\n\nThe class contains various public variables that represent UI elements such as image lists, label lists, buttons, toggles, and scroll views. These variables are used to reference and manipulate these UI elements in the dialog box.\n\nThe \"Start\" method is overridden from the base \"Dialog\" class and is called when the dialog box is first created. In this method, the \"id\" variable is set to a specific value to identify this dialog box. The \"listBases\" property of the \"scrollNameList\" scroll view is populated with the UI elements that should be included in the scroll view.\n\nThe \"OnPopup\" method is also overridden from the base \"Dialog\" class and is called when the dialog box is shown. In this method, the position and size of the dialog box are calculated and stored in the \"rc\" variable.\n\nThe \"InitDialog\" method is used to initialize the state of the toggles in the dialog box. It sets all the toggles to false.\n\nThe \"Update\" method is overridden from the base \"Dialog\" class but is left empty in this implementation. This method can be used to update the state of the dialog box during runtime.\n\nThe \"DoDialog\" method is the main method that handles the behavior of the dialog box. It is called repeatedly while the dialog box is open. In this method, the UI elements are drawn on the screen using the \"Draw\" method of each element. The \"scrollNameList\" scroll view is populated with data from an array of \"BrickManDesc\" objects. The selected item in the scroll view is determined by the \"currentSelect\" variable. If the \"backButton\" is clicked, the \"currentSelect\" variable is updated. If the \"exit\" button is clicked or the escape key is pressed, the method returns true to indicate that the dialog box should be closed. If the \"ok\" button is clicked, the \"GetReason\" method is called to determine the reason for banishing the selected player. If the reason is 0, a message is shown to the user. Otherwise, a network request is sent to initiate the banishing process.\n\nThe \"GetReason\" method is used to calculate the reason for banishing the player based on the state of the toggles. It uses bitwise OR operations to combine the reasons into a single integer value.\n\nOverall, this code represents the functionality of a banish dialog box in the larger Brick-Force project. It handles the UI elements, user interactions, and network requests related to suggesting a banishment of a player.\n## Questions: \n 1. What is the purpose of the `SuggestBanishDialog` class?\n- The `SuggestBanishDialog` class is a subclass of `Dialog` and represents a dialog window for suggesting banishment of a player in the game.\n\n2. What is the significance of the `InitDialog()` method?\n- The `InitDialog()` method is used to reset the state of the toggle buttons (`curse`, `hackTool`, `noManner`, `etc`) to false when the dialog is initialized.\n\n3. What does the `GetReason()` method do?\n- The `GetReason()` method returns an integer value based on the state of the toggle buttons (`curse`, `hackTool`, `noManner`, `etc`). The integer value represents the selected reasons for suggesting banishment.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\SuggestBanishDialog.md"}}],["467",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Sure2UnpackDialog.cs)\n\nThe code provided is a class called \"Sure2UnpackDialog\" that extends the \"Dialog\" class. This class is responsible for displaying a dialog box that prompts the user to confirm whether they want to unpack a bundle. \n\nThe class contains several private variables that define the positions and sizes of various UI elements within the dialog box. These variables include the positions of the title, the outline of the dialog box, the \"Yes\" and \"No\" buttons, and the icon representing the bundle. \n\nThe class also has two public variables, \"item\" and \"tBundle\", which are used to store information about the item and the bundle that the user wants to unpack. These variables are set using the \"InitDialog\" method.\n\nThe class overrides several methods from the base \"Dialog\" class. The \"Start\" method sets the ID of the dialog box. The \"OnPopup\" method calculates the position of the dialog box based on the size of the screen. \n\nThe main functionality of the class is implemented in the \"DoDialog\" method. This method is responsible for rendering the UI elements of the dialog box and handling user interactions. \n\nInside the \"DoDialog\" method, the code first sets the GUI skin to a custom skin. It then draws the outline of the dialog box and the title using the \"LabelUtil.TextOut\" method. The icon representing the bundle is drawn using the \"TextureUtil.DrawTexture\" method.\n\nNext, the code calls the \"Unpack\" method of the \"BundleManager\" class to unpack the bundle. The method returns an array of \"BundleUnit\" objects, which contain information about the items in the bundle. The code iterates over this array and displays the name and quantity of each item using the \"LabelUtil.TextOut\" method.\n\nIf the application is in a specific build mode (either \"Netmarble\" or \"Developer\"), additional UI elements are rendered. These elements include a label with a purchase policy message and a button that opens a URL when clicked.\n\nFinally, the code renders the \"Yes\" and \"No\" buttons. If the \"Yes\" button is clicked, a network request is sent to unpack the bundle. If the \"No\" button is clicked, the dialog box is closed.\n\nOverall, this class is used to display a dialog box that allows the user to confirm whether they want to unpack a bundle. It provides a visual representation of the bundle and its contents, and handles user interactions to initiate the unpacking process.\n## Questions: \n 1. What is the purpose of the `InitDialog` method and how is it used?\n- The `InitDialog` method is used to initialize the `item` and `tBundle` variables. It is likely used to set the values of these variables before the `DoDialog` method is called.\n\n2. What is the significance of the `BundleUnit` array and how is it used?\n- The `BundleUnit` array is used to store the results of unpacking a bundle. It is iterated over in the `DoDialog` method to display information about each item in the bundle.\n\n3. What is the purpose of the `OnPopup` method and when is it called?\n- The `OnPopup` method is used to set the position and size of the dialog window. It is likely called when the dialog is being displayed to ensure it is properly positioned on the screen.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Sure2UnpackDialog.md"}}],["468",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\SystemInform.cs)\n\nThe `SystemInform` class in the Brick-Force project is responsible for displaying system messages to the user. It manages two types of system messages: messages that appear at the top of the screen and messages that appear in the center of the screen.\n\nThe class contains several private variables, including `crdLT` and `crdRB`, which define the coordinates of the top-left and bottom-right corners of the message display area. The `rcSysMessage` and `rcSysMessageCenter` variables are `Rect` objects that represent the position and size of the message display areas. The `statusMessageQ` and `statusMessageCenterQ` variables are queues that store the system messages to be displayed. The `SysMessage` and `SysMessageCenter` variables store the currently displayed messages. The `bReceived` and `bReceivedCenter` variables indicate whether new messages have been received. The `statusDelta` and `statusDeltaCenter` variables keep track of the time elapsed since the last message was displayed.\n\nThe class also has a reference to the `Lobby` class and a static instance of the `SystemInform` class.\n\nThe `Awake` method is called when the object is created and ensures that the object is not destroyed when a new scene is loaded.\n\nThe `SetToolbarSize` method sets the width of the toolbar.\n\nThe `SetCoord` method sets the position and size of the message display areas based on the width of the toolbar.\n\nThe `AddMessage` method adds a new message to the top message queue. If there are no messages currently being displayed, the `bReceived` flag is set to true.\n\nThe `AddMessageCenter` method adds a new message to the center message queue. If there is no message currently being displayed in the center, the `bReceivedCenter` flag is set to true. If there is already a message being displayed, the `statusDeltaCenter` variable is set to a value that will cause the message to be displayed for a shorter duration.\n\nThe `Start` method initializes the message queues.\n\nThe `VerifyLobby` method finds the `Lobby` object in the scene.\n\nThe `Update` method is called every frame. It updates the state of the system messages. If a new message has been received, it sets the appropriate variables and dequeues the message from the queue. If there is a message being displayed and it has not reached the end of the display area, it updates the `statusDelta` variable. If there is a message being displayed in the center and it has reached the end of its display duration, it dequeues the message from the queue.\n\nThe `OnGUI` method is responsible for rendering the system messages on the screen. It sets the GUI skin and depth, and then checks if there is a message to be displayed in the center. If there is, it calculates the position and opacity of the message based on the `statusDeltaCenter` variable and renders the message using different colors. Finally, it resets the GUI settings.\n\nThe `DoScrollMessage` method is responsible for rendering the top system message. It calculates the position of the message based on the `statusDelta` variable and the width of the toolbar, and then renders the message using the `LabelUtil.TextOut` method.\n\nIn summary, the `SystemInform` class manages the display of system messages in the Brick-Force project. It provides methods to add messages to the top and center message queues, and updates and renders the messages on the screen. The class also has a reference to the `Lobby` class and a static instance of itself for easy access.\n## Questions: \n 1. What is the purpose of the `SystemInform` class?\n- The `SystemInform` class is responsible for displaying system messages in the game.\n\n2. What is the significance of the `SysMessage` and `SysMessageCenter` variables?\n- The `SysMessage` variable stores the current system message to be displayed on the screen, while the `SysMessageCenter` variable stores the current center system message to be displayed on the screen.\n\n3. What is the purpose of the `DoScrollMessage` method?\n- The `DoScrollMessage` method is responsible for scrolling and displaying the system message on the screen.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\SystemInform.md"}}],["469",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\SystemMessage.cs)\n\nThe code provided is a class called \"SystemMessage\" that is used to display system messages in a graphical user interface (GUI) in the Brick-Force project. The purpose of this class is to handle the management and display of system messages in two different areas of the screen.\n\nThe class has several private variables, including coordinates for the top-left and bottom-right corners of the GUI elements, as well as rectangles to define the size and position of the GUI elements. It also has queues to store the system messages that need to be displayed.\n\nThe class has several public properties and methods that can be used to interact with the system messages. The \"SetCoord\" method is used to set the coordinates of the GUI elements based on the width of the screen. The \"Start\" method initializes the queues for the system messages. The \"AddMessage\" and \"AddMessageCenter\" methods are used to add new system messages to the respective queues.\n\nThe \"OnGUI\" method is responsible for rendering the GUI elements and displaying the system messages. It uses the \"GUI\" class to begin and end a GUI group for the first GUI element. It then checks if there is a system message to display and calculates the length of the message if needed. It then creates a rectangle to define the position of the message and uses the \"GUI.Label\" method to display the message.\n\nThe \"Update\" method is called every frame and is responsible for updating the system messages. It checks if there is a new system message to display and updates the status delta and length calculation variables accordingly. It also checks if the system message has reached the end of the GUI element and if so, it removes the message from the queue and resets the status delta and length calculation variables.\n\nOverall, this class provides a way to manage and display system messages in the Brick-Force project. It allows for the addition of new messages, as well as the automatic scrolling and removal of messages when they reach the end of the GUI element.\n## Questions: \n 1. What is the purpose of the `SystemMessage` class?\n- The `SystemMessage` class is used to display system messages on the screen.\n\n2. What is the significance of the `SysMsg` property?\n- The `SysMsg` property returns the value of the `SysMessageCenter` field, which is the system message displayed at the center of the screen.\n\n3. What is the purpose of the `Update` method?\n- The `Update` method is responsible for updating the system messages and their display on the screen based on certain conditions and time intervals.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\SystemMessage.md"}}],["470",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\SystemMsg.cs)\n\nThe code provided is for a class called `SystemMsg` in the Brick-Force project. This class is responsible for displaying system messages on the screen during gameplay. \n\nThe `SystemMsg` class has several private variables, including `clrText` and `clrOutline` which represent the color of the text and its outline, `offset` which determines the vertical position of the message, `message` which stores the actual message to be displayed, `lap` which keeps track of the time elapsed since the message was shown, and `valid` which indicates whether the message is still valid and should be displayed.\n\nThe class also has public variables for the starting and ending colors of the text and outline, as well as the starting and ending colors of the line. These variables can be modified to change the appearance of the system message.\n\nThe class has methods for updating the message, calculating the position and size of the message rectangle, adjusting the position of the message, showing the message on the screen, and resetting the message to its initial state.\n\nThe `Update()` method is called every frame and updates the message's appearance and position based on the elapsed time. If the elapsed time exceeds the `lapTime` plus the `fadeoutTime`, the message is marked as invalid and will no longer be displayed. Otherwise, the colors of the text and outline are interpolated between the starting and ending colors based on the elapsed time, and the offset is incremented to create a scrolling effect.\n\nThe `CalcRC()` method calculates the position and size of the message rectangle based on the size of the message text. It uses the `LabelUtil.CalcSize()` method to determine the size of the text and sets the `rc` variable accordingly. The height of the message is also returned as an output parameter.\n\nThe `Adjust()` method is used to adjust the position of the message rectangle by a specified height. This is useful when multiple messages need to be displayed one after another.\n\nThe `Show()` method is responsible for actually displaying the message on the screen. It uses the `GUI.Label()` method to draw the text and outline with the appropriate colors and position.\n\nThe `Reset()` method resets the message to its initial state, setting the colors, offset, and lap time back to their starting values.\n\nOverall, this class provides a way to display system messages on the screen during gameplay, with customizable appearance and scrolling effects. It can be used in the larger Brick-Force project to show important information or notifications to the player.\n## Questions: \n 1. What is the purpose of the `SystemMsg` class?\n- The `SystemMsg` class is used to display messages on the screen with fading effects.\n\n2. How does the fading effect work?\n- The fading effect is achieved by gradually changing the color and position of the message over time.\n\n3. How is the position of the message calculated?\n- The position of the message is calculated using the `CalcRC` method, which takes into account the size of the message and the screen dimensions.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\SystemMsg.md"}}],["471",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\SystemMsgManager.cs)\n\nThe `SystemMsgManager` class is responsible for managing system messages in the Brick-Force project. It handles the display and management of messages that appear on the screen during gameplay.\n\nThe class contains a private queue `qMessages` that stores instances of the `SystemMsg` class. The `SystemMsg` class represents a single system message and contains information such as the message text and the duration it should be displayed.\n\nThe `SystemMsgManager` class is a singleton, meaning that there can only be one instance of it in the project. The `Instance` property provides access to this singleton instance. If there is no existing instance, it tries to find one using `Object.FindObjectOfType`. If it fails to find an instance, it logs an error message.\n\nThe `Awake` method initializes the `qMessages` queue and ensures that the `SystemMsgManager` object is not destroyed when a new scene is loaded using `Object.DontDestroyOnLoad`.\n\nThe `OnGUI` method is called every frame and is responsible for displaying the system messages on the screen. It retrieves the GUI skin from the `GUISkinFinder` class and sets the GUI depth. It then iterates over the messages in the queue and adjusts their position based on the height of the previous message. Finally, it calls the `Show` method on each message to display it on the screen.\n\nThe `ShowMessage` methods are used to add new system messages to the queue. The first method takes only the message text as a parameter and adds a new `SystemMsg` instance with a default duration of 5 seconds. The second method allows specifying a custom duration for the message.\n\nThe `Update` method is called every frame and updates each message in the queue by calling their `Update` method. It also removes any messages from the queue that have expired and are no longer valid.\n\nIn summary, the `SystemMsgManager` class manages the display and management of system messages in the Brick-Force project. It provides methods to add new messages to the queue and handles their display on the screen. This class is an important component of the user interface system in the larger project.\n## Questions: \n 1. What is the purpose of the `SystemMsgManager` class?\n- The `SystemMsgManager` class manages a queue of system messages and displays them on the GUI.\n\n2. What is the significance of the `guiDepth` variable?\n- The `guiDepth` variable determines the depth at which the system messages will be displayed on the GUI.\n\n3. What is the purpose of the `ShowMessage` methods?\n- The `ShowMessage` methods are used to add system messages to the queue, with an optional time parameter to control how long the message will be displayed.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\SystemMsgManager.md"}}],["472",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TAccessory.cs)\n\nThe code provided is a class called `TAccessory` that extends another class called `TItem`. This class represents an accessory item in the larger project called Brick-Force. \n\nThe purpose of this code is to define and manage the properties and behavior of accessory items in the game. It contains various variables and methods that are used to store and manipulate data related to accessories.\n\nThe class has several properties, including `prefab` (a reference to the accessory's game object), `bone` (the bone that the accessory is attached to), `functionMask` (a bitmask representing the functions of the accessory), `functionFactor` (a factor that affects the accessory's function), and `armor` (the armor value of the accessory).\n\nThe constructor of the class takes in various parameters to initialize the properties of the accessory. It sets the values of the properties based on the provided arguments. For example, it sets the `armor` property to the value of the `_armor` parameter, and the `prefab` property to the value of the `itemPrefab` parameter.\n\nThe class also has two methods: `resetArmor` and `safeArmor`. The `resetArmor` method takes in an integer value and sets the `armor` property to that value. It also updates the `ah_armor` array and other related variables.\n\nThe `safeArmor` method checks if the current `armor` value matches the value stored in the `ah_armor` array. If they don't match, it calls the `Application.Quit()` method, which quits the application.\n\nOverall, this code provides the necessary functionality to define and manage accessory items in the Brick-Force project. It allows for the creation, modification, and validation of accessory items in the game.\n## Questions: \n 1. What is the purpose of the `TAccessory` class and how does it relate to the `TItem` class? \n- The `TAccessory` class is a subclass of the `TItem` class and represents an accessory item in the game. It adds additional properties and methods specific to accessories.\n\n2. What is the significance of the `ah_armor` array and how is it used in the code? \n- The `ah_armor` array is an integer array with a length of 5. It is used to store armor values for the accessory item. The index of the array is calculated based on the length of the accessory's name, and the armor value is stored at that index.\n\n3. What is the purpose of the `safeArmor` method and what does it do? \n- The `safeArmor` method compares the stored armor value in the `ah_armor` array with the current armor value of the accessory. If they are not equal, it calls `Application.Quit()` to quit the application. This suggests that the method is used for checking the integrity of the armor value.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TAccessory.md"}}],["473",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TakeAwayAll.cs)\n\nThe code provided is a class called `TakeAwayAll` that extends the `ScriptCmd` class. This class is likely a part of a larger project called Brick-Force and is used to define a specific command or action that can be executed within the project.\n\nThe purpose of this code is to provide a command called \"TakeAwayAll\" that can be used in the Brick-Force project. The `GetDescription()` method returns a string description of the command, which in this case is simply \"TakeAwayAll\". The `GetIconIndex()` method returns an integer index that represents the icon associated with this command, with a value of 7 in this case.\n\nThe `GetDefaultDescription()` method is a static method that returns a default description for the command, which is \"takeawayall\". This method is likely used as a fallback in case the `GetDescription()` method is not overridden or returns null.\n\nThe `GetName()` method returns the name of the command, which is also \"TakeAwayAll\". This method is likely used to identify and reference the command within the project.\n\nOverall, this code defines a command called \"TakeAwayAll\" that can be used in the Brick-Force project. It provides methods to retrieve the description, icon index, default description, and name of the command. This class can be used to create instances of the command and execute it within the larger project.\n\nExample usage:\n\n```csharp\nTakeAwayAll command = new TakeAwayAll();\nstring description = command.GetDescription(); // \"TakeAwayAll\"\nint iconIndex = command.GetIconIndex(); // 7\nstring defaultDescription = TakeAwayAll.GetDefaultDescription(); // \"takeawayall\"\nstring name = command.GetName(); // \"TakeAwayAll\"\n```\n## Questions: \n 1. **What is the purpose of this code?**\nThe smart developer might want to know what functionality or behavior this code is implementing.\n\n2. **What does the `ScriptCmd` class do?**\nThe smart developer might want to understand the role and responsibilities of the `ScriptCmd` class and how it relates to the `TakeAwayAll` class.\n\n3. **What is the significance of the `GetIconIndex()` method?**\nThe smart developer might be curious about the purpose and usage of the `GetIconIndex()` method and how it is used within the codebase.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TakeAwayAll.md"}}],["474",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TBuff.cs)\n\nThe code provided defines a class called `TBuff`. This class represents a buff or power-up in the larger Brick-Force project. \n\nThe `TBuff` class has several private variables: `index`, `isPoint`, `isXp`, `isLuck`, and `factor`. These variables are used to store information about the buff. \n\nThe class also has several public properties: `Index`, `IsPoint`, `IsXp`, `IsLuck`, and `Factor`. These properties provide read-only access to the private variables. \n\nThe `Index` property returns the value of the `index` variable. The `IsPoint`, `IsXp`, and `IsLuck` properties return the values of the corresponding boolean variables. The `Factor` property returns the value of the `factor` variable. \n\nAdditionally, the class has three public methods: `PointRatio`, `XpRatio`, and `Luck`. These methods calculate and return the ratio of the buff's factor value as a percentage. \n\nThe `PointRatio` method returns the ratio of the buff's factor value multiplied by 100 if the `isPoint` variable is true. Otherwise, it returns 0. \n\nThe `XpRatio` method returns the ratio of the buff's factor value multiplied by 100 if the `isXp` variable is true. Otherwise, it returns 0. \n\nThe `Luck` method returns the ratio of the buff's factor value multiplied by 100 if the `isLuck` variable is true. Otherwise, it returns 0. \n\nThe `TBuff` class also has a constructor that takes in five parameters: `_index`, `_isPoint`, `_isXp`, `_isLuck`, and `_factor`. These parameters are used to initialize the private variables of the class. \n\nOverall, this code provides a way to create and manage buffs or power-ups in the Brick-Force project. The `TBuff` class allows for the creation of different types of buffs with different properties, such as point buffs, XP buffs, and luck buffs. The class also provides methods to calculate the ratio of the buff's factor value as a percentage. This code can be used in the larger project to implement various gameplay mechanics related to buffs and power-ups. \n\nExample usage:\n\n```\n// Create a point buff with an index of 1, a factor of 0.5, and enable the point effect\nTBuff pointBuff = new TBuff(1, true, false, false, 0.5f);\n\n// Get the index of the buff\nint buffIndex = pointBuff.Index;\n\n// Check if the buff has a point effect\nbool hasPointEffect = pointBuff.IsPoint;\n\n// Get the point ratio of the buff\nint pointRatio = pointBuff.PointRatio;\n```\n## Questions: \n 1. What is the purpose of the `TBuff` class?\n- The `TBuff` class represents a buff in the game and stores information about its index, whether it affects points, XP, or luck, and the factor by which it affects these attributes.\n\n2. What is the significance of the `Index`, `IsPoint`, `IsXp`, `IsLuck`, and `Factor` properties?\n- The `Index` property returns the index of the buff. The `IsPoint`, `IsXp`, and `IsLuck` properties indicate whether the buff affects points, XP, or luck, respectively. The `Factor` property returns the factor by which the buff affects the attribute.\n\n3. What do the `PointRatio`, `XpRatio`, and `Luck` properties represent?\n- The `PointRatio`, `XpRatio`, and `Luck` properties calculate and return the ratio of the factor to 100 for points, XP, and luck, respectively.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TBuff.md"}}],["475",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TBundle.cs)\n\nThe code provided is a class called `TBundle` that inherits from another class called `TItem`. This class is used to create bundle items in the larger Brick-Force project. \n\nThe `TBundle` class has a constructor that takes in several parameters including `itemCode`, `itemName`, `itemIcon`, `ct`, `_isAmount`, `itemComment`, `_season`, and `starRate`. These parameters are used to initialize the properties of the `TBundle` object.\n\nThe constructor calls the base class constructor (`TItem`) passing in some of the parameters along with additional values. The base class constructor initializes the properties inherited from `TItem` and sets their values based on the provided parameters. \n\nThe `TBundle` class also has a property called `IsAmount` which is set to the value of the `_isAmount` parameter passed into the constructor. This property is used to determine if the bundle item has a specific amount associated with it.\n\nThe `season` property is also set to the value of the `_season` parameter passed into the constructor. This property is used to determine the season of the bundle item.\n\nOverall, this code is responsible for creating bundle items in the Brick-Force project. It sets the properties of the bundle item based on the provided parameters and inherits properties from the `TItem` class. This class can be used to create different types of bundle items with specific properties such as item code, name, icon, amount, season, and star rate. \n\nExample usage:\n\n```csharp\nTexture2D itemIcon = LoadItemIcon(\"bundle_icon.png\");\nTBundle bundleItem = new TBundle(\"B001\", \"Bundle Item\", itemIcon, 10, true, \"This is a bundle item\", 1, 5);\n```\n\nIn the example above, a new `TBundle` object is created with the specified parameters. The `itemIcon` is loaded from a file called \"bundle_icon.png\". The bundle item has an item code of \"B001\", a name of \"Bundle Item\", an icon of `itemIcon`, a count of 10, an `IsAmount` value of true, a comment of \"This is a bundle item\", a season of 1, and a star rate of 5.\n## Questions: \n 1. What is the purpose of the TBundle class and how does it relate to the TItem class?\n- The TBundle class is a subclass of the TItem class and represents a bundle item. It inherits properties and methods from the TItem class and adds additional properties specific to bundles.\n\n2. What is the significance of the \"IsAmount\" and \"season\" variables in the TBundle constructor?\n- The \"IsAmount\" variable determines if the bundle item has a specific amount or if it is unlimited. The \"season\" variable represents the season of the bundle item.\n\n3. What is the purpose of the \"starRate\" parameter in the TBundle constructor?\n- The \"starRate\" parameter represents the rating or quality of the bundle item.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TBundle.md"}}],["476",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TCGateDialog.cs)\n\nThe code provided is a class called TCGateDialog, which is a subclass of the Dialog class. This class is used to create a dialog window for the Brick-Force project. The purpose of this dialog window is to display information about treasure chests and allow the player to interact with them.\n\nThe TCGateDialog class contains a number of public fields that represent different UI elements such as images, labels, and buttons. These fields are used to reference the corresponding UI elements in the Unity scene.\n\nThe Start() method is overridden from the base Dialog class and is called when the dialog window is first created. In this method, the id of the dialog is set, and the list of UI elements for the scrollBoard and scrollRare is populated.\n\nThe OnPopup() method is also overridden from the base Dialog class and is called when the dialog window is opened. In this method, the position of the dialog window is set, and the images for the myToken and token UI elements are set to the current token mark.\n\nThe OnClose() method is overridden from the base Dialog class and is called when the dialog window is closed. In this method, a network request is sent to close the treasure chest.\n\nThe InitDialog() method is a custom method that is not used in the provided code.\n\nThe DoDialog() method is the main method of the TCGateDialog class and is called every frame to update the dialog window. In this method, the GUI skin is set, and the UI elements are drawn on the screen. The method also handles user input, such as button clicks and double clicks, and sends network requests based on the user's actions.\n\nThe DoTooltip() method is a helper method that is called to display tooltips when the user hovers over certain UI elements. The method checks if the tooltip has changed and plays a sound effect if it has. It then calculates the position and size of the tooltip window and draws the tooltip text and labels.\n\nOverall, the TCGateDialog class is responsible for creating and updating a dialog window that displays information about treasure chests and allows the player to interact with them. It handles user input and sends network requests to open and close treasure chests.\n## Questions: \n 1. What is the purpose of the `TCGateDialog` class?\n- The `TCGateDialog` class is a subclass of the `Dialog` class and represents a dialog window in the game related to the Treasure Chest Gate feature.\n\n2. What are the variables `imgList` and `labelList` used for?\n- `imgList` and `labelList` are instances of `UIImageList` and `UILabelList` respectively, and they are used to display lists of images and labels in the dialog window.\n\n3. What is the purpose of the `DoDialog` method?\n- The `DoDialog` method is responsible for updating and rendering the contents of the dialog window, including handling user input and interactions with the UI elements.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TCGateDialog.md"}}],["477",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TCharacter.cs)\n\nThe code provided is a class called `TCharacter` that inherits from another class called `TItem`. This class represents a character in the larger Brick-Force project. \n\nThe `TCharacter` class has several properties, including `prefix`, `gender`, and `mainMat`. These properties store information about the character's prefix, gender, and main material. \n\nThe class also has a constructor that takes in several parameters, including `itemCode`, `itemName`, `itemIcon`, `ct`, `itemTakeoffable`, `_gender`, `_prefix`, `itemComment`, `tb`, `itemDiscomposable`, `itemBpBackCode`, `_season`, `itemMainMat`, `_grp1`, `_grp2`, `_grp3`, and `starRate`. These parameters are used to initialize the properties of the `TCharacter` object.\n\nThe constructor calls the base constructor of the `TItem` class, passing in some of the parameters and additional values. This allows the `TCharacter` object to inherit properties and methods from the `TItem` class.\n\nOverall, this code defines the `TCharacter` class and its constructor, which is used to create instances of characters in the Brick-Force project. This class is likely used in other parts of the project to represent and manipulate characters. \n\nExample usage:\n\n```csharp\n// Create a new TCharacter object\nTCharacter character = new TCharacter(\"001\", \"John\", iconTexture, 1, true, \"male\", \"Mr.\", \"This is a comment\", buff, false, \"bpBackCode\", 1, mainMaterial, \"grp1\", \"grp2\", \"grp3\", 5);\n```\n## Questions: \n 1. What is the purpose of the `TCharacter` class and how does it relate to the `TItem` class? \n- The `TCharacter` class is a subclass of the `TItem` class and represents a character item in the game. It inherits properties and methods from the `TItem` class and adds additional properties specific to characters.\n\n2. What is the significance of the `prefix` and `gender` properties in the `TCharacter` class? \n- The `prefix` property represents a prefix for the character's name, and the `gender` property represents the gender of the character. These properties are used to customize the character's appearance or behavior.\n\n3. What is the purpose of the `mainMat` property and how is it used in the `TCharacter` class? \n- The `mainMat` property represents the main material used for rendering the character. It is likely used to apply a specific texture or visual effect to the character's model.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TCharacter.md"}}],["478",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TCNetmarbleDialog.cs)\n\nThe code provided is a class called `TCNetmarbleDialog` that extends the `Dialog` class. This class is part of the larger Brick-Force project and is responsible for managing a specific dialog window in the game.\n\nThe purpose of this code is to handle the functionality and behavior of the TCNetmarble dialog window. This dialog window is used to display information and options related to purchasing tokens and coins in the game.\n\nThe `TCNetmarbleDialog` class contains various public fields that represent different UI elements in the dialog window, such as buttons, labels, and images. These fields are assigned in the Unity editor and are used to reference and manipulate these UI elements in the code.\n\nThe `InitDialog` method is called to initialize the dialog window with the current status of the TCNetmarble feature. It sets the text and visibility of various UI elements based on the current status. For example, if the coin price is 0, it hides the coin-related UI elements.\n\nThe `DoDialog` method is responsible for rendering and updating the dialog window. It draws all the UI elements, handles user input, and updates the visual effects. It also checks if the user clicks on the token button or coin button and performs the corresponding actions, such as displaying a confirmation dialog or showing a prize animation.\n\nThe `ReceivePrize` method is called when the player receives a prize from the TCNetmarble feature. It initializes and displays a roulette effect dialog to show the prize animation and details.\n\nOverall, this code manages the functionality and behavior of the TCNetmarble dialog window in the Brick-Force game. It handles UI rendering, user input, and prize animations related to purchasing tokens and coins.\n## Questions: \n 1. What is the purpose of the `InitDialog` method?\n- The `InitDialog` method initializes the dialog by setting the appropriate values for the UI elements based on the current status of the `TcStatus` object.\n\n2. What is the purpose of the `DoMain` method?\n- The `DoMain` method handles the main functionality of the dialog, including drawing the UI elements, handling button clicks, and updating the dialog state.\n\n3. What is the purpose of the `ReceivePrize` method?\n- The `ReceivePrize` method is called when a prize is received. It initializes the `rouletteEffect` dialog with the received prize information.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TCNetmarbleDialog.md"}}],["479",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TCostume.cs)\n\nThe code provided is a class called `TCostume` that extends another class called `TItem`. This class represents a costume item in the larger project called Brick-Force. \n\nThe purpose of this code is to define the properties and behavior of a costume item. The costume item has various attributes such as a main color, auxiliary color, mark, function mask, function factor, materials for the main, auxiliary, and mark, armor value, and other variables. \n\nThe constructor of the `TCostume` class is responsible for initializing these attributes based on the provided parameters. It also initializes an array called `ah_armor` with a length of 5, sets the `ah_key` variable to the length of the `itemName`, and calculates the `ah_index` as the remainder of `ah_key` divided by 5. It then sets the value of `ah_armor[ah_index]` as the `armor` value shifted left by 1. \n\nThe `resetArmor` method allows the `armor` value to be reset to a new value. It performs the same calculations as the constructor to update the `ah_armor` array with the new `armor` value. \n\nThe `safeArmor` method checks if the `armor` value has been modified since it was last set. If it has, it calls `Application.Quit()` to exit the application. This method is likely used for security purposes to prevent unauthorized modifications to the armor value. \n\nOverall, this code provides the necessary functionality to create and manage costume items in the Brick-Force project. It allows for the customization of various attributes of the costume and ensures the integrity of the armor value.\n## Questions: \n 1. What is the purpose of the `TCostume` class and how does it relate to the `TItem` class? \n- The `TCostume` class is a subclass of the `TItem` class and represents a costume item in the game. It adds additional properties and methods specific to costumes.\n\n2. What is the purpose of the `ah_armor` array and how is it used? \n- The `ah_armor` array is an array of integers with a length of 5. It is used to store armor values for the costume. The index of the array is calculated based on the length of the costume's name, and the armor value is stored at that index.\n\n3. What does the `safeArmor` method do and why does it call `Application.Quit()`? \n- The `safeArmor` method compares the stored armor value in the `ah_armor` array with the current armor value of the costume. If they are not equal, it calls `Application.Quit()` to quit the application. This suggests that the method is used for checking the integrity of the armor value and taking action if it has been tampered with.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TCostume.md"}}],["480",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TcPrize.cs)\n\nThe code provided is a class called `TcPrize` that is part of the larger Brick-Force project. This class represents a prize that can be won in the game. It contains various properties and methods to handle the prize's attributes and behavior.\n\nThe `TcPrize` class has the following properties:\n- `tItem`: An instance of the `TItem` class, which represents the item that the prize is.\n- `amount`: An integer representing the quantity of the prize.\n- `deltaTime`: A float value that keeps track of the time passed since the prize was created.\n- `flickering`: A float value that keeps track of the time passed since the last flickering effect.\n- `outline`: A boolean value that determines whether the prize should be outlined or not.\n- `isRareItem`: A boolean value indicating whether the prize is a rare item or not.\n\nThe class also has the following read-only properties:\n- `Icon`: Returns the current icon of the prize, obtained from the `CurIcon()` method of the `tItem` object.\n- `Name`: Returns the name of the prize, obtained from the `Name` property of the `tItem` object.\n- `Code`: Returns the code of the prize, obtained from the `code` property of the `tItem` object.\n- `AmountString`: Returns a string representation of the prize's amount, obtained from the `GetOptionStringByOption()` method of the `tItem` object.\n- `IsRareItem`: Returns the value of the `isRareItem` property.\n\nThe `TcPrize` class has a constructor that takes a `Flying` object as a parameter. This constructor initializes the `tItem`, `amount`, `isRareItem`, `deltaTime`, `flickering`, and `outline` properties based on the values of the `Flying` object.\n\nThe class also has an `Update()` method that is called periodically to update the state of the prize. In this method, the `deltaTime` and `flickering` properties are incremented by the elapsed time since the last update. If the `flickering` value exceeds 0.3f, the `outline` property is toggled, creating a flickering effect.\n\nOverall, this code provides a representation of a prize in the Brick-Force game. It allows for accessing and manipulating various properties of the prize, such as its icon, name, code, amount, and rarity. The `Update()` method is responsible for updating the state of the prize, including the flickering effect. This class can be used in the larger project to handle and display prizes won by players.\n## Questions: \n 1. **What does this code do?**\nThis code defines a class called `TcPrize` that represents a prize in the game. It has properties for the prize's icon, name, code, amount, rarity, and whether it needs an outline. It also has a constructor and an update method.\n\n2. **What is the purpose of the `Update` method?**\nThe `Update` method is called to update the `deltaTime` and `flickering` variables. It checks if `flickering` has exceeded a certain threshold and toggles the `outline` variable accordingly.\n\n3. **What is the significance of the `Icon` property?**\nThe `Icon` property returns the current icon of the `tItem` object, which represents the prize. This property can be used to display the icon of the prize in the game's user interface.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TcPrize.md"}}],["481",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TCResultItemDialog.cs)\n\nThe code provided is a class called `TCResultItemDialog` that extends the `Dialog` class. This class represents a dialog box that displays the result of a treasure chest opening in the game. It contains various UI elements such as images, labels, and buttons to display the result and allow the player to interact with the dialog.\n\nThe purpose of this code is to initialize and manage the UI elements of the treasure chest result dialog, as well as handle user input and update the UI elements when necessary.\n\nThe `TCResultItemDialog` class has several public fields that represent the UI elements of the dialog, such as `successRotate`, `successEffect`, `background`, `imgList`, `labelList`, `exit`, `ok`, `itemName`, `itemBackNomal`, `itemBackRare`, `itemIcon`, `itemTime`, `property`, and `itemExplain`. These fields are assigned in the Unity editor and are used to reference the corresponding UI elements in the scene.\n\nThe class also has private fields `winner`, `nickname`, and `code`, which store information about the treasure chest result, such as the winner's ID, nickname, and the code of the item obtained from the chest.\n\nThe `Start` method is overridden from the base `Dialog` class and is called when the dialog is first created. It sets the ID of the dialog and initializes some properties of the `property` field.\n\nThe `OnPopup` method is called when the dialog is shown on the screen. It calculates the position of the dialog based on the screen size.\n\nThe `InitDialog` method is used to initialize the dialog with the result of a treasure chest opening. It takes parameters such as the sequence number, index, code, amount, and a boolean indicating whether a key was used. It retrieves the corresponding `TItem` object from a `TItemManager` instance based on the provided code and updates the UI elements with the information from the `TItem` object.\n\nThe `Update` method is called every frame and updates the `successRotate` and `successEffect` UI elements.\n\nThe `DoDialog` method is called to draw and handle user input for the dialog. It draws all the UI elements and checks for button clicks or keyboard input. If any of these events occur, it returns `true` to indicate that the dialog should be closed.\n\nThe `SetRareText` method is used to set the `winner`, `nickname`, and `code` fields with the provided values. This method is likely called when the treasure chest result is determined.\n\nThe `RareTextAdd` method is called to add a chat message to the game's main chat window when a rare item is obtained from the treasure chest. It retrieves the `TItem` object based on the stored `code` field and constructs a chat message string. It then finds the main game object and sends a message to it to add the chat message to the chat window.\n\nIn summary, this code represents a dialog box that displays the result of a treasure chest opening in the game. It manages the UI elements of the dialog, handles user input, and updates the UI elements based on the treasure chest result. It also adds a chat message to the game's main chat window when a rare item is obtained.\n## Questions: \n 1. What is the purpose of the `InitDialog` method and how is it used?\n- The `InitDialog` method is used to initialize the dialog with specific values. It takes parameters such as `seq`, `index`, `code`, `amount`, and `wasKey` to set the properties of the dialog based on the provided values.\n\n2. What is the purpose of the `DoDialog` method and what does it return?\n- The `DoDialog` method is responsible for drawing and updating the dialog. It returns a boolean value indicating whether the dialog should be closed or not.\n\n3. What is the purpose of the `RareTextAdd` method and when is it called?\n- The `RareTextAdd` method is used to add a rare text message to the chat when a treasure is obtained. It is called after the dialog is initialized and the rare item information is set.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TCResultItemDialog.md"}}],["482",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TcStatus.cs)\n\nThe code provided is a class called `TcStatus` that represents the status of a game feature in the larger Brick-Force project. This class is responsible for storing and updating various properties related to the status of the game feature.\n\nThe class has several private fields, including `seq`, `index`, `max`, `cur`, `key`, `maxKey`, `coinPrice`, `tokenPrice`, and `alias`. These fields represent different aspects of the game feature's status, such as the current sequence, index, maximum value, current value, key value, maximum key value, coin price, token price, and an alias.\n\nThe class also has a public property for each of these fields, allowing external code to access their values. For example, the `Seq` property returns the value of the `seq` field.\n\nThe class has a constructor that takes in values for all the fields and initializes them accordingly. There are also two `Update` methods that allow for updating the `cur`, `key`, and `maxKey` fields, or all the fields at once.\n\nThe class provides several methods for retrieving information about the status. The `GetTitle` method returns the alias of the game feature. The `GetDescription` method returns a string representation of the current value and maximum value. The `GetKeyDescription` method returns a string representation of the key value and maximum key value.\n\nThe class also provides methods for managing a list of `TcTItem` objects. The `ClearExpectations` method clears the list of items. The `AddExpectations` method adds an item to the list. The `GetRareArray` method returns an array of items from the list that are marked as keys. The `GetNormalArray` method returns an array of items from the list that are not marked as keys. The `GetArraySorted` method returns an array of items from the list, sorted so that the key items come first. The `TcTItemToArray` method returns the list of items as an array. The `GetFirstRare` method returns the first item from the list that is marked as a key.\n\nOverall, this class provides a way to store and manage the status of a game feature in the Brick-Force project. It allows for updating the status, retrieving information about the status, and managing a list of related items.\n## Questions: \n 1. What is the purpose of the `TcStatus` class?\n- The `TcStatus` class represents the status of a game feature in the Brick-Force project, including information such as sequence, index, maximum value, current value, key value, coin price, token price, and alias.\n\n2. What is the significance of the `Update` methods in the `TcStatus` class?\n- The `Update` methods allow for updating the current value, key value, and maximum key value of the `TcStatus` object.\n\n3. What is the purpose of the `GetArraySorted` method in the `TcStatus` class?\n- The `GetArraySorted` method returns an array of `TcTItem` objects sorted by whether they are keys or not. Keys are placed before non-key items in the sorted array.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TcStatus.md"}}],["483",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TcTItem.cs)\n\nThe code provided is a struct named `TcTItem` that represents an item in the Brick-Force project. This struct has four fields: `code`, `isKey`, `opt`, and a method `IsNull()`. \n\nThe `code` field is a string that represents the code of the item. The `isKey` field is a boolean value that indicates whether the item is a key or not. The `opt` field is an integer that represents some optional value associated with the item. \n\nThe `IsNull()` method is used to check if the `code` field is empty or null. It returns a boolean value indicating whether the `code` field is empty or not. If the length of the `code` field is less than or equal to 0, the method returns `true`, indicating that the item is null. Otherwise, it returns `false`, indicating that the item is not null.\n\nThis struct can be used in the larger Brick-Force project to represent and manipulate items. It provides a way to store information about an item, such as its code, whether it is a key or not, and an optional value. The `IsNull()` method can be used to check if an item is null before performing any operations on it.\n\nHere is an example of how this struct can be used in the Brick-Force project:\n\n```csharp\nTcTItem item = new TcTItem();\nitem.code = \"ABC123\";\nitem.isKey = true;\nitem.opt = 10;\n\nif (!item.IsNull())\n{\n    // Perform operations on the item\n    Console.WriteLine(\"Item code: \" + item.code);\n    Console.WriteLine(\"Is key: \" + item.isKey);\n    Console.WriteLine(\"Optional value: \" + item.opt);\n}\nelse\n{\n    Console.WriteLine(\"Item is null\");\n}\n```\n\nIn this example, we create a new `TcTItem` object and set its fields. We then check if the item is null using the `IsNull()` method and perform operations on the item if it is not null. If the item is null, we print a message indicating that the item is null.\n## Questions: \n 1. **What is the purpose of the `TcTItem` struct?**\nThe `TcTItem` struct appears to represent an item in the Brick-Force project. It contains properties such as `code`, `isKey`, and `opt`, which likely hold information about the item.\n\n2. **What does the `IsNull()` method do?**\nThe `IsNull()` method checks if the `code` property of the `TcTItem` struct is empty or null. It returns a boolean value indicating whether the `code` is null or empty.\n\n3. **What are the possible values for the `opt` property?**\nWithout further information, it is unclear what the possible values for the `opt` property are. It would be helpful to know the range or specific values that can be assigned to this property.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TcTItem.md"}}],["484",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TeamMatch.cs)\n\nThe `TeamMatch` class is a script that is part of the larger Brick-Force project. This script is responsible for managing the gameplay mechanics and functionality related to team matches in the game.\n\nThe `InitializeFirstPerson` method is called to initialize the first-person perspective for the player. It retrieves the weapon options chosen by the player and initializes the player's equipment accordingly. It also retrieves the `EquipCoordinator` component attached to the player's game object and initializes it with the chosen weapon options. Additionally, it retrieves the `LocalController` component attached to the player's game object.\n\nThe `OnLoadComplete` method is called when the game finishes loading. It first loads the train manager and then retrieves the spawner for the player's team from the `BrickManager` instance. If a spawner is found, it spawns the player at the spawner's position and rotation. Otherwise, it spawns the player at a random spawn position with a random rotation. It then checks if the player has enabled the battle guide dialog and if it hasn't been shown before. If both conditions are met, it shows the battle guide dialog.\n\nThe `Start` method is called when the game starts. It clears all dropped weapons, applies the audio source settings, and disables the flashbang effect. It then calls the `InitializeFirstPerson` method to initialize the first-person perspective. It retrieves the `BattleChat` component attached to the game object and initializes it. It also calls the `OnStart` method of the `BrickManManager` instance and sets up the camera for visual effects optimization.\n\nThe `StartLoad` method is called to start loading the game. It first collects garbage to free up memory. It then creates a new `UserMap` instance and tries to load the current map from the `RoomManager` instance. If the map is successfully loaded, it sets the `userMap` property of the `BrickManager` instance to the loaded map. Otherwise, it sets the `userMap` property to a new empty `UserMap` instance and sends a cache brick request to the server.\n\nThe `ResetGameStuff` method is called to reset various game-related data and components. It resets the game stuff for the wanted manager, the player's info manager, and the train manager. It also resets the game stuff for all brick men in the `BrickManManager` instance.\n\nThe `Awake` method is empty and does not contain any code.\n\nThe `OnDisable` method is called when the script is disabled. If the game is still loading a level, it resets the game stuff, unlocks the cursor, and clears the `BrickManager` instance.\n\nThe `OnGUI` method is called to handle the graphical user interface. It sets the GUI skin to the one retrieved from the `GUISkinFinder` instance.\n\nThe `Update` method is called every frame to update the game logic. It first checks if the connecting component is showing, and if it is, it sets a flag to true. It then locks the cursor if certain conditions are met (the game is not loading a level, the player is not chatting, there are no modal dialogs, and the connecting component is not showing). \n\nIf the `delayLoad` flag is true, it increments the `deltaTime` variable by the time since the last frame. If `deltaTime` exceeds 1 second, it sets `delayLoad` to false and calls the `StartLoad` method.\n\nIf `delayLoad` is false and the game is not loading a level, it checks for various input conditions. If the player presses the main menu button and certain conditions are met, it shows the menu dialog. If the player presses the help button and certain conditions are met, it shows the help window dialog. It also updates the flashbang effect.\n\nOverall, this script manages the initialization, loading, resetting, and updating of game-related components and functionality for team matches in the Brick-Force game.\n## Questions: \n 1. What is the purpose of the `InitializeFirstPerson()` method?\n- The `InitializeFirstPerson()` method is responsible for initializing the equipment and local controller components for the player character in the first-person perspective.\n\n2. What does the `OnLoadComplete()` method do?\n- The `OnLoadComplete()` method loads the train manager, gets the spawner for the player's team, and spawns the player character at the appropriate position and rotation.\n\n3. What is the significance of the `StartLoad()` method?\n- The `StartLoad()` method is responsible for loading the user map for the current game session. If the map fails to load, it sends a request to the server to cache the brick data.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TeamMatch.md"}}],["485",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TeamMatchConfig.cs)\n\nThe code provided is a class called \"TeamMatchConfig\" that is used in the larger Brick-Force project. This class is responsible for configuring and displaying various options and information related to a team match in the game.\n\nThe class contains several private variables that define the positions and dimensions of various GUI elements, such as thumbnails, labels, and buttons. These variables are used to position and size the GUI elements on the screen.\n\nThe class also contains an array of strings called \"weaponOptions\" that stores different weapon options for the team match. These options are used to display the selected weapon option for the match.\n\nThe class has a public method called \"OnGUI\" that is responsible for rendering the GUI elements on the screen. This method is called every frame and is responsible for updating and displaying the GUI elements based on the current state of the game.\n\nInside the \"OnGUI\" method, the class retrieves the thumbnail image for the current map from the \"RegMapManager\" and displays it on the screen. It also checks if the map is a new map or has certain tags (such as \"glory\", \"medal\", or \"gold ribbon\") and displays corresponding icons next to the thumbnail.\n\nThe method also displays the alias and mode of the current room, as well as various options related to the team match, such as time limit, kill count, weapon option, break-in option, team balance option, item drop option, and wanted option. These options are displayed as labels on the screen.\n\nThe class also handles tooltip functionality. If the user hovers over a GUI element and a tooltip message is available, the class displays the tooltip message in a separate window.\n\nOverall, the \"TeamMatchConfig\" class is responsible for configuring and displaying various options and information related to a team match in the Brick-Force game. It handles rendering GUI elements, retrieving and displaying map thumbnails, displaying icons based on map tags, and handling tooltip functionality.\n## Questions: \n 1. What is the purpose of the `Start()` method in the `TeamMatchConfig` class?\n- The purpose of the `Start()` method is not clear from the provided code. It seems to be an empty method that does not have any functionality.\n\n2. What is the significance of the `tooltipMessage` variable and how is it used?\n- The `tooltipMessage` variable is used to store the tooltip message from the GUI. It is used in the `ShowTooltip()` method to display the tooltip message in a GUI window.\n\n3. What is the purpose of the `DoOption()` method and how is it used?\n- The `DoOption()` method is used to display various options related to a room, such as time limit, kill count, weapon options, etc. It is called in the `OnGUI()` method to render these options on the GUI.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TeamMatchConfig.md"}}],["486",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TeamMatchScore.cs)\n\nThe `TeamMatchScore` class is a script that is used to display the scores and goals in a team match in the game. It is a part of the larger Brick-Force project. \n\nThe purpose of this code is to update and display the scores of the red and blue teams, as well as the number of goals achieved in the match. It also handles the flickering effect for the team scores. \n\nThe class has several public variables that can be set in the Unity editor, such as the GUI depth, fonts for the scores and goals, and the background texture for the score display. It also has private variables to store the current scores of the red and blue teams. \n\nThe `Start` method is called when the script is initialized. It sets the initial scores of both teams to 0 and sends a request to the server to get the current team scores if the player is currently breaking into a room. \n\nThe `OnTeamScore` method is called when the server sends an update on the team scores. It updates the scores of the red and blue teams and adjusts the scale of the score fonts to create a visual effect. \n\nThe `OnGUI` method is called to draw the GUI elements on the screen. It checks if the GUI is enabled and if there are no modal dialogs currently open. It then sets the GUI skin and depth, and begins a GUI group to draw the score display. It draws the background texture, the flickering effect for the current team, and the scores and goals using the specified fonts and coordinates. \n\nThe `Update` method is called every frame to update the flickering effect for the team scores. \n\nOverall, this code provides a visual representation of the team scores and goals in a team match. It is used to enhance the gameplay experience and provide feedback to the players.\n## Questions: \n 1. What is the purpose of the `OnTeamScore` method?\n- The `OnTeamScore` method is responsible for updating the red and blue team scores and adjusting the scale of the corresponding score fonts.\n\n2. What is the purpose of the `Start` method?\n- The `Start` method initializes the red and blue team scores to 0 and sends a team score request if the player is currently breaking into a room.\n\n3. What is the purpose of the `OnGUI` method?\n- The `OnGUI` method is responsible for rendering the team match score GUI, including the background, team scores, and kill count.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TeamMatchScore.md"}}],["487",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TeamScore.cs)\n\nThe code provided defines a class called `TeamScore` that represents the scores of two teams in a game. The class has two public integer variables, `redTeam` and `blueTeam`, which store the scores of the red team and the blue team, respectively. The class also has a constructor that takes two integer parameters, `red` and `blue`, and assigns them to the `redTeam` and `blueTeam` variables.\n\nThis code is likely part of a larger project that involves tracking and managing the scores of teams in a game. The `TeamScore` class provides a convenient way to store and access the scores of the red and blue teams. By creating an instance of the `TeamScore` class and setting the scores using the constructor, the scores can be easily accessed and manipulated throughout the project.\n\nHere is an example of how this code might be used in the larger project:\n\n```java\n// Create a new instance of the TeamScore class with initial scores of 0 for both teams\nTeamScore teamScore = new TeamScore(0, 0);\n\n// Update the scores of the red and blue teams\nteamScore.redTeam += 10;\nteamScore.blueTeam += 5;\n\n// Print the scores of the red and blue teams\nSystem.out.println(\"Red Team Score: \" + teamScore.redTeam);\nSystem.out.println(\"Blue Team Score: \" + teamScore.blueTeam);\n```\n\nIn this example, a new instance of the `TeamScore` class is created with initial scores of 0 for both teams. The scores are then updated by adding 10 to the red team's score and 5 to the blue team's score. Finally, the scores are printed to the console.\n\nOverall, this code provides a simple and reusable way to store and manage the scores of two teams in a game. It can be easily integrated into the larger project to track and display the scores to the users.\n## Questions: \n 1. **What is the purpose of the `TeamScore` class?**\nThe `TeamScore` class is used to store the scores of the red and blue teams in a game.\n\n2. **What are the data types of the `redTeam` and `blueTeam` variables?**\nThe `redTeam` and `blueTeam` variables are of type `int`, indicating that they store integer values.\n\n3. **What is the purpose of the `TeamScore` constructor?**\nThe `TeamScore` constructor is used to initialize the `redTeam` and `blueTeam` variables with the provided values.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TeamScore.md"}}],["488",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TextureUtil.cs)\n\nThe code provided is a part of the Brick-Force project and is contained in the `TextureUtil` class. This class provides several static methods for drawing textures on the GUI in Unity.\n\nThe `DrawTexture` method is overloaded and can be used in different scenarios depending on the parameters passed. \n\nThe first `DrawTexture` method takes a `Rect` position and a `Texture` image as parameters. It draws the texture at the specified position on the GUI. Before drawing, it checks if the GUI is enabled. If it is not enabled, it reduces the alpha value of the color to make the texture appear faded.\n\nThe second `DrawTexture` method is similar to the first one, but it also takes a `ScaleMode` parameter. This parameter determines how the texture should be scaled when drawn. The rest of the method is the same as the first one.\n\nThe third `DrawTexture` method is similar to the second one, but it also takes a `bool` parameter `alphaBlend`. This parameter determines whether the texture should be alpha blended when drawn. The rest of the method is the same as the second one.\n\nThe fourth `DrawTexture` method takes a `Rect` position, a `Texture` image, and a `Rect` source rectangle as parameters. It draws a portion of the texture specified by the source rectangle at the specified position on the GUI. This method is only executed when the current event type is `Repaint`. If the GUI is enabled, it simply draws the texture using the `Graphics.DrawTexture` method. If the GUI is not enabled, it reduces the alpha value of the color to make the texture appear faded before drawing.\n\nThese methods can be used in the larger Brick-Force project to draw textures on the GUI. They provide flexibility in terms of positioning, scaling, alpha blending, and drawing specific portions of a texture. Developers can use these methods to create visually appealing GUI elements such as buttons, panels, or backgrounds by drawing textures on the screen.\n## Questions: \n 1. What does the `DrawTexture` method do?\n- The `DrawTexture` method is used to draw a texture on the GUI at a specified position with various options such as scale mode, alpha blending, and source rectangle.\n\n2. What is the purpose of the `Color` variable and how is it used?\n- The `Color` variable is used to store the current GUI color. It is used to modify the alpha value of the color when GUI is disabled, making the texture appear faded.\n\n3. What is the significance of the `Event.current.type.Equals(EventType.Repaint)` condition?\n- The `Event.current.type.Equals(EventType.Repaint)` condition ensures that the texture is only drawn when the GUI is being repainted, preventing unnecessary drawing during other events.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TextureUtil.md"}}],["489",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ThumbnailDownloader.cs)\n\nThe `ThumbnailDownloader` class is responsible for managing the downloading and processing of thumbnails in the Brick-Force project. It contains methods for enqueueing thumbnail requests, dequeuing completed requests, and stacking received thumbnail data.\n\nThe class uses three main data structures: `dicRegMap`, `dicUserMap`, and `queue`. `dicRegMap` and `dicUserMap` are dictionaries that store `ThumbnailRequest` objects, with the request ID as the key. These dictionaries are used to keep track of the requests that have been enqueued. `queue` is a queue that stores the `ThumbnailRequest` objects in the order they were enqueued.\n\nThe `Awake()` method is called when the `ThumbnailDownloader` object is created. It initializes the `queue`, `dicRegMap`, and `dicUserMap` data structures, and sets `waitingForResponse` to false. It also ensures that the `ThumbnailDownloader` object is not destroyed when a new scene is loaded.\n\nThe `Update()` method is called every frame. It checks if there is a thumbnail request in the queue and if the `ThumbnailDownloader` is not currently waiting for a response. If both conditions are met, it dequeues the next request from the queue and sends a download request to the `CSNetManager` class. It sets `waitingForResponse` to true to indicate that it is waiting for a response.\n\nThe `Enqueue()` method is used to enqueue a new thumbnail request. It takes a boolean parameter `isUserMap` to indicate whether the request is for a user map or a regular map, and an integer parameter `id` to specify the ID of the map. It checks if the request is already in the corresponding dictionary (`dicUserMap` or `dicRegMap`) and returns if it is. Otherwise, it creates a new `ThumbnailRequest` object and enqueues it in the `queue`. It also adds the request to the corresponding dictionary.\n\nThe `Dequeue()` method is used to dequeue a completed thumbnail request. It takes a boolean parameter `success` to indicate whether the request was successful or not. It dequeues the next request from the `queue` and removes it from the corresponding dictionary (`dicUserMap` or `dicRegMap`) if the request was successful. It sets `waitingForResponse` to false to indicate that it is no longer waiting for a response.\n\nThe `Stack()` method is used to stack received thumbnail data. It takes a byte array `data2` as input. It checks if there is a thumbnail request in the `queue` and if the request's `ThumbnailBuffer` is null. If both conditions are met, it creates a new byte array with the same length as `data2` and copies the data from `data2` to the `ThumbnailBuffer`. If the `ThumbnailBuffer` is not null, it creates a new byte array with the combined length of the existing `ThumbnailBuffer` and `data2`, and copies the data from both arrays to the new `ThumbnailBuffer`.\n\nOverall, the `ThumbnailDownloader` class provides a way to manage and process thumbnail requests in the Brick-Force project. It allows for enqueuing requests, dequeuing completed requests, and stacking received thumbnail data.\n## Questions: \n 1. What is the purpose of the `ThumbnailDownloader` class?\n- The `ThumbnailDownloader` class is responsible for downloading and managing thumbnail images.\n\n2. What is the significance of the `queue` variable?\n- The `queue` variable is used to store thumbnail requests in the order they are received, and the code processes them one by one.\n\n3. What is the purpose of the `Stack` method?\n- The `Stack` method is used to store the downloaded thumbnail image data in the `ThumbnailRequest` object.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ThumbnailDownloader.md"}}],["490",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ThumbnailRequest.cs)\n\nThe code provided is a class called `ThumbnailRequest` that is used to represent a request for a thumbnail image. \n\nThe `ThumbnailRequest` class has the following properties:\n\n- `IsUserMap`: A boolean value that indicates whether the thumbnail is for a user map or not.\n- `Id`: An integer value that represents the ID of the thumbnail.\n- `ThumbnailBuffer`: A byte array that stores the thumbnail image data.\n\nThe class also has a constructor that takes in two parameters: `isUserMap` and `id`. These parameters are used to initialize the `IsUserMap` and `Id` properties respectively. The `ThumbnailBuffer` property is set to `null` initially.\n\nThe purpose of this class is to encapsulate the information needed to request a thumbnail image. It provides a convenient way to pass this information between different parts of the codebase. \n\nFor example, in the larger project, there might be a module responsible for generating and storing thumbnail images. Another module might be responsible for handling user requests for these thumbnails. The `ThumbnailRequest` class can be used to pass the necessary information between these modules.\n\nHere is an example of how this class might be used:\n\n```csharp\n// Create a new ThumbnailRequest object\nThumbnailRequest request = new ThumbnailRequest(true, 123);\n\n// Pass the request to another module for processing\nThumbnailGenerator.GenerateThumbnail(request);\n\n// Retrieve the generated thumbnail from the request object\nbyte[] thumbnail = request.ThumbnailBuffer;\n```\n\nIn this example, a new `ThumbnailRequest` object is created with `IsUserMap` set to `true` and `Id` set to `123`. The `ThumbnailGenerator` module is then called to generate the thumbnail based on the request. Finally, the generated thumbnail can be retrieved from the `ThumbnailBuffer` property of the request object.\n\nOverall, the `ThumbnailRequest` class provides a convenient way to represent and pass around thumbnail image requests in the larger Brick-Force project.\n## Questions: \n 1. **What is the purpose of the `ThumbnailRequest` class?**\nThe `ThumbnailRequest` class is used to represent a request for a thumbnail, which includes information such as whether it is a user map or not, the ID of the map, and the thumbnail buffer.\n\n2. **What is the significance of the `IsUserMap` property?**\nThe `IsUserMap` property is used to indicate whether the thumbnail request is for a user map or not. This property helps in distinguishing between different types of maps.\n\n3. **Why is the `ThumbnailBuffer` initially set to null in the constructor?**\nThe `ThumbnailBuffer` is initially set to null in the constructor to indicate that the thumbnail buffer has not been assigned a value yet. It will be populated with the actual thumbnail data later on.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ThumbnailRequest.md"}}],["491",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TimeLimitedDestroyer.cs)\n\nThe code provided is for a class called \"TimeLimitedDestroyer\" that extends the \"MonoBehaviour\" class from the Unity game engine. This class is responsible for destroying a game object after a certain amount of time has passed.\n\nThe class has two member variables: \"limit\" and \"deltaTime\". The \"limit\" variable is a public float that determines the time limit in seconds before the game object is destroyed. The \"deltaTime\" variable is a private float that keeps track of the time that has passed since the game object was created.\n\nThe class has two methods: \"Start()\" and \"Update()\". The \"Start()\" method is called when the game object is first created and initializes the \"deltaTime\" variable to 0. The \"Update()\" method is called every frame and increments the \"deltaTime\" variable by the time that has passed since the last frame using the \"Time.deltaTime\" property.\n\nInside the \"Update()\" method, there is an if statement that checks if the \"deltaTime\" variable has exceeded the \"limit\" value. If it has, the \"Object.DestroyImmediate()\" method is called to destroy the game object immediately.\n\nThis class can be used in the larger project to create time-limited game objects that need to be destroyed after a certain amount of time. For example, it can be used to create power-ups that disappear after a few seconds or to create temporary obstacles that disappear after a set time. \n\nHere is an example of how this class can be used in a larger project:\n\n```csharp\npublic class PowerUp : MonoBehaviour\n{\n    private TimeLimitedDestroyer destroyer;\n\n    private void Start()\n    {\n        destroyer = gameObject.AddComponent<TimeLimitedDestroyer>();\n        destroyer.limit = 5f; // Destroy the power-up after 5 seconds\n    }\n\n    private void Update()\n    {\n        // Power-up logic\n    }\n}\n```\n\nIn this example, the \"PowerUp\" class adds the \"TimeLimitedDestroyer\" component to the game object and sets the time limit to 5 seconds. After 5 seconds, the power-up game object will be destroyed automatically. The \"Update()\" method can be used to implement the logic for the power-up, such as applying effects to the player when they collect it.\n## Questions: \n 1. **What is the purpose of the `TimeLimitedDestroyer` class?**\nThe `TimeLimitedDestroyer` class is responsible for destroying the game object it is attached to after a certain time limit has passed.\n\n2. **What does the `limit` variable represent?**\nThe `limit` variable represents the time limit in seconds after which the game object will be destroyed.\n\n3. **Why is `Object.DestroyImmediate` used instead of `Object.Destroy`?**\n`Object.DestroyImmediate` is used instead of `Object.Destroy` to immediately destroy the game object without waiting for the end of the frame.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TimeLimitedDestroyer.md"}}],["492",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TimeLimitedParticleDestroyer.cs)\n\nThe code provided is a script called \"TimeLimitedParticleDestroyer\" that is used in the larger Brick-Force project. This script is responsible for destroying particle effects after a certain amount of time has passed.\n\nThe script starts by declaring several variables. \"particleTime\" is a float variable that determines how long the particle effect will be active before it is destroyed. \"lifeTime\" is another float variable that determines the total lifespan of the particle effect. \"particlePhase\" is a boolean variable that keeps track of whether the particle effect is currently active or not. \"deltaTime\" is a float variable that keeps track of the time that has passed since the particle effect started.\n\nIn the \"Start\" method, the \"particlePhase\" variable is set to true and the \"deltaTime\" variable is set to 0. This ensures that the particle effect starts in an active state and the time counter is reset.\n\nIn the \"Update\" method, the \"deltaTime\" variable is incremented by the time that has passed since the last frame using \"Time.deltaTime\". This allows the script to keep track of the total time that has passed since the particle effect started.\n\nThe script then checks if the particle effect is currently active and if the \"particleTime\" has been exceeded. If both conditions are true, the script sets the \"particlePhase\" variable to false and disables the emission of particles by setting the \"minEmission\" and \"maxEmission\" properties of all ParticleEmitter components to 0. This effectively stops the particle effect from emitting any more particles.\n\nFinally, the script checks if the \"lifeTime\" has been exceeded. If it has, the script destroys the game object that the script is attached to using \"Object.DestroyImmediate\".\n\nIn the larger Brick-Force project, this script can be used to control the lifespan of particle effects. By attaching this script to a game object that has particle effects, the effects will automatically be destroyed after a certain amount of time has passed. This can be useful for managing memory and performance by ensuring that particle effects are not active for longer than necessary.\n## Questions: \n 1. What is the purpose of the `particlePhase` variable and how does it affect the behavior of the code?\n- The `particlePhase` variable is used to control whether the particle emission is active or not. When `particlePhase` is true and `deltaTime` exceeds `particleTime`, the particle emission is disabled.\n\n2. What is the significance of the `particleTime` variable and how does it relate to the `deltaTime` variable?\n- The `particleTime` variable determines the duration (in seconds) after which the particle emission will be disabled. It is compared to the `deltaTime` variable to check if enough time has passed to disable the particle emission.\n\n3. What is the purpose of the `lifeTime` variable and how does it affect the code?\n- The `lifeTime` variable determines the duration (in seconds) after which the entire game object containing this script will be destroyed using `Object.DestroyImmediate()`. If `deltaTime` exceeds `lifeTime`, the game object will be destroyed.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TimeLimitedParticleDestroyer.md"}}],["493",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TimeLimitedPoisonDestroyer.cs)\n\nThe `TimeLimitedPoisonDestroyer` class is a script that is used to apply poison damage to objects within a certain radius for a limited amount of time. It is likely used in the larger Brick-Force project to create a gameplay mechanic where certain objects can emit poison and damage nearby entities.\n\nThe class has several public and private variables. The `poisonDamage` variable determines the amount of damage the poison will inflict on the affected entities. The `limit` variable determines the duration of the poison effect. The `deltaTime` and `dtPoison` variables are used to track the elapsed time.\n\nThe `Start` method initializes the `deltaTime` and `dtPoison` variables to 0 and 10 respectively.\n\nThe `Update` method is called every frame. It increments the `dtPoison` variable by the elapsed time since the last frame using `Time.deltaTime`. If `dtPoison` exceeds 1, it calls the `CheckMyself` method to damage the player object and the `CheckMonster` method to damage monsters within a certain radius. After that, `dtPoison` is reset to 0.\n\nThe `deltaTime` variable is also incremented by the elapsed time. If `deltaTime` exceeds the `limit` value, the `base.gameObject` (the object this script is attached to) is destroyed using `Object.DestroyImmediate`.\n\nThe `CheckMyself` method is responsible for damaging the player object. It finds the player object in the scene and retrieves the `LocalController` component attached to it. If the component exists and the distance between the player object and the `boomPos` parameter (the position of the poison emitter) is less than `DamageRadius`, the `GetHit` method of the `LocalController` component is called to apply the poison damage.\n\nThe `CheckBoxmen` and `CheckMonster` methods are similar to `CheckMyself`, but they are used to damage other entities such as non-player characters and monsters. These methods use different utility methods (`ExplosionUtil.CheckBoxmen` and `ExplosionUtil.CheckMon`) to find the entities within the specified radius.\n\nOverall, this script allows for the creation of poison-emitting objects that can damage nearby entities within a certain radius for a limited amount of time. It provides a way to implement a poison mechanic in the game, adding an additional layer of gameplay strategy and challenge.\n## Questions: \n 1. What is the purpose of the `TimeLimitedPoisonDestroyer` class?\n- The purpose of the `TimeLimitedPoisonDestroyer` class is to apply poison damage to certain game objects within a specified time limit and destroy itself after a certain amount of time.\n\n2. What is the significance of the `limit` variable?\n- The `limit` variable determines the amount of time (in seconds) that the `TimeLimitedPoisonDestroyer` object can exist before it is destroyed.\n\n3. What is the purpose of the `CheckMyself`, `CheckBoxmen`, and `CheckMonster` methods?\n- The `CheckMyself` method checks if the `TimeLimitedPoisonDestroyer` object is within a certain distance of the player character and applies poison damage if it is. The `CheckBoxmen` method checks if any non-friendly characters are within a certain distance of the explosion and applies poison damage if they are. The `CheckMonster` method checks if any non-friendly monsters are within a certain distance of the explosion and applies poison damage if they are.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TimeLimitedPoisonDestroyer.md"}}],["494",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Timer.cs)\n\nThe `Timer` class is a script that is used to manage and display a countdown timer in the Brick-Force game. It is responsible for keeping track of the remaining time and updating the timer display accordingly.\n\nThe `Timer` class has several member variables that are used for various purposes. The `guiDepth` variable determines the depth at which the timer GUI is rendered. The `offset` variable specifies the position of the timer GUI on the screen. The `bkgnd` variable holds the background texture for the timer GUI. The `backChange` variable is an instance of the `UIImageSizeChange` class, which is used to animate the background of the timer GUI. The `play` variable keeps track of the number of times the timer has been played. The `playDelta` variable is used to control the frequency at which the timer updates. The `deltaTime` variable is used to track the time elapsed since the last timer update. The `remain` variable holds the remaining time in seconds. The `localController` variable is a reference to the `LocalController` component attached to the player character. The `expandArea` variable determines the size of the expanded area around the timer GUI.\n\nThe `Start` method is called when the script is initialized. It initializes the member variables, finds the player character object, and retrieves the `LocalController` component attached to it. It also sets the position and size of the background image and sets up the animation for the background.\n\nThe `OnGUI` method is called every frame to render the timer GUI. It checks if the GUI is enabled and if there are any active dialogs. It then calculates the minutes and seconds from the remaining time and displays them on the GUI. If the remaining time is less than 11 seconds, the background animation is played and the text color is set to red. Otherwise, the background image is displayed normally and the text color is set to yellow.\n\nThe `Update` method is called every frame to update the timer. It checks if the player is the master of the room, if the player is controllable, and if the brick manager is loaded. If these conditions are met, it updates the `playDelta` variable and sends a network message to update the timer on the server. If the current room type is not explosion or if the bomb is not installed, it updates the `deltaTime` variable and decreases the remaining time. If the remaining time reaches zero, it stops the timer.\n\nThe `OnPlayTime` and `OnTimer` methods are event handlers that are called when the play time and remaining time are received from the server. They update the `play` and `remain` variables if the received values are greater or smaller than the current values, respectively.\n\nIn summary, the `Timer` class is responsible for managing and displaying a countdown timer in the Brick-Force game. It updates the timer every frame, animates the background of the timer GUI, and sends network messages to synchronize the timer with the server. It also handles events related to the play time and remaining time received from the server.\n## Questions: \n 1. What is the purpose of the `Timer` class?\n- The `Timer` class is responsible for managing the countdown timer in the game.\n\n2. What is the significance of the `TimeLimit` property?\n- The `TimeLimit` property allows other classes to get and set the remaining time for the timer.\n\n3. What is the purpose of the `OnGetBack2Spawner` method?\n- The `OnGetBack2Spawner` method is called when the player returns to the spawner. It checks the current room type and updates the remaining time accordingly.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Timer.md"}}],["495",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TimerDefense.cs)\n\nThe `TimerDefense` class is a script that manages the timer functionality for a defense game in the larger Brick-Force project. It is responsible for displaying and updating the remaining time for the game.\n\nThe class has several private variables, including `play`, `deltaTime`, `remain`, `bBigFont`, `remain2`, `BigNumber`, `deltaTimerBigFont`, and `localController`. These variables are used to keep track of the game state and the remaining time.\n\nThe `Start` method is called when the script is initialized. It sets the initial values for the `play` and `remain` variables and finds the \"Me\" game object. It also retrieves the `LocalController` component attached to the \"Me\" game object.\n\nThe `OnGUI` method is responsible for rendering the timer on the screen. It checks if the GUI is enabled and sets the GUI skin and depth. It then calculates the minutes and seconds from the `remain2` variable and checks if the remaining time is less than or equal to 10 seconds. If so, it checks if the current time is different from the `BigNumber` and sets the `bBigFont` flag accordingly. It then uses the `LabelUtil.TextOut` method to display the time on the screen using either the \"BigLabel\" or \"Label\" style, depending on the `bBigFont` flag.\n\nThe `Update` method is called every frame and is responsible for updating the timer. It checks if the player is the master of the room, if the `localController` is not null, and if the `BrickManager` is loaded. If these conditions are met, it increments the `deltaTime` variable by the time since the last frame. If `deltaTime` is greater than 1 second, it updates the remaining time and sends a network request to update the timer on the server. It also checks if the `bBigFont` flag is set and updates it every 0.5 seconds.\n\nThe `OnPlayTime` and `OnTimer` methods are event handlers that are called when the play time or remaining time is updated from the server. They update the `play` and `remain` variables accordingly.\n\nIn summary, the `TimerDefense` class is responsible for managing and displaying the remaining time for a defense game in the Brick-Force project. It updates the timer every second and sends network requests to synchronize the timer with the server. The class also handles rendering the timer on the screen using different styles based on the remaining time.\n## Questions: \n 1. What is the purpose of the `TimeLimit` and `TimeLimit2` properties?\n- The `TimeLimit` property gets and sets the value of the `remain` variable, which represents the remaining time limit. The `TimeLimit2` property gets and sets the value of the `remain2` variable, which represents another type of time limit. \n\n2. What is the significance of the `bBigFont` variable?\n- The `bBigFont` variable is used to determine whether to display the time in a big font or not. It is set to true when the `TimeLimit2` property is set, and is set to false after a certain amount of time has passed.\n\n3. What is the purpose of the `OnPlayTime` and `OnTimer` methods?\n- The `OnPlayTime` method is called when the play time changes, and it updates the `play` variable if the new play time is greater than the current play time. The `OnTimer` method is called when the remaining time changes, and it updates the `remain` and `remain2` variables if the new remaining time is less than the current remaining time.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TimerDefense.md"}}],["496",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TipDef.cs)\n\nThe code provided defines a class called `TipDef` which is marked as `[Serializable]`. This means that objects of this class can be serialized and deserialized, allowing them to be easily stored or transmitted.\n\nThe `TipDef` class has two properties: `target` and `tips`. The `target` property is of type `BuildOption.TARGET`, which suggests that it is an enumeration defined in another part of the codebase. The `tips` property is an array of strings.\n\nThe purpose of this code is to define a data structure that represents a tip definition. The `target` property specifies the target for which the tip is applicable, and the `tips` property contains an array of strings that represent the actual tips.\n\nThis code can be used in the larger project to store and manage tips for different targets. For example, if the project is a game, the `target` property could represent different levels or stages, and the `tips` property could contain helpful hints or instructions for each level.\n\nHere is an example of how this code could be used:\n\n```csharp\n// Create a new tip definition\nTipDef tipDef = new TipDef();\n\n// Set the target\ntipDef.target = BuildOption.TARGET.Level1;\n\n// Set the tips\ntipDef.tips = new string[]\n{\n    \"Collect all the coins to unlock the secret level.\",\n    \"Avoid the red enemies, they are dangerous.\",\n    \"Use power-ups to gain an advantage.\"\n};\n\n// Serialize the tip definition to a file\nstring json = JsonConvert.SerializeObject(tipDef);\nFile.WriteAllText(\"tipDef.json\", json);\n\n// Deserialize the tip definition from a file\nstring jsonFromFile = File.ReadAllText(\"tipDef.json\");\nTipDef deserializedTipDef = JsonConvert.DeserializeObject<TipDef>(jsonFromFile);\n\n// Access the target and tips\nBuildOption.TARGET target = deserializedTipDef.target;\nstring[] tips = deserializedTipDef.tips;\n```\n\nIn this example, a new `TipDef` object is created and populated with a target and a set of tips. The object is then serialized to a JSON file using the `JsonConvert.SerializeObject` method. Later, the JSON file is read and deserialized back into a `TipDef` object using the `JsonConvert.DeserializeObject` method. The target and tips can then be accessed from the deserialized object.\n## Questions: \n 1. **What is the purpose of the `BuildOption.TARGET` enum?**\nThe smart developer might want to know what values are included in the `BuildOption.TARGET` enum and how it is used within the `TipDef` class.\n\n2. **What is the purpose of the `tips` array?**\nThe smart developer might want to know how the `tips` array is used within the `TipDef` class and what kind of information it stores.\n\n3. **What is the purpose of the `[Serializable]` attribute?**\nThe smart developer might want to know why the `TipDef` class is marked as `[Serializable]` and how it affects the behavior of the class when it is serialized or deserialized.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TipDef.md"}}],["497",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Token.cs)\n\nThe code provided is a class definition for a Token in the Brick-Force project. The Token class is marked as Serializable, which means its instances can be converted into a format that can be stored or transmitted and then reconstructed later. This is useful for saving and loading game data or sending data over a network.\n\nThe Token class has three properties: name, mark, and skin. The name property is a string that represents the name of the token. The mark property is a Texture2D object that represents a mark or symbol associated with the token. The skin property is a string that represents the visual appearance or skin of the token.\n\nAdditionally, the Token class has an enum called TYPE, which defines three possible values: TOKEN, NETMARBLE, and TOONY. This enum can be used to categorize or classify tokens based on their type. For example, a token with the type NETMARBLE could represent a special token associated with the Netmarble company.\n\nThe purpose of this code is to define the structure and properties of a Token in the Brick-Force project. This class can be used to create instances of tokens with different names, marks, and skins. These tokens can then be used in various parts of the project, such as gameplay mechanics, user interfaces, or visual effects.\n\nHere is an example of how this code could be used in the larger project:\n\n```csharp\nToken myToken = new Token();\nmyToken.name = \"My Token\";\nmyToken.mark = Resources.Load<Texture2D>(\"TokenMark\");\nmyToken.skin = \"DefaultSkin\";\n\nif (myToken.name == \"My Token\")\n{\n    Debug.Log(\"This is my token!\");\n}\n\nswitch (myToken.TYPE)\n{\n    case Token.TYPE.TOKEN:\n        // Handle token logic\n        break;\n    case Token.TYPE.NETMARBLE:\n        // Handle Netmarble token logic\n        break;\n    case Token.TYPE.TOONY:\n        // Handle Toony token logic\n        break;\n}\n```\n\nIn this example, a new Token instance is created and its properties are set. The name property is checked and a debug message is printed if it matches a specific value. The TYPE enum is used in a switch statement to handle different types of tokens. Depending on the type, different logic can be executed.\n\nOverall, this code provides a foundation for creating and managing tokens in the Brick-Force project, allowing for flexibility and customization in the game.\n## Questions: \n 1. **What is the purpose of the Token class?**\nThe Token class appears to be a data structure for representing different types of tokens in the game. It has properties for the token's name, mark (presumably an image), and skin.\n\n2. **What is the purpose of the TYPE enum within the Token class?**\nThe TYPE enum is used to define different types of tokens. It includes three options: TOKEN, NETMARBLE, and TOONY. It is likely used to categorize or differentiate tokens within the game.\n\n3. **What is the purpose of the Serializable attribute on the Token class?**\nThe Serializable attribute indicates that instances of the Token class can be serialized and deserialized, meaning they can be converted into a format that can be stored or transmitted and then reconstructed back into an object. This suggests that the Token class may need to be saved or transferred in some way within the game.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Token.md"}}],["498",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TokenManager.cs)\n\nThe `TokenManager` class is a part of the Brick-Force project and is responsible for managing tokens. Tokens are objects that represent a specific type of item or currency within the game. This class provides functionality to set and retrieve the current token, as well as get the string representation of the token.\n\nThe class has a private static variable `_instance` which holds the singleton instance of the `TokenManager` class. The `Instance` property is a getter that returns the singleton instance. If the `_instance` variable is null, it tries to find an existing instance of the `TokenManager` class using `Object.FindObjectOfType`. If no instance is found, it logs an error message. This ensures that there is only one instance of the `TokenManager` class throughout the game.\n\nThe `tokens` variable is an array of `Token` objects. Each `Token` object represents a specific type of token in the game. The `currentToken` variable holds the currently selected token.\n\nThe `Awake` method is called when the object is initialized and it prevents the `TokenManager` object from being destroyed when a new scene is loaded using `Object.DontDestroyOnLoad(this)`. This ensures that the `TokenManager` persists across different scenes.\n\nThe `Start` method is called when the object is enabled and it sets the `currentToken` to the token specified by the `BuildOption.Instance.Props.TokenType` value. This allows the game to start with a specific token selected.\n\nThe `SetCurrentToken` method takes a `Token.TYPE` parameter and sets the `currentToken` to the token of that type. This allows the game to change the current token based on user input or game logic.\n\nThe `GetTokenString` method returns the string representation of the `currentToken` by calling `StringMgr.Instance.Get(currentToken.name)`. This suggests that there is a `StringMgr` class that manages string resources and the `Get` method retrieves the string associated with the given token name.\n\nOverall, the `TokenManager` class provides functionality to manage tokens in the game, including setting the current token, retrieving the string representation of the token, and ensuring that there is only one instance of the `TokenManager` class throughout the game.\n## Questions: \n 1. What is the purpose of the TokenManager class?\n- The TokenManager class is responsible for managing tokens and providing access to the current token.\n\n2. How does the TokenManager determine the current token?\n- The current token is determined by the value of `BuildOption.Instance.Props.TokenType`, which is used as an index to access the corresponding token in the `tokens` array.\n\n3. What is the purpose of the `GetTokenString()` method?\n- The `GetTokenString()` method returns the localized string for the name of the current token, using the `StringMgr.Instance.Get()` method.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TokenManager.md"}}],["499",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Tooltip.cs)\n\nThe code provided is a class called \"Tooltip\" that extends the \"Dialog\" class. This class is used to display tooltips for items in the larger Brick-Force project. \n\nThe Tooltip class has several properties and methods that are used to set and display information about an item. \n\nThe class has properties for various textures, such as icons and gauges, that are used to visually represent the item. It also has properties for strings that represent the item code and sequence, as well as a boolean flag to indicate if the tooltip is being used in a shop context. \n\nThe class also has references to other classes and objects, such as an Item object, a TItem object, a Good object, and a TcPrize object. These objects are used to retrieve and store information about the item being displayed in the tooltip. \n\nThe class has several methods that are used to set and display information about the item. For example, the \"SetItem\" method is used to set the item object, and the \"DoDialog\" method is used to display the tooltip. \n\nThe \"DoDialog\" method is the main method of the class and is responsible for displaying the tooltip. It first calculates the total height of the tooltip based on the item information and sets the size of the tooltip accordingly. It then uses various GUI methods to draw and display the item information, such as the item icon, name, comments, price tags, and amount. \n\nOverall, the Tooltip class is an important component of the Brick-Force project as it provides a way to display information about items in a visually appealing and informative manner. It is likely used in various parts of the project, such as in the shop interface or when hovering over items in the game world.\n## Questions: \n **Question 1:** What is the purpose of the `Tooltip` class and how is it used in the project?\n    \n**Answer:** The `Tooltip` class is a subclass of `Dialog` and is used to display tooltips for items in the game. It contains methods for setting the item, calculating the height of the tooltip, and drawing the tooltip on the screen.\n\n**Question 2:** What is the significance of the `ItemCode`, `ItemSeq`, and `IsShop` properties?\n    \n**Answer:** The `ItemCode` property is used to set the code of the item for which the tooltip is being displayed. The `ItemSeq` property is used to set the sequence of the item. The `IsShop` property is used to determine if the tooltip is being displayed in a shop or not.\n\n**Question 3:** What is the purpose of the `DoPriceTag`, `DoAmount`, and `DoCashBack` methods?\n    \n**Answer:** The `DoPriceTag` method is used to display the price of the item in the tooltip, including the price in different currencies. The `DoAmount` method is used to display the amount of the item available for purchase in a shop. The `DoCashBack` method is used to display the cashback amount for the item in a shop.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Tooltip.md"}}],["500",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TooltipBrick.cs)\n\nThe code provided is a class called `TooltipBrick` that extends the `Dialog` class. This class is used to display tooltips for bricks in the larger Brick-Force project. \n\nThe `TooltipBrick` class has several public fields and properties that define the position and content of the tooltip. These include `category`, `crdName`, `crdCategory`, `crdMax`, and `crdComment`. The `category` field is an array of strings representing the different categories that a brick can belong to. The `crdName`, `crdCategory`, `crdMax`, and `crdComment` fields are `Vector2` and `Rect` objects that define the position of the name, category, maximum instances, and comment sections of the tooltip, respectively.\n\nThe class also has a private field `brick` of type `Brick`, which represents the brick that the tooltip is associated with. The `TargetBrick` property provides access to this private field.\n\nThe class has several private methods, including `DoName()`, `DoCategory()`, `DoMax()`, and `DoComment()`, which are responsible for rendering the name, category, maximum instances, and comment sections of the tooltip, respectively. These methods use the `LabelUtil.TextOut()` method to display the text on the screen.\n\nThe `DoDialog()` method overrides the `DoDialog()` method of the `Dialog` class. It checks if the `brick` field is not null and then proceeds to render the tooltip by calling the private methods mentioned above. It also sets the GUI skin to the one obtained from `GUISkinFinder.Instance.GetGUISkin()`.\n\nThe `Start()` method is empty and does not have any functionality.\n\nThe `SetCoord()` method is used to set the position of the tooltip based on the given `pos` parameter. It calculates the size of the tooltip based on the content and adjusts the position if it goes beyond the screen boundaries.\n\nIn summary, the `TooltipBrick` class is responsible for rendering tooltips for bricks in the Brick-Force project. It displays information such as the name, category, maximum instances, and comments of the brick. The class provides methods to set the position of the tooltip and renders the tooltip using the `LabelUtil.TextOut()` method.\n## Questions: \n 1. What is the purpose of the `TooltipBrick` class?\n- The `TooltipBrick` class is a subclass of the `Dialog` class and is used to display information about a specific `Brick` object in a tooltip format.\n\n2. What are the properties and methods of the `TooltipBrick` class?\n- The `TooltipBrick` class has properties such as `category`, `crdName`, `crdCategory`, `crdMax`, and `crdComment` which define the position and size of various elements in the tooltip. It also has methods such as `DoName()`, `DoCategory()`, `DoMax()`, and `DoComment()` which are responsible for rendering the tooltip elements.\n\n3. How is the position of the tooltip determined?\n- The position of the tooltip is determined by the `SetCoord(Vector2 pos)` method. It calculates the size of the tooltip based on the content and adjusts the position to ensure that the tooltip is fully visible on the screen.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TooltipBrick.md"}}],["501",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TosMain.cs)\n\nThe code provided is a script called \"TosMain\" that is part of the larger Brick-Force project. This script is responsible for displaying the Terms of Service (TOS) agreement to the user and handling user interactions with the TOS screen.\n\nThe script starts by declaring various variables, such as `guiDepth`, `languages`, `langTex`, `scrollPosition`, `txtsHeight`, `bAgree`, `isAgreeing`, `texPopupBg`, `crdPopupBg`, `grbWidth`, `crdTosRect`, `crdOkBtn`, `crdCloseBtn`, `crdCurLangBtn`, and `crdAgree`. These variables are used to store information about the GUI elements and their positions on the screen.\n\nThe `Start` method initializes some of the variables, such as setting `bAgree` and `isAgreeing` to false, and populating the `languages` and `langTex` arrays based on the supported languages defined in the `BuildOption` class. If the `ShowAgb` property is true in the `BuildOption` class, the script loads the \"Abg\" asset using the `GlobalVars` class.\n\nThe `OnGUI` method is responsible for rendering the TOS screen. It sets the GUI depth, skin, and enables GUI interaction if there are no modal dialogs present. It then begins the GUI with a box background, draws the TOS popup background texture, and creates a scroll view for the TOS text. The TOS text is rendered using a label style, and the height of the text is calculated and stored in the `txtsHeight` variable. The user can toggle the \"Agree\" checkbox, and if the checkbox is checked, the \"OK\" button becomes enabled. Clicking the \"OK\" button triggers different actions depending on the state of the application. If the `NeedPlayerInfo` property in the `MyInfoManager` class is true, the application loads the \"PlayerInfo\" scene. Otherwise, if `isAgreeing` is false, the script sends a \"CS_I_AGREE_TOS_REQ\" message using the `CSNetManager` class. The script also handles language selection and closing the TOS screen.\n\nThe `Update` method is empty and does not contain any code.\n\nThe `CalculateHeight` method calculates the height of the TOS text by summing up the heights of each line of text using the `CalcHeight` method of the GUI skin's label style. The calculated height is stored in the `txtsHeight` variable.\n\nOverall, this script is responsible for displaying the TOS agreement to the user, allowing them to agree to the terms, and handling user interactions with the TOS screen. It also handles language selection and closing the TOS screen. This script is likely used in the larger Brick-Force project to ensure that users agree to the terms before accessing certain features or content.\n## Questions: \n 1. What is the purpose of the `Start()` method?\n- The `Start()` method initializes variables and loads the AGB (Acceptance of Game Bylaws) if it is set to be shown.\n\n2. What does the `OnGUI()` method do?\n- The `OnGUI()` method is responsible for rendering the graphical user interface (GUI) elements on the screen, including labels, buttons, and textures.\n\n3. What is the purpose of the `CalculateHeight()` method?\n- The `CalculateHeight()` method calculates the height of the text in the AGB (Acceptance of Game Bylaws) and stores it in the `txtsHeight` variable.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TosMain.md"}}],["502",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TouchTrigger.cs)\n\nThe code provided is a class called \"TouchTrigger\" that extends the \"Trigger\" class. This class is responsible for detecting when a game object collides with a trigger zone in the game. \n\nThe main purpose of this code is to check if the game object that enters the trigger zone is a \"LocalController\" and if so, it will execute the \"RunScript()\" method. \n\nThe \"OnTriggerEnter\" method is a Unity callback method that is automatically called when a game object with a collider component enters a trigger collider. In this case, the method takes in a \"Collider\" parameter named \"other\", which represents the collider of the game object that entered the trigger zone.\n\nThe code first checks if the current scene is not the \"MapEditor\" scene and if the \"TouchTrigger\" component is enabled. If these conditions are met, it proceeds to check if the game object that entered the trigger zone has a \"LocalController\" component attached to it. If it does, it calls the \"RunScript()\" method.\n\nHere is an example of how this code might be used in the larger project:\n\nLet's say we have a game where the player controls a character and needs to interact with various objects in the game world. One of these objects is a trigger zone that, when entered by the player's character, should execute a specific script.\n\nTo achieve this, we can attach the \"TouchTrigger\" script to the trigger zone game object in the Unity editor. We would also need to attach a \"LocalController\" script to the player character game object.\n\nWhen the player's character enters the trigger zone, the \"OnTriggerEnter\" method in the \"TouchTrigger\" script will be called. It will check if the entered game object has a \"LocalController\" component, and if so, it will execute the \"RunScript()\" method.\n\nThis allows us to define custom behavior for different trigger zones in the game, such as opening a door, activating a cutscene, or triggering a dialogue sequence.\n\nOverall, the \"TouchTrigger\" class provides a way to detect collisions with trigger zones and execute specific actions based on the type of game object that enters the trigger zone.\n## Questions: \n 1. **What is the purpose of the `Trigger` class that `TouchTrigger` inherits from?**\nThe `Trigger` class is not shown in the provided code, so a smart developer might wonder what functionality or behavior it provides to the `TouchTrigger` class.\n\n2. **What does the `OnTriggerEnter` method do and when is it called?**\nThe `OnTriggerEnter` method is called when a collider enters the trigger area of the game object. A smart developer might want to know what specific actions are taken when this method is called.\n\n3. **What is the purpose of the `RunScript` method and how is it implemented?**\nThe `RunScript` method is called if the `other` collider has a `LocalController` component. A smart developer might want to know what this method does and how it is implemented in order to understand the overall functionality of the code.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TouchTrigger.md"}}],["503",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TrainController.cs)\n\nThe code provided is a class called `TrainController` that is used to control a train object in the larger Brick-Force project. The purpose of this class is to manage the position and rotation of the train object.\n\nThe `TrainController` class has several member variables. The `shooter` variable is an integer that represents the shooter of the train. The `seq` variable is also an integer that represents the sequence of the train. The `start` variable is a Vector3 that stores the initial position of the train. The `rot` variable is a Quaternion that stores the initial rotation of the train. The `train` variable is a reference to the train object in the scene.\n\nThe class has two methods. The `setInit` method takes in a Vector3 `p` and a Quaternion `r` and sets the `start` and `rot` variables to the provided values. This method is used to initialize the position and rotation of the train.\n\nThe `regen` method is used to reset the position and rotation of the train to their initial values. It sets the position of the `train` object to the `start` position and the rotation to the `rot` rotation. This method is likely called when the train needs to be reset to its original state.\n\nOverall, the `TrainController` class provides functionality to manage the position and rotation of a train object in the Brick-Force project. It allows for initializing the train's position and rotation, as well as resetting it to its initial state. This class can be used in conjunction with other classes and scripts to control the behavior of the train in the larger project.\n## Questions: \n 1. **What is the purpose of the `shooter` and `seq` variables?**\nThe `shooter` and `seq` variables are used to store integer values, but without further context it is unclear what these values represent or how they are used in the code.\n\n2. **What is the significance of the `start` and `rot` variables?**\nThe `start` and `rot` variables are of type `Vector3` and `Quaternion` respectively, but it is not clear what these variables are used for or how they are related to the rest of the code.\n\n3. **What is the purpose of the `setInit` and `regen` methods?**\nThe `setInit` and `regen` methods are defined in the `TrainController` class, but without further context it is unclear what these methods do or how they are intended to be used in the code.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TrainController.md"}}],["504",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TrainManager.cs)\n\nThe `TrainManager` class is responsible for managing trains in the Brick-Force project. It contains methods for loading and unloading trains, updating their positions, and handling collisions with other objects.\n\nThe `TrainManager` class is a singleton, meaning that there can only be one instance of it in the project. This is enforced by the private static `_instance` variable and the public static `Instance` property. The `Instance` property ensures that there is always a valid instance of the `TrainManager` class available.\n\nThe `TrainManager` class has a list of `TrainController` objects called `trainObj`. Each `TrainController` object represents a train in the game. The `Load` method is responsible for initializing the `trainObj` list with the trains defined in the user's map. It uses the `BrickManager` class to get the rail spawners from the user's map and creates a new `TrainController` object for each rail spawner. The `trainObj` list is then populated with these `TrainController` objects.\n\nThe `Update` method is called every frame and is responsible for updating the positions of the trains. It first checks if the `trainObj` list is empty using the `IsEmpty` method. If it is not empty, it verifies that the `localController` variable is not null by calling the `VerifyLocalController` method. It then calls the `collideTest` method to check for collisions between the trains and other objects. Finally, it updates the positions of the trains based on the positions of the players controlling them.\n\nThe `SetRotation` method is used to set the rotation of a specific train. It takes an `Id` parameter to identify the train and a `fwd` parameter to set the forward direction of the train.\n\nThe `Unload` method clears the `trainObj` list by calling the `Clear` method if it is not null or empty.\n\nThe `GetTrainCount` method returns the number of trains in the `trainObj` list.\n\nThe `GetController` method returns the `TrainController` object at a specific index in the `trainObj` list.\n\nThe `GetPosition` method returns the position of a specific train based on its index in the `trainObj` list.\n\nThe `GetSequance` method returns the sequence number of a specific train based on its index in the `trainObj` list.\n\nThe `IsEmpty` method checks if the `trainObj` list is empty and returns a boolean value indicating whether it is empty or not.\n\nThe `SetShooter` method is used to set the player controlling a specific train. It takes a `ctrl` parameter to identify the train and a `player` parameter to set the player controlling the train. If the `player` parameter is -1, it means that the train is no longer being controlled by a player and it needs to be regenerated. If the `player` parameter is the same as the player's sequence number, it means that the local player is controlling the train and the `OnGetTrain` method of the `localController` is called.\n\nOverall, the `TrainManager` class is responsible for managing the trains in the game, including loading and unloading them, updating their positions, and handling collisions. It provides methods to interact with the trains and retrieve information about them.\n## Questions: \n 1. What is the purpose of the TrainManager class?\n- The TrainManager class manages trains in the game, including their creation, movement, and collision detection.\n\n2. What is the significance of the collideTest() method?\n- The collideTest() method checks for collisions between the trains and objects with the \"BoxMan\" layer. If a collision occurs and the shooter of the train is the same as the player's sequence, it stops the train.\n\n3. What does the SetShooter() method do?\n- The SetShooter() method sets the shooter of a specific train. If the shooter is set to -1, it regenerates the train and if the shooter is the same as the player's sequence, it calls the OnGetTrain() method in the localController.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TrainManager.md"}}],["505",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TreasureChestManager.cs)\n\nThe code provided is a part of the TreasureChestManager class in the Brick-Force project. The purpose of this class is to manage and keep track of treasure chests in the game. It provides methods to retrieve, update, and convert the treasure chest data.\n\nThe class contains a private dictionary called `dicTc` which stores the treasure chest data. The keys in the dictionary are integers representing the sequence number of the treasure chest, and the values are instances of the `TcStatus` class.\n\nThe class also has a private static instance variable `_instance` and a public static property `Instance`. The `Instance` property is a singleton implementation that ensures only one instance of the `TreasureChestManager` class is created. It uses the `Object.FindObjectOfType` method to find an existing instance of the class, and if none is found, it logs an error message. The `Instance` property is used to access the `TreasureChestManager` instance throughout the project.\n\nThe `Awake` method is called when the object is initialized and it initializes the `dicTc` dictionary and ensures that the object is not destroyed when a new scene is loaded using the `Object.DontDestroyOnLoad` method.\n\nThe `Get` method takes a sequence number as a parameter and returns the `TcStatus` object associated with that sequence number from the `dicTc` dictionary. If the sequence number is not found in the dictionary, it returns null.\n\nThe `Refresh` method is used to update the data of a specific treasure chest. It takes the sequence number, current value, key value, and maximum key value as parameters. If the sequence number exists in the `dicTc` dictionary, it calls the `Update` method of the corresponding `TcStatus` object to update its data.\n\nThe `UpdateAlways` method is used to update or add a new treasure chest to the `dicTc` dictionary. It takes various parameters representing the sequence number, index, maximum value, current value, key value, maximum key value, coin price, token price, and alias. If the sequence number exists in the dictionary, it calls the `Update` method of the corresponding `TcStatus` object to update its data. If the sequence number does not exist, it creates a new `TcStatus` object with the provided parameters and adds it to the dictionary.\n\nThe `ToArray` method converts the `dicTc` dictionary to an array of `TcStatus` objects and returns it.\n\nThe `Start` and `Update` methods are empty and do not have any functionality.\n\nOverall, the `TreasureChestManager` class provides methods to retrieve, update, and convert treasure chest data. It is an essential component of the Brick-Force project for managing the game's treasure chests.\n## Questions: \n 1. **What is the purpose of the `TreasureChestManager` class?**\nThe `TreasureChestManager` class is responsible for managing treasure chests in the game. It provides methods to get, refresh, and update the status of treasure chests.\n\n2. **What is the purpose of the `dicTc` variable?**\nThe `dicTc` variable is a dictionary that stores the status of treasure chests. The keys are integers representing the sequence of the treasure chests, and the values are instances of the `TcStatus` class.\n\n3. **What is the purpose of the `UpdateAlways` method?**\nThe `UpdateAlways` method is used to update the status of a treasure chest. If the treasure chest with the given sequence already exists in the dictionary, its status is updated. Otherwise, a new `TcStatus` instance is created and added to the dictionary.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TreasureChestManager.md"}}],["506",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TreeInfo.cs)\n\nThe code provided defines a class called `TreeInfo` that is marked as `[Serializable]`. This means that objects of this class can be converted into a format that can be stored or transmitted and then reconstructed later. \n\nThe `TreeInfo` class has several properties:\n- `clicked`: a boolean value that represents whether the tree has been clicked or not.\n- `bExpand`: a boolean value that represents whether the tree should be expanded or collapsed.\n- `Name`: a string that represents the name of the tree.\n- `childTrees`: an array of `TreeInfo` objects that represents the child trees of the current tree.\n\nThe purpose of this code is to define a data structure that can be used to represent a tree-like structure. Each `TreeInfo` object represents a node in the tree, with the `childTrees` property representing the children of that node. This allows for the creation of a hierarchical structure where each node can have multiple child nodes.\n\nThis code can be used in the larger project to store and manipulate tree-like data structures. For example, it can be used to represent a file system hierarchy, where each node represents a directory and the `childTrees` property represents the subdirectories and files within that directory. It can also be used to represent a menu structure, where each node represents a menu item and the `childTrees` property represents the submenus.\n\nHere is an example of how this code can be used:\n\n```csharp\nTreeInfo root = new TreeInfo()\n{\n    clicked = false,\n    bExpand = true,\n    Name = \"Root\",\n    childTrees = new TreeInfo[]\n    {\n        new TreeInfo()\n        {\n            clicked = false,\n            bExpand = false,\n            Name = \"Child 1\",\n            childTrees = null\n        },\n        new TreeInfo()\n        {\n            clicked = true,\n            bExpand = true,\n            Name = \"Child 2\",\n            childTrees = new TreeInfo[]\n            {\n                new TreeInfo()\n                {\n                    clicked = false,\n                    bExpand = false,\n                    Name = \"Grandchild 1\",\n                    childTrees = null\n                }\n            }\n        }\n    }\n};\n```\n\nIn this example, we create a tree structure with a root node and two child nodes. The second child node also has a child node of its own. Each node has its own properties such as `clicked`, `bExpand`, and `Name`. This structure can be easily serialized and deserialized for storage or transmission.\n## Questions: \n 1. **What is the purpose of the `[Serializable]` attribute on the `TreeInfo` class?**\nThe `[Serializable]` attribute indicates that objects of the `TreeInfo` class can be converted into a format that can be stored or transmitted, such as binary or XML.\n\n2. **What do the `clicked` and `bExpand` boolean variables represent in the `TreeInfo` class?**\nThe `clicked` variable represents whether the tree has been clicked or not, while the `bExpand` variable represents whether the tree should be expanded or not.\n\n3. **What is the purpose of the `childTrees` array in the `TreeInfo` class?**\nThe `childTrees` array represents the child trees of the current tree, allowing for a hierarchical structure of trees.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TreeInfo.md"}}],["507",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Trigger.cs)\n\nThe code provided is a script for a Trigger object in the Brick-Force project. The purpose of this script is to handle the behavior of the Trigger object, including showing or hiding the object and running a script associated with it.\n\nThe `Start()` method is called when the Trigger object is initialized. In this method, the script first attempts to find the `BrickProperty` component on the parent object of the Trigger. If the component is not found, an error message is logged. If the component is found, the script retrieves the `BrickInst` associated with the `BrickProperty` component. If the `BrickInst` is not found, another error message is logged. If the `BrickInst` is found, the `BrickForceScript` property of the `BrickInst` is assigned to the `script` variable. The `enabled` property of the Trigger object is set to the value of `EnableOnAwake` property of the `script`, and the `Show()` method is called with the value of the `VisibleOnAwake` property of the `script`.\n\nThe `Show(bool visible)` method is responsible for showing or hiding the Trigger object. It first checks if the current scene is the MapEditor scene. If it is not, it enables or disables the `MeshRenderer`, `SkinnedMeshRenderer`, and `ParticleRenderer` components of the Trigger object based on the value of the `visible` parameter. It then checks the `Index` property of the `BrickProperty` component. If the index is 162 and `visible` is true, it sets the `Visible_t` property of the `BrickProperty` component to true. If `visible` is false and `Visible_t` is true, it destroys the brick associated with the `BrickProperty` component. If the index is 180 and `visible` is false and `immediateKillBrickTutor` property of the `GlobalVars` instance is true, it destroys the brick associated with the `BrickProperty` component and sets `immediateKillBrickTutor` to false.\n\nThe `RunScript()` method is responsible for running the script associated with the Trigger object. It first checks if the `script` variable is not null. If it is not null, it finds the \"Main\" object in the scene. If the object is found, it instantiates a new object from the `Executor` property of the `ScriptResManager` instance and assigns it to the `gameObject2` variable. If `gameObject2` is not null, it sets the parent of `gameObject2` to the \"Main\" object and calls the `Run()` method of the `ScriptExecutor` component attached to `gameObject2` with the `script` as the parameter.\n\nThe `Update()` method is empty and does not contain any code.\n\nIn summary, this script handles the behavior of the Trigger object in the Brick-Force project. It shows or hides the object based on certain conditions and runs a script associated with it.\n## Questions: \n 1. What is the purpose of the `Trigger` class and how is it used in the project?\n- The `Trigger` class is used to control the visibility and behavior of certain objects in the game. It is likely used to trigger events or actions based on certain conditions.\n\n2. What is the significance of the `Show` method and how does it affect the visibility of objects?\n- The `Show` method is responsible for enabling or disabling the visibility of various components (MeshRenderer, SkinnedMeshRenderer, ParticleRenderer) based on the value of the `visible` parameter. It also contains conditional logic specific to certain `BrickProperty` components.\n\n3. How does the `RunScript` method work and what does it do with the `script` variable?\n- The `RunScript` method checks if the `script` variable is not null and then instantiates a new game object (`gameObject2`) and runs the `script` using a `ScriptExecutor` component. It seems to be executing a script associated with the `Trigger` object.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Trigger.md"}}],["508",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TSpecial.cs)\n\nThe code provided is a class called `TSpecial` that extends another class called `TItem`. This class represents a special item in the larger project called Brick-Force. \n\nThe `TSpecial` class has several properties and methods that are used to define and manipulate special items. \n\nThe properties of the `TSpecial` class include:\n- `functionMask`: an integer that represents the function mask of the special item.\n- `param`: a string that represents a parameter associated with the special item.\n- `IsConsumableBuff`: a boolean property that returns true if the function mask of the special item matches certain values, indicating that the item is a consumable buff.\n\nThe constructor of the `TSpecial` class takes in several parameters and initializes the properties of the class. It sets the `functionMask`, `IsAmount`, `season`, and `param` properties based on the provided arguments.\n\nThe `Param2Index` method is used to convert the `param` property to an index value. It first checks if the length of `param` is greater than 0. If it is, it checks if the special item is a consumable buff by calling the `IsConsumableBuff` property. If it is a consumable buff, it retrieves the corresponding `TBuff` object from the `BuffManager` and sets the `result` variable to the index of the `TBuff`. If it is not a consumable buff, it checks if the `functionMask` is equal to 80. If it is, it tries to parse the `param` string as an integer and returns the parsed value. If any parsing or conversion errors occur, it returns -1.\n\nIn the larger project, this `TSpecial` class would be used to define and manipulate special items. It provides a way to set and retrieve properties of special items, as well as convert a parameter to an index value. Other parts of the project can create instances of the `TSpecial` class and use its properties and methods to interact with special items. For example, the `TSpecial` class could be used in a game inventory system to manage and display special items to the player.\n## Questions: \n 1. What is the purpose of the `functionMask` variable and how is it used in the code?\n- The `functionMask` variable is used to determine the functionality of the `TSpecial` object. It is used in various conditional statements throughout the code to perform different actions based on its value.\n\n2. What is the significance of the `param` variable and how is it used in the code?\n- The `param` variable is a string parameter that is used in different ways depending on the value of `functionMask`. It is used to retrieve a `TBuff` object from `BuffManager` or to parse an integer value.\n\n3. What is the purpose of the `Param2Index()` method and when is it called?\n- The `Param2Index()` method is used to convert the `param` value into an index value. It is called in certain conditions to retrieve the index value for further processing or comparison.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TSpecial.md"}}],["509",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TUpgrade.cs)\n\nThe code provided is a class called `TUpgrade` that inherits from another class called `TItem`. This class represents an upgrade item in the larger Brick-Force project. \n\nThe `TUpgrade` class has several properties including `tier`, `target`, `playerLv`, `reqLv`, `maxLv`, and `targetType`. These properties store information about the upgrade item such as its tier, target, player level requirement, maximum level, and target type. \n\nThe class also has a constructor that takes in several parameters to initialize the properties of the upgrade item. The constructor calls the base class constructor of `TItem` to initialize some common properties of the item. It then sets the specific properties of the upgrade item using the provided parameters. \n\nOne important thing to note is the `targetType` property. It is set using a static method `String2UpgradeType` from the `TItem` class. This method takes in a string parameter and converts it to an integer representing the upgrade type. This suggests that the `target` property is a string representation of the upgrade type and needs to be converted to an integer for further processing. \n\nOverall, this code defines the `TUpgrade` class which represents an upgrade item in the Brick-Force project. It provides properties to store information about the upgrade item and a constructor to initialize those properties. The code also utilizes a static method from the base class to convert a string representation of the upgrade type to an integer. This class can be used to create and manage upgrade items in the larger project. \n\nExample usage:\n\n```csharp\n// Create a new upgrade item\nTUpgrade upgrade = new TUpgrade(\"code123\", \"Upgrade Item\", iconTexture, 1, 2, \"targetType\", 10, 5, 10, \"This is an upgrade item\", 4);\n\n// Access the properties of the upgrade item\nint tier = upgrade.tier;\nstring target = upgrade.target;\nint playerLv = upgrade.playerLv;\nint reqLv = upgrade.reqLv;\nint maxLv = upgrade.maxLv;\nint targetType = upgrade.targetType;\n```\n## Questions: \n 1. What is the purpose of the `TUpgrade` class and how does it relate to the `TItem` class? \n- The `TUpgrade` class is a subclass of the `TItem` class and represents an upgrade item in the game. It adds additional properties specific to upgrades, such as tier, target, player level requirements, and maximum level.\n\n2. What is the significance of the `targetType` property and how is it determined? \n- The `targetType` property is an integer that represents the type of upgrade target. It is determined by calling the `String2UpgradeType` method from the `TItem` class, passing in the `target` string as an argument.\n\n3. What is the purpose of the `IsAmount` property and how is it used? \n- The `IsAmount` property is a boolean that determines whether the upgrade item has a specific amount associated with it. It is set to `true` in the constructor of the `TUpgrade` class, indicating that the upgrade item does have an amount.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TUpgrade.md"}}],["510",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TutorCompleteDialog.cs)\n\nThe code provided is a class called `TutorCompleteDialog` that extends the `Dialog` class. This class is responsible for displaying a dialog box that appears when a tutorial is completed in the larger Brick-Force project. \n\nThe `TutorCompleteDialog` class has several methods and variables that control the behavior and appearance of the dialog box. \n\nThe `Start()` method sets the `id` variable of the dialog to a specific value from the `DialogManager.DIALOG_INDEX` enum. This value is used to identify the dialog in the `DialogManager` class.\n\nThe `OnPopup()` method sets the size and position of the dialog box based on the size of the screen. It calculates the position of the dialog box to be centered vertically on the screen.\n\nThe `InitDialog()` method is empty and does not have any functionality.\n\nThe `OnClose()` method is called when the dialog box is closed. If the `Tutorialed` variable in the `MyInfoManager` class is greater than or equal to 2, the `Application.LoadLevel()` method is called to load the \"BfStart\" level.\n\nThe `DoDialog()` method is responsible for rendering the dialog box and handling user interaction. It first sets the `GUI.skin` variable to a specific GUI skin obtained from the `GUISkinFinder` class. \n\nDepending on the value of the `isLoadBattleTutor` variable in the `GlobalVars` class, the method displays a different message using the `GUI.Label()` method. The message is obtained from the `StringMgr` class.\n\nThe method also renders a button using the `GlobalVars.MyButton()` method. If the button is clicked, it checks if the `Tutorialed` variable in the `MyInfoManager` class is less than 2. If it is, it pushes a new dialog box onto the dialog stack using the `DialogManager.Instance.Push()` method. \n\nFinally, the method checks if there are any active popups using the `ContextMenuManager.Instance.IsPopup` property. If there are no active popups, it calls the `WindowUtil.EatEvent()` method to prevent any further input events from being processed.\n\nOverall, this code provides the functionality for displaying a dialog box when a tutorial is completed in the Brick-Force project. It handles rendering the dialog box, displaying the appropriate message, and handling user interaction.\n## Questions: \n 1. What is the purpose of the `InitDialog()` method?\n- The purpose of the `InitDialog()` method is not clear from the provided code. It appears to be an empty method that does not have any functionality.\n\n2. What is the significance of the `Tutorialed` variable in the `OnClose()` method?\n- The `Tutorialed` variable is being used to check if the value is greater than or equal to 2. It is not clear what this variable represents or how it is being used elsewhere in the code.\n\n3. What is the purpose of the `DoDialog()` method?\n- The `DoDialog()` method is responsible for displaying a dialog box with a message and an \"OK\" button. It also checks the value of `Tutorialed` and performs additional actions based on its value.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TutorCompleteDialog.md"}}],["511",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TutorPopupDlg.cs)\n\nThe code provided is a class called `TutorPopupDlg` that extends the `Dialog` class. This class represents a tutorial popup dialog in the larger Brick-Force project. \n\nThe purpose of this code is to display a tutorial popup dialog to the user and handle user interactions with the dialog. The dialog contains an icon, some text, and two buttons: \"OK\" and \"CANCEL\". The dialog is displayed in the center of the screen with a specific size and position.\n\nThe `DoDialog()` method is the main method that handles the logic of the dialog. It first displays some text using the `LabelUtil.TextOut()` method, passing in the position, text, font, color, and other parameters. It then draws an icon using the `TextureUtil.DrawTexture()` method, passing in the position and the `iconCompensation` texture.\n\nNext, it retrieves a `Good` object from the `ShopManager` using the key \"a71\". If the `Good` object is not null, it displays the name and comment of the `Good` object using the `LabelUtil.TextOut()` method.\n\nThe method then checks if the \"OK\" button is pressed using the `GlobalVars.Instance.MyButton()` method. If the button is pressed, it sets a flag `isLoadBattleTutor` to false and checks if the \"Lobby\" and \"BattleTutor\" levels can be loaded. If they can be loaded, it retrieves a tutorialable channel using the `ChannelManager.Instance.GetTutorialableChannel()` method. If a tutorialable channel is found, it sets the destination of the `Compass` to the \"BATTLE_TUTOR\" level with the tutorialable channel ID.\n\nIf the \"CANCEL\" button is pressed, it checks if the current loaded level contains \"BfStart\". If it does, it checks if the \"Lobby\" level can be loaded. If it can be loaded, it retrieves the best build channel using the `ChannelManager.Instance.GetBestBuildChannel()` method. If a best build channel is found, it sets the destination of the `Compass` to the \"LOBBY\" level with the best build channel ID. If the current loaded level does not contain \"BfStart\", it loads the \"BfStart\" level.\n\nFinally, the method checks if the close button is pressed or if the escape key is pressed. If either of these conditions is true, it sets the result to true and loads the \"BfStart\" level if the current loaded level does not contain \"BfStart\".\n\nIn summary, this code represents a tutorial popup dialog that displays information to the user and handles user interactions such as button clicks. It is used in the larger Brick-Force project to provide tutorial information and allow the user to navigate between different levels and channels.\n## Questions: \n 1. What is the purpose of the `TutorPopupDlg` class?\n- The `TutorPopupDlg` class is a subclass of the `Dialog` class and represents a tutorial popup dialog in the game.\n\n2. What is the purpose of the `Start()` method?\n- The `Start()` method is called when the dialog is started and it sets the `id` of the dialog to a specific value.\n\n3. What is the purpose of the `DoDialog()` method?\n- The `DoDialog()` method is responsible for rendering and handling user interactions with the tutorial popup dialog. It returns a boolean value indicating whether the dialog should be closed or not.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TutorPopupDlg.md"}}],["512",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TutorPopupDlg2.cs)\n\nThe code provided is a class called \"TutorPopupDlg2\" that extends the \"Dialog\" class. This class represents a popup dialog box that is used in the larger Brick-Force project. \n\nThe purpose of this code is to create and display a popup dialog box that allows the user to select an item from a list of items. The selected item is then used to perform a specific action in the game. \n\nThe class has several member variables that define the layout and position of various UI elements within the dialog box. These variables include \"itemCodes\", which is an array of strings representing the codes of the items that can be selected, and \"sel\", which is an integer representing the index of the currently selected item. \n\nThe class also has a member variable called \"selTItem\" of type \"TItem\", which represents the currently selected item. The \"TItem\" class is not provided in the code snippet, but it can be assumed that it is a class that represents an item in the game, with properties such as name, icon, and comment. \n\nThe class overrides several methods from the base \"Dialog\" class. The \"Start\" method sets the \"id\" member variable to a specific value. The \"OnPopup\" method sets the size and position of the dialog box, initializes the \"sel\" and \"selTItem\" variables, and sets the position of the selected item within the dialog box. \n\nThe \"DoDialog\" method is the main method of the class that is called to display and handle user interactions with the dialog box. It first displays a label at the top of the dialog box using the \"LabelUtil.TextOut\" method. It then iterates over the \"itemCodes\" array and displays each item as a button using the \"GlobalVars.Instance.MyButton\" method. When a button is clicked, the \"sel\" and \"selTItem\" variables are updated to reflect the selected item, and the position of the selected item within the dialog box is updated. \n\nThe method also displays additional information about the selected item, such as its name and comment, and highlights the selected item using a box. It also displays two buttons, \"OK\" and \"CANCEL\", which perform specific actions when clicked. Finally, it checks for the \"Escape\" key being pressed and closes the dialog box if it is. \n\nIn summary, this code represents a popup dialog box that allows the user to select an item from a list of items. The selected item is then used to perform a specific action in the game.\n## Questions: \n 1. What is the purpose of the `TutorPopupDlg2` class?\n- The `TutorPopupDlg2` class is a subclass of the `Dialog` class and represents a popup dialog in the game.\n\n2. What is the purpose of the `itemCodes` array?\n- The `itemCodes` array stores a list of string codes that represent different items in the game.\n\n3. What is the purpose of the `DoDialog` method?\n- The `DoDialog` method is responsible for rendering and handling user interactions with the popup dialog.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TutorPopupDlg2.md"}}],["513",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TUTO_INPUT.cs)\n\nThe code provided is an enumeration called `TUTO_INPUT` that defines various input options for a game or application. Each input option is assigned a unique value using hexadecimal notation.\n\nThe purpose of this code is to provide a way to represent different input options in a concise and readable manner. By using an enumeration, developers can easily reference and compare different input options in their code.\n\nThe `TUTO_INPUT` enumeration includes options for keyboard inputs such as W, A, S, D, SPACE, and E. It also includes options for mouse inputs such as left click (M_L), right click (M_R), and middle click (M). Additionally, there are options for combining multiple inputs, such as WASD (representing the combination of W, A, S, and D keys) and KEYALL (representing all keyboard inputs). Finally, there is an option for representing all mouse inputs (MOUSEALL).\n\nHere is an example of how this enumeration could be used in the larger project:\n\n```csharp\nTUTO_INPUT input = TUTO_INPUT.W;\n\nif (input == TUTO_INPUT.W)\n{\n    // Move character forward\n}\nelse if (input == TUTO_INPUT.SPACE)\n{\n    // Jump\n}\nelse if (input == TUTO_INPUT.MOUSEALL)\n{\n    // Handle mouse input\n}\n```\n\nIn this example, the `input` variable is assigned the value `TUTO_INPUT.W`. The code then checks the value of `input` using an `if` statement. If the value is `TUTO_INPUT.W`, it means the W key was pressed, and the code can perform the appropriate action, such as moving the character forward.\n\nThis enumeration provides a convenient way to handle different input options in the larger project, making the code more readable and maintainable. Developers can easily understand and reference the different input options defined in the `TUTO_INPUT` enumeration.\n## Questions: \n 1. **Question:** What does the `TUTO_INPUT` enum represent and how is it used in the code?\n   - **Answer:** The `TUTO_INPUT` enum represents different input actions, such as keyboard keys and mouse buttons. It is likely used to handle user input in the game.\n\n2. **Question:** What do the numeric values assigned to each enum member represent?\n   - **Answer:** The numeric values assigned to each enum member likely represent bit flags, where each value is a power of 2. This allows for combining multiple input actions using bitwise operations.\n\n3. **Question:** Why are some of the enum member values represented in hexadecimal format?\n   - **Answer:** The enum member values represented in hexadecimal format are likely used to make it easier to combine multiple input actions using bitwise operations. Hexadecimal values are commonly used for bit manipulation in programming.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TUTO_INPUT.md"}}],["514",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TWeapon.cs)\n\nThe code provided is a class called `TWeapon` that extends another class called `TItem`. This class represents a weapon in the game and contains various properties and methods related to weapons.\n\nThe `TWeapon` class has an enum called `CATEGORY` which represents the different categories of weapons available in the game. The categories include \"HEAVY\", \"ASSAULT\", \"SNIPER\", \"SUB_MACHINE\", \"HAND_GUN\", \"MELEE\", and \"SPECIAL\".\n\nThe class has several private and public variables. The private variables include `prefab` and `prefab11`, which are GameObjects representing the main and alternative prefabs of the weapon respectively. There is also a `bone` variable which represents the bone associated with the weapon. The `cat` variable is an integer representing the weapon category index. The `durabilityMax` variable represents the maximum durability of the weapon. The `IsTwoHands` variable is a boolean flag indicating if the weapon requires both hands.\n\nThe class also has a static string array called `categories` which contains the names of the weapon categories.\n\nThe class has a constructor that takes various parameters to initialize the weapon object. It sets the values of the private variables and also calls the constructor of the base class `TItem` to initialize its properties.\n\nThe class has several methods. The `CurPrefab()` method returns the current prefab of the weapon based on certain conditions. It checks the developer options and age restrictions to determine which prefab to return.\n\nThe `String2WeaponCategory()` method converts a string category to an integer index. It iterates through the `categories` array and returns the index of the matching category. If no match is found, it logs an error.\n\nThe `GetWeaponType()` method returns the weapon type based on the slot value. It subtracts 2 from the slot value and casts it to the `Weapon.TYPE` enum.\n\nThe `GetDiscountRatio(int lv)` method calculates and returns the discount ratio based on the provided level. It checks the level and returns a specific discount ratio based on certain conditions.\n\nThe `GetDiscountRatio()` method calculates and returns the discount ratio based on the weapon category and the player's XP values. It uses a switch statement to determine the category and calls the `GetDiscountRatio()` method of the `XpManager` class to get the discount ratio based on the category and the corresponding XP value.\n\nOverall, this code represents a weapon class in the game with various properties and methods related to weapons. It provides functionality to get the current prefab of the weapon, convert a string category to an integer index, get the weapon type, and calculate the discount ratio based on the level and weapon category. This class is likely used in the larger project to handle weapon-related logic and functionality.\n## Questions: \n 1. What is the purpose of the `TWeapon` class and how does it relate to the `TItem` class?\n- The `TWeapon` class is a subclass of the `TItem` class and represents a weapon in the game. It adds additional properties and methods specific to weapons.\n\n2. What is the significance of the `prefab` and `prefab11` variables?\n- The `prefab` variable represents the main prefab (game object) of the weapon, while the `prefab11` variable represents an alternative prefab of the weapon. The code checks for developer options and age restrictions to determine which prefab to return.\n\n3. How does the `GetDiscountRatio()` method calculate the discount ratio for a weapon?\n- The `GetDiscountRatio()` method calculates the discount ratio based on the weapon category and the player's XP values. It uses a switch statement to determine the category and then calls the `GetDiscountRatio()` method of the `XpManager` class with the corresponding category and XP value.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TWeapon.md"}}],["515",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\TxtDump.cs)\n\nThe code provided is a class called `TxtDump` that contains a few static variables and a static method. \n\nThe `dataPath` variable is a string that is initially empty. It is likely meant to store the path to a file or directory where data will be dumped. \n\nThe `needDump` variable is a boolean that is also initially false. It is likely used to determine whether or not data needs to be dumped. \n\nThe `Dump` method takes in two parameters: `fileName` and `txt`. It does not have a return type, indicating that it does not return any value. \n\nBased on the code provided, it seems that the purpose of the `Dump` method is to dump or save some text data to a file. However, the implementation of the method is missing, as the method body is empty. \n\nTo use this code in the larger project, one would need to provide an implementation for the `Dump` method. This implementation would likely involve writing the `txt` parameter to a file specified by the `fileName` parameter. The `dataPath` variable could be used to construct the full path to the file. \n\nHere is an example of how the `Dump` method could be implemented:\n\n```csharp\npublic static void Dump(string fileName, string txt)\n{\n    string fullPath = Path.Combine(dataPath, fileName);\n    File.WriteAllText(fullPath, txt);\n}\n```\n\nIn this example, the `Path.Combine` method is used to combine the `dataPath` and `fileName` variables to create the full path to the file. The `File.WriteAllText` method is then used to write the `txt` parameter to the file specified by the full path. \n\nOverall, this code provides a basic structure for dumping text data to a file, but it requires further implementation to be fully functional.\n## Questions: \n 1. **What is the purpose of the `dataPath` variable?**\nThe `dataPath` variable is declared as a public static string, but its purpose is not clear from the provided code. It would be helpful to know what data it represents and how it is used in the context of the `TxtDump` class.\n\n2. **What is the purpose of the `needDump` variable?**\nThe `needDump` variable is declared as a public static bool, but its purpose is not clear from the provided code. It would be helpful to know what condition or criteria determine whether `needDump` is true or false, and how it is used in the context of the `TxtDump` class.\n\n3. **What is the intended functionality of the `Dump` method?**\nThe `Dump` method is declared with two parameters, `fileName` and `txt`, but its implementation is not provided in the code snippet. It would be helpful to know what the intended functionality of this method is and how it is expected to be used in the context of the `TxtDump` class.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\TxtDump.md"}}],["516",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\UIBase.cs)\n\nThe code provided is a class called `UIBase` that serves as a base class for user interface elements in the larger Brick-Force project. This class contains various properties and methods that are common to all UI elements.\n\nThe `UIBase` class has a protected boolean variable `isDraw` that determines whether the UI element should be drawn or not. It also has a public `Vector2` variable `position` that represents the position of the UI element on the screen. Additionally, there is a private `Vector2` variable `addPosition` that is used to add an offset to the UI element's position.\n\nThe class has a public property `IsDraw` that allows other classes to get or set the value of `isDraw`. This property provides a way to control the visibility of the UI element.\n\nThe `showPosition` property returns the sum of `position` and `addPosition`, which represents the final position of the UI element after applying any offset.\n\nThe class also contains several virtual methods that can be overridden by derived classes. The `Draw()` method is responsible for drawing the UI element on the screen and should be implemented in derived classes. The `SkipDraw()` method determines whether the UI element should be skipped during the drawing process. The `Update()` method is responsible for updating the state of the UI element and should be implemented in derived classes.\n\nThe class provides several helper methods for manipulating the `addPosition` variable. The `AddPositionX()` and `AddPositionY()` methods allow adding an offset to the UI element's position along the X and Y axes, respectively. The `ResetAddPosition()` method resets the `addPosition` variable to zero.\n\nOverall, the `UIBase` class provides a foundation for creating and managing UI elements in the Brick-Force project. Derived classes can inherit from this base class and override its methods to implement specific UI functionality.\n## Questions: \n 1. **What is the purpose of the `isDraw` variable and how is it used?**\nThe `isDraw` variable is used to determine whether or not the UI element should be drawn. It can be accessed and modified through the `IsDraw` property.\n\n2. **What is the purpose of the `showPosition` property and how is it calculated?**\nThe `showPosition` property calculates the final position of the UI element by adding the `position` and `addPosition` vectors together.\n\n3. **What is the difference between the `Draw()`, `SkipDraw()`, and `Update()` methods?**\nThe `Draw()` method is responsible for drawing the UI element, the `SkipDraw()` method determines whether the UI element should be skipped during drawing, and the `Update()` method is used for updating the UI element.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\UIBase.md"}}],["517",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\UIBaseList.cs)\n\nThe code provided is a class called `UIBaseList` that extends another class called `UIBase`. This class is used to create a list of `UIBase` objects and perform various operations on them.\n\nThe `UIBaseList` class has a public field called `listBases` which is a list of `UIBase` objects. This list is used to store the `UIBase` objects that are added to the `UIBaseList`.\n\nThe class overrides two methods from the `UIBase` class: `Draw()` and `SkipDraw()`. The `Draw()` method iterates over each `UIBase` object in the `listBases` list and calls the `Draw()` method on each object. The `SkipDraw()` method does the same thing, but calls the `SkipDraw()` method on each `UIBase` object instead.\n\nThe class also has three additional methods: `ListAddPositionX()`, `ListAddPositionY()`, and `ListResetAddPosition()`. These methods iterate over each `UIBase` object in the `listBases` list and call the corresponding method on each object. The `ListAddPositionX()` method adds a given value to the X position of each `UIBase` object, the `ListAddPositionY()` method adds a given value to the Y position of each `UIBase` object, and the `ListResetAddPosition()` method resets the add position of each `UIBase` object.\n\nThis class can be used in the larger project to manage a list of `UIBase` objects and perform operations on them. For example, it can be used to draw all the `UIBase` objects in the list, skip drawing them, or modify their positions. By extending the `UIBase` class and adding these additional methods, the `UIBaseList` class provides a convenient way to perform these operations on multiple `UIBase` objects at once.\n\nExample usage:\n\n```csharp\nUIBaseList uiBaseList = new UIBaseList();\n\n// Add UIBase objects to the list\nuiBaseList.listBases.Add(new UIBase());\nuiBaseList.listBases.Add(new UIBase());\n\n// Draw all the UIBase objects in the list\nuiBaseList.Draw();\n\n// Add 10 to the X position of all the UIBase objects in the list\nuiBaseList.ListAddPositionX(10);\n\n// Reset the add position of all the UIBase objects in the list\nuiBaseList.ListResetAddPosition();\n```\n## Questions: \n 1. **What is the purpose of the `UIBaseList` class?**\nThe `UIBaseList` class is a subclass of `UIBase` and represents a list of `UIBase` objects. It provides methods for drawing, skipping drawing, and manipulating the positions of the objects in the list.\n\n2. **What is the purpose of the `Draw` method?**\nThe `Draw` method is responsible for drawing all the `UIBase` objects in the `listBases` list. It returns a boolean value indicating whether the drawing was successful or not.\n\n3. **What is the purpose of the `ListAddPositionX` method?**\nThe `ListAddPositionX` method is used to add a specified value to the X position of all the `UIBase` objects in the `listBases` list. This allows for easy manipulation of the X positions of multiple objects at once.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\UIBaseList.md"}}],["518",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\UIChangeColor.cs)\n\nThe code provided is a class called `UIChangeColor` that extends the `UIImage` class. This class is responsible for changing the color of a UI image over time. It has properties for the start color, end color, and the time it takes to transition between the two colors. \n\nThe `Update()` method is called every frame and updates the current color of the UI image. It checks if the image is currently being drawn and if the current time is less than the specified change time. If both conditions are met, it calculates the current change value based on the elapsed time and the total change time. If the change value is equal to or greater than 1, it checks if the `changeEndHide` flag is set to true. If it is, it sets the `isDraw` flag to false, effectively hiding the image. Finally, it sets the change value to 1 to ensure the image reaches the end color. The method returns true to indicate that the update is complete.\n\nThe `Draw()` method is responsible for actually drawing the UI image with the updated color. It first checks if the image is currently being drawn. If not, it returns false to indicate that the drawing is not complete. It then saves the current GUI color, sets the GUI color to a lerped value between the start and end colors based on the current change value, and calculates the position of the image based on its base position and size. It then uses the `TextureUtil.DrawTexture()` method to draw the image with the updated color. Finally, it restores the original GUI color and returns false to indicate that the drawing is complete.\n\nThe `Reset()` method is used to reset the current time and set the `isDraw` flag to true, effectively restarting the color change process.\n\nThis class can be used in the larger project to create dynamic UI elements that change color over time. For example, it can be used to create buttons that change color when hovered over or progress bars that change color as the progress increases. By setting the start and end colors and the change time, developers can easily customize the appearance and behavior of these UI elements.\n## Questions: \n 1. **What is the purpose of this code?**\nThe purpose of this code is to change the color of a UI image over time.\n\n2. **What does the `changeEndHide` variable do?**\nThe `changeEndHide` variable determines whether the UI image should be hidden (`isDraw = false`) when the color change is complete.\n\n3. **What does the `Reset()` method do?**\nThe `Reset()` method resets the `currentTime` variable to 0 and sets `isDraw` to true, allowing the UI image to be drawn again.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\UIChangeColor.md"}}],["519",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\UIComboBox.cs)\n\nThe code provided is a class called `UIComboBox` that extends the `UIBase` class. This class represents a combo box UI element that can be used in the larger Brick-Force project. \n\nThe purpose of this code is to create a customizable combo box that allows the user to select an item from a list of options. The combo box is drawn on the screen using the `Draw()` method, and the selected item can be retrieved using the `GetSelectString()` method.\n\nThe class has several properties that can be customized:\n- `area`: a `Vector2` that represents the size of the combo box area.\n- `list`: an array of strings that represents the list of options in the combo box.\n- `parentSize`: a `Vector2` that represents the size of the parent window.\n- `buttonStyle`, `boxStyle`, `btnStyleDn`, `btnStyleUp`: strings that represent the styles for the combo box button and box.\n- `dependentComboBox`: a reference to another `UIComboBox` that this combo box depends on.\n- `IsStringKey`: a boolean flag that indicates whether the list items are string keys that need to be looked up in a string manager.\n\nThe `Draw()` method is responsible for drawing the combo box on the screen. It first checks if the combo box has already been drawn (`isDraw` flag), and if not, it initializes the combo box and sets its style and colors. It also sets the parent window size if provided. Then, it calls the `DoCombo()` method to handle the combo box interaction.\n\nThe `DoCombo()` method is responsible for handling the combo box interaction. It first checks if the list of options is not empty. If there is a dependent combo box, it disables the combo box if the dependent combo box's button is clicked. It then calls the `List()` method of the `ComboBox` class (which is instantiated in the `Draw()` method) to draw the combo box and get the selected item index. Finally, it updates the selected item content.\n\nThe `ResetList()` method is responsible for resetting the list of options in the combo box. It first checks if the list is not empty, and if so, it initializes the combo box and sets its style and colors. It then creates an array of `GUIContent` objects based on the list items, and sets the selected item index to 0.\n\nThe `IsClickedComboButton()` method checks if the combo box button is clicked and returns a boolean value.\n\nThe `GetSelectString()` method returns the selected item as a string.\n\nOverall, this code provides a flexible and customizable combo box UI element that can be used in the Brick-Force project to allow users to select options from a list.\n## Questions: \n 1. What is the purpose of the `UIComboBox` class?\n- The `UIComboBox` class is used to create a combo box UI element that allows the user to select an item from a list.\n\n2. What is the significance of the `dependentComboBox` property?\n- The `dependentComboBox` property allows for the enabling or disabling of the combo box based on the state of another combo box. \n\n3. What is the purpose of the `GetSelectString()` method?\n- The `GetSelectString()` method returns the selected item from the combo box as a string.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\UIComboBox.md"}}],["520",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\UIFlickerColor.cs)\n\nThe code provided is a class called `UIFlickerColor` that extends the `UIImage` class. This class is responsible for creating a flickering effect between two colors for a UI element. \n\nThe class has several public properties:\n- `startColor` and `endColor` represent the two colors between which the UI element will flicker.\n- `changeTime` determines the duration of each color transition.\n- `hideTime` specifies the time after which the UI element will be hidden.\n- `totalTime` keeps track of the total time that has passed since the UI element started flickering.\n- `currentTime` keeps track of the time that has passed since the last color transition.\n- `change` represents the progress of the current color transition, ranging from 0 to 1.\n- `isReverse` is a boolean flag that determines whether the color transition is moving from `startColor` to `endColor` or vice versa.\n\nThe class overrides two methods from the `UIImage` class:\n- `Update()` is called every frame and updates the flickering effect. It checks if the UI element is currently being drawn and if the `hideTime` has been reached. If so, it stops drawing the UI element and resets the flickering effect. It then updates the `currentTime` and `totalTime` variables and calculates the `change` value based on the current time and the `changeTime`. Finally, it returns `true` to indicate that the UI element should continue to be updated.\n- `Draw()` is responsible for actually drawing the UI element with the current color. It first stores the current GUI color, then uses `Color.Lerp()` to calculate the current color based on the `startColor`, `endColor`, and `change` values. It then calls the `Draw()` method from the base `UIImage` class to draw the UI element with the current color. Finally, it restores the original GUI color and returns `false` to indicate that the UI element should not be drawn again.\n\nThe class also provides a `Reset()` method that resets all the variables to their initial values, effectively stopping the flickering effect.\n\nThis class can be used in the larger project to create dynamic and visually appealing UI elements that flicker between two colors. Developers can create instances of the `UIFlickerColor` class and set the desired colors, change time, and hide time to achieve the desired flickering effect. They can then add these UI elements to the game's UI system to enhance the visual experience for the players.\n## Questions: \n 1. **What is the purpose of the `UIFlickerColor` class?**\nThe `UIFlickerColor` class is a subclass of `UIImage` and is responsible for creating a flickering effect by smoothly transitioning between two colors.\n\n2. **What are the variables `startColor` and `endColor` used for?**\nThe `startColor` and `endColor` variables define the two colors between which the flickering effect will transition.\n\n3. **What is the significance of the `changeTime` and `hideTime` variables?**\nThe `changeTime` variable determines the duration of each color transition, while the `hideTime` variable specifies the maximum amount of time the flickering effect will be active before automatically hiding.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\UIFlickerColor.md"}}],["521",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\UIGauge.cs)\n\nThe code provided is a class called `UIGauge` that extends the `UIImage` class. This class represents a gauge or progress bar that can be used in a graphical user interface (GUI) in a game or application. The purpose of this code is to handle the drawing and calculation of the gauge's appearance based on its current value and maximum value.\n\nThe `UIGauge` class has several public properties that can be set to customize the gauge's behavior and appearance. These properties include `valueMax` (the maximum value of the gauge), `valueNow` (the current value of the gauge), `isLandscape` (a boolean indicating whether the gauge is horizontal or vertical), `isReverse` (a boolean indicating whether the gauge should be drawn in reverse), and `isDrawCut` (a boolean indicating whether the gauge should be drawn with a cut-off effect).\n\nThe main method in this class is the `Draw()` method, which is responsible for drawing the gauge. It first checks if the gauge should be drawn at all (`isDraw` property), and if not, it returns false. If `isDrawCut` is true, it calls the `DrawCut()` method, which handles the drawing of the gauge with a cut-off effect. Otherwise, it calls the `Calculate()` method to calculate the gauge's appearance and then calls the `Draw()` method of the base class to actually draw the gauge.\n\nThe `DrawCut()` method calculates the position and size of the cut-off area based on the current value of the gauge and then calls the `Draw()` method of the base class to draw the gauge within the cut-off area.\n\nThe `Calculate()` method is responsible for calculating the position and size of the gauge based on its current value. It first checks if the `imageMax` variable is zero, which indicates that it needs to be initialized. It sets the `imageStart` variable to the current position of the gauge and initializes the `imageMax` variable with the size of the gauge. It then calculates the current size of the gauge based on the current value and the maximum value, and updates the position and size of the gauge accordingly.\n\nThe `SetRatio()` method is a public method that can be used to set the current value of the gauge based on a ratio of the maximum value. For example, calling `SetRatio(0.5f)` would set the current value of the gauge to half of the maximum value.\n\nIn summary, this code provides a class that can be used to create and manage a gauge or progress bar in a GUI. It allows customization of the gauge's appearance and provides methods to set and update its current value.\n## Questions: \n 1. **What is the purpose of the `UIGauge` class?**\nThe `UIGauge` class is a subclass of `UIImage` and represents a gauge UI element. It has properties and methods for drawing and calculating the gauge's appearance based on its current value.\n\n2. **What is the significance of the `isDrawCut` property?**\nThe `isDrawCut` property determines whether the gauge should be drawn with a cut-off effect. If `isDrawCut` is true, the `DrawCut()` method is called to draw the gauge with a cut-off appearance.\n\n3. **What does the `SetRatio(float ratio)` method do?**\nThe `SetRatio(float ratio)` method sets the current value of the gauge based on a given ratio. The current value is calculated by multiplying the ratio with the maximum value of the gauge.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\UIGauge.md"}}],["522",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\UIGroup.cs)\n\nThe code provided is a class called `UIGroup` that extends from `UIBaseList` and is used for creating a group of UI elements in the Brick-Force project. \n\nThe `UIGroup` class has the following properties:\n- `area`: A `Vector2` variable that represents the size of the group area.\n- `style`: A `string` variable that represents the style of the group.\n\nThe `UIGroup` class also has two methods:\n- `BeginGroup()`: This method is used to begin a new UI group. It checks if the `style` property has a value. If it does, it uses the `GUI.BeginGroup()` method to create a new group with the specified area and style. If the `style` property is empty, it creates a group without a specific style.\n- `EndGroup()`: This method is used to end the current UI group. It calls the `GUI.EndGroup()` method to close the group.\n\nThe purpose of this code is to provide a way to create and manage UI groups in the Brick-Force project. UI groups are used to organize and group related UI elements together. By using the `UIGroup` class, developers can easily create and manage UI groups by calling the `BeginGroup()` and `EndGroup()` methods.\n\nHere is an example of how this code can be used in the larger project:\n\n```csharp\nUIGroup group = new UIGroup();\ngroup.area = new Vector2(200, 100);\ngroup.style = \"groupStyle\";\ngroup.BeginGroup();\n\n// Add UI elements to the group\n\ngroup.EndGroup();\n```\n\nIn this example, a new `UIGroup` object is created and configured with a specific area and style. The `BeginGroup()` method is called to start a new UI group. UI elements can then be added to the group. Finally, the `EndGroup()` method is called to close the group. This allows developers to easily create and manage UI groups in the Brick-Force project.\n## Questions: \n 1. What is the purpose of the `UIGroup` class?\n- The `UIGroup` class is a subclass of `UIBaseList` and represents a group of UI elements.\n\n2. What does the `BeginGroup` method do?\n- The `BeginGroup` method begins a GUI group using the specified area and style.\n\n3. What does the `EndGroup` method do?\n- The `EndGroup` method ends the current GUI group.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\UIGroup.md"}}],["523",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\UIHorizontalSlider.cs)\n\nThe code provided is a class called `UIHorizontalSlider` that extends from the `UIBase` class. This class represents a horizontal slider UI element that can be used in the larger Brick-Force project.\n\nThe `UIHorizontalSlider` class has several properties:\n- `area`: A `Vector2` that represents the size of the slider's area.\n- `minValue`: A `float` that represents the minimum value of the slider.\n- `maxValue`: A `float` that represents the maximum value of the slider. The default value is 1.\n- `value`: A `float` that represents the current value of the slider.\n\nThe class also overrides the `Draw` method from the `UIBase` class. This method is responsible for drawing the slider on the screen. It returns a boolean value indicating whether the slider was drawn successfully.\n\nInside the `Draw` method, there is a check to see if the `isDraw` property is `false`. If it is, the method returns `false` indicating that the slider was not drawn. If `isDraw` is `true`, the method continues to draw the slider using the `GUI.HorizontalSlider` method.\n\nThe `GUI.HorizontalSlider` method takes several parameters:\n- `Rect`: A `Rect` object that represents the position and size of the slider.\n- `value`: The current value of the slider.\n- `minValue`: The minimum value of the slider.\n- `maxValue`: The maximum value of the slider.\n\nThe method updates the `value` property of the `UIHorizontalSlider` class with the new value selected by the user. Finally, the method returns `false` indicating that the slider was not drawn successfully.\n\nThis `UIHorizontalSlider` class can be used in the larger Brick-Force project to create and display horizontal sliders in the user interface. Developers can create instances of this class and customize its properties to fit their specific needs. They can also use the `Draw` method to draw the slider on the screen and retrieve the selected value from the `value` property.\n## Questions: \n 1. What is the purpose of the `UIHorizontalSlider` class?\n- The `UIHorizontalSlider` class is a subclass of `UIBase` and is used to create a horizontal slider UI element.\n\n2. What does the `Draw` method do?\n- The `Draw` method is responsible for drawing the horizontal slider UI element on the screen. It returns a boolean value indicating whether the element was successfully drawn.\n\n3. What are the parameters of the `GUI.HorizontalSlider` method?\n- The `GUI.HorizontalSlider` method takes in a `Rect` object representing the position and size of the slider, a `float` value representing the current value of the slider, and two `float` values representing the minimum and maximum values of the slider.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\UIHorizontalSlider.md"}}],["524",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\UIImage.cs)\n\nThe code provided is a class called `UIImage` that inherits from the `UIBase` class. This class represents an image that can be displayed on the user interface (UI) of the Brick-Force project. \n\nThe `UIImage` class has several properties:\n- `area`: A `Vector2` that represents the size of the image area on the UI.\n- `texImage`: A `Texture2D` that represents the image to be displayed.\n- `guiStyle`: A `string` that represents the GUI style to be applied to the image.\n\nThe `UIImage` class also overrides the `Draw()` method from the `UIBase` class. This method is responsible for actually drawing the image on the UI. \n\nThe `Draw()` method first checks if the `isDraw` property is set to `true`. If it is not, the method returns `false`, indicating that the image should not be drawn. \n\nIf the `texImage` property is not null, the method proceeds to draw the image using the `TextureUtil.DrawTexture()` method. The position and size of the image are determined based on the `area` property. If the `area` is set to `Vector2.zero`, the full size of the `texImage` is used. Otherwise, the `area` property is used to determine the size of the image.\n\nIf the `texImage` property is null, the method checks if the `guiStyle` property is not null and has a length greater than 0. If it is, the method uses the `GUI.Box()` method to draw an empty box with the specified `guiStyle`. The position and size of the box are determined based on the `area` property.\n\nFinally, the method returns `false`, indicating that the image has been drawn.\n\nThis `UIImage` class can be used in the larger Brick-Force project to display images on the UI. Developers can create instances of the `UIImage` class, set the `area`, `texImage`, and `guiStyle` properties, and then call the `Draw()` method to display the image on the UI.\n## Questions: \n 1. **What is the purpose of the `UIImage` class?**\nThe `UIImage` class is a subclass of `UIBase` and is used to draw images or GUI boxes on the screen.\n\n2. **What does the `Draw()` method do?**\nThe `Draw()` method is responsible for rendering the image or GUI box on the screen based on the provided parameters.\n\n3. **What is the significance of the `area` variable?**\nThe `area` variable represents the size of the image or GUI box to be drawn on the screen.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\UIImage.md"}}],["525",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\UIImageCounter.cs)\n\nThe code provided is a class called `UIImageCounter` that extends the `UIImage` class. It is used to draw multiple instances of an image or a GUI box in a grid-like pattern.\n\nThe class has several public variables that can be set to customize the appearance of the drawn images. These variables include `offSetY`, `offSetXCount`, and `offSetX`. \n\nThe `offSetY` variable determines the vertical spacing between each row of images, while `offSetXCount` determines the number of images in each row. `offSetX` determines the horizontal spacing between each image in a row.\n\nThe class also has private variables such as `listCount` and `curPosition`. `listCount` is used to keep track of the total number of images to be drawn, while `curPosition` is a Vector2 variable that stores the current position of the image being drawn.\n\nThe main functionality of the class is implemented in the `Draw()` method. This method is responsible for drawing the images on the screen. It uses a for loop to iterate over the `listCount` and calculate the position of each image based on the `offSetX` and `offSetY` values.\n\nInside the loop, the method checks if an image (`texImage`) or a GUI style (`guiStyle`) is provided. If an image is available, it uses the `TextureUtil.DrawTexture()` method to draw the image at the calculated position. If a GUI style is available, it uses the `GUI.Box()` method to draw an empty box at the calculated position.\n\nThe `SetListCount()` method is used to set the value of `listCount`, which determines the total number of images to be drawn.\n\nOverall, this class provides a convenient way to draw multiple instances of an image or a GUI box in a grid-like pattern. It can be used in the larger project to create menus, grids of icons, or any other UI element that requires multiple instances of the same image or GUI box.\n## Questions: \n 1. **What is the purpose of the `UIImageCounter` class?**\nThe `UIImageCounter` class is a subclass of `UIImage` and is used to draw a series of images or GUI boxes in a grid-like pattern.\n\n2. **What does the `SetListCount` method do?**\nThe `SetListCount` method sets the number of items in the list that will be drawn by the `Draw` method.\n\n3. **What is the purpose of the `offSetXCount` variable?**\nThe `offSetXCount` variable determines the number of items that will be drawn in each row of the grid.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\UIImageCounter.md"}}],["526",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\UIImageList.cs)\n\nThe code provided is a class called `UIImageList` that inherits from the `UIBase` class and is marked as `[Serializable]`. This class represents a list of `UIImage` objects and provides a method called `Draw()`.\n\nThe purpose of this code is to draw a list of `UIImage` objects on the screen. The `Draw()` method is responsible for iterating through the `uiImages` array and calling the `Draw()` method on each `UIImage` object. \n\nThe `Draw()` method first checks if the `isDraw` flag is set to true. If it is not, the method returns false, indicating that nothing should be drawn. This flag is likely used to control whether the `UIImageList` should be drawn or not.\n\nNext, the method checks if the `uiImages` array is null. If it is, the method returns false, indicating that nothing should be drawn. This check ensures that the `uiImages` array is not null before attempting to iterate over it.\n\nFinally, the method checks if the length of the `uiImages` array is 0. If it is, the method returns false, indicating that nothing should be drawn. This check ensures that there are `UIImage` objects in the array before attempting to draw them.\n\nIf all the checks pass, the method enters a for loop that iterates over each `UIImage` object in the `uiImages` array and calls the `Draw()` method on each object. This is where the actual drawing of the `UIImage` objects occurs.\n\nAfter iterating over all the `UIImage` objects, the method returns false. It is unclear why the method always returns false at the end, as it seems more appropriate to return true to indicate that the drawing was successful.\n\nIn the larger project, this code may be used to display a list of images on a user interface. The `UIImageList` class can be instantiated and populated with `UIImage` objects, and then the `Draw()` method can be called to render the images on the screen. This class provides a convenient way to manage and draw multiple images in a UI context.\n## Questions: \n 1. **What is the purpose of the `[Serializable]` attribute on the `UIImageList` class?**\nThe `[Serializable]` attribute indicates that instances of the `UIImageList` class can be serialized and deserialized, allowing them to be easily stored or transmitted.\n\n2. **What is the purpose of the `Draw()` method in the `UIImageList` class?**\nThe `Draw()` method is responsible for rendering the `uiImages` array of `UIImage` objects. It returns a boolean value indicating whether the drawing was successful or not.\n\n3. **What happens if the `uiImages` array is null or empty in the `Draw()` method?**\nIf the `uiImages` array is null or empty, the `Draw()` method will return false, indicating that there is nothing to draw.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\UIImageList.md"}}],["527",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\UIImageRotate.cs)\n\nThe code provided is a class called `UIImageRotate` that extends the `UIBase` class. This class is used to rotate and draw an image on a user interface (UI) element in a Unity game.\n\nThe `UIImageRotate` class has several properties and methods that control the rotation and drawing of the image. \n\nThe `area` property is a `Vector2` that represents the size of the image. It is used to calculate the position and size of the image when drawing it on the UI.\n\nThe `texImage` property is a `Texture2D` that holds the image to be drawn on the UI. This property is set externally by assigning a texture to it.\n\nThe `rotateSpeed` property is a `float` that determines the speed at which the image rotates. It is measured in degrees per second.\n\nThe `rotateAngle` property is a `float` that keeps track of the current rotation angle of the image. It is updated in the `Update()` method by incrementing it with the product of `Time.deltaTime` and `rotateSpeed`. \n\nThe `Update()` method is called every frame and updates the rotation angle of the image. It returns a boolean value indicating whether the update was successful or not.\n\nThe `Draw()` method is responsible for drawing the image on the UI. It first checks if the image should be drawn (`isDraw` property) and if the `texImage` is not null. If the image should be drawn, it calculates the position and size of the image based on the `area` property. It then applies a rotation transformation to the UI using `GUIUtility.RotateAroundPivot()` method, passing in the `rotateAngle` and the center point of the image. Finally, it draws the image using `TextureUtil.DrawTexture()` method, passing in the position, size, and the `texImage`. After drawing the image, it resets the GUI matrix to its original state.\n\nIn summary, the `UIImageRotate` class provides functionality to rotate and draw an image on a UI element in a Unity game. It can be used to create dynamic and visually appealing UI elements that rotate over time.\n## Questions: \n 1. What is the purpose of the `UIImageRotate` class?\n- The `UIImageRotate` class is a subclass of `UIBase` and is used to rotate and draw an image on the GUI.\n\n2. What does the `Update` method do?\n- The `Update` method updates the rotation angle of the image based on the `rotateSpeed` and returns a boolean value indicating if the update was successful.\n\n3. What does the `Draw` method do?\n- The `Draw` method draws the rotated image on the GUI using the provided texture and area dimensions. It returns a boolean value indicating if the image was successfully drawn.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\UIImageRotate.md"}}],["528",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\UIImageSizeChange.cs)\n\nThe code provided is a class called `UIImageSizeChange` that extends the `UIBase` class. This class is responsible for changing the size of a UI image over time. It is likely used in the larger Brick-Force project to create dynamic and animated UI elements.\n\nThe `UIImageSizeChange` class has several properties and methods that control the size change behavior. \n\nThe `texImage` property is of type `Texture2D` and represents the image that will be resized. \n\nThe `startSize` property is a float that represents the initial size of the image. \n\nThe `repeat` property is a boolean that determines whether the size change animation should repeat after reaching the end. \n\nThe `sizeChange` property is a list of `SizeChangeStep` objects. Each `SizeChangeStep` object represents a step in the size change animation and contains information such as the target size, duration, and speed of the step.\n\nThe `curSize` property is a float that represents the current size of the image. \n\nThe `curStep` property is an integer that represents the current step in the size change animation.\n\nThe `Update` method is responsible for updating the size change animation. It checks if the image is being drawn and if the necessary conditions are met to continue the animation. It then updates the current time and current size based on the speed of the current step.\n\nThe `Draw` method is responsible for drawing the resized image on the screen. It calculates the new size of the image based on the current size and the original image dimensions, and then uses the `TextureUtil.DrawTexture` method to draw the image.\n\nThe `AddStep` method is used to add a new step to the size change animation. It calculates the speed of the step based on the difference between the target size and the previous end size, divided by the duration of the step.\n\nThe `Reset` method is used to reset the animation to its initial state. It sets the current time, current size, and current step to their initial values.\n\nThe `SetEndStep` method is used to set the animation to its final step. It sets the current step to the last step in the animation and updates the current size accordingly.\n\nOverall, this code provides a flexible and reusable way to animate the size change of UI images in the Brick-Force project. Developers can use the `UIImageSizeChange` class to create dynamic and visually appealing UI elements that change size over time.\n## Questions: \n 1. What is the purpose of the `UIImageSizeChange` class?\n- The `UIImageSizeChange` class is a subclass of `UIBase` and is responsible for changing the size of a UI image over time.\n\n2. What does the `Update` method do?\n- The `Update` method checks if the image is being drawn and if the current step of size change has been completed. It updates the current size of the image based on the speed and time of the current step.\n\n3. What does the `Draw` method do?\n- The `Draw` method draws the image on the screen using the current size and position. It returns false to indicate that the drawing is complete.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\UIImageSizeChange.md"}}],["529",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\UILabel.cs)\n\nThe code provided is a class called `UILabel` that is a part of the larger Brick-Force project. This class is responsible for creating and managing labels in the user interface of the game. \n\nThe `UILabel` class has several properties and methods that allow for customization and manipulation of the labels. \n\nThe `LABEL_STYLE` enum defines three different styles for the labels: `BIGLABEL`, `LABEL`, and `MINILABEL`. These styles determine the size and appearance of the labels.\n\nThe `LABEL_COLOR` enum defines a list of colors that can be used for the text and outline of the labels. The colors range from `CLEAR` to `C_98_60_10`, which are represented as `Color` objects.\n\nThe `textKey` property is a string that can be used to reference a localized text string for the label. If the `text` property is empty and the `textKey` is not, the `text` property will be set to the localized string retrieved from the `StringMgr` instance.\n\nThe `style` property determines the style of the label, the `textColor` property determines the color of the text, and the `outLineColor` property determines the color of the outline of the label. The `alignment` property determines the alignment of the text within the label.\n\nThe `width` property determines the width of the label. If the width is set to 0, the label will be drawn with the default width. If the width is set to a non-zero value, the label will be drawn with the specified width.\n\nThe `Draw` method is responsible for drawing the label on the screen. It first checks if the label should be drawn by checking the `isDraw` property. If the label should be drawn, it retrieves the text to be displayed by checking if the `text` property is empty and the `textKey` property is not. It then calls the `LabelUtil.TextOut` method to draw the label with the specified text, style, colors, alignment, and width.\n\nThe `SetText` method allows for setting the text of the label directly.\n\nThe `SetTextFormat` methods allow for setting the text of the label using a format string and arguments. The `textKey` property is used to retrieve the format string from the `StringMgr` instance.\n\nThe `GetByteColor2FloatColor` method is a utility method that converts byte values to float values and returns a `Color` object.\n\nThe `CalcLength` method calculates the length of the label based on its style and text.\n\nThe `GetLabelColor` method returns the `Color` object associated with the specified `LABEL_COLOR` enum value.\n\nOverall, the `UILabel` class provides a way to create and manage labels in the user interface of the Brick-Force game. It allows for customization of the label's style, color, alignment, and width, and provides methods for setting the label's text using localized strings and format strings.\n## Questions: \n 1. What is the purpose of the `UILabel` class?\n- The `UILabel` class is a subclass of `UIBase` and represents a label UI element. It is used to display text with various styles and colors.\n\n2. How does the `Draw` method work?\n- The `Draw` method is responsible for rendering the label on the screen. It checks if the label is set to be drawn, retrieves the text to be displayed, and then calls the `LabelUtil.TextOut` method to render the label with the specified style, colors, alignment, and width.\n\n3. What is the purpose of the `SetTextFormat` methods?\n- The `SetTextFormat` methods are used to set the text of the label using a formatted string. They take one or more arguments and use `string.Format` to replace placeholders in the text with the provided arguments.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\UILabel.md"}}],["530",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\UILabelList.cs)\n\nThe code provided is a class called `UILabelList` that extends from the `UIBase` class. It represents a list of `UILabel` objects, which are UI elements used to display text. \n\nThe purpose of this code is to provide a way to draw a list of `UILabel` objects on the screen. The `Draw()` method is responsible for rendering the UI elements. \n\nThe `Draw()` method first checks if the `isDraw` flag is set to true. If it is not, the method returns false, indicating that the UI should not be drawn. This flag is likely used to control when the UI should be displayed.\n\nNext, the method checks if the `uiLabels` array is null. If it is, the method also returns false. This check ensures that there are `UILabel` objects to be drawn. If the array is null, there is nothing to draw, so the method returns false.\n\nFinally, the method checks if the length of the `uiLabels` array is zero. If it is, the method returns false. This check ensures that there are `UILabel` objects in the array. If the length is zero, there are no objects to draw, so the method returns false.\n\nIf all the checks pass, the method enters a loop that iterates over each `UILabel` object in the `uiLabels` array. For each object, the `Draw()` method of the `UILabel` class is called to render the UI element.\n\nAfter all the `UILabel` objects have been drawn, the method returns false. It is unclear why the method always returns false, as it seems more logical for it to return true to indicate that the UI has been drawn successfully.\n\nIn the larger project, this code can be used to create and manage lists of `UILabel` objects. It provides a convenient way to draw multiple UI elements at once, without having to call the `Draw()` method for each individual element. This can be useful for displaying lists of items, such as a menu or inventory.\n## Questions: \n 1. **What is the purpose of the `[Serializable]` attribute on the `UILabelList` class?**\nThe `[Serializable]` attribute indicates that instances of the `UILabelList` class can be serialized and deserialized, allowing them to be stored or transmitted as data.\n\n2. **What is the purpose of the `Draw()` method in the `UILabelList` class?**\nThe `Draw()` method is responsible for rendering the `UILabelList` and its associated `UILabel` elements on the screen. It returns a boolean value indicating whether the drawing was successful or not.\n\n3. **What is the significance of the `uiLabels` array in the `UILabelList` class?**\nThe `uiLabels` array holds references to `UILabel` objects that are part of the `UILabelList`. The `Draw()` method iterates over this array and calls the `Draw()` method on each `UILabel` to render them on the screen.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\UILabelList.md"}}],["531",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\UIMyButton.cs)\n\nThe code provided is a class called `UIMyButton` that extends from the `UIBase` class. This class represents a custom button for a user interface in the Brick-Force project. \n\nThe purpose of this code is to handle the drawing and interaction of a button in the user interface. It provides functionality to set the button's text, style, image, and tooltip. The `Draw` method is responsible for rendering the button on the screen and handling user input.\n\nThe `Draw` method first checks if the button should be drawn by checking the `isDraw` flag. If it is false, the method returns false and the button is not rendered. Next, it checks if a GUI style has been assigned to the button. If not, the method returns false and the button is not rendered.\n\nIf a GUI style is assigned, the method proceeds to determine the text to display on the button. It checks if the `text` field is empty and if a `textKey` has been assigned. If the `text` field is empty and a `textKey` is provided, it retrieves the localized text using the `StringMgr` class and assigns it to the `text` field.\n\nNext, the method checks if a content image has been assigned to the button. If so, it creates a `GUIContent` object with the text and image, and calls the `MyButton3` method of the `GlobalVars` instance to draw the button with the provided content, position, and style.\n\nIf a tooltip string has been assigned to the button, the method calls the `MyButton` method of the `GlobalVars` instance with the text, tooltip, position, and style to draw the button with a tooltip.\n\nIf neither a content image nor a tooltip string is assigned, the method calls the `MyButton` method of the `GlobalVars` instance with just the text, position, and style to draw a basic button.\n\nFinally, the method updates the `buttonClick` field based on whether the button was clicked or not, and returns the value of `buttonClick`.\n\nThe `SkipDraw` method simply sets `buttonClick` to false and returns it. This method is used to reset the button's click state.\n\nThe `SetText` method allows setting the text of the button externally.\n\nThe `isClick` method returns the value of `buttonClick`, indicating whether the button was clicked or not.\n\nOverall, this code provides a flexible and customizable button component for the Brick-Force user interface, allowing for different text, styles, images, and tooltips to be assigned to the button.\n## Questions: \n 1. **What is the purpose of the `UIMyButton` class?**\nThe `UIMyButton` class is a subclass of `UIBase` and is used to create buttons in a user interface. It has properties for defining the button's appearance, text, and functionality.\n\n2. **What is the purpose of the `Draw` method?**\nThe `Draw` method is responsible for rendering the button on the screen. It checks if the button should be drawn based on the `isDraw` property, sets the button's text based on the `text` and `textKey` properties, and uses the `GlobalVars` instance to draw the button with the specified style and content.\n\n3. **What is the purpose of the `SetText` method?**\nThe `SetText` method is used to set the text of the button. It takes a string parameter `_text` and assigns it to the `text` property of the button.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\UIMyButton.md"}}],["532",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\UIRegMap.cs)\n\nThe code provided is a class called `UIRegMap` that extends the `UIBase` class. This class is part of a larger project called Brick-Force and is responsible for drawing and managing the UI representation of a registered map.\n\nThe `UIRegMap` class has a member variable called `regmap` of type `RegMap`, which represents the registered map that this UI element is associated with. The `RegMap` class is not provided in the code snippet, but it can be assumed that it contains information about a registered map, such as its thumbnail, registered date, and tag mask.\n\nThe `Draw()` method is an overridden method from the `UIBase` class and is responsible for drawing the UI representation of the registered map. It first checks if the UI element is set to be drawn (`isDraw` flag). If not, it returns false. If the UI element is set to be drawn, it then checks if the `regmap` variable is not null and if it has a valid thumbnail. If these conditions are met, it uses the `TextureUtil.DrawTexture()` method to draw the thumbnail at the specified position.\n\nThe method then checks the registered date of the `regmap`. If the registered date is the same as the current date, it draws an icon representing a new map. If the `tagMask` of the `regmap` has the 8th bit set, it draws an icon representing glory. If the 4th bit is set, it draws an icon representing a medal. If the 2nd bit is set, it draws an icon representing a gold ribbon. Finally, if the `regmap` is flagged as an abuse map, it draws an icon representing a declaration of abuse.\n\nThe `SetRegMap(int id)` method sets the `regmap` variable by retrieving the `RegMap` object with the specified ID from the `RegMapManager` instance. The `SetRegMap(RegMap reg)` method sets the `regmap` variable directly with the provided `RegMap` object.\n\nThe `GetRegMapId()` method returns the ID of the `regmap` object, if it is not null. Otherwise, it returns 0.\n\nOverall, this code provides the functionality to draw the UI representation of a registered map and manage the associated `RegMap` object. It allows for setting and retrieving the `RegMap` object, as well as drawing different icons based on the properties of the `RegMap` object.\n## Questions: \n 1. What is the purpose of the `Draw()` method in the `UIRegMap` class?\n- The `Draw()` method is responsible for rendering the UI elements associated with a `RegMap` object, including its thumbnail and any additional icons based on its properties.\n\n2. What is the purpose of the `SetRegMap(int id)` method in the `UIRegMap` class?\n- The `SetRegMap(int id)` method is used to set the `regmap` variable of the `UIRegMap` object to the `RegMap` object with the specified ID.\n\n3. What does the `GetRegMapId()` method return?\n- The `GetRegMapId()` method returns the ID of the `RegMap` object associated with the `UIRegMap` object, or 0 if there is no associated `RegMap` object.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\UIRegMap.md"}}],["533",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\UIScrollView.cs)\n\nThe code provided is a class called `UIScrollView` that extends the `UIBaseList` class. It is used to create a scrollable view in a user interface. \n\nThe `UIScrollView` class has several properties and methods that are used to control the behavior of the scroll view. \n\nThe `area` property is a `Vector2` that represents the size of the scroll view area. \n\nThe `offSetY` property is a float that represents the vertical offset between items in the scroll view. \n\nThe `offSetXCount` property is an integer that represents the number of items per row in the scroll view. \n\nThe `offSetX` property is a float that represents the horizontal offset between items in the scroll view. \n\nThe `listCount` property is an integer that represents the total number of items in the scroll view. \n\nThe `scrollPoint` property is a `Vector2` that represents the current scroll position of the scroll view. \n\nThe `Draw` method is an override of the `Draw` method in the `UIBaseList` class. It checks if the scroll view can be skipped and returns the result of the `SkipDraw` method if it can be skipped, otherwise it calls the `Draw` method of the base class. \n\nThe `BeginScroll` method is used to begin the scroll view. It calculates the size of the view rectangle based on the `area`, `listCount`, `offSetXCount`, and `offSetY` properties. It then calls the `GUI.BeginScrollView` method to begin the scroll view. \n\nThe `EndScroll` method is used to end the scroll view. It simply calls the `GUI.EndScrollView` method. \n\nThe `SetListCount` method is used to set the `listCount` property. \n\nThe `GetListCount` method is used to get the value of the `listCount` property. \n\nThe `SetListPosition` method is used to set the position of an item in the scroll view based on its index. It calculates the row and column of the item based on the `offSetXCount` property and then sets the position using the `ListAddPositionX` and `ListAddPositionY` methods. \n\nThe `IsSkipAble` method is used to determine if the scroll view can be skipped. It checks if any of the items in the scroll view are outside the visible area and returns true if they are. \n\nOverall, this code provides the functionality to create a scrollable view in a user interface. It allows for setting the size and position of items in the scroll view, as well as determining if the scroll view can be skipped.\n## Questions: \n 1. What is the purpose of the `UIScrollView` class?\n- The `UIScrollView` class is a subclass of `UIBaseList` and is used to create a scrollable view in a user interface.\n\n2. What does the `BeginScroll` method do?\n- The `BeginScroll` method sets up the scroll view by defining the view rectangle and the scroll position.\n\n3. What does the `IsSkipAble` method determine?\n- The `IsSkipAble` method determines whether the scroll view can be skipped based on the current scroll position and the size of the view area.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\UIScrollView.md"}}],["534",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\UISprite.cs)\n\nThe code provided is a class called `UISprite` that inherits from the `UIBase` class. This class is used to display a series of images (textures) in a UI element, creating an animation effect. \n\nThe `UISprite` class has several properties and methods that control the behavior of the animation. \n\n- The `area` property is a `Vector2` that represents the size of the area where the image will be displayed. If the `area` is set to `Vector2.zero`, the image will be displayed at its original size. Otherwise, the image will be stretched to fit the specified area.\n\n- The `texImage` property is an array of `Texture2D` objects that represent the images to be displayed in the animation. Each image in the array represents a frame of the animation.\n\n- The `changeTime` property is a `float` that represents the time it takes to switch from one frame to another in the animation. The default value is 0.3 seconds.\n\n- The `currentTime` property is a `float` that keeps track of the current time in the animation. It is incremented by the `Update` method, which is called every frame.\n\n- The `playOnce` property is a `bool` that determines whether the animation should play only once or loop indefinitely.\n\nThe `Update` method updates the `currentTime` property by adding the time since the last frame (`Time.deltaTime`). It returns `true` to indicate that the animation is still active.\n\nThe `Draw` method is responsible for actually drawing the current frame of the animation. It checks if the animation is currently being drawn (`isDraw` property) and if there are images in the `texImage` array and a valid `changeTime` value. It calculates the current frame based on the `currentTime` and `changeTime` properties and draws the corresponding image using the `TextureUtil.DrawTexture` method.\n\nThe `ResetTime` method sets the `currentTime` property to 0, effectively resetting the animation to the beginning.\n\nThe `SetEndTime` method sets the `currentTime` property to the `changeTime` value, effectively setting the animation to the last frame.\n\nOverall, this `UISprite` class provides a way to create and control animated UI elements using a series of images. It can be used in the larger project to add visual effects and animations to the user interface.\n## Questions: \n 1. What is the purpose of the `UISprite` class and how is it used in the project?\n- The `UISprite` class is a subclass of `UIBase` and is used to display a series of images as a sprite animation. It has properties for the images, animation speed, and play options.\n\n2. What is the significance of the `changeTime` property and how does it affect the animation?\n- The `changeTime` property determines the duration between each image change in the sprite animation. It is used to calculate the current frame of the animation based on the elapsed time.\n\n3. What is the purpose of the `ResetTime` and `SetEndTime` methods?\n- The `ResetTime` method sets the `currentTime` property to 0, effectively resetting the animation to the beginning. The `SetEndTime` method sets the `currentTime` property to the value of `changeTime`, effectively setting the animation to the last frame.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\UISprite.md"}}],["535",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\UISpriteMove.cs)\n\nThe code provided is a class called `UISpriteMove` that extends the `UISprite` class. This class is used to create a moving sprite in a user interface (UI) using Unity game engine. \n\nThe `UISpriteMove` class has three member variables: `moveSpeed`, `deadTime`, and `position`. \n\n- `moveSpeed` is a `Vector2` variable that represents the speed at which the sprite moves in the UI. It has an `x` and `y` component that determines the direction and magnitude of the movement.\n- `deadTime` is a `float` variable that represents the time in seconds after which the sprite is considered \"dead\" or no longer active.\n- `position` is a member variable inherited from the `UISprite` class and represents the current position of the sprite in the UI.\n\nThe class overrides the `Update()` method from the `UISprite` class. The `Update()` method is a built-in Unity method that is called every frame to update the state of the object. In the overridden `Update()` method, the base `Update()` method is called to ensure that any necessary updates from the parent class are performed. Then, the `position` of the sprite is updated by adding the `moveSpeed` multiplied by the `Time.deltaTime` value. This ensures that the movement is frame-rate independent and consistent across different devices.\n\nThe class also has a method called `IsTimeOver()` which returns a boolean value indicating whether the current time has exceeded the `deadTime`. This method is used to determine if the sprite has been active for longer than the specified `deadTime` and should be considered \"dead\".\n\nThis class can be used in the larger project to create moving sprites in the UI. By instantiating objects of the `UISpriteMove` class and setting the `moveSpeed` and `deadTime` values, developers can create sprites that move across the screen and are automatically deactivated after a certain amount of time. For example:\n\n```csharp\nUISpriteMove movingSprite = new UISpriteMove();\nmovingSprite.moveSpeed = new Vector2(1, 0); // Move horizontally at a speed of 1 unit per second\nmovingSprite.deadTime = 5.0f; // Deactivate after 5 seconds\n\n// Update the sprite's position every frame\nvoid Update()\n{\n    if (movingSprite.Update())\n    {\n        // Sprite is still active\n        if (movingSprite.IsTimeOver())\n        {\n            // Sprite has exceeded the deadTime and should be deactivated\n            // Perform necessary actions\n        }\n    }\n}\n```\n\nIn summary, the `UISpriteMove` class provides functionality to create moving sprites in a UI using Unity game engine. It allows developers to specify the movement speed and duration of the sprite, and provides methods to update the sprite's position and check if it has exceeded the specified time limit.\n## Questions: \n 1. **What is the purpose of the `UISpriteMove` class?**\nThe `UISpriteMove` class is a subclass of `UISprite` and it adds functionality for moving the sprite based on a specified speed.\n\n2. **What does the `Update` method do?**\nThe `Update` method is an overridden method from the base class `UISprite` and it updates the position of the sprite based on the move speed and the elapsed time.\n\n3. **What is the purpose of the `IsTimeOver` method?**\nThe `IsTimeOver` method checks if the current time is greater than the specified dead time, indicating that a certain time period has elapsed.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\UISpriteMove.md"}}],["536",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\UISpriteMoveEmitter.cs)\n\nThe code provided is a class called `UISpriteMoveEmitter` that inherits from `UIBase`. This class is responsible for creating and managing a list of `UISpriteMove` objects, which are used to display moving sprites on the screen.\n\nThe `UISpriteMoveEmitter` class has several public variables that can be set to customize the behavior of the moving sprites. These variables include `deadTime` (the time it takes for a sprite to disappear), `totalArea` (the area on the screen where the sprites can be displayed), `createArea` (the area within the `totalArea` where the sprites can be created), `moveSpeed` (the speed at which the sprites move), and `scaleScope` (the range of scales that the sprites can have).\n\nThe class also has a private variable `emitTime` that determines how often a new sprite is created. The `curTime` variable keeps track of the time since the last sprite was created.\n\nThe `Update` method is called every frame and is responsible for updating the state of the sprites. It first checks if enough time has passed to create a new sprite. If so, it calls the `CreateParticle` method to create a new sprite and resets the `curTime` variable. It then iterates over the list of sprites and updates each one. If a sprite's time is over (i.e., it has reached its `deadTime`), it is removed from the list.\n\nThe `Draw` method is responsible for drawing the sprites on the screen. It first checks if drawing is enabled (`isDraw` variable) and returns false if not. It then uses the `GUI` class to begin a group within the `totalArea` and iterates over the list of sprites, calling their `Draw` method.\n\nThe `CreateParticle` method is called when a new sprite needs to be created. It creates a new `UISpriteMove` object and sets its properties based on the `sampleSprite` object. It randomly selects a scale within the `scaleScope` range, sets the move speed based on the `moveSpeed` and scale, sets the dead time based on the `deadTime` and scale, and sets the area and position based on the `createArea` and scale. Finally, it adds the new sprite to the `listSprite` list.\n\nThe `Clear` method is a private method that clears the `listSprite` list, effectively removing all sprites.\n\nIn summary, the `UISpriteMoveEmitter` class is responsible for creating and managing a list of moving sprites. It allows customization of various parameters such as speed, scale, and appearance. The class provides methods for updating and drawing the sprites, as well as creating and clearing the sprite list. This class can be used in the larger project to create dynamic and animated visual effects.\n## Questions: \n 1. What is the purpose of the `UISpriteMoveEmitter` class?\n- The `UISpriteMoveEmitter` class is responsible for emitting and managing moving sprites in a UI.\n\n2. What is the significance of the `emitTime` variable?\n- The `emitTime` variable determines the time interval at which new sprites are emitted.\n\n3. What does the `Clear()` method do?\n- The `Clear()` method clears the list of sprites, effectively removing all existing sprites from the emitter.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\UISpriteMoveEmitter.md"}}],["537",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\UITextArea.cs)\n\nThe code provided is a class called `UITextArea` that extends the `UIBase` class. It is used to create a text area UI element in a larger project called Brick-Force. \n\nThe `UITextArea` class has several properties and methods that allow for the customization and functionality of the text area. \n\nThe `area` property is a `Vector2` that represents the size of the text area. \n\nThe `controlName` property is a string that is used to set the control name for the text area. This is important for identifying and manipulating the text area in other parts of the project. \n\nThe `maxTextLength` property is an integer that represents the maximum number of characters allowed in the text area. \n\nThe `deleteSpace` property is a boolean that determines whether or not spaces should be deleted from the input text. \n\nThe `inputText` property is a string that holds the current text input in the text area. \n\nThe `Draw` method is an override of the `Draw` method from the `UIBase` class. It is responsible for rendering the text area on the screen. It first checks if the text area should be drawn by checking the `isDraw` property. If it is not set to true, the method returns false. Otherwise, it sets the control name for the text area using the `GUI.SetNextControlName` method. It then renders the text area using the `GUI.TextArea` method, passing in the position, size, current input text, and maximum text length. If the input text exceeds the maximum text length, it reverts back to the previous text. Finally, the method returns false.\n\nThe `GetInputText` method is used to retrieve the input text from the text area. It first removes any tabs from the input text using the `Replace` method. If the `deleteSpace` property is set to true, it also removes any spaces from the input text. It then returns the modified input text.\n\nThe `ResetText` method is used to reset the input text to an empty string.\n\nOverall, this code provides the functionality to create and manipulate a text area UI element in the Brick-Force project. It allows for customization of the text area's size, maximum text length, and control name. It also provides methods to retrieve the input text and reset the text area.\n## Questions: \n 1. **What is the purpose of the `UITextArea` class?**\nThe `UITextArea` class is a subclass of `UIBase` and is used to create a text area UI element in the game.\n\n2. **What does the `Draw` method do?**\nThe `Draw` method is responsible for rendering the text area UI element on the screen. It returns a boolean value indicating whether the element was successfully drawn.\n\n3. **What does the `GetInputText` method do?**\nThe `GetInputText` method returns the input text from the text area, after removing any tabs and spaces if specified.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\UITextArea.md"}}],["538",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\UITextFiled.cs)\n\nThe code provided is a class called `UITextFiled` that extends the `UIBase` class. This class is used to create a text input field in a user interface (UI) for the larger Brick-Force project.\n\nThe `UITextFiled` class has several properties and methods that control the behavior and functionality of the text input field. \n\nThe `area` property is a `Vector2` that represents the size of the text input field in the UI. \n\nThe `controlName` property is a string that represents the name of the text input field control. This is used to identify the control in the UI and can be set by the user. If the `controlName` is not set, an error message is logged.\n\nThe `maxTextLength` property is an integer that represents the maximum number of characters allowed in the text input field. If the input text exceeds this limit, it is truncated.\n\nThe `deleteSpace` property is a boolean that determines whether spaces should be deleted from the input text. If set to `true`, spaces are removed from the input text.\n\nThe `inputText` property is a string that holds the current text entered in the input field.\n\nThe `Draw` method is an override of the `Draw` method from the `UIBase` class. It is responsible for rendering the text input field in the UI. It first checks if the field should be drawn by checking the `isDraw` property. If it is not set to `true`, the method returns `false`. Otherwise, it sets the control name using `GUI.SetNextControlName` and renders the text input field using `GUI.TextField`. If the input text exceeds the maximum length, it reverts the text back to the previous value.\n\nThe `GetInputText` method is used to retrieve the current input text. It removes tabs and newlines from the text and deletes spaces if the `deleteSpace` property is set to `true`.\n\nThe `ResetText` method is used to reset the input text to an empty string.\n\nOverall, this code provides a reusable class for creating and managing text input fields in the Brick-Force project's UI. Developers can use this class to easily add text input functionality to their UI elements.\n## Questions: \n 1. **What is the purpose of the `UITextFiled` class?**\nThe `UITextFiled` class is a subclass of `UIBase` and is used to create a text field UI element in the game.\n\n2. **What does the `Draw` method do?**\nThe `Draw` method is responsible for rendering the text field UI element on the screen. It returns a boolean value indicating whether the element was successfully drawn.\n\n3. **What does the `GetInputText` method do?**\nThe `GetInputText` method returns the current input text of the text field, after performing some string replacements to remove tabs, newlines, and spaces if specified.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\UITextFiled.md"}}],["539",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\UIToggle.cs)\n\nThe code provided is a class called `UIToggle` that extends the `UIBase` class. It is used to create a toggle button in a user interface (UI) for the larger Brick-Force project. \n\nThe `UIToggle` class has several properties and methods that are relevant to its purpose. \n\n- The `area` property is a `Vector2` that represents the size of the toggle button in the UI.\n- The `textKey` property is a string that can be used to retrieve the text to be displayed on the toggle button from a localization manager.\n- The `text` property is a string that holds the actual text to be displayed on the toggle button.\n- The `toggle` property is a boolean that represents the current state of the toggle button (true for toggled on, false for toggled off).\n- The `toggleOld` property is a boolean that represents the previous state of the toggle button.\n\nThe `Draw` method is responsible for rendering the toggle button in the UI. It first checks if the toggle button should be drawn by checking the `isDraw` property. If it is not set to true, the method returns false and the toggle button is not rendered. \n\nIf the `text` property is empty and the `textKey` property is not empty, the method retrieves the text from a localization manager using the `textKey` and displays it on the toggle button. Otherwise, it displays the text from the `text` property.\n\nThe `SetText` method is used to set the value of the `text` property. This allows the text on the toggle button to be dynamically changed.\n\nThe `isChangeToggle` method is used to check if the state of the toggle button has changed since the last frame. It compares the current state (`toggle`) with the previous state (`toggleOld`) and returns true if they are different, indicating that the toggle button has been toggled.\n\nOverall, this code provides a way to create and manage toggle buttons in the UI for the Brick-Force project. It allows for dynamic text changes and provides a way to check if the toggle button has been toggled.\n## Questions: \n 1. **What is the purpose of the `UIToggle` class?**\nThe `UIToggle` class is a subclass of `UIBase` and is used to create a toggle UI element with a text label.\n\n2. **What does the `Draw` method do?**\nThe `Draw` method is responsible for rendering the toggle UI element on the screen. It checks if the toggle has a text label and uses the appropriate method to render the toggle with or without the label.\n\n3. **What is the purpose of the `isChangeToggle` method?**\nThe `isChangeToggle` method is used to check if the toggle value has changed since the last frame. It compares the current toggle value with the previous toggle value and returns a boolean indicating whether there has been a change.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\UIToggle.md"}}],["540",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\UnbreakableCapsule.cs)\n\nThe code provided is a script for an object called \"UnbreakableCapsule\" in the Brick-Force project. This script is written in C# and utilizes the Unity game engine.\n\nThe purpose of this script is to define the behavior and properties of an unbreakable capsule object in the game. The \"UnbreakableCapsule\" class inherits from the \"MonoBehaviour\" class, which is a base class provided by Unity for creating scripts that can be attached to game objects.\n\nThe main property defined in this script is a public variable called \"hitImpact\" of type \"GameObject\". This variable is used to reference a game object that represents the visual effect or impact that occurs when the unbreakable capsule is hit or interacted with in the game. By making this variable public, it can be easily accessed and assigned in the Unity editor or through other scripts.\n\nThe purpose of this script is to provide a template for creating unbreakable capsule objects in the game. By attaching this script to a game object in the Unity editor, developers can define the visual impact that occurs when the capsule is hit by assigning a game object to the \"hitImpact\" variable.\n\nHere is an example of how this script might be used in the larger project:\n\n```csharp\nusing UnityEngine;\n\npublic class GameManager : MonoBehaviour\n{\n    public GameObject unbreakableCapsulePrefab;\n\n    private void SpawnUnbreakableCapsule()\n    {\n        GameObject newCapsule = Instantiate(unbreakableCapsulePrefab, Vector3.zero, Quaternion.identity);\n        UnbreakableCapsule capsuleScript = newCapsule.GetComponent<UnbreakableCapsule>();\n        capsuleScript.hitImpact = Resources.Load<GameObject>(\"HitImpactPrefab\");\n    }\n}\n```\n\nIn this example, the \"GameManager\" script is responsible for spawning unbreakable capsules in the game. It has a public variable called \"unbreakableCapsulePrefab\" which references a prefab (a pre-configured game object) for the unbreakable capsule. When the \"SpawnUnbreakableCapsule\" method is called, it instantiates a new unbreakable capsule from the prefab and assigns a hit impact effect to its \"hitImpact\" variable. This effect is loaded from a resource called \"HitImpactPrefab\".\n\nOverall, this script provides a foundation for creating and customizing unbreakable capsules in the Brick-Force game.\n## Questions: \n 1. **What is the purpose of the `UnbreakableCapsule` class?**\nThe `UnbreakableCapsule` class appears to be a script attached to a game object in the Unity game engine. The purpose of this class is not clear from the provided code snippet alone.\n\n2. **What is the significance of the `hitImpact` variable?**\nThe `hitImpact` variable is of type `GameObject` and is declared but not used in the provided code snippet. It is unclear what role this variable plays in the functionality of the `UnbreakableCapsule` class.\n\n3. **Are there any other methods or properties in the `UnbreakableCapsule` class?**\nThe provided code snippet only shows the declaration of the `UnbreakableCapsule` class and the `hitImpact` variable. It is uncertain if there are any other methods or properties defined within this class that may affect its behavior.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\UnbreakableCapsule.md"}}],["541",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\UniformedScaler.cs)\n\nThe code provided is for a class called \"UniformedScaler\" that is a part of the larger Brick-Force project. This class is responsible for scaling a game object uniformly over time. \n\nThe class inherits from the MonoBehaviour class, which is a base class provided by the Unity game engine. This allows the class to be attached to a game object in the Unity editor and have its methods called automatically during runtime.\n\nThe class has three public variables: \"speed\", \"targetScale\", and \"base.transform.localScale\". \n\nThe \"speed\" variable determines how fast the game object will scale. It is set to a default value of 1f, but can be modified in the Unity editor or through code.\n\nThe \"targetScale\" variable is a Vector3 that represents the desired scale of the game object. This can also be modified in the Unity editor or through code.\n\nThe \"base.transform.localScale\" variable represents the current scale of the game object. It is updated in the Update() method using the Lerp() function from the Vector3 class. Lerp stands for linear interpolation and is used to smoothly transition between two values over time. In this case, it is used to gradually change the scale of the game object from its current scale to the target scale.\n\nThe Update() method is called every frame by Unity and is where the scaling logic is implemented. It uses the Lerp() function to calculate the new scale based on the current scale, target scale, and speed. The result is then assigned back to the \"base.transform.localScale\" variable, effectively scaling the game object.\n\nThis class can be used in the larger Brick-Force project to create dynamic scaling effects for game objects. For example, it could be used to gradually scale up a character model when it levels up or to create a pulsating effect on a power-up item. By attaching this script to a game object and setting the desired target scale and speed, the game object will automatically scale over time.\n## Questions: \n 1. **What does the `UniformedScaler` class do?**\nThe `UniformedScaler` class is responsible for scaling the object uniformly based on the `targetScale` vector.\n\n2. **What is the purpose of the `speed` variable?**\nThe `speed` variable determines the rate at which the object scales towards the `targetScale`.\n\n3. **What is the purpose of the `Start` method?**\nThe `Start` method is currently empty and does not have any functionality. It might be used for initialization or setting up variables in future development.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\UniformedScaler.md"}}],["542",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\UpgradeCategoryPropTable.cs)\n\nThe code provided defines a public class called `UpgradeCategoryPropTable`. This class has two properties: a string property called `name` and a boolean array property called `props`. \n\nThe purpose of this class is to represent a category of upgrade properties in the larger Brick-Force project. Each instance of the `UpgradeCategoryPropTable` class represents a specific category of upgrade properties, and the `name` property stores the name of that category. The `props` property is an array of boolean values that represents the individual properties within that category. \n\nThis class can be used in the larger project to organize and manage different categories of upgrade properties. For example, in a game where players can upgrade their characters or equipment, there may be different categories of upgrades such as \"Attack\", \"Defense\", \"Speed\", etc. Each of these categories can be represented by an instance of the `UpgradeCategoryPropTable` class, with the `name` property storing the name of the category and the `props` property storing the individual properties within that category.\n\nHere is an example of how this class could be used in the larger project:\n\n```csharp\nUpgradeCategoryPropTable attackCategory = new UpgradeCategoryPropTable();\nattackCategory.name = \"Attack\";\nattackCategory.props = new bool[] { true, false, true, false };\n\nUpgradeCategoryPropTable defenseCategory = new UpgradeCategoryPropTable();\ndefenseCategory.name = \"Defense\";\ndefenseCategory.props = new bool[] { false, true, false, true };\n```\n\nIn this example, we create two instances of the `UpgradeCategoryPropTable` class: `attackCategory` and `defenseCategory`. We set the `name` property of each instance to the respective category name, and we set the `props` property to an array of boolean values representing the individual properties within that category.\n\nOverall, the `UpgradeCategoryPropTable` class provides a way to organize and manage different categories of upgrade properties in the larger Brick-Force project.\n## Questions: \n 1. **What is the purpose of the `UpgradeCategoryPropTable` class?**\nThe `UpgradeCategoryPropTable` class appears to be a data structure that represents a category of upgrade properties. It contains a `name` property and an array of `props` which likely represent the specific properties within that category.\n\n2. **What is the data type of the `name` property?**\nThe `name` property is of type `string`, as indicated by the `public string name;` declaration.\n\n3. **What does the `props` array represent?**\nThe `props` array is of type `bool[]`, suggesting that it represents a collection of boolean values. It is likely used to store information about the availability or status of specific upgrade properties within the category.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\UpgradeCategoryPropTable.md"}}],["543",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\UpgradeChargeTable.cs)\n\nThe code provided defines a class called `UpgradeChargeTable`. This class is used to store information about the upgrade charges for different weapons in the game. \n\nThe class has several public variables, including `Level`, `AssultAtkVal`, `SubmachineAtkVal`, `SniperAtkVal`, `HeavyAtkVal`, `HandgunAtkVal`, `SpecialAtkVal`, and `Price`. \n\nThe `Level` variable represents the level of the upgrade charge. The `AssultAtkVal`, `SubmachineAtkVal`, `SniperAtkVal`, `HeavyAtkVal`, `HandgunAtkVal`, and `SpecialAtkVal` variables represent the attack values for different types of weapons at that level. The `Price` variable represents the price of the upgrade charge at that level.\n\nThis class can be used in the larger project to manage and store information about the upgrade charges for different weapons. For example, the game may have a shop where players can purchase upgrade charges for their weapons. The `UpgradeChargeTable` class can be used to store the different upgrade charges available, their attack values, and their prices. \n\nHere is an example of how this class could be used in the larger project:\n\n```java\nUpgradeChargeTable upgradeCharge = new UpgradeChargeTable();\nupgradeCharge.Level = 1;\nupgradeCharge.AssultAtkVal = 10;\nupgradeCharge.SubmachineAtkVal = 8;\nupgradeCharge.SniperAtkVal = 15;\nupgradeCharge.HeavyAtkVal = 12;\nupgradeCharge.HandgunAtkVal = 6;\nupgradeCharge.SpecialAtkVal = 20;\nupgradeCharge.Price = 100;\n\n// Display the information about the upgrade charge\nSystem.out.println(\"Level: \" + upgradeCharge.Level);\nSystem.out.println(\"Assult Attack Value: \" + upgradeCharge.AssultAtkVal);\nSystem.out.println(\"Submachine Attack Value: \" + upgradeCharge.SubmachineAtkVal);\nSystem.out.println(\"Sniper Attack Value: \" + upgradeCharge.SniperAtkVal);\nSystem.out.println(\"Heavy Attack Value: \" + upgradeCharge.HeavyAtkVal);\nSystem.out.println(\"Handgun Attack Value: \" + upgradeCharge.HandgunAtkVal);\nSystem.out.println(\"Special Attack Value: \" + upgradeCharge.SpecialAtkVal);\nSystem.out.println(\"Price: \" + upgradeCharge.Price);\n```\n\nThis code creates an instance of the `UpgradeChargeTable` class and sets the values for its variables. It then displays the information about the upgrade charge, including the level, attack values, and price. This information can be used in the game to show players the available upgrade charges and their attributes.\n## Questions: \n 1. What is the purpose of the `UpgradeChargeTable` class?\n- The `UpgradeChargeTable` class is used to store information about the level, attack values, and price of different types of weapons in the game.\n\n2. What are the different types of weapons represented by the `AssultAtkVal`, `SubmachineAtkVal`, `SniperAtkVal`, `HeavyAtkVal`, `HandgunAtkVal`, and `SpecialAtkVal` variables?\n- The `AssultAtkVal`, `SubmachineAtkVal`, `SniperAtkVal`, `HeavyAtkVal`, `HandgunAtkVal`, and `SpecialAtkVal` variables represent the attack values of different types of weapons, such as assault rifles, submachine guns, sniper rifles, heavy weapons, handguns, and special weapons.\n\n3. How is the `Price` variable used in the `UpgradeChargeTable` class?\n- The `Price` variable is used to store the price of upgrading a weapon to a certain level.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\UpgradeChargeTable.md"}}],["544",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\UpgradeProp.cs)\n\nThe code provided defines a public class called `UpgradeProp`. This class has two public properties: `use` and `grade`. \n\nThe `use` property is of type `bool`, which means it can only have two possible values: `true` or `false`. This property is used to determine whether or not the upgrade should be used. If `use` is set to `true`, it means the upgrade should be used, and if it is set to `false`, it means the upgrade should not be used.\n\nThe `grade` property is of type `int`, which means it can hold integer values. This property is used to specify the grade of the upgrade. The grade represents the level or quality of the upgrade, with higher values indicating better upgrades. The specific range of values that `grade` can hold is not defined in the provided code, so it could be any valid integer value.\n\nThis `UpgradeProp` class can be used in the larger Brick-Force project to represent upgrade properties for various game elements. For example, if the project has a game character that can be upgraded with different abilities or attributes, an instance of the `UpgradeProp` class can be created for each upgrade option. The `use` property can be used to determine whether or not the upgrade should be applied to the character, and the `grade` property can be used to specify the level or quality of the upgrade.\n\nHere is an example of how the `UpgradeProp` class can be used in code:\n\n```csharp\nUpgradeProp upgrade = new UpgradeProp();\nupgrade.use = true;\nupgrade.grade = 3;\n\nif (upgrade.use)\n{\n    // Apply the upgrade with grade 3 to the game character\n    ApplyUpgrade(upgrade.grade);\n}\n```\n\nIn this example, an instance of the `UpgradeProp` class is created and assigned to the `upgrade` variable. The `use` property is set to `true`, indicating that the upgrade should be used. The `grade` property is set to `3`, indicating that the upgrade has a grade of 3. The code then checks if the `use` property is `true`, and if so, it calls a function `ApplyUpgrade` to apply the upgrade with the specified grade to the game character.\n## Questions: \n 1. **What is the purpose of the `UpgradeProp` class?**\nThe `UpgradeProp` class appears to be a data structure that represents an upgradeable property. It contains a boolean variable `use` to indicate if the property is being used and an integer variable `grade` to represent the level or grade of the property.\n\n2. **What are the possible values for the `use` variable?**\nWithout further information, it is unclear what the possible values for the `use` variable are. It could be a simple true/false flag or it could have additional states such as \"active\" or \"inactive\".\n\n3. **What is the significance of the `grade` variable?**\nThe `grade` variable likely represents the level or grade of the upgradeable property, but it is unclear what the range of possible values is or how it is used within the codebase.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\UpgradeProp.md"}}],["545",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\UpgradePropManager.cs)\n\nThe `UpgradePropManager` class is responsible for managing the upgrade properties of a game object in the larger Brick-Force project. \n\nThe purpose of this code is to load and parse a CSV file containing upgrade properties for different categories of game objects. The loaded data is stored in the `upgradeCatTable` array, which is an array of `UpgradeCategoryPropTable` objects. Each `UpgradeCategoryPropTable` object represents a category of game objects and contains an array of boolean values representing the upgrade properties for that category.\n\nThe code provides a singleton pattern implementation through the `Instance` property, which ensures that only one instance of the `UpgradePropManager` class is created and accessed throughout the project. This allows other parts of the project to easily access the upgrade properties.\n\nThe `LoadAll` method is responsible for loading the upgrade properties. It first checks if the game is running in a web player environment or not. If it is, it starts a coroutine `LoadAllFromWWW` to load the properties from a web server. Otherwise, it calls the `LoadUpgradePropTableFromLocalFileSystem` method to load the properties from the local file system.\n\nThe `LoadAllFromWWW` method uses a `WWW` object to download the upgrade properties CSV file from a specified URL. It then uses a `CSVLoader` object to parse the downloaded data and populate the `upgradeCatTable` array.\n\nThe `LoadUpgradePropTableFromLocalFileSystem` method loads the upgrade properties CSV file from the local file system using a `CSVLoader` object. If the file is not found or fails to load, it logs an error message. If the file is successfully loaded, it saves a secured version of the file and then calls the `ParseUpgradePropTable` method to populate the `upgradeCatTable` array.\n\nThe `UseProp` method is a utility method that takes a category index and a property index as parameters and returns the corresponding upgrade property value from the `upgradeCatTable` array.\n\nOverall, this code provides a way to load and manage upgrade properties for different categories of game objects in the Brick-Force project. Other parts of the project can use the `UpgradePropManager.Instance` property to access and use these upgrade properties.\n## Questions: \n **Question 1:** What is the purpose of the `UpgradePropManager` class?\n    \n**Answer:** The `UpgradePropManager` class is responsible for managing upgrade properties in the game.\n\n**Question 2:** How does the `LoadAll` method determine whether to load upgrade properties from the web or from the local file system?\n    \n**Answer:** The `LoadAll` method checks the `isWebPlayer` property of the `Property` class from the `BuildOption.Instance.Props` instance to determine whether to load from the web or from the local file system.\n\n**Question 3:** What is the purpose of the `UseProp` method and how does it determine which upgrade property to use?\n    \n**Answer:** The `UseProp` method returns a boolean value indicating whether a specific upgrade property should be used. It determines which upgrade property to use based on the `cat` and `prop` parameters, which are used as indices to access the `props` array in the `upgradeCatTable`.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\UpgradePropManager.md"}}],["546",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\UpgradeTable.cs)\n\nThe code provided defines a class called `UpgradeTable`. This class is used to represent an upgrade table for a game called Brick-Force. \n\nThe `UpgradeTable` class has several public variables that store different values related to the upgrade table. These variables include `Level`, `AssultAtkVal`, `SubmachineAtkVal`, `SniperAtkVal`, `HeavyAtkVal`, `HandgunAtkVal`, `SpecialAtkVal`, and `Price`. \n\nThe `Level` variable is an integer that represents the level of the upgrade table. The `AssultAtkVal`, `SubmachineAtkVal`, `SniperAtkVal`, `HeavyAtkVal`, `HandgunAtkVal`, and `SpecialAtkVal` variables are floats that represent the attack values for different types of weapons in the game. The `Price` variable is an integer that represents the price of the upgrade table.\n\nThis class can be used in the larger Brick-Force project to store and manage upgrade table data. For example, the game may have multiple upgrade tables with different levels and attack values. The `UpgradeTable` class can be used to create instances of these upgrade tables and store their data.\n\nHere is an example of how the `UpgradeTable` class can be used in the Brick-Force project:\n\n```csharp\nUpgradeTable upgradeTable = new UpgradeTable();\nupgradeTable.Level = 1;\nupgradeTable.AssultAtkVal = 10.5f;\nupgradeTable.SubmachineAtkVal = 8.2f;\nupgradeTable.SniperAtkVal = 15.3f;\nupgradeTable.HeavyAtkVal = 12.7f;\nupgradeTable.HandgunAtkVal = 6.9f;\nupgradeTable.SpecialAtkVal = 9.8f;\nupgradeTable.Price = 100;\n\n// Use the upgrade table data in the game\nint level = upgradeTable.Level;\nfloat assaultAttackValue = upgradeTable.AssultAtkVal;\nfloat submachineAttackValue = upgradeTable.SubmachineAtkVal;\nfloat sniperAttackValue = upgradeTable.SniperAtkVal;\nfloat heavyAttackValue = upgradeTable.HeavyAtkVal;\nfloat handgunAttackValue = upgradeTable.HandgunAtkVal;\nfloat specialAttackValue = upgradeTable.SpecialAtkVal;\nint price = upgradeTable.Price;\n```\n\nIn this example, an instance of the `UpgradeTable` class is created and its variables are set with some sample values. These values can then be used in the game to determine the attack values and price of the upgrade table.\n## Questions: \n 1. **What is the purpose of the UpgradeTable class?**\nThe UpgradeTable class appears to be a data structure that holds various attributes related to upgrades, such as attack values and price. However, without further context, it is unclear how this class is used within the project.\n\n2. **What does the \"Level\" attribute represent?**\nThe \"Level\" attribute is an integer, but it is not clear what it represents. It could potentially indicate the level or rank of the upgrade, but this would need to be confirmed by reviewing the code that interacts with this class.\n\n3. **What are the different types of attacks represented by the \"AtkVal\" attributes?**\nThe code includes several float attributes with names like \"AssultAtkVal\" and \"SniperAtkVal\". It is unclear what these attributes represent and how they are used within the project. Further clarification or code analysis would be needed to understand their purpose.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\UpgradeTable.md"}}],["547",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\UPGRADE_CAT.cs)\n\nThe code provided is an enumeration called `UPGRADE_CAT` that represents different categories of upgrades in the Brick-Force project. \n\nAn enumeration is a way to define a set of named values, in this case, the different categories of upgrades. Each value in the enumeration represents a specific category, such as \"HEAVY\", \"ASSAULT\", \"SNIPER\", and so on. \n\nThis enumeration is likely used throughout the project to categorize and organize different types of upgrades. It provides a convenient and consistent way to refer to these categories in the code. \n\nFor example, if there is a class or method that needs to handle upgrades, it can use the `UPGRADE_CAT` enumeration to specify the category of the upgrade it is working with. This makes the code more readable and maintainable, as developers can easily understand what category of upgrade is being referred to.\n\nHere is an example of how this enumeration might be used in the larger project:\n\n```java\npublic class Upgrade {\n    private String name;\n    private UPGRADE_CAT category;\n\n    public Upgrade(String name, UPGRADE_CAT category) {\n        this.name = name;\n        this.category = category;\n    }\n\n    // Other methods and properties of the Upgrade class...\n\n    public void applyUpgrade(Player player) {\n        switch (category) {\n            case HEAVY:\n                player.increaseHealth(10);\n                break;\n            case ASSAULT:\n                player.increaseDamage(5);\n                break;\n            case SNIPER:\n                player.increaseAccuracy(0.1);\n                break;\n            // Handle other categories...\n            default:\n                // Handle unknown or unsupported categories...\n                break;\n        }\n    }\n}\n```\n\nIn this example, the `Upgrade` class has a `category` property of type `UPGRADE_CAT`. When an upgrade is created, its category is specified using one of the values from the `UPGRADE_CAT` enumeration.\n\nThe `applyUpgrade` method then uses a switch statement to apply the appropriate effects to the player based on the category of the upgrade. For example, if the upgrade is in the \"HEAVY\" category, it might increase the player's health by 10.\n\nOverall, the `UPGRADE_CAT` enumeration provides a way to categorize and organize different types of upgrades in the Brick-Force project, making the code more readable and maintainable.\n## Questions: \n 1. **What is the purpose of this enum?**\nThe enum appears to define different categories of upgrades in the game Brick-Force, such as heavy, assault, sniper, etc.\n\n2. **What is the significance of the \"MAX\" value?**\nThe \"MAX\" value at the end of the enum may indicate the maximum number of upgrade categories allowed in the game.\n\n3. **Are there any specific rules or restrictions for using this enum?**\nWithout further context, it is unclear if there are any specific rules or restrictions for using this enum, such as whether certain categories can only be used in certain contexts or if there are any dependencies between categories.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\UPGRADE_CAT.md"}}],["548",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\UserMapInfo.cs)\n\nThe code provided is a class called `UserMapInfo` that represents information about a user-created map in the Brick-Force project. This class is responsible for storing and managing various properties of a user map, such as its slot number, alias, brick count, last modified date, premium status, and thumbnail image.\n\nThe `UserMapInfo` class has several properties and methods that allow for the retrieval and manipulation of these properties. \n\nThe `Thumbnail` property is a getter and setter for the thumbnail image of the map. If the `regMap` (a reference to a `RegMap` object) has a non-null thumbnail, it is returned. Otherwise, if the `thumbnail` property is null and the `alias` property has a length greater than 0 and the `lastModified` property has a year greater than 1971, the `ThumbnailDownloader` class is used to enqueue a download of the thumbnail image. The `Thumbnail` property returns the `thumbnail` property.\n\nThe `Slot` property is a getter that returns the `slot` property.\n\nThe `Alias` property is a getter and setter for the `alias` property.\n\nThe `BrickCount` property is a getter and setter for the `brickCount` property.\n\nThe `LastModified` property is a getter and setter for the `lastModified` property.\n\nThe `IsPremium` property is a getter that returns a boolean indicating whether the map is premium based on the `premium` property.\n\nThe `Premium` property is a getter and setter for the `premium` property.\n\nThe `UserMapInfo` class has two constructors. The first constructor takes a slot number and premium status as parameters and initializes the `slot`, `alias`, and `premium` properties. If the slot number is greater than 0, it assigns the corresponding `RegMap` object to the `regMap` property using the `AssignRegMap` method.\n\nThe second constructor takes a slot number, alias, brick count, last modified date, and premium status as parameters and initializes all the corresponding properties. If the slot number is greater than 0, it assigns the corresponding `RegMap` object to the `regMap` property using the `AssignRegMap` method.\n\nThe `AssignRegMap` method is used to assign a `RegMap` object to the `regMap` property.\n\nThe `VerifySavedData` method checks if the `alias` property has a length greater than 0, the `thumbnail` property is null, and the `lastModified` property has a year less than or equal to 1971. If these conditions are met, it resets the `alias` property to an empty string and sets the `brickCount` property to 0.\n\nThe `LoadCache` method attempts to load cached data for the map. It checks if the cache directory exists and if the cache file exists. If both conditions are met, it calls the `Load` method to load the data from the cache file.\n\nThe `SaveCache` method attempts to save the map data to the cache. It checks if the cache directory exists and if it doesn't, it creates it. Then it calls the `Save` method to save the data to the cache file.\n\nThe `Save` method is a private method that takes a file name as a parameter and attempts to save the map data to the specified file. It opens the file in write mode, creates a `BinaryWriter` object, and writes the various properties of the map to the file. If an exception occurs during the process, it logs an error message and returns false. Otherwise, it returns true.\n\nThe `Load` method is a private method that takes a file name as a parameter and attempts to load the map data from the specified file. It opens the file in read mode, creates a `BinaryReader` object, and reads the various properties of the map from the file. If an exception occurs during the process, it logs an error message and returns false. Otherwise, it returns true.\n\nIn summary, the `UserMapInfo` class is responsible for storing and managing information about a user-created map in the Brick-Force project. It provides methods for loading and saving map data to a cache, as well as properties for accessing and modifying the map's properties.\n## Questions: \n 1. What is the purpose of the `UserMapInfo` class?\n- The `UserMapInfo` class is used to store information about a user-created map, such as its slot, alias, brick count, last modified date, premium status, and thumbnail.\n\n2. What is the purpose of the `LoadCache` method?\n- The `LoadCache` method is used to load cached data for a user map from a file. It checks if the cache file exists and returns `true` if it does, indicating that the cache was successfully loaded.\n\n3. What is the purpose of the `Save` method?\n- The `Save` method is used to save the `UserMapInfo` data to a cache file. It writes the slot, alias, brick count, last modified date, and thumbnail (if it exists) to the file.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\UserMapInfo.md"}}],["549",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\UserMenu.cs)\n\nThe code provided is a class called \"UserMenu\" that extends the \"Dialog\" class. This class is responsible for displaying a user menu dialog in the game. The user menu dialog provides various options and actions that can be performed on a specific user.\n\nThe class has several private variables, including \"target\" which represents the user's ID, \"targetNickname\" which represents the user's nickname, \"isClanInvitable\" which indicates whether the user can be invited to a clan, \"isMasterAssign\" which indicates whether the user can be assigned as a master, and \"crdBtnBase\" which represents the base position and size of the buttons in the dialog.\n\nThe class has a public \"offset\" variable that determines the vertical spacing between buttons in the dialog.\n\nThe class overrides the \"Start\" method from the base \"Dialog\" class, where it sets the ID of the dialog to \"USER_MENU\".\n\nThe class also overrides the \"DoDialog\" method from the base \"Dialog\" class, which is responsible for rendering and handling user interactions with the dialog. The method first checks if the target user is valid and not the current user. If so, it returns true, indicating that the dialog should be closed.\n\nThe method then proceeds to render the buttons in the dialog based on various conditions and user permissions. For example, if the user is in a room, it displays an \"INVITE_MENU\" button that sends an invitation to the target user. If the user is not in a room, it displays a \"JOIN_MENU\" button that sends a following request to the target user.\n\nThe method also displays buttons for adding/removing the target user as a friend or banning/unbanning the target user. These buttons are only displayed if the target user is not already a friend or banned.\n\nAdditionally, if the current user is a clan staff member and the target user can be invited to a clan, a \"CLAN_INVITATION\" button is displayed. If the target user can be assigned as a master, a \"MASTER_ASSIGN\" button is displayed.\n\nThe method also displays a \"WHISPER\" button that allows the user to send a private message to the target user. It also displays a \"SEND_MEMO\" button that opens a memo dialog for the user to send a memo to the target user.\n\nFinally, the method displays a \"REPORT_GM_TITLE_01\" button if the game's build options allow it. This button opens an accusation dialog to report the target user to a game master.\n\nThe class also includes a private method called \"RecalcButtonWidth\" that calculates the width of the buttons based on their text content. This method is called during the initialization of the dialog to ensure that the buttons have appropriate widths.\n\nThe class also overrides the \"OnPopup\" method from the base \"Dialog\" class, where it sets the position of the dialog based on the screen size.\n\nThe class includes a public method called \"InitDialog\" that initializes the dialog with the target user's information and recalculates the button widths. This method is called before displaying the dialog.\n\nIn summary, the \"UserMenu\" class is responsible for rendering and handling user interactions with a user menu dialog in the game. The dialog provides various options and actions that can be performed on a specific user, such as inviting them to a room, adding/removing them as a friend, banning/unbanning them, sending private messages, and more. The class ensures that the dialog is displayed correctly and handles the corresponding actions when the user interacts with the buttons.\n## Questions: \n 1. What is the purpose of the `UserMenu` class?\n- The `UserMenu` class is a subclass of `Dialog` and represents a user menu dialog in the game.\n\n2. What are the conditions for displaying the different buttons in the `DoDialog` method?\n- The buttons displayed depend on the value of `target`, whether the current room info is available, and whether the target is a friend or banned.\n\n3. What is the purpose of the `RecalcButtonWidth` method?\n- The `RecalcButtonWidth` method calculates the width of the buttons based on the text content and adjusts the `crdBtnBase` width accordingly.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\UserMenu.md"}}],["550",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\UskManager.cs)\n\nThe code provided is for a class called `UskManager` in the Brick-Force project. This class is responsible for managing a dictionary of textures, where each texture is associated with a unique key. The purpose of this class is to provide a centralized location for adding, retrieving, and clearing textures.\n\nThe `UskManager` class has a private dictionary variable called `dic` which stores the textures. The dictionary is initialized in the `Awake()` method using the `new` keyword. The `Awake()` method is a Unity callback method that is called when the script instance is being loaded. The `Object.DontDestroyOnLoad(this)` line ensures that the `UskManager` object is not destroyed when a new scene is loaded.\n\nThe class also has a public boolean variable `bLoaded` which is not used in the provided code snippet. It is unclear what its purpose is in the larger project.\n\nThe class has a private static variable `_instance` which is used to implement the Singleton design pattern. The Singleton pattern ensures that only one instance of the `UskManager` class exists throughout the project. The `Instance` property is a getter that returns the `_instance` variable. If `_instance` is null, it tries to find an existing instance of `UskManager` using `Object.FindObjectOfType`. If no instance is found, it logs an error message. This ensures that there is always a valid instance of `UskManager` available for use.\n\nThe class provides three public methods: `Add()`, `Get()`, and `Clear()`. The `Add()` method takes a key and a texture as parameters, converts the key to lowercase, and adds the key and texture to the dictionary if the key does not already exist. The `Get()` method takes a key as a parameter, converts it to lowercase, and returns the associated texture if the key exists in the dictionary. If the key does not exist, it returns null. The `Clear()` method clears the dictionary if it is not null and contains any elements.\n\nOverall, the `UskManager` class provides a convenient way to manage and access textures in the Brick-Force project. Other parts of the project can use the `UskManager.Instance` property to access the singleton instance and add, retrieve, or clear textures as needed. For example:\n\n```csharp\nUskManager.Instance.Add(\"key1\", texture1);\nTexture texture = UskManager.Instance.Get(\"key1\");\nUskManager.Instance.Clear();\n```\n## Questions: \n 1. **What is the purpose of the `UskManager` class?**\nThe `UskManager` class is responsible for managing a dictionary of textures, allowing for adding, retrieving, and clearing textures based on a given key.\n\n2. **What is the significance of the `Instance` property?**\nThe `Instance` property provides a way to access a singleton instance of the `UskManager` class. It ensures that only one instance of the class exists and can be accessed globally.\n\n3. **Why is the `Awake()` method used in this code?**\nThe `Awake()` method is used to initialize the `dic` dictionary and ensure that the `UskManager` object is not destroyed when a new scene is loaded.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\UskManager.md"}}],["551",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\UVAnimation.cs)\n\nThe code provided is a script called \"UVAnimation\" that is used in the larger Brick-Force project. This script is responsible for animating the UV coordinates of a material in Unity. UV coordinates determine how textures are mapped onto 3D objects.\n\nThe script contains a public enum called \"SCROLL_DIR\" which defines three options: X, Y, and XY. This enum is used to specify the direction in which the UV coordinates should scroll. The default value is set to XY.\n\nThe script also has a public float variable called \"speed\" which determines the speed of the scrolling animation. The default value is set to 1.\n\nIn the Start() method, the script retrieves the Material component attached to the game object and assigns it to the private variable \"_mat\". If no material is found, an error message is logged.\n\nIn the Update() method, the script calculates the new UV offset based on the current time and the specified scroll direction and speed. The UV offset is then applied to the material using the \"_MainTex\" texture property. This creates the scrolling effect on the material.\n\nAdditionally, the script modifies the alpha value of the material's color based on the current time. This creates a pulsating effect on the material.\n\nHere is an example of how this script can be used in the larger Brick-Force project:\n\n1. Attach the \"UVAnimation\" script to a game object that has a material with a texture.\n2. Set the desired scroll direction and speed in the script's inspector.\n3. Run the game and observe the scrolling and pulsating effect on the material.\n\nThis script can be used to add dynamic and visually appealing animations to materials in the Brick-Force project, enhancing the overall visual experience of the game.\n## Questions: \n 1. What does the `SCROLL_DIR` enum represent and how is it used in the code?\n- The `SCROLL_DIR` enum represents the direction of scrolling for the UV animation. It is used to determine which axis to apply the scrolling effect on.\n\n2. What is the purpose of the `_mat` variable and how is it initialized?\n- The `_mat` variable is used to store the material of the object. It is initialized in the `Start()` method by assigning it the value of `base.renderer.material`.\n\n3. How is the UV animation effect achieved in this code?\n- The UV animation effect is achieved by modifying the texture offset of the material based on the current time. The `Update()` method calculates the new offset values based on the `scrollDir` and `speed` variables, and then sets the new offset using `_mat.SetTextureOffset()`.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\UVAnimation.md"}}],["552",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\VersionTextureManager.cs)\n\nThe `VersionTextureManager` class is a script that manages the textures used in the Brick-Force project. It is responsible for handling the textures for building objects, seasonal objects, and movie publishing. \n\nThe class has several public variables, including `buildObject`, `seasonObject`, `buildTexture`, `seasonTexture`, and `moviePublisher`. These variables are used to reference the game objects and textures that will be managed by the `VersionTextureManager`.\n\nThe class also has a private static variable `_instance` and a public static property `Instance`. This property provides a way to access the `VersionTextureManager` instance from other scripts. The `Instance` property uses the singleton pattern to ensure that only one instance of the `VersionTextureManager` is created. If there is no existing instance, it will attempt to find one using `Object.FindObjectOfType`. If no instance is found, an error message will be logged.\n\nThe `Awake` method is called when the script is first loaded. It uses `Object.DontDestroyOnLoad` to ensure that the `VersionTextureManager` object persists between scene changes. This is important because the textures managed by the `VersionTextureManager` should remain consistent throughout the game.\n\nThe `Start` method is called after the script is initialized. It retrieves the `ArmorTexture` component from the `buildObject` and assigns it to the `buildTexture` variable. Similarly, it retrieves the `SeasonTexture` component from the `seasonObject` and assigns it to the `seasonTexture` variable. These components are responsible for managing the textures for building objects and seasonal objects, respectively.\n\nIn summary, the `VersionTextureManager` class is responsible for managing the textures used in the Brick-Force project. It ensures that only one instance of the manager is created and provides a way to access that instance from other scripts. It also initializes the textures for building objects and seasonal objects. This class plays a crucial role in maintaining consistency and managing the textures throughout the game.\n## Questions: \n 1. What is the purpose of the `VersionTextureManager` class?\n- The `VersionTextureManager` class is responsible for managing version textures in the game.\n\n2. What is the significance of the `buildObject` and `seasonObject` variables?\n- The `buildObject` and `seasonObject` variables are GameObjects that are used to retrieve the `ArmorTexture` and `SeasonTexture` components, respectively.\n\n3. What is the purpose of the `Awake()` and `Start()` methods?\n- The `Awake()` method ensures that the `VersionTextureManager` object is not destroyed when a new scene is loaded, while the `Start()` method initializes the `buildTexture` and `seasonTexture` variables by retrieving the corresponding components from the `buildObject` and `seasonObject`.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\VersionTextureManager.md"}}],["553",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\VfxOptimizer.cs)\n\nThe `VfxOptimizer` class is a script that is part of the Brick-Force project. Its purpose is to optimize the visual effects (VFX) in the game by controlling the creation and rendering of various VFX objects.\n\nThe class contains an enumeration called `VFX_TYPE`, which defines different types of VFX that can be created. These types include shell, muzzle fire, bullet trail, bullet mark, bullet impact, and shell2. \n\nThe class also has an array of `GameObject` called `impacts`, which represents the different impact effects that can be created. Additionally, there is an array of strings called `layers`, which represents the layers that the impact effects can be associated with.\n\nThe class has a dictionary called `dicImpact`, which maps layer numbers to impact effects. This allows for easy retrieval of the impact effect associated with a specific layer.\n\nThe class has a private float array called `deltaTimes`, which stores the time elapsed since the last creation of each VFX type. The `deltaMax` variable represents the maximum time interval allowed between VFX creations.\n\nThe class has a reference to the main camera in the scene, stored in the `cam` variable. This is used to determine if a VFX should be created based on its position relative to the camera.\n\nThe class has a static instance of itself called `Instance`, which can be accessed through a static property. This allows other scripts to easily access the `VfxOptimizer` instance and use its methods.\n\nThe `Awake` method initializes the `dicImpact` dictionary and ensures that the `VfxOptimizer` object is not destroyed when a new scene is loaded.\n\nThe `Start` method initializes the `deltaTimes` array based on the current quality settings. It also populates the `dicImpact` dictionary with the impact effects associated with their respective layers.\n\nThe `VerifyCamera` method checks if the `cam` variable is null and tries to find the main camera in the scene if it is. This is necessary for determining if a VFX should be created based on its position relative to the camera.\n\nThe `Update` method updates the `deltaTimes` array by adding the elapsed time since the last frame. This is used to control the creation rate of each VFX type.\n\nThe `SetupCamera` method is used to manually set the `cam` variable. It finds the main camera in the scene and assigns it to the `cam` variable.\n\nThe `CreateFx` method is used to create a VFX object based on the provided prefab, position, rotation, and VFX type. It checks if the creation conditions are met, such as the prefab and camera being non-null, the position being in front of the camera, and the elapsed time since the last creation being greater than the maximum allowed time interval.\n\nThe `CreateFxImmediate` method is similar to `CreateFx`, but it does not check the elapsed time since the last creation. This allows for immediate creation of the VFX object without any delay.\n\nThe `GetImpact` method is used to retrieve the impact effect associated with a specific layer. It looks up the layer in the `dicImpact` dictionary and returns the associated impact effect.\n\nIn summary, the `VfxOptimizer` class is responsible for optimizing the creation and rendering of VFX objects in the Brick-Force game. It controls the creation rate of different VFX types based on elapsed time and camera position. It also provides methods for creating VFX objects and retrieving impact effects based on layer numbers.\n## Questions: \n 1. What is the purpose of the `VfxOptimizer` class?\n- The `VfxOptimizer` class is responsible for optimizing visual effects (VFX) in the game.\n\n2. How does the `VfxOptimizer` determine the maximum delta time for each quality level?\n- The `VfxOptimizer` determines the maximum delta time based on the current quality level set in the `QualitySettings`.\n\n3. What is the purpose of the `VerifyCamera` method?\n- The `VerifyCamera` method is used to check if the `cam` variable is null and assign it the reference to the main camera if it exists.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\VfxOptimizer.md"}}],["554",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\VoiceManager.cs)\n\nThe `VoiceManager` class is a script that manages audio clips in the Brick-Force project. It provides methods to add, retrieve, and play audio clips. \n\nThe class has two dictionaries, `dic` and `dic2`, which are used to store audio clips. The `Add` and `Add2` methods are used to add audio clips to the dictionaries. The `Get` and `Get2` methods are used to retrieve audio clips from the dictionaries based on a given key. The keys are converted to lowercase before performing the dictionary lookup.\n\nThe `Play0`, `Play`, and `Play2` methods are used to play audio clips. The `Play0` method retrieves an audio clip using the `Get` method and plays it using the `PlaySound` method from the `GlobalVars` class. The `Play` method checks if the player is a \"Yang\" player using the `IsYang` property from the `MyInfoManager` class. If the player is a \"Yang\" player, it calls the `Play2` method to play the audio clip. Otherwise, it behaves the same as the `Play0` method. The `Play2` method retrieves an audio clip using the `Get2` method and plays it using the `PlaySound` method from the `GlobalVars` class.\n\nThe `Clear` and `Clear2` methods are used to clear the dictionaries. They check if the dictionaries are not null and have elements before clearing them.\n\nThe `Awake` method is called when the script is initialized. It initializes the dictionaries and ensures that the `VoiceManager` object is not destroyed when a new scene is loaded using the `DontDestroyOnLoad` method.\n\nOverall, the `VoiceManager` class provides a centralized way to manage audio clips in the Brick-Force project. It allows for adding, retrieving, and playing audio clips, and provides separate dictionaries for different types of audio clips. The class also includes methods to clear the dictionaries and ensures that the `VoiceManager` object persists across scene changes.\n## Questions: \n 1. What is the purpose of the `VoiceManager` class?\n- The `VoiceManager` class is responsible for managing audio clips and playing them in the game.\n\n2. What is the difference between `dic` and `dic2`?\n- `dic` and `dic2` are both dictionaries that store audio clips, but they are separate instances and likely serve different purposes within the code.\n\n3. What is the significance of the `Play0`, `Play`, and `Play2` methods?\n- The `Play0`, `Play`, and `Play2` methods are used to play audio clips. `Play0` and `Play2` directly use the `Get` and `Get2` methods to retrieve the audio clip, while `Play` checks if a specific condition is met before playing the audio clip.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\VoiceManager.md"}}],["555",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\VoteBanishDialog.cs)\n\nThe code provided is a class called `VoteBanishDialog` that extends the `Dialog` class. This class represents a dialog box that is used for voting to banish a player from a game room. \n\nThe purpose of this code is to handle the functionality and display of the banish voting dialog. It contains various UI elements such as image lists, label lists, gauges, buttons, and labels that are used to display information and interact with the user. \n\nThe `Start()` method sets the `id` of the dialog to a specific value from the `DialogManager` class. The `OnPopup()` method calculates the position of the dialog box based on the screen size. The `InitDialog()` method is empty and does not have any functionality. The `Update()` method updates the `timeFlicker` object, which is responsible for flickering the color of the time remaining label.\n\nThe `DoDialog()` method is the main method that is called to display and handle the banish voting dialog. It first checks if there is an active vote in the `RoomManager` class. If there is no active vote, the method returns `true`, indicating that the dialog should be closed.\n\nIf there is an active vote, the method proceeds to draw and update all the UI elements of the dialog. It sets the text of various labels based on the information from the `VoteStatus` object obtained from the `RoomManager`. It also sets the values of the gauges based on the vote counts.\n\nThe method then checks for user interaction with the dialog. If the user clicks the exit button or presses the escape key, the method sets the `result` variable to `true`, indicating that the dialog should be closed. If the user clicks the ok button, the method sends a kickout vote request with a `yes` value of `true` to the server using the `CSNetManager` class. If the user clicks the cancel button, the method sends a kickout vote request with a `yes` value of `false` to the server.\n\nFinally, the method checks if there is any other active popup dialog and consumes the event if there is none. It then restores the original GUI skin and returns the `result` variable.\n\nIn the larger project, this code is likely used to handle the banish voting functionality in the game room. It provides a user interface for players to vote on whether to banish a specific player from the game. The code handles the display of the dialog and the interaction with the user, as well as the communication with the server to send the vote requests.\n## Questions: \n 1. What is the purpose of the `InitDialog()` method?\n- The purpose of the `InitDialog()` method is not clear from the provided code. It is an empty method and does not have any implementation.\n\n2. What does the `DoDialog()` method do?\n- The `DoDialog()` method is responsible for drawing and updating the UI elements of the VoteBanishDialog. It also handles user interactions with the UI elements and sends corresponding network requests.\n\n3. What is the significance of the `id` variable in the `Start()` method?\n- The `id` variable is set to `DialogManager.DIALOG_INDEX.VOTE_BANISH` in the `Start()` method. The significance of this variable is not clear from the provided code, as its usage is not shown.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\VoteBanishDialog.md"}}],["556",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\VoteStatus.cs)\n\nThe code provided is a class called `VoteStatus` that represents the status of a vote in the larger Brick-Force project. This class contains various properties and methods that are used to manage and retrieve information about a vote.\n\nThe properties of the `VoteStatus` class include `yes`, `no`, `total`, `reason`, `target`, `targetNickname`, `isVoteAble`, `isVoted`, `remainTime`, and `makeTime`. These properties store information such as the number of \"yes\" and \"no\" votes, the total number of votes, the reason for the vote, the target of the vote, the nickname of the target, whether the vote is able to be cast, whether the user has already voted, the remaining time for the vote, and the time the vote was made.\n\nThe `GetVoteReason()` method is used to retrieve the reason for the vote. It checks the `reason` property and appends the corresponding reason strings to a `text` variable. The method uses a `flag` variable to determine if a comma should be added before appending the reason string. The method then returns the `text` variable.\n\nThe `IsReason()` method is a private helper method that checks if a specific vote reason is present in the `reason` property. It performs a bitwise AND operation between the `reason` property and the specified `voteReason` parameter. If the result is not zero, it means that the specific vote reason is present and the method returns `true`.\n\nThe `SetMakeTime()` method is used to set the `makeTime` property to the current time using the `Time.time` property from the Unity engine.\n\nThe `GetRemainTime()` method calculates and returns the remaining time for the vote. It subtracts the difference between the current time (`Time.time`) and the `makeTime` property from the `remainTime` property. The result is divided by 1000 to convert it from milliseconds to seconds.\n\nOverall, this `VoteStatus` class provides functionality to manage and retrieve information about a vote in the Brick-Force project. It allows users to check the vote status, retrieve the reason for the vote, and calculate the remaining time for the vote.\n## Questions: \n 1. What is the purpose of the `VoteStatus` class?\n- The `VoteStatus` class is used to store information related to a vote, such as the number of yes and no votes, the total number of votes, the reason for the vote, the target of the vote, and other related properties.\n\n2. What is the purpose of the `GetVoteReason()` method?\n- The `GetVoteReason()` method is used to generate a string that represents the reasons for the vote. It checks the `reason` property and appends the corresponding reason strings based on the value of `reason`.\n\n3. What is the purpose of the `SetMakeTime()` and `GetRemainTime()` methods?\n- The `SetMakeTime()` method is used to set the `makeTime` property to the current time. The `GetRemainTime()` method calculates and returns the remaining time for the vote by subtracting the elapsed time since `makeTime` from `remainTime`.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\VoteStatus.md"}}],["557",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\WaitQueueDialog.cs)\n\nThe code provided is a class called `WaitQueueDialog` that extends the `Dialog` class. This class is used to create a dialog box that displays a message and a cancel button. \n\nThe `WaitQueueDialog` class has several properties and methods that control the behavior and appearance of the dialog box. \n\nThe `sizeOk` property is a `Vector2` that represents the size of the cancel button. \n\nThe `msgY` property is a float that represents the y-coordinate of the message text within the dialog box. \n\nThe `waiting` property is an integer that represents the number of items in the queue. It has a getter and setter method. \n\nThe `Start` method sets the `id` property of the dialog to a specific value from an enum called `DIALOG_INDEX`. \n\nThe `DoDialog` method is responsible for rendering the dialog box and handling user input. It first sets the GUI depth to 0 and assigns a GUI skin from an instance of `GUISkinFinder`. It then creates a string that combines a localized string from an instance of `StringMgr` with the value of the `waiting` property. The `LabelUtil.TextOut` method is called to display the message text at a specific position on the screen. \n\nNext, it checks if the cancel button is pressed using the `MyButton` method from an instance of `GlobalVars`. If the button is pressed, it finds a game object called \"Main\" and sends a message to it to handle a login failure. It also clears an instance of `CSNetManager` and sets the `result` variable to true. \n\nThe method then checks if there is a popup menu open using an instance of `ContextMenuManager`. If there is no popup menu, it calls the `WindowUtil.EatEvent` method. Finally, it returns the value of the `result` variable. \n\nThe `OnPopup` method is called when the dialog is opened as a popup. It sets the `size.x` property to the width of the screen and calculates the position of the dialog box based on the screen size. \n\nThe `InitDialog` method is empty and does not have any functionality. \n\nIn the larger project, this code can be used to create a dialog box that displays a message and a cancel button. It can be used to inform the user about the number of items in a queue and allow them to cancel the operation if needed. The `WaitQueueDialog` class can be instantiated and used in other parts of the project to display this dialog box when necessary.\n## Questions: \n 1. What is the purpose of the `WaitQueueDialog` class?\n- The `WaitQueueDialog` class is a subclass of the `Dialog` class and represents a dialog box for displaying a waiting queue.\n\n2. What is the significance of the `waiting` variable and its corresponding property?\n- The `waiting` variable represents the number of items in the waiting queue, and the property allows getting and setting the value of `waiting`.\n\n3. What is the purpose of the `DoDialog` method?\n- The `DoDialog` method is responsible for rendering the dialog box and handling user interactions, such as clicking the cancel button. It returns a boolean value indicating whether the dialog should be closed.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\WaitQueueDialog.md"}}],["558",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\Wanted.cs)\n\nThe code provided is a part of the Brick-Force project and is contained within the \"Wanted\" class. The purpose of this code is to handle the display and functionality of the \"Wanted\" feature in the game.\n\nThe \"Wanted\" feature allows players to mark other players as \"Wanted\" and display their names on the screen. The code includes various variables and methods to control the appearance and behavior of the \"Wanted\" feature.\n\nThe code starts by defining an enum called \"ACTION_STEP\" which represents the different steps of the animation that occurs when a player is marked as \"Wanted\". The enum includes steps such as \"MOVE_IN\", \"PAUSE\", and \"MOVE_OUT\".\n\nThe class includes several public variables that can be set in the Unity editor, such as textures for the \"Wanted\" checkmark, background, and player icons. These variables allow for customization of the appearance of the \"Wanted\" feature.\n\nThe class also includes private variables to store the positions and sizes of various UI elements, as well as variables to control the timing and animation of the \"Wanted\" feature.\n\nThe \"Start\" method initializes some variables and checks if the current game mode is a team match or an individual match. It also sets the colors for the \"Wanted\" feature based on global variables.\n\nThe \"Action\" method is called when a player is marked as \"Wanted\". It sets the initial positions and sizes for the background and player icons, and starts the animation by setting the \"actionStep\" variable to \"MOVE_IN\".\n\nThe \"Update\" method is called every frame and handles the animation of the \"Wanted\" feature. It updates the positions and sizes of the UI elements based on the current action step and the elapsed time.\n\nThe \"DrawWanted\" method is responsible for drawing a single \"Wanted\" entry on the screen. It takes a nickname and a color as parameters and uses the \"LabelUtil\" and \"TextureUtil\" classes to draw the checkmark and the player's name.\n\nThe \"DrawWantedList\" method is called to draw the list of \"Wanted\" players on the screen. It retrieves the list of \"Wanted\" players from the \"WantedManager\" class and iterates over them to draw each entry using the \"DrawWanted\" method.\n\nThe \"DrawIAMWanted\" method is responsible for drawing the \"I Am Wanted\" icon on the screen if the current player is marked as \"Wanted\". It uses the \"TextureUtil\" class to draw the icon with a size that is interpolated based on the elapsed time.\n\nThe \"DrawCenterAction\" method is called to draw the background and player icons during the animation. It uses the \"TextureUtil\" class to draw the textures at the appropriate positions.\n\nThe \"OnGUI\" method is called to handle the GUI rendering. It checks if the \"Wanted\" feature is enabled and if the current player is in a \"Wanted\" room. If so, it calls the \"DrawWantedList\", \"DrawIAMWanted\", and \"DrawCenterAction\" methods to draw the UI elements on the screen.\n\nThe \"VerifyLocalController\" method is called to ensure that the \"localController\" variable is properly initialized. It finds the \"Me\" game object and retrieves the \"LocalController\" component from it.\n\nThe \"OnSelectWanted\" method is called when a player selects another player to mark as \"Wanted\". It checks if the selected player is the current player and if so, it starts the animation and enables the \"Wanted\" state in the \"localController\" component. Otherwise, it displays a system message with the name of the selected player.\n\nIn summary, this code handles the display and functionality of the \"Wanted\" feature in the game. It allows players to mark other players as \"Wanted\" and displays their names on the screen with an animation. The code includes methods to draw the UI elements, handle the animation, and respond to player interactions.\n## Questions: \n 1. What is the purpose of the `Action()` method?\n- The `Action()` method is used to initiate the animation of the wanted poster moving in and out of the screen.\n\n2. What is the significance of the `wantedDelta` variable?\n- The `wantedDelta` variable is used to control the speed of the animation of the wanted poster.\n\n3. What is the purpose of the `VerifyLocalController()` method?\n- The `VerifyLocalController()` method is used to check if the `localController` variable is null and assign it the `LocalController` component of the \"Me\" game object if it is not null.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\Wanted.md"}}],["559",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\WantedManager.cs)\n\nThe code provided is for a class called `WantedManager` in the Brick-Force project. This class is responsible for managing a list of \"wanted\" items and providing various functionalities related to these items.\n\nThe class has a private static variable `_instance` which holds a reference to the singleton instance of the `WantedManager` class. The instance is accessed through a public static property `Instance`. The purpose of this singleton pattern is to ensure that there is only one instance of the `WantedManager` class throughout the project.\n\nThe class also has a private list variable `list` which stores integers representing the \"wanted\" items. The class provides methods to add, remove, and check if an item is wanted. The `AddWanted` method adds an item to the list if certain conditions are met, such as the current room type being a team match or individual match, and the use of wanted items being enabled. The `DelWanted` method removes an item from the list if it exists.\n\nThe class also provides methods to retrieve information about the wanted items. The `ToArray` method returns an array representation of the list. The `IsWanted` method checks if a given item is in the list. The `GetWantedHpMaxBoost` and `GetWantedAtkPowBoost` methods calculate and return the boost values for the maximum HP and attack power of a given item, based on whether it is wanted or not.\n\nThe `Awake` method is called when the object is initialized and ensures that the `WantedManager` instance is not destroyed when a new scene is loaded. The `Start` and `Update` methods are empty and do not have any functionality.\n\nOverall, the `WantedManager` class is responsible for managing a list of wanted items, providing methods to add, remove, and check if an item is wanted, as well as retrieving boost values for wanted items. This class is likely used in the larger Brick-Force project to handle the logic and functionality related to wanted items in the game.\n## Questions: \n 1. What is the purpose of the `WantedManager` class?\n- The `WantedManager` class is responsible for managing a list of wanted items and providing methods to add, remove, and check if an item is wanted.\n\n2. What is the significance of the `Instance` property?\n- The `Instance` property provides a singleton instance of the `WantedManager` class, ensuring that there is only one instance of the class throughout the application.\n\n3. What is the purpose of the `GetWantedHpMaxBoost` and `GetWantedAtkPowBoost` methods?\n- These methods calculate and return the boost values for maximum HP and attack power based on whether a specific item is wanted or not.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\WantedManager.md"}}],["560",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\WantedOpt.cs)\n\nThe code provided is a C# class called `WantedOpt` that is marked with the `[Serializable]` attribute. This attribute indicates that objects of this class can be serialized and deserialized, meaning they can be converted into a format that can be stored or transmitted and then reconstructed back into an object.\n\nThe `WantedOpt` class has two public float variables: `hpMaxUp` and `atkPowUp`. These variables represent the maximum health points increase and attack power increase, respectively. The values of these variables are initialized to 1.0 and 0.3, indicating the default values for these properties.\n\nThis class is likely used in the larger Brick-Force project to represent the desired options or upgrades for a character or object in the game. By serializing objects of this class, the game can save and load the desired options for a character or object, allowing the player to customize and upgrade their gameplay experience.\n\nHere's an example of how this class might be used in the larger project:\n\n```csharp\n// Create a new instance of the WantedOpt class\nWantedOpt wantedOptions = new WantedOpt();\n\n// Customize the options for a character\nwantedOptions.hpMaxUp = 1.5f; // Increase maximum health points by 50%\nwantedOptions.atkPowUp = 0.5f; // Increase attack power by 50%\n\n// Serialize the object to save the desired options\nstring serializedOptions = Serialize(wantedOptions);\n\n// Save the serialized options to a file or database\n\n// Later, load the serialized options and deserialize them back into an object\nstring serializedOptions = LoadSerializedOptionsFromStorage();\nWantedOpt loadedOptions = Deserialize(serializedOptions);\n\n// Use the loaded options to apply the desired upgrades to a character or object\nApplyUpgrades(loadedOptions);\n```\n\nIn summary, the `WantedOpt` class is used to represent desired options or upgrades for a character or object in the Brick-Force project. By serializing and deserializing objects of this class, the game can save and load the desired options, allowing players to customize and upgrade their gameplay experience.\n## Questions: \n 1. **What is the purpose of the `[Serializable]` attribute on the `WantedOpt` class?**\nThe `[Serializable]` attribute indicates that instances of the `WantedOpt` class can be serialized and deserialized, allowing them to be stored or transmitted as data.\n\n2. **What do the `hpMaxUp` and `atkPowUp` variables represent?**\nThe `hpMaxUp` variable represents the maximum health points increase, while the `atkPowUp` variable represents the attack power increase.\n\n3. **What are the default values for `hpMaxUp` and `atkPowUp`?**\nThe default value for `hpMaxUp` is 1.0 and the default value for `atkPowUp` is 0.3.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\WantedOpt.md"}}],["561",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\WaveTable.cs)\n\nThe code provided defines a class called `WaveTable`. This class has two public variables: `numWave` of type `int` and `interval` of type `float`. \n\nThe purpose of this code is to represent a wave table, which is a data structure commonly used in audio synthesis and digital signal processing. A wave table is essentially a large array of precomputed audio samples that can be accessed and used to generate sound in real-time. Each sample in the wave table represents the amplitude of the audio signal at a specific point in time.\n\nIn the context of the larger project, this `WaveTable` class can be used to store and manage wave tables for use in audio synthesis. The `numWave` variable represents the number of waves in the table, while the `interval` variable represents the time interval between each wave.\n\nHere's an example of how this code might be used in the larger project:\n\n```java\n// Create a new wave table\nWaveTable waveTable = new WaveTable();\n\n// Set the number of waves and interval\nwaveTable.numWave = 4;\nwaveTable.interval = 0.1f;\n\n// Access and use the wave table in audio synthesis\nfor (int i = 0; i < waveTable.numWave; i++) {\n    // Generate audio using the wave table\n    float sample = generateAudio(waveTable, i);\n    \n    // Play the audio sample\n    playAudio(sample);\n}\n```\n\nIn this example, we create a new `WaveTable` object and set the number of waves to 4 and the interval between each wave to 0.1 seconds. We then iterate over each wave in the table and generate audio using the `generateAudio` function, passing in the `WaveTable` object and the index of the current wave. Finally, we play the generated audio sample using the `playAudio` function.\n\nOverall, this code provides a simple representation of a wave table and can be used as a building block for more complex audio synthesis functionality in the larger project.\n## Questions: \n 1. **What is the purpose of the `WaveTable` class?**\nThe `WaveTable` class appears to be a data structure that holds information about a wave, such as the number of waves and the interval between them.\n\n2. **What is the data type of the `numWave` variable?**\nThe `numWave` variable is of type `int`, which means it can hold integer values.\n\n3. **What is the data type of the `interval` variable?**\nThe `interval` variable is of type `float`, which means it can hold floating-point values.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\WaveTable.md"}}],["562",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\WeaponChangeDialog.cs)\n\nThe code provided is a class called \"WeaponChangeDialog\" that extends the \"Dialog\" class. This class is used to create a dialog box for changing weapons in the game. \n\nThe purpose of this code is to handle the logic and functionality of the weapon change dialog box. It includes methods for initializing the dialog, drawing the dialog box and its contents, and handling user input for changing weapons. \n\nThe class contains several member variables that store information about the dialog box, such as the textures for the premium icon and slot lock, the coordinates for the slot outline and weapon slot list, and an array of strings representing the keyboard keys for changing weapons. \n\nThe class also has a boolean variable \"premiumAccount\" that determines whether the player has a premium account, and a boolean variable \"done\" that indicates whether the weapon change is complete. \n\nThe class overrides several methods from the base \"Dialog\" class. The \"Start\" method sets the ID of the dialog box. The \"OnPopup\" method sets the position of the dialog box on the screen. The \"DoDialog\" method handles the drawing of the dialog box and its contents, and checks for user input to close the dialog box. The \"Update\" method checks for user input to change weapons. \n\nThe class also includes several helper methods. The \"CheckShortcut\" method checks if any of the keyboard keys for changing weapons have been pressed, and returns the index of the key that was pressed. The \"ChangeWeapon\" method is called when a weapon slot is selected, and it checks if the selected slot is valid and if the player has a premium account. If the conditions are met, it sends a request to the server to change the weapon. The \"IsLock\" method checks if a weapon is locked based on the current weapon option in the game. The \"DrawSlotIcon\" method draws the icon for a weapon slot. The \"DoWeaponSlots\" method draws the weapon slots and handles user input for selecting a slot. The \"DoTitle\" method draws the title of the dialog box. \n\nIn the larger project, this code would be used to create a dialog box that allows players to change their weapons. The dialog box would be displayed when the player interacts with a weapon change feature in the game. The player can select a weapon slot and press a keyboard key to change their weapon. The dialog box would also display information about the current weapons and any restrictions or limitations on changing weapons.\n## Questions: \n 1. What is the purpose of the `WeaponChangeDialog` class?\n- The `WeaponChangeDialog` class is a subclass of the `Dialog` class and represents a dialog for changing weapons in the game.\n\n2. What is the significance of the `premiumAccount` and `done` variables?\n- The `premiumAccount` variable is a boolean that indicates whether the player has a premium account. The `done` variable is a boolean that indicates whether the weapon change is done.\n \n3. What is the purpose of the `ChangeWeapon` method?\n- The `ChangeWeapon` method is responsible for changing the weapon in a specific slot. It checks if the slot is valid and if the player has a premium account. If the conditions are met, it sends a request to the server to change the weapon.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\WeaponChangeDialog.md"}}],["563",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\WeaponChanger.cs)\n\nThe code provided is a script called \"WeaponChanger\" that is used in the Brick-Force project. This script is responsible for managing the changing and displaying of weapons in the game.\n\nThe script contains several variables and methods that are used to control the behavior of the weapon changer. Let's go through each part of the code to understand its purpose.\n\nThe script starts by declaring some variables. The `guiDepth` variable is of type `GUIDepth.LAYER` and is set to `GUIDepth.LAYER.MENU`. This variable is used to determine the depth of the GUI elements in the game.\n\nThe `bombtex` variable is of type `Texture2D` and is used to store the texture of a bomb. This variable is not used in the provided code and may be used in other parts of the project.\n\nThe `weapons` variable is an array of `Texture2D` and is used to store the textures of the weapons in the game. The size of this array is determined by the length of the `usables` array passed to the `Initialize` method.\n\nThe `scale`, `offset`, and `showTimeLimit` variables are of type `float` and are used to control the scaling, spacing, and time limit for displaying the weapons.\n\nThe `slot2Key` variable is an array of `int` and is used to map the weapon slots to their corresponding keys. The `key2Slot` variable is an array of `Weapon.TYPE` and is used to map the keys to their corresponding weapon slots.\n\nThe `deltaTime` variable is of type `float` and is used to track the time since the last weapon swap.\n\nThe `Initialize` method is responsible for initializing the weapon changer. It takes an array of `GameObject` called `usables` as a parameter. Inside the method, the `slot2Key` and `key2Slot` arrays are initialized with predefined values. The `deltaTime` variable is set to `float.PositiveInfinity`. The `weapons` array is initialized with `null` values. Then, a loop iterates over the `usables` array and checks if each element is not null and has a valid weapon slot. If so, it retrieves the weapon texture and stores it in the `weapons` array at the corresponding slot index.\n\nThe `NeedSpecificSlot` method returns a boolean value indicating whether a specific weapon slot is needed. This is determined based on the current room type and whether the player is blasting.\n\nThe `OnGUI` method is responsible for displaying the weapons on the GUI. It first checks if the GUI is enabled and if the time since the last weapon swap is within the show time limit. It then retrieves the current weapon index from the `EquipCoordinator` component attached to the game object. It calculates the position of each weapon based on their textures and offsets. It then draws each weapon texture on the GUI using the `TextureUtil.DrawTexture` method.\n\nThe `Start` and `Update` methods are empty and do not contain any code.\n\nThe `Swap` method is called to initiate a weapon swap. It sets the `deltaTime` variable to 0, indicating that a weapon swap has occurred.\n\nIn summary, the `WeaponChanger` script is responsible for managing the changing and displaying of weapons in the game. It initializes the weapon textures based on the `usables` array, displays the weapons on the GUI, and handles weapon swaps. This script is likely used in conjunction with other scripts and components to provide the player with a way to switch between different weapons during gameplay.\n## Questions: \n 1. What is the purpose of the `Initialize` method?\n- The `Initialize` method is used to set up the `weapons` array by iterating through the `usables` array and assigning the corresponding textures to the `weapons` array based on certain conditions.\n\n2. What is the purpose of the `OnGUI` method?\n- The `OnGUI` method is responsible for rendering the weapon icons on the screen based on the current weapon selected and the available weapons in the `weapons` array.\n\n3. What is the purpose of the `Swap` method?\n- The `Swap` method is used to reset the `deltaTime` variable to 0, which is used to determine if the weapon icons should be displayed on the screen or not.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\WeaponChanger.md"}}],["564",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\WeaponFunction.cs)\n\nThe code provided is a script called \"WeaponFunction\" that is a part of the larger Brick-Force project. This script is responsible for managing the functionality and behavior of a weapon in the game. It contains various properties and methods that control aspects such as camera settings, weapon offsets, ammo backgrounds, and weapon upgrades.\n\nThe script starts by declaring several protected variables, including a long variable called \"itemSeq\" and several references to different camera and controller objects. It also includes several public properties that allow for the customization of various weapon attributes such as category, speed factor, and first-person and second-person offsets.\n\nThe script also includes a method called \"VerifyCamera\" that checks if the camera and camera controller objects are assigned and returns a boolean value accordingly. Similarly, the \"VerifyLocalController\" method checks if the local controller object is assigned and returns a boolean value.\n\nThe script also includes several virtual methods that can be overridden by derived classes to provide custom functionality. These methods include \"SetDrawn\", \"Reset\", \"setFever\", \"IsFullAmmo\", \"AddUpgradedDamagef\", \"AddUpgradedShockf\", \"NextUpgradedShockf\", \"AddUpgradedChargei\", \"NextUpgradedChargei\", \"AddUpgradedDamagei\", \"NextUpgradedDamagei\", \"SetShootEnermyEffect\", \"UpdateCrossEffect\", and \"SetDetonating\".\n\nOverall, this script provides a foundation for managing the behavior and functionality of a weapon in the Brick-Force game. It allows for customization of various weapon attributes and provides methods for handling weapon upgrades, ammo management, and visual effects. This script can be used as a base class for specific weapon types, allowing for easy customization and extension of weapon functionality in the larger Brick-Force project.\n## Questions: \n **Question 1:** What is the purpose of the `WeaponFunction` class?\n    \n**Answer:** The `WeaponFunction` class is responsible for managing the functionality and properties of a weapon in the game. It includes methods for setting the weapon's state, calculating damage, and managing visual effects.\n\n**Question 2:** What is the significance of the `itemSeq` and `isFirstPerson` variables?\n    \n**Answer:** The `itemSeq` variable represents the unique identifier for the weapon item, while the `isFirstPerson` variable determines whether the weapon is currently in first-person view. These variables are used to track and control the state of the weapon.\n\n**Question 3:** What is the purpose of the `VerifyCamera` and `VerifyLocalController` methods?\n    \n**Answer:** The `VerifyCamera` method is used to find and assign the main camera and first-person camera objects in the game scene. The `VerifyLocalController` method is used to find and assign the local controller component attached to the weapon object. These methods ensure that the necessary components are present for the weapon to function properly.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\WeaponFunction.md"}}],["565",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\WeaponGadget.cs)\n\nThe code provided is a class called `WeaponGadget` that extends the `MonoBehaviour` class from the Unity game engine. This class represents a weapon gadget in the larger Brick-Force project. \n\nThe `WeaponGadget` class has several public methods that can be overridden by subclasses to define specific behavior for the weapon gadget. These methods include `ClipOut()`, `ClipIn()`, `BoltUp()`, `FireAction()`, `GunAnim()`, `setFever()`, `Fire()`, `Fire2()`, `Fly()`, `KaBoom()`, `Throw()`, `SetSenseBeam()`, `Compose()`, and `Install()`. Each of these methods takes different parameters and performs different actions related to the weapon gadget.\n\nFor example, the `Fire()` method takes an `int` parameter `projectile`, and `Vector3` parameters `origin` and `direction`. This method is responsible for firing the weapon gadget by creating a projectile at the specified origin position and with the specified direction.\n\nThe `WeaponGadget` class also has a public boolean property called `ApplyUsk`, which has a getter and setter. This property is used to determine whether or not the weapon gadget should apply the USK (Unterhaltungssoftware Selbstkontrolle) rating. The default value is `true`, but it can be changed by setting the property.\n\nThe `WeaponGadget` class also has a `[RequireComponent(typeof(Weapon))]` attribute, which indicates that the `Weapon` component is required for this class to function properly. This suggests that the `WeaponGadget` class is meant to be attached to a game object that also has a `Weapon` component.\n\nOverall, the `WeaponGadget` class provides a framework for defining and implementing different weapon gadgets in the Brick-Force project. Subclasses can override the provided methods to customize the behavior of their specific weapon gadgets.\n## Questions: \n 1. **What is the purpose of the `WeaponGadget` class?**\nThe `WeaponGadget` class is a MonoBehaviour that represents a weapon gadget in the game. It contains various methods related to the functionality of the gadget.\n\n2. **What is the significance of the `RequireComponent(typeof(Weapon))` attribute?**\nThe `RequireComponent(typeof(Weapon))` attribute ensures that the `Weapon` component is automatically added to any GameObject that has the `WeaponGadget` script attached to it. This attribute is used to enforce a dependency between the `WeaponGadget` and `Weapon` components.\n\n3. **What is the purpose of the `ApplyUsk` property?**\nThe `ApplyUsk` property is a boolean property that allows getting and setting the value of the `applyUsk` field. It provides a way to control whether the \"Usk\" (unknown acronym) should be applied or not.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\WeaponGadget.md"}}],["566",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\WeaponModifier.cs)\n\nThe `WeaponModifier` class is responsible for managing and modifying weapon properties in the Brick-Force project. It contains two dictionaries, `dic` and `dicEx`, which store instances of the `WpnMod` and `WpnModEx` classes respectively. \n\nThe `WeaponModifier` class is a singleton, meaning that there can only be one instance of it in the project. This is enforced by the `Instance` property, which ensures that only one instance of `WeaponModifier` is created and accessed throughout the project. \n\nThe `Get` method is used to retrieve a `WpnMod` object from the `dic` dictionary based on a given weapon ID. If the dictionary contains the weapon ID, the corresponding `WpnMod` object is returned. Otherwise, it returns null.\n\nThe `UpdateWpnMod` method is used to update the properties of a `WpnMod` object in the `dic` dictionary. It takes in various parameters that represent different weapon properties and updates the corresponding properties of the `WpnMod` object with the given weapon ID. If the dictionary does not contain the weapon ID, a new `WpnMod` object is created and added to the dictionary.\n\nSimilarly, the `GetEx` method is used to retrieve a `WpnModEx` object from the `dicEx` dictionary based on a given weapon ID. If the dictionary contains the weapon ID, the corresponding `WpnModEx` object is returned. Otherwise, it returns null.\n\nThe `UpdateWpnModEx` method is used to update the properties of a `WpnModEx` object in the `dicEx` dictionary. It takes in various parameters that represent different weapon properties and updates the corresponding properties of the `WpnModEx` object with the given weapon ID. If the dictionary does not contain the weapon ID, a new `WpnModEx` object is created and added to the dictionary.\n\nThe `Awake` method is called when the `WeaponModifier` object is created. It initializes the `dic` and `dicEx` dictionaries and ensures that the `WeaponModifier` object is not destroyed when a new scene is loaded.\n\nThe `Clear` method is used to clear the `dic` and `dicEx` dictionaries, removing all stored weapon properties.\n\nOverall, the `WeaponModifier` class provides a centralized way to manage and modify weapon properties in the Brick-Force project. It allows for easy retrieval and updating of weapon properties based on weapon IDs.\n## Questions: \n 1. What is the purpose of the `WeaponModifier` class?\n- The `WeaponModifier` class is responsible for managing weapon modifications and providing methods to update and retrieve weapon modification data.\n\n2. What is the purpose of the `UpdateWpnMod` method?\n- The `UpdateWpnMod` method is used to update the weapon modification data for a specific weapon identified by its sequence number.\n\n3. What is the purpose of the `Clear` method?\n- The `Clear` method is used to clear the dictionary of weapon modifications, removing all stored data.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\WeaponModifier.md"}}],["567",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\WeaponWatch.cs)\n\nThe `WeaponWatch` class is responsible for tracking the amount of time that each weapon in the game is held by the player. This information is then used to calculate the ratio of time each weapon is held compared to the total time all weapons are held. \n\nThe class contains a private `Dictionary<long, float>` variable called `weaponHeldTime`, which stores the total time each weapon has been held. The `deltaTime` variable keeps track of the time since the last update, and `deltaMax` determines the maximum time interval between updates.\n\nThe `Start()` method initializes the `deltaMax` and `deltaTime` variables, and creates a new instance of the `weaponHeldTime` dictionary.\n\nThe `OnSwapWeapon()` method is called when the player swaps weapons. It resets the `deltaMax` variable and calls the `UpdateWeaponHeldTime()` method.\n\nThe `UpdateWeaponHeldTime()` method retrieves all the `Weapon` components in the game, including inactive ones. It then iterates through each weapon and checks if it is a valid weapon type (melee, projectile, etc.). If it is, it retrieves the corresponding `Item` object using the `ItemSeq` property of the `WeaponFunction` component. If the `Item` is not null, it updates the `weaponHeldTime` dictionary with the time the weapon has been held.\n\nAfter updating the `weaponHeldTime` dictionary, the method calculates the total time all weapons have been held by summing the values in the dictionary. It then creates a new dictionary called `dictionary3` and calculates the ratio of time each weapon has been held compared to the total time. Finally, it sends this information to the `CSNetManager` class using the `SendCS_WEAPON_HELD_RATIO_REQ()` method.\n\nThe `Update()` method is called every frame and updates the `deltaTime` variable. If the `deltaTime` exceeds the `deltaMax` value, it resets the `deltaTime` and increases the `deltaMax` value. It then calls the `UpdateWeaponHeldTime()` method.\n\nOverall, this code tracks the amount of time each weapon is held by the player and calculates the ratio of time each weapon is held compared to the total time all weapons are held. This information can be used for various purposes in the larger project, such as balancing weapon usage, providing statistics to the player, or adjusting gameplay mechanics based on weapon popularity.\n## Questions: \n 1. What is the purpose of the `WeaponWatch` class?\n- The `WeaponWatch` class is responsible for tracking the amount of time that each weapon is held by the player.\n\n2. What triggers the `OnSwapWeapon` method?\n- The `OnSwapWeapon` method is triggered when the player swaps their current weapon for a different one.\n\n3. What does the `Update` method do?\n- The `Update` method is called every frame and updates the `deltaTime` and `deltaMax` variables. It also calls the `UpdateWeaponHeldTime` method if a certain amount of time has passed.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\WeaponWatch.md"}}],["568",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\WebParam.cs)\n\nThe `WebParam` class in the `Brick-Force` project is responsible for managing and storing parameters related to web requests. It is a MonoBehaviour class, which means it can be attached to a GameObject in the Unity engine.\n\nThe `WebParam` class has a private string variable called `param` that is initially set to an empty string. This variable holds the web parameters.\n\nThere is also a private static instance of the `WebParam` class called `_instance`. This instance is used to access the `WebParam` class from other scripts in the project.\n\nThe `Parameters` property is a public getter that returns the value of the `param` variable. This allows other scripts to access the web parameters.\n\nThe `HasParameters` property is a public getter that returns a boolean value indicating whether the `param` variable has any parameters. It checks if the length of the `param` string is greater than 0.\n\nThe `Instance` property is a public getter that returns the `_instance` variable. It first checks if the `_instance` variable is null. If it is null, it tries to find an instance of the `WebParam` class in the scene using `Object.FindObjectOfType`. If it fails to find an instance, it logs an error message. Finally, it returns the `_instance` variable.\n\nThe `Awake` method is a Unity lifecycle method that is called when the script is first loaded. It uses `Object.DontDestroyOnLoad` to prevent the `WebParam` instance from being destroyed when a new scene is loaded.\n\nThe `SetLoginParameters` method is used to set the web parameters. It takes a string parameter called `parameters`. It logs a debug message with the provided parameters and assigns the `parameters` value to the `param` variable. It then finds a GameObject called \"Main\" in the scene and gets the `AutoLogout` component attached to it. If the component is found, it calls the `Relogin` method on the component, passing in the `param` variable.\n\nOverall, the `WebParam` class is responsible for managing and storing web parameters and providing access to them for other scripts in the project. It also has a method to set the web parameters and trigger a relogin process in the `AutoLogout` component.\n## Questions: \n 1. What is the purpose of the `WebParam` class?\n- The `WebParam` class is used to store and manage parameters related to web requests.\n\n2. What is the significance of the `Instance` property?\n- The `Instance` property provides a singleton instance of the `WebParam` class, ensuring that only one instance of the class exists throughout the application.\n\n3. What is the purpose of the `SetLoginParameters` method?\n- The `SetLoginParameters` method is used to set the login parameters for the web request and trigger a relogin process if a specific component is found in the scene.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\WebParam.md"}}],["569",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\WindowSystemManager.cs)\n\nThe code provided is a part of the Brick-Force project and is contained in the `WindowSystemManager` class. This class is responsible for managing the window system of the game.\n\nThe code starts by defining several constants that represent different window styles and flags. These constants are used later in the code to modify the window properties.\n\nThe class also contains several variables that are used to keep track of the window position and size, as well as flags for resizing and the current state of the window.\n\nThe `Instance` property is a singleton pattern implementation that ensures only one instance of the `WindowSystemManager` class is created. It uses the `FindObjectOfType` method to find an existing instance of the class or create a new one if none exists.\n\nThe `Awake` method is called when the object is initialized and sets the `DontDestroyOnLoad` flag to prevent the object from being destroyed when a new scene is loaded.\n\nThe `Start` method is empty and does not contain any code.\n\nThe `HideWindowBorderAndTitle` method is responsible for hiding the window border and title. It first checks if the game is not running in a duplicate executable mode and if the window currently has a border and title. If these conditions are met, it uses several Win32 API functions to modify the window properties and adjust its position and size.\n\nThe `ShowWindowBorderAndTitle` method is the opposite of `HideWindowBorderAndTitle` and is responsible for showing the window border and title.\n\nThe `Update` method is called every frame and is responsible for managing the window state based on certain conditions. If the game is not running in full-screen mode and not in a web player mode, it either hides or shows the window border and title based on whether the game is in a playing scene or not.\n\nThe remaining methods in the code are Win32 API function declarations that are used to interact with the window system. These functions are used to get and set window properties, find windows by name, adjust window rectangles, and get system metrics.\n\nIn summary, the `WindowSystemManager` class is responsible for managing the window system of the game. It provides methods to hide and show the window border and title, as well as manage the window state based on certain conditions. The Win32 API functions are used to interact with the window system and modify window properties.\n## Questions: \n 1. What is the purpose of the `WindowSystemManager` class?\n- The `WindowSystemManager` class manages the window system for the Brick-Force project, including hiding and showing the window border and title.\n\n2. What is the purpose of the `HideWindowBorderAndTitle` method?\n- The `HideWindowBorderAndTitle` method is used to hide the border and title of the window when the game is not in fullscreen mode.\n\n3. What is the purpose of the `ReSize` method?\n- The `ReSize` method is used to resize the window by adjusting its position and dimensions based on the difference between the client area and the window area.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\WindowSystemManager.md"}}],["570",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\WindowUtil.cs)\n\nThe code provided is a part of the Brick-Force project and is located in the `WindowUtil` class. The purpose of this code is to handle events related to windows in the game. \n\nThe `WindowUtil` class is a MonoBehaviour, which means it can be attached to a game object in the Unity engine. It contains a single public static method called `EatEvent()`. This method is responsible for consuming events that are not of type `EventType.Layout` or `EventType.Repaint`.\n\nThe `EatEvent()` method first checks the type of the current event using `Event.current.type`. If the event type is not `EventType.Layout` or `EventType.Repaint`, it calls `Event.current.Use()`. The `Use()` method marks the current event as used, preventing it from being processed further by other event handlers.\n\nThis code can be used in the larger Brick-Force project to handle events related to windows. By attaching the `WindowUtil` script to a game object, developers can call the `EatEvent()` method to consume events that are not relevant to the layout or repainting of windows. This can be useful in scenarios where certain events need to be ignored or prevented from triggering other actions.\n\nHere's an example of how this code can be used:\n\n```csharp\nusing UnityEngine;\n\npublic class MyWindow : MonoBehaviour\n{\n    private void Update()\n    {\n        // Check for user input or other events\n\n        // Call EatEvent() to consume events that are not relevant to the window\n        WindowUtil.EatEvent();\n\n        // Continue handling relevant events\n    }\n}\n```\n\nIn this example, the `Update()` method of a window script is called every frame. By calling `WindowUtil.EatEvent()` within the `Update()` method, the window can consume events that are not related to its layout or repainting, allowing it to focus on handling only the relevant events.\n## Questions: \n 1. What is the purpose of the `EatEvent` method?\n- The `EatEvent` method is used to consume an event if it is not of type `Layout` or `Repaint`.\n\n2. What is the significance of the `Event.current` variable?\n- The `Event.current` variable represents the current event being processed by the Unity engine.\n\n3. Why is the `Use()` method called on the `Event.current` object?\n- The `Use()` method is called to mark the current event as used, preventing it from being processed further by other components or systems.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\WindowUtil.md"}}],["571",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/.autodoc\\docs\\json\\Assembly-CSharp\\wlic)\n\nThe `WXCS_IF.cs` file in the `wlic` folder of the `Assembly-CSharp` directory is a C# class that serves as an interface to the `keel_xt.dll` library. This library is likely a crucial part of the Brick-Force project, and the `WXCS_IF` class provides methods and constants to interact with it.\n\nThe class contains several constants such as `CS2_POPT_PE`, `CS2_POPT_TEXT`, `CS2_POPT_RDATA`, `CS2_POPT_EDATA`, `CS2_POPT_RSRC`, `CS2_POPT_RELOC`, and `CS2_POPT_E_V`. These constants are used to define different options for the `dwMethod` parameter in the `XTrap_CS_Step2` method, specifying different types of data or operations.\n\nThe class also includes several methods declared with the `DllImport` attribute, indicating they are external functions from the `keel_xt.dll` library. These methods (`L0`, `C0`, `C1`, `C2`, `C4`, and `S0`) are likely responsible for various operations such as initializing the game, starting the XTrap protection system, keeping the XTrap system alive, setting user information, and performing step 2 of the XTrap client-server communication.\n\nFor example, the `C0` method might be used to start the XTrap protection system:\n\n```csharp\n[DllImport(\"keel_xt.dll\")]\npublic static extern int C0();\n```\n\nThe methods `XTrap_L_Patch`, `XTrap_C_Start`, `XTrap_C_KeepAlive`, `XTrap_C_CallbackAlive`, `XTrap_C_SetUserInfoEx`, and `XTrap_CS_Step2` are wrappers around the corresponding `DllImport` methods. Although currently commented out, these methods were likely intended to simplify the usage of the `DllImport` methods by providing a higher-level interface.\n\nIn summary, the `WXCS_IF` class provides an interface to interact with the `keel_xt.dll` library, performing various operations related to the Brick-Force project. Other parts of the project can use this class to interact with the XTrap system and perform necessary operations.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\wlic\\summary.md"}}],["572",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\wlic\\WXCS_IF.cs)\n\nThe code provided is a C# class called `WXCS_IF` that contains various methods and constants related to the Brick-Force project. The purpose of this code is to provide an interface to interact with the `keel_xt.dll` library, which is likely a part of the Brick-Force project.\n\nThe class contains several constants that define different options for the `dwMethod` parameter used in the `XTrap_CS_Step2` method. These options include `CS2_POPT_PE`, `CS2_POPT_TEXT`, `CS2_POPT_RDATA`, `CS2_POPT_EDATA`, `CS2_POPT_RSRC`, `CS2_POPT_RELOC`, and `CS2_POPT_E_V`. These constants are likely used to specify different types of data or operations to be performed in the `S0` method.\n\nThe class also contains several methods that are declared with the `DllImport` attribute, indicating that they are external functions from the `keel_xt.dll` library. These methods include `L0`, `C0`, `C1`, `C2`, `C4`, and `S0`. These methods are likely responsible for performing various operations related to the Brick-Force project, such as initializing the game, starting the XTrap protection system, keeping the XTrap system alive, setting user information, and performing step 2 of the XTrap client-server communication.\n\nThe methods `XTrap_L_Patch`, `XTrap_C_Start`, `XTrap_C_KeepAlive`, `XTrap_C_CallbackAlive`, `XTrap_C_SetUserInfoEx`, and `XTrap_CS_Step2` are provided as wrappers around the corresponding `DllImport` methods. These wrapper methods are currently commented out and do not perform any operations. It is likely that these methods were intended to be used to simplify the usage of the `DllImport` methods by providing a higher-level interface.\n\nOverall, this code provides an interface to interact with the `keel_xt.dll` library and perform various operations related to the Brick-Force project, such as initializing the game, starting the XTrap protection system, and communicating with the server. The `WXCS_IF` class and its methods can be used by other parts of the Brick-Force project to interact with the XTrap system and perform necessary operations.\n## Questions: \n 1. What is the purpose of the `WXCS_IF` class?\n- The `WXCS_IF` class appears to be a wrapper for various functions and constants related to the XTrap anti-cheat system.\n\n2. What is the purpose of the `DllImport` attribute?\n- The `DllImport` attribute is used to import functions from a native DLL (in this case, \"keel_xt.dll\") into the managed code.\n\n3. What is the purpose of the commented out code in the methods?\n- The commented out code suggests that the methods were originally intended to call the corresponding functions from the native DLL, but they are currently disabled.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\wlic\\WXCS_IF.md"}}],["573",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\WordFilter.cs)\n\nThe `WordFilter` class is responsible for filtering and censoring inappropriate words in a text input. It is part of the larger Brick-Force project and is used to ensure that user-generated content within the game adheres to community guidelines and remains family-friendly.\n\nThe class contains several private variables, including `badWords`, `blind`, and `ignore`. `badWords` is a 2-dimensional array of strings that stores the list of inappropriate words categorized by language. `blind` is an array of characters that will be used to replace the inappropriate words in the filtered output. `ignore` is an array of characters that will be ignored during the filtering process.\n\nThe class also has a public boolean variable `displayReadString` that determines whether or not the filtered words will be logged to the console.\n\nThe class has a static instance `_instance` that ensures only one instance of the `WordFilter` class is created. The `Instance` property returns the instance of the `WordFilter` class.\n\nThe `Awake` method is called when the script instance is being loaded. It ensures that the `WordFilter` object is not destroyed when a new scene is loaded.\n\nThe `Load` method is responsible for loading the list of inappropriate words from either a local file or a web server, depending on the platform. If the platform is a web player, the `LoadFromWWW` coroutine is started, which downloads the word list from a specified URL. If the platform is not a web player, the `LoadFromLocalFileSystem` method is called, which loads the word list from a local file. The loaded word list is then parsed and stored in the `badWords` array.\n\nThe `Filter` method takes an input string and filters out any inappropriate words based on the current language option. It replaces the inappropriate words with a string of characters from the `blind` array. The filtered string is then returned.\n\nThe `IgnoreFilter` method is similar to the `Filter` method, but it also ignores certain characters specified in the `ignore` array. It removes these characters from the input string before filtering and then inserts them back into their original positions after filtering.\n\nThe `CheckBadword` method checks if the input string contains any inappropriate words without filtering them. It returns the first inappropriate word found, or an empty string if no inappropriate words are found.\n\nOverall, the `WordFilter` class provides a way to filter and censor inappropriate words in user-generated content within the Brick-Force game. It ensures that the game remains family-friendly and adheres to community guidelines.\n## Questions: \n **Question 1:** What is the purpose of the `WordFilter` class?\n    \n**Answer:** The `WordFilter` class is responsible for filtering and censoring words in a given input string.\n\n**Question 2:** How does the `WordFilter` class load the list of bad words?\n    \n**Answer:** The `WordFilter` class can load the list of bad words either from a web server or from the local file system, depending on the platform.\n\n**Question 3:** How does the `WordFilter` class handle filtering and censoring words?\n    \n**Answer:** The `WordFilter` class replaces any occurrence of a bad word in the input string with a string of random characters from the `blind` array. It also has a method called `IgnoreFilter` that ignores certain characters from being censored.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\WordFilter.md"}}],["574",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\WoundFx.cs)\n\nThe `WoundFx` class is responsible for managing and displaying visual effects related to wounds and damage in the game. It is part of the larger Brick-Force project.\n\nThe class has several public properties and fields that define various textures, colors, and audio clips used for the visual effects. These include `screenFx`, `screenFxChild`, `ToScreenFxClr`, `FromScreenFxClr`, `ToScreenFxClrChild`, `FromScreenFxClrChild`, `ToBloodClr`, `FromBloodClr`, `bloodMarks`, `piercedWounds`, `heartbeatSound`, and `growling`.\n\nThe class also has private fields and variables used for internal calculations and tracking. These include `screenFxClr`, `bloodMarkQ`, `localController`, `deltaTime`, `zombieFxClr`, `rcScreen`, `zombieDelta`, and `zombieDeltaGrowling`.\n\nThe `Start` method initializes the various fields and variables, including setting the initial values for `screenFxClr` and `zombieFxClr`. It also calls the `ResetZombieGrawling` method.\n\nThe `ClearScreen` method resets the screen effects and clears the `bloodMarkQ` queue.\n\nThe `OnRespawn` method is called when the player respawns and clears the screen effects.\n\nThe `Growling` method plays the growling audio clip.\n\nThe `OnGUI` method is responsible for rendering the screen effects and blood marks on the GUI. It sets the GUI skin, depth, and color, and then draws the screen effects and blood marks using the `TextureUtil.DrawTexture` method.\n\nThe `ApplyScreenFx` method updates the screen effects based on the current state of the game. It adjusts the `screenFxClr` color and updates the blood marks.\n\nThe `ResetZombieGrawling` method resets the zombie growling effect.\n\nThe `ApplyScreenFxForZombie` method updates the screen effects specifically for the zombie player. It adjusts the `zombieFxClr` color and plays the growling audio clip.\n\nThe `OnHit` method is called when the player is hit by a weapon. It adds a blood mark to the `bloodMarkQ` queue and updates the screen effects.\n\nThe `ApplyHeartbeat` method applies the heartbeat effect when the player's health is low. It plays the heartbeat audio clip and updates the screen effects.\n\nThe `Update` method is called every frame and applies the heartbeat and screen effects.\n\nOverall, the `WoundFx` class manages and displays visual effects related to wounds and damage in the game. It handles the rendering of screen effects, blood marks, and audio clips. It also adjusts the effects based on the player's health and game state.\n## Questions: \n 1. What is the purpose of the `WoundFx` class?\n- The `WoundFx` class is responsible for managing visual effects related to wounds and blood in the game.\n\n2. What are the different textures and colors used in the code?\n- The code uses various textures (`screenFx`, `screenFxChild`, `bloodMarks`, `piercedWounds`) and colors (`ToScreenFxClr`, `FromScreenFxClr`, `ToScreenFxClrChild`, `FromScreenFxClrChild`, `ToBloodClr`, `FromBloodClr`, `ToZombieFxClr`, `FromZombieFxClr`) for different visual effects.\n\n3. How are the screen effects and blood marks applied and updated?\n- The screen effects and blood marks are applied and updated in the `ApplyScreenFx()` and `ApplyScreenFxForZombie()` methods respectively. These methods use color interpolation and time-based calculations to achieve the desired visual effects.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\WoundFx.md"}}],["575",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\WpnMod.cs)\n\nThe code provided defines a class called `WpnMod`. This class represents a weapon modification in the larger Brick-Force project. \n\nThe `WpnMod` class has several public fields that represent various properties of the weapon modification. These properties include things like reload speed, range, attack power, accuracy, and more. Each property is represented by a float or integer value.\n\nThe purpose of this code is to provide a blueprint for creating different weapon modifications in the Brick-Force project. By creating an instance of the `WpnMod` class and setting the appropriate values for each property, developers can define the characteristics of a specific weapon modification.\n\nFor example, if a developer wants to create a weapon modification that has a reload speed of 2.5 seconds, a range of 100 meters, and an attack power of 50, they can create a new instance of the `WpnMod` class and set the corresponding property values:\n\n```csharp\nWpnMod myWeaponMod = new WpnMod();\nmyWeaponMod.fReloadSpeed = 2.5f;\nmyWeaponMod.fRange = 100f;\nmyWeaponMod.fAtkPow = 50f;\n```\n\nThis code can be used in the larger Brick-Force project to define and customize different weapon modifications. These modifications can then be applied to weapons in the game, allowing players to enhance their weapons with different characteristics and abilities.\n\nOverall, this code provides a foundation for creating and defining weapon modifications in the Brick-Force project. It allows developers to easily customize the properties of each modification and integrate them into the game.\n## Questions: \n 1. What is the purpose of this class?\n- This class appears to be a representation of a weapon modification in the game Brick-Force, as it contains various attributes related to the weapon's performance and characteristics.\n\n2. What do the different float variables represent?\n- The float variables in this class likely represent different attributes or properties of the weapon modification, such as reload speed, range, accuracy, recoil, etc.\n\n3. Are there any methods or functions associated with this class?\n- Based on the provided code, there are no methods or functions included in this class. It only contains public variables to store the values of the weapon modification attributes.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\WpnMod.md"}}],["576",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\WpnModEx.cs)\n\nThe code provided defines a class called `WpnModEx`. This class is likely a part of the larger Brick-Force project and is used to represent a weapon modification extension. \n\nThe class has several public variables, each representing a different attribute of the weapon modification. These attributes include `nSeq`, `misSpeed`, `throwForce`, `maxLauncherAmmo`, `radius2ndWpn`, `damage2ndWpn`, `recoilPitch2ndWpn`, `recoilYaw2ndWpn`, `Radius1stWpn`, `semiAutoMaxCyclicAmmo`, `minBuckShot`, `maxBuckShot`, `persistTime`, and `continueTime`. \n\nThese attributes likely define various properties and characteristics of the weapon modification, such as its firing speed, damage, recoil, and ammunition capacity. \n\nFor example, the `misSpeed` attribute may represent the missile speed of the weapon modification, while the `damage2ndWpn` attribute may represent the damage inflicted by the secondary weapon. \n\nDevelopers working on the Brick-Force project can use this `WpnModEx` class to create instances of weapon modifications and set their attributes accordingly. They can then use these instances to modify the behavior and characteristics of weapons within the game. \n\nHere's an example of how this class could be used:\n\n```java\nWpnModEx weaponMod = new WpnModEx();\nweaponMod.misSpeed = 10.0f;\nweaponMod.damage2ndWpn = 50;\nweaponMod.recoilPitch2ndWpn = 2.5f;\n\n// Use the weapon modification in the game\nWeapon weapon = new Weapon();\nweapon.applyModification(weaponMod);\n```\n\nIn this example, a new instance of `WpnModEx` is created and its attributes are set. The `weaponMod` instance is then passed to a `Weapon` object's `applyModification` method, which applies the modification to the weapon.\n## Questions: \n 1. **What is the purpose of this class?**\nA smart developer might ask what the purpose of the `WpnModEx` class is and how it fits into the overall project.\n\n2. **What do the different variables represent?**\nA smart developer might ask for clarification on what each variable in the class represents, such as `nSeq`, `misSpeed`, `throwForce`, etc.\n\n3. **Are there any methods or functions associated with this class?**\nA smart developer might ask if there are any methods or functions associated with the `WpnModEx` class, or if it is solely a data storage class.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\WpnModEx.md"}}],["577",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\XpTableByBuild.cs)\n\nThe code provided defines a class called `XpTableByBuild` that is marked as `[Serializable]`. This class has two properties: `xp_mode` of type `BuildOption.XP_MODE` and `Table` of type `int[]`. \n\nThe purpose of this class is to store experience point (XP) tables for different build options in the larger Brick-Force project. The `xp_mode` property represents the specific build option for which the XP table is defined. The `Table` property is an array of integers that represents the XP values for different levels.\n\nBy using this class, the Brick-Force project can define and store XP tables for different build options, allowing for customization and flexibility in the game. For example, the project may have different build options such as \"Warrior\", \"Mage\", and \"Rogue\", each with their own XP table. The `XpTableByBuild` class can be used to define and store these tables.\n\nHere is an example of how this class may be used in the larger project:\n\n```csharp\n// Define an XP table for the \"Warrior\" build option\nXpTableByBuild warriorXpTable = new XpTableByBuild();\nwarriorXpTable.xp_mode = BuildOption.XP_MODE.Warrior;\nwarriorXpTable.Table = new int[] { 0, 100, 200, 300, 400, 500, ... };\n\n// Define an XP table for the \"Mage\" build option\nXpTableByBuild mageXpTable = new XpTableByBuild();\nmageXpTable.xp_mode = BuildOption.XP_MODE.Mage;\nmageXpTable.Table = new int[] { 0, 150, 250, 350, 450, 550, ... };\n\n// Store the XP tables in a collection\nList<XpTableByBuild> xpTables = new List<XpTableByBuild>();\nxpTables.Add(warriorXpTable);\nxpTables.Add(mageXpTable);\n\n// Retrieve the XP table for the \"Warrior\" build option\nXpTableByBuild retrievedTable = xpTables.FirstOrDefault(x => x.xp_mode == BuildOption.XP_MODE.Warrior);\n\n// Access the XP values for different levels\nint level1Xp = retrievedTable.Table[0]; // 0\nint level2Xp = retrievedTable.Table[1]; // 100\nint level3Xp = retrievedTable.Table[2]; // 200\n// ...\n```\n\nIn summary, the `XpTableByBuild` class is used to define and store XP tables for different build options in the Brick-Force project. This allows for customization and flexibility in the game by providing different XP progression for different build options.\n## Questions: \n 1. **What is the purpose of the `XpTableByBuild` class?**\nThe `XpTableByBuild` class is used to store XP tables for different build options in the Brick-Force project.\n\n2. **What is the significance of the `xp_mode` property?**\nThe `xp_mode` property is used to determine the XP mode for which the XP table is being stored in the `XpTableByBuild` class.\n\n3. **What does the `Table` array represent?**\nThe `Table` array represents the XP table for a specific build option and XP mode in the Brick-Force project.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\XpTableByBuild.md"}}],["578",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\XTrap.cs)\n\nThe code provided is a part of the Brick-Force project and is contained in a file called \"XTrap.cs\". This file defines a class called \"XTrap\" which inherits from the MonoBehaviour class in the UnityEngine namespace.\n\nThe purpose of this code is to handle the initialization and management of the XTrap anti-cheat system within the larger Brick-Force project. The XTrap system is used to prevent cheating and hacking in the game.\n\nThe XTrap class has a private float variable called \"xtrapAliveTime\" which is used to keep track of the time since the XTrap system was started. It also has a private static instance variable called \"_instance\" which is used to store a reference to the singleton instance of the XTrap class.\n\nThe XTrap class also has a public static property called \"Instance\" which provides access to the singleton instance of the XTrap class. This property ensures that only one instance of the XTrap class is created and provides a way to access that instance from other parts of the code.\n\nThe Awake() method is commented out and not used in the current implementation. It seems to be responsible for initializing the XTrap system based on different build options. The XTrap system is started with different configurations depending on the build options specified in the BuildOption class.\n\nThe Start() method initializes the \"xtrapAliveTime\" variable to 0 and calls the XTrap_C_KeepAlive() method from the WXCS_IF class if the \"UseXTrap\" build option is enabled. This method is responsible for keeping the XTrap system alive.\n\nThe Update() method is called every frame and updates the \"xtrapAliveTime\" variable. If the \"UseXTrap\" build option is enabled and the \"xtrapAliveTime\" is greater than 2 seconds, the XTrap_C_CallbackAlive() method from the WXCS_IF class is called with the period calculated from the \"xtrapAliveTime\" value.\n\nThe SetUserInfo() method is used to set the user information for the XTrap system. It takes a string parameter called \"nickname\" and calls the XTrap_C_SetUserInfoEx() method from the WXCS_IF class with the provided nickname.\n\nOverall, this code is responsible for initializing and managing the XTrap anti-cheat system within the Brick-Force project. It provides a way to start and keep the XTrap system alive, as well as set user information for the system.\n## Questions: \n 1. What is the purpose of the `XTrap` class?\n- The `XTrap` class is responsible for managing the XTrap system in the game.\n\n2. What is the significance of the `Instance` property?\n- The `Instance` property is a singleton pattern implementation that ensures only one instance of the `XTrap` class is created and accessed throughout the game.\n\n3. What is the purpose of the `SetUserInfo` method?\n- The `SetUserInfo` method is used to set the user's information, such as their nickname, in the XTrap system.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\XTrap.md"}}],["579",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ZombieGuideDialog.cs)\n\nThe code provided is a class called `ZombieGuideDialog` that extends the `Dialog` class. This class is used to create a dialog box in the Brick-Force project. The purpose of this code is to display a dialog box with various UI elements such as an image list, label list, toggle, and a button. The dialog box is used to guide the player about zombies in the game.\n\nThe `ZombieGuideDialog` class has several public variables that are used to reference the UI elements in the dialog box. These variables include `imgList`, `labelList`, `toggle`, and `ok`. The `imgList` and `labelList` variables are used to display a list of images and labels respectively. The `toggle` variable represents a toggle button that allows the player to choose whether they want to see the guide message again or not. The `ok` variable represents a button that the player can click to close the dialog box.\n\nThe `DontShowThisMessageAgain` property is a shorthand way of accessing the value of the `toggle` variable. It returns `true` if the toggle is checked, indicating that the player does not want to see the guide message again.\n\nThe `Start` method is overridden from the base `Dialog` class and sets the `id` of the dialog box to a specific value.\n\nThe `OnPopup` method is also overridden from the base `Dialog` class and is responsible for positioning the dialog box on the screen.\n\nThe `InitDialog` method is empty and does not have any functionality.\n\nThe `DoDialog` method is the main method that is called to display the dialog box and handle user interactions. It first sets the GUI skin to a specific skin obtained from `GUISkinFinder.Instance.GetGUISkin()`. Then, it calls the `Draw` method on the `imgList`, `labelList`, `toggle`, and `ok` variables to display their respective UI elements. If the `ok` button is clicked, it checks if the `DontShowThisMessageAgain` property is `true` and saves this information using `MyInfoManager.Instance.SaveDonotCommonMask` method. Finally, it checks if there is no other popup menu open and calls `WindowUtil.EatEvent()` to prevent any further events from being processed. The GUI skin is then reset to its original value and the method returns a boolean value indicating whether the dialog box should be closed or not.\n\nOverall, this code provides the functionality to display a dialog box with various UI elements and handle user interactions. It is used to guide the player about zombies in the game and allows them to choose whether they want to see the guide message again or not.\n## Questions: \n 1. What is the purpose of the `ZombieGuideDialog` class?\n- The `ZombieGuideDialog` class is a subclass of the `Dialog` class and represents a dialog for guiding the player in the context of zombies.\n\n2. What is the purpose of the `InitDialog()` method?\n- The `InitDialog()` method does not have any code inside it, so a smart developer might wonder why it exists and what its intended purpose is.\n\n3. What does the `DoDialog()` method do?\n- The `DoDialog()` method is responsible for drawing the dialog elements, handling user input, and returning a boolean result indicating whether the dialog should be closed or not.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ZombieGuideDialog.md"}}],["580",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ZombieMatchScore.cs)\n\nThe code provided is a script for managing and displaying the score and progress of a zombie-themed game mode in the larger Brick-Force project. \n\nThe `ZombieMatchScore` class extends the `MonoBehaviour` class from the Unity engine, indicating that it is a script that can be attached to a game object in the Unity editor. \n\nThe script contains several public variables that can be set in the Unity editor, including `guiDepth`, `curFont`, `totalFont`, `scoreBg`, `gaugeBg`, `gauge`, `humanIcon`, `zombieIcon`, and `arrow`. These variables represent various textures and fonts used for displaying the score and progress.\n\nThe script also contains several private variables, such as `cur` and `total`, which represent the current and total score, and `size`, `crdCurrent`, `crdTotal`, `sizeZH`, and `offsetZH`, which represent the size and coordinates of various UI elements.\n\nThe `Start` method is called when the script is first initialized. It sets the initial value of `cur` to 1 and `total` to the kill count obtained from the `RoomManager` instance. If the player is in \"Breaking Into\" mode, it sends a request to the server to retrieve the zombie mode score.\n\nThe `Update` method is empty and does not contain any code.\n\nThe `DrawRounding` method is responsible for drawing the score UI elements. It uses the `GUI` class from Unity to draw a background texture (`scoreBg`) and the current and total scores using the `curFont` and `totalFont` fonts, respectively.\n\nThe `DrawZombieVsHuman` method is responsible for drawing the progress of the zombie vs human game mode. It uses the `ZombieVsHumanManager` instance to retrieve the human and zombie ratios and counts. It then uses the `TextureUtil` and `LabelUtil` classes to draw the UI elements, including icons, gauges, arrows, and text labels.\n\nThe `OnGUI` method is called by Unity to draw the GUI elements. It sets the GUI skin, depth, and enabled state based on the game state and whether a modal dialog is open. It then calls the `DrawRounding` and `DrawZombieVsHuman` methods to draw the score and progress UI elements.\n\nThe `OnZombieScore` method is called when the server sends an updated zombie score. It updates the `cur` and `total` variables and adjusts the scale of the fonts if necessary.\n\nIn summary, this script manages and displays the score and progress of a zombie-themed game mode in the Brick-Force project. It uses various textures, fonts, and UI elements to draw the score and progress on the screen. The `Start` method initializes the score values and sends a request to the server if necessary. The `Update` method is empty. The `DrawRounding` and `DrawZombieVsHuman` methods are responsible for drawing the score and progress UI elements. The `OnGUI` method is called by Unity to draw the GUI elements. The `OnZombieScore` method is called when the server sends an updated zombie score.\n## Questions: \n 1. What is the purpose of the `ZombieMatchScore` class?\n- The `ZombieMatchScore` class is responsible for displaying the score and other UI elements related to a zombie match in the game.\n\n2. What are the `cur` and `total` variables used for?\n- The `cur` variable represents the current score in the zombie match, while the `total` variable represents the total score.\n\n3. What is the purpose of the `DrawZombieVsHuman` method?\n- The `DrawZombieVsHuman` method is responsible for drawing the UI elements related to the zombie vs human ratio and count in the game.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ZombieMatchScore.md"}}],["581",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ZombieMatchSituation.cs)\n\nThe code provided is a part of the Brick-Force project and is contained within the `ZombieMatchSituation` class. The purpose of this code is to display a graphical user interface (GUI) that shows the current situation of players in a zombie match. \n\nThe code uses various variables to define the positions and sizes of different GUI elements, such as text boxes, labels, and textures. These variables are initialized with specific values that determine the layout and appearance of the GUI.\n\nThe `OnGUI` method is responsible for rendering the GUI elements on the screen. It first checks if the GUI is enabled and if the `on` flag is set to true. If both conditions are met, the method proceeds to render the GUI.\n\nInside the `OnGUI` method, the code sets the GUI skin and depth, and begins a GUI group with a specific position and size. It then draws a box with a specific style to serve as the background for the GUI. \n\nThe code retrieves the current room from the `RoomManager` and displays its title using the `LabelUtil.TextOut` method. It also draws several other GUI elements, such as text boxes and labels, to display information about each player in the match. The information includes the player's mark, badge, nickname, zombie/brickman status, score, and ping.\n\nThe code uses a `GridOut` method to draw each player's information in a grid-like layout. It takes various parameters, such as clan mark, XP, rank, nickname, zombie status, score, ping, and status, to determine the appearance of each player's row in the GUI.\n\nThe `DrawClanMark` method is used to draw the clan mark of a player, if available. It retrieves the appropriate textures for the background and emblem of the clan mark and draws them using the `TextureUtil.DrawTexture` method.\n\nThe `VerifyLocalController` method is used to find and assign the `LocalController` component to the `localController` variable if it is null. This component is used to control the local player's actions in the game.\n\nThe `Start` and `Update` methods are empty and do not contain any code.\n\nIn summary, this code is responsible for rendering a GUI that displays the current situation of players in a zombie match. It uses various GUI elements, such as text boxes, labels, and textures, to present information about each player's status, score, and ping. The GUI is rendered using the `OnGUI` method, and the layout and appearance of the GUI elements are determined by the values of the variables defined in the code.\n## Questions: \n 1. What is the purpose of the `VerifyLocalController()` method?\n- The `VerifyLocalController()` method is used to check if the `localController` variable is null and assign it the `LocalController` component of the \"Me\" GameObject if it exists.\n\n2. What does the `OnGUI()` method do?\n- The `OnGUI()` method is responsible for rendering the graphical user interface (GUI) elements for the ZombieMatchSituation class. It displays various labels, boxes, and textures based on the current game state.\n\n3. What is the significance of the `DrawClanMark()` method?\n- The `DrawClanMark()` method is used to draw the clan mark of a player on the GUI. It takes the clan mark index as a parameter and uses the ClanMarkManager to retrieve the appropriate background and emblem textures for the mark.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ZombieMatchSituation.md"}}],["582",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ZombieModeConfig.cs)\n\nThe code provided is a class called `ZombieModeConfig` that is used in the larger Brick-Force project. This class is responsible for handling the graphical user interface (GUI) elements and logic related to the zombie mode configuration in the game.\n\nThe `ZombieModeConfig` class contains various properties and methods that are used to display and interact with the zombie mode configuration in the game. Let's go through the code to understand its functionality:\n\n1. The class is marked with the `[Serializable]` attribute, which allows instances of this class to be serialized and deserialized.\n\n2. The class has several private fields that store the coordinates and dimensions of various GUI elements, such as thumbnails, buttons, and labels.\n\n3. The `OnGUI` method is the main entry point for rendering the GUI elements related to the zombie mode configuration. It first retrieves the thumbnail image for the current map from the `RegMapManager` and assigns it to the `thumbnail` variable. If the thumbnail is not available, it falls back to the `nonavailable` texture.\n\n4. The method then proceeds to render various GUI elements, such as the map thumbnail, icons for new maps, glory maps, medal maps, and gold ribbon maps. It also checks if the current map is flagged as an abuse map and renders an icon accordingly.\n\n5. The method also displays the alias of the current map and the game mode associated with the current room.\n\n6. The `DoOption` method is called to render additional GUI elements related to the game options, such as the round goal and the break-in option.\n\n7. The `ShowTooltip` method is responsible for displaying a tooltip window when the user hovers over certain GUI elements. It renders the tooltip message passed to it at the current mouse position.\n\n8. The `Start` method is empty and does not contain any logic.\n\nIn summary, the `ZombieModeConfig` class handles the rendering and interaction of GUI elements related to the zombie mode configuration in the game. It retrieves information about the current map and room from other classes, and uses that information to render appropriate GUI elements and handle user interactions. This class plays a crucial role in providing a user-friendly interface for configuring and managing the zombie mode in the Brick-Force game.\n## Questions: \n 1. What is the purpose of the `OnGUI()` method?\n- The `OnGUI()` method is responsible for rendering the graphical user interface elements related to the ZombieModeConfig class, such as textures, labels, and buttons.\n\n2. What does the `DoOption()` method do?\n- The `DoOption()` method is responsible for rendering and displaying options related to a specific room, such as the round number and the \"break into\" setting.\n\n3. What is the purpose of the `ShowTooltip()` method?\n- The `ShowTooltip()` method is responsible for displaying a tooltip message at the specified position on the screen. The tooltip message is retrieved from the `GUI.tooltip` property.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ZombieModeConfig.md"}}],["583",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ZombieStatus.cs)\n\nThe code provided defines a class called `ZombieStatus`. This class has three public integer variables: `_status`, `_time`, and `_cntDn`. The class also has a constructor that takes three integer parameters: `status`, `time`, and `cntDn`. \n\nThe purpose of this code is to represent the status of a zombie in the larger Brick-Force project. The `_status` variable represents the current status of the zombie, the `_time` variable represents the time the zombie has been in that status, and the `_cntDn` variable represents the number of times the zombie has been defeated.\n\nThis class can be used in various parts of the Brick-Force project where the status of a zombie needs to be tracked and updated. For example, it can be used in a game level where players have to defeat zombies. Each zombie instance can have its own `ZombieStatus` object to keep track of its status, time, and defeat count.\n\nHere is an example of how this class can be used in the larger project:\n\n```java\nZombieStatus zombie1Status = new ZombieStatus(1, 10, 0);\nZombieStatus zombie2Status = new ZombieStatus(2, 5, 2);\n\n// Update the status and time of zombie1\nzombie1Status._status = 2;\nzombie1Status._time = 15;\n\n// Increase the defeat count of zombie2\nzombie2Status._cntDn++;\n\n// Print the status, time, and defeat count of zombie1\nSystem.out.println(\"Zombie 1 status: \" + zombie1Status._status);\nSystem.out.println(\"Zombie 1 time: \" + zombie1Status._time);\nSystem.out.println(\"Zombie 1 defeat count: \" + zombie1Status._cntDn);\n```\n\nIn this example, we create two `ZombieStatus` objects to represent the status of two zombies. We then update the status and time of `zombie1` and increase the defeat count of `zombie2`. Finally, we print the status, time, and defeat count of `zombie1`.\n\nOverall, this code provides a simple and reusable way to represent and track the status of zombies in the Brick-Force project.\n## Questions: \n 1. **What is the purpose of the ZombieStatus class?**\nThe ZombieStatus class appears to be a data structure that holds information about the status, time, and count down of a zombie. \n\n2. **What are the possible values for the _status variable?**\nWithout further information, it is unclear what the possible values for the _status variable are. It would be helpful to know the range or specific values that can be assigned to this variable.\n\n3. **What is the significance of the _cntDn variable?**\nThe purpose or significance of the _cntDn variable is not clear from the provided code. It would be helpful to have more context or documentation to understand its role in the ZombieStatus class.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ZombieStatus.md"}}],["584",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ZombieTimer.cs)\n\nThe `ZombieTimer` class is a script that is used to manage the timer for a zombie game in the larger Brick-Force project. \n\nThe purpose of this code is to display a timer on the game screen and update it based on the game progress. The timer is displayed as a countdown in minutes and seconds. The timer starts at a specified time limit and decreases by one second every second until it reaches zero. \n\nThe code uses the Unity game engine and the `UnityEngine` namespace. It also relies on other classes and components from the larger Brick-Force project, such as `GUIDepth`, `UIImageSizeChange`, `LocalController`, `ZombieMatch`, `RoomManager`, `MyInfoManager`, `DialogManager`, `GUISkinFinder`, `LabelUtil`, `TextureUtil`, `CSNetManager`, and `BrickManager`.\n\nThe `ZombieTimer` class has several member variables that store information about the timer and its components. These variables include `guiDepth`, `offset`, `bkgnd`, `backChange`, `play`, `dummyDelta`, `playDelta`, `deltaTime`, `remain`, `localController`, `zombieMatch`, and `expandArea`.\n\nThe `Start` method is called when the script is first initialized. It initializes the member variables, finds the player object in the game scene, and gets the `LocalController` and `ZombieMatch` components attached to the player object. It also sets the position and size of the background image for the timer.\n\nThe `OnGUI` method is called every frame to update the graphical user interface. It checks if the GUI is enabled and then draws the timer on the screen. If the remaining time is less than 11 seconds, it uses a special effect to draw the timer in red. Otherwise, it draws the timer in yellow.\n\nThe `Update` method is called every frame to update the timer logic. It checks if the player is the master of the game, if the `ZombieMatch` component exists, if the `LocalController` component exists, and if the `BrickManager` is loaded. If all these conditions are met, it updates the timer based on the game state. If the player is not a spectator, it updates the timer based on the `ZombieMatch` step. If the step is not `ZOMBIE_PLAY`, it sends a timer request to the server every second. If the step is `ZOMBIE_PLAY`, it increments the play time every second and sends a timer request to the server. It also updates the remaining time every second and sends a timer request to the server.\n\nThe `OnPlayTime` and `OnTimer` methods are event handlers that are called when the server sends updates about the play time and remaining time, respectively. They update the local variables `play` and `remain` if the received values are greater than the current values.\n\nOverall, this code manages the timer for a zombie game in the Brick-Force project, displaying it on the screen and updating it based on the game progress.\n## Questions: \n 1. What is the purpose of the `ZombieTimer` class?\n- The `ZombieTimer` class is responsible for managing the timer for a zombie game mode in the Brick-Force project.\n\n2. What is the significance of the `remain` variable?\n- The `remain` variable represents the remaining time in seconds for the game mode.\n\n3. What is the purpose of the `backChange` object?\n- The `backChange` object is used to animate the background image of the timer.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ZombieTimer.md"}}],["585",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ZombieVirus.cs)\n\nThe code provided is a class called `ZombieVirus` that represents a zombie virus in the larger project called Brick-Force. The purpose of this class is to manage the state and behavior of the zombie virus within the game.\n\nThe class has a private boolean variable called `active` which represents whether the zombie virus is currently active or not. It also has a public property called `Active` which allows other parts of the code to get and set the value of `active`.\n\nThe class has two additional public properties: `IsReallyActive` and `SpeedFactor`. \n\nThe `IsReallyActive` property returns a boolean value based on the current state of the game. It checks if the current room type is a zombie room, if the zombie mode is enabled, and if the zombie virus is active. If all these conditions are true, then `IsReallyActive` returns `true`, otherwise it returns `false`.\n\nThe `SpeedFactor` property returns a float value that represents the speed factor of the zombie virus. If `IsReallyActive` is `false`, then the speed factor is 1.0f, otherwise it is 1.15f.\n\nThere is also a `MaxHpFactor` property that returns a float value representing the maximum health points factor of the zombie virus. If `IsReallyActive` is `false`, then the maximum health points factor is 0.0f, otherwise it is 3.0f.\n\nThe class also has a constructor that initializes the `active` variable to `false`.\n\nIn the larger project, this `ZombieVirus` class can be used to manage the behavior and attributes of the zombie virus. Other parts of the code can check the `Active` property to see if the zombie virus is active or not. They can also use the `IsReallyActive`, `SpeedFactor`, and `MaxHpFactor` properties to determine the behavior and attributes of the zombie virus in different situations.\n\nFor example, if the `IsReallyActive` property is `true`, it means that the zombie virus is active in a zombie room with the zombie mode enabled. In this case, the `SpeedFactor` property can be used to increase the speed of the zombie virus, and the `MaxHpFactor` property can be used to increase its maximum health points.\n\nOverall, this `ZombieVirus` class provides a way to manage the state and behavior of the zombie virus in the Brick-Force project.\n## Questions: \n 1. What is the purpose of the `active` variable and how is it used in the code?\n- The `active` variable is a boolean that determines whether the zombie virus is active or not. It is used in the `IsReallyActive`, `SpeedFactor`, and `MaxHpFactor` properties to check if the zombie virus is active.\n\n2. What conditions need to be met for the `IsReallyActive` property to return true?\n- The `IsReallyActive` property will return true if the current room type is \"ZOMBIE\", the zombie mode is enabled, and the zombie virus is active.\n\n3. How are the `SpeedFactor` and `MaxHpFactor` properties calculated?\n- The `SpeedFactor` property is calculated as 1.15f if the zombie virus is active, and 1f otherwise. The `MaxHpFactor` property is calculated as 3f if the zombie virus is active, and 0f otherwise.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ZombieVirus.md"}}],["586",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\ZombieVsHumanManager.cs)\n\nThe `ZombieVsHumanManager` class is responsible for managing the state and behavior of zombies and humans in a game. It keeps track of the lists of zombies, humans, and dead players, and provides methods to add, remove, and check the status of players.\n\nThe class has a private static instance variable `_instance` and a public static property `Instance` that allows other classes to access the singleton instance of the `ZombieVsHumanManager`. The `Instance` property uses the `Object.FindObjectOfType` method to find and return the instance of the `ZombieVsHumanManager` in the scene.\n\nThe class also has a private boolean variable `respawnable` and a public property `AmIRespawnable` that allows other classes to get and set the respawnable status of the player.\n\nThe `Awake` method is called when the object is initialized and it uses `Object.DontDestroyOnLoad` to prevent the `ZombieVsHumanManager` object from being destroyed when a new scene is loaded.\n\nThe `SetupLocalDeath` method is called when a player dies and it determines if the player is respawnable based on the current room type and build options. If the player is a zombie and the zombie mode is enabled, the player is respawnable unless they were killed by a headshot.\n\nThe `ResetGameStuff` method is called to reset the lists of zombies, humans, and dead players, as well as the respawnable status.\n\nThe `AddZombie` method is called when a player becomes a zombie. It removes the player from the list of humans and adds them to the list of zombies if the current room type is zombie and the zombie mode is enabled.\n\nThe `DelZombie` method is called to remove a zombie from the list of zombies.\n\nThe `Die` method is called when a player dies. It removes the player from the lists of humans and zombies and adds them to the list of dead players if the current room type is zombie and the zombie mode is enabled.\n\nThe `AddHuman` method is called when a player becomes a human. It adds the player to the list of humans if the current room type is zombie and the zombie mode is enabled.\n\nThe `DelHuman` method is called to remove a human from the list of humans.\n\nThe `IsZombie` method checks if a player is a zombie by checking if their sequence number is in the list of zombies.\n\nThe `IsHuman` method checks if a player is a human by checking if their sequence number is in the list of humans.\n\nThe `GetZombieRatio` method calculates and returns the ratio of zombies to the maximum number of players. It ensures that the ratio is capped at 1.\n\nThe `GetHumanRatio` method calculates and returns the ratio of humans to the maximum number of players. It ensures that the ratio is capped at 1.\n\nThe `GetZombieCount` method returns the number of zombies.\n\nThe `GetHumanCount` method returns the number of humans.\n\nThe `Start` and `Update` methods are empty and do not have any functionality.\n\nOverall, the `ZombieVsHumanManager` class provides a centralized way to manage the state and behavior of zombies and humans in the game. Other classes can access the singleton instance of the `ZombieVsHumanManager` to add, remove, and check the status of players.\n## Questions: \n 1. What is the purpose of the `ZombieVsHumanManager` class?\n- The `ZombieVsHumanManager` class manages the lists of zombies, humans, and dead players in a game, and provides methods for adding, deleting, and checking the status of players.\n\n2. What is the significance of the `respawnable` variable?\n- The `respawnable` variable determines whether a player is able to respawn after death. It is set based on the game mode and the type of player (zombie or human).\n\n3. What is the purpose of the `SetupLocalDeath` method?\n- The `SetupLocalDeath` method is called when a player dies and is responsible for determining if the player is a zombie or human, and whether they are able to respawn based on the game mode and other conditions.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\ZombieVsHumanManager.md"}}],["587",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\_Emulator\\Config.cs)\n\nThe code provided is a part of the Brick-Force project and is located in the `_Emulator` namespace. It defines a class called `Config` that is responsible for managing and loading/saving configuration settings for the project.\n\nThe `Config` class has several public properties that represent different configuration settings. These settings include the color of the crosshair, the hue of the crosshair color, whether to use USK textures, the axis ratio for camera movement, whether to allow only one client per IP, whether to block connections, whether to automatically clear dead clients, and the maximum number of connections.\n\nThe class also has a constructor that calls the `LoadConfigFromDisk` method to load the configuration settings from a CSV file located at the specified path. The `LoadConfigFromDisk` method uses a `CSVLoader` object to load the CSV file and then retrieves the values for each configuration setting from the loaded CSV data. It also applies some additional transformations to the loaded values, such as converting the crosshair color from RGB to HSV and calculating the crosshair hue.\n\nThe `Config` class also has a `SaveConfigToDisk` method that saves the current configuration settings to a CSV file located at the specified path. It uses the `CSVLoader` object to set the values for each configuration setting in the CSV data and then saves the CSV data to the file.\n\nAdditionally, the `Config` class has three methods: `ApplyAxisRatio`, `ApplyUskTextures`, and `ApplyCrosshairHue`. These methods are responsible for applying the changes made to the configuration settings. For example, the `ApplyAxisRatio` method adjusts the camera's ySpeed based on the axis ratio, the `ApplyUskTextures` method updates various build options based on the `uskTextures` setting, and the `ApplyCrosshairHue` method updates the crosshair color based on the `crosshairHue` setting.\n\nOverall, the `Config` class provides a way to manage and persist configuration settings for the Brick-Force project. It allows the project to load and save these settings from a CSV file and apply the changes made to the settings in the appropriate places.\n## Questions: \n 1. What is the purpose of the `Config` class?\n- The `Config` class is responsible for loading and saving configuration settings from a CSV file.\n\n2. What are the default values for the configuration settings?\n- The default values for the configuration settings are as follows:\n  - `crosshairColor` is set to `Color.green`\n  - `crosshairHue` is set to `90f`\n  - `uskTextures` is set to `false`\n  - `axisRatio` is set to `2.25f`\n  - `oneClientPerIP` is set to `true`\n  - `blockConnections` is set to `false`\n  - `autoClearDeadClients` is set to `false`\n  - `maxConnections` is set to `16`\n\n3. What is the purpose of the `ApplyAxisRatio()`, `ApplyUskTextures()`, and `ApplyCrosshairHue()` methods?\n- The `ApplyAxisRatio()` method adjusts the camera's ySpeed based on the axisRatio value.\n- The `ApplyUskTextures()` method updates various build options based on the uskTextures value.\n- The `ApplyCrosshairHue()` method updates the crosshairColor based on the crosshairHue value.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\_Emulator\\Config.md"}}],["588",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\_Emulator\\Core.cs)\n\nThe code provided is a part of the Brick-Force project and is located in the `Brick-Force` file. The purpose of this code is to initialize the core components of the project and set up the build configuration.\n\nThe `Core` class is responsible for initializing the necessary components and setting up the build configuration. It has a public method called `Initialize()` which is called to start the initialization process. \n\nIn the `Initialize()` method, several components are instantiated and assigned to the `coreObject` GameObject. These components include `MainGUI`, `InventoryGUI`, `ConfigGUI`, `DebugConsole`, and `ServerEmulator`. These components are added as components to the `coreObject` using the `AddComponent<T>()` method. The `coreObject` is then marked as a DontDestroyOnLoad object using `UnityEngine.Object.DontDestroyOnLoad()` method, ensuring that it persists across scene changes.\n\nThe `Config` instance is created and assigned to the `Config.instance` variable. The `Config` class is not shown in the provided code, but it is likely responsible for storing and managing configuration settings for the project.\n\nThe `SetupBuildConfig()` method is a private method that sets up the build configuration. It sets `Application.runInBackground` to true, allowing the application to continue running even when it loses focus. It also sets `BuildOption.Instance.Props.UseP2pHolePunching` and `BuildOption.Instance.Props.isDuplicateExcuteAble` to true, which are likely specific build options for the project.\n\nOverall, this code initializes the core components of the Brick-Force project and sets up the build configuration. It ensures that the necessary components are instantiated and assigned to the `coreObject`, and it sets specific build options for the project. This code is likely called at the start of the project to set up the initial state and configuration.\n## Questions: \n 1. What is the purpose of the `Initialize()` method?\n- The `Initialize()` method is responsible for setting up various components and configurations for the Core object.\n\n2. What is the significance of the `coreObject` variable?\n- The `coreObject` variable is an instance of the GameObject class and is used to attach various components to it.\n\n3. What does the `SetupBuildConfig()` method do?\n- The `SetupBuildConfig()` method sets certain build options for the application, such as running in the background and enabling P2P hole punching.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\_Emulator\\Core.md"}}],["589",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\_Emulator\\GUI\\ConfigGUI.cs)\n\nThe code provided is a part of the Brick-Force project and is located in the `ConfigGUI` class. This class is responsible for creating and managing a graphical user interface (GUI) window that allows the user to configure various settings for the game.\n\nThe `ConfigGUI` class extends the `MonoBehaviour` class from the Unity engine, which means it can be attached to a game object in the scene and respond to events such as `Update` and `OnGUI`.\n\nThe `ConfigGUI` class has a few member variables. The `configGUIRect` variable is a `Rect` object that defines the position and size of the GUI window. The `hidden` variable is a boolean flag that determines whether the GUI window should be hidden or shown.\n\nThe `Update` method is called every frame and checks if the F7 key is pressed. If it is, the `hidden` flag is toggled, which hides or shows the GUI window accordingly. \n\nThe `OnGUI` method is called whenever the GUI needs to be rendered. If the `hidden` flag is false, the `GUILayout.Window` method is called to create a GUI window with the title \"Config\" and the ID 104. The `ConfigGUIWindow` method is then called to draw the contents of the GUI window.\n\nThe `ConfigGUIWindow` method contains various GUI elements such as buttons, labels, sliders, and toggle switches. These elements allow the user to save and load configurations, adjust the axis ratio and crosshair hue, and toggle various settings related to client connections and debugging.\n\nFor example, the code `Config.instance.axisRatio = GUILayout.HorizontalSlider(Config.instance.axisRatio, 1f, 2.25f);` creates a horizontal slider that allows the user to adjust the `axisRatio` property of the `Config` class. The current value of `axisRatio` is displayed as a label next to the slider.\n\nOverall, the `ConfigGUI` class provides a user-friendly way for players to customize their game settings. It is an important component of the larger Brick-Force project as it allows players to tailor their gameplay experience to their preferences.\n## Questions: \n 1. What is the purpose of the `ConfigGUI` class?\n- The `ConfigGUI` class is responsible for handling the GUI window for configuring various settings.\n\n2. What does the `Update` method do?\n- The `Update` method checks if the F7 key is pressed and toggles the `hidden` variable accordingly. It also applies the axis ratio and crosshair hue settings from the `Config` instance.\n\n3. What happens when the \"Save\" button is clicked in the GUI window?\n- When the \"Save\" button is clicked, the `SaveConfigToDisk` method of the `Config` instance is called to save the configuration to disk.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\_Emulator\\GUI\\ConfigGUI.md"}}],["590",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\_Emulator\\GUI\\DebugConsole.cs)\n\nThe code provided is for a DebugConsole class in the Brick-Force project. This class is responsible for displaying debug logs and messages in a console window within the game. \n\nThe DebugConsole class is a MonoBehaviour, meaning it can be attached to a GameObject in the Unity scene and will be updated and rendered automatically. It contains several variables and methods that control the behavior and appearance of the console.\n\nThe class defines a struct called Log, which represents a single log message. Each log message has a message string, a stackTrace string, and a LogType enum value. The LogType enum represents the type of log message, such as Log, Warning, Error, etc.\n\nThe class also defines a list of Log objects called logs, which stores all the log messages that have been received. There is a scrollPosition variable that keeps track of the current scroll position of the console window, and hidden and collapse variables that control the visibility and behavior of the console.\n\nThe OnEnable and OnDisable methods are Unity lifecycle methods that register and unregister a log callback function using the Application class. This callback function, HandleLog, is called whenever a new log message is received. The HandleLog function creates a new Log object with the message, stackTrace, and type parameters, and adds it to the logs list.\n\nThe Update method checks for user input to toggle the visibility of the console and to scroll through the log messages.\n\nThe OnGUI method is another Unity lifecycle method that is responsible for rendering the console window. If the console is not hidden, it uses the GUILayout.Window function to create a window with a unique ID and a title of \"Console\". Inside the window, it uses GUILayout.BeginScrollView and GUILayout.EndScrollView to create a scrollable area for the log messages. It then iterates over the logs list and displays each log message using GUILayout.Label. If the collapse variable is true, it skips displaying log messages that are the same as the previous one, to avoid repetition. Finally, it renders buttons for clearing the logs and toggling the collapse behavior.\n\nOverall, this DebugConsole class provides a way to display and manage debug logs and messages in a console window within the game. It can be used during development and testing to track and troubleshoot issues.\n## Questions: \n 1. What is the purpose of the `DebugConsole` class?\n- The `DebugConsole` class is responsible for displaying logs and stack traces in a console window in the Unity game engine.\n\n2. What is the significance of the `toggleKey` variable?\n- The `toggleKey` variable determines the key that can be pressed to show or hide the console window.\n\n3. How are log messages and stack traces stored and displayed in the console window?\n- Log messages and stack traces are stored in a list of `Log` structs and are displayed using the `GUILayout.Label` method.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\_Emulator\\GUI\\DebugConsole.md"}}],["591",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\_Emulator\\GUI\\InventoryGUI.cs)\n\nThe code provided is a part of the Brick-Force project and is located in the `InventoryGUI` class. This class is responsible for displaying and managing the inventory GUI (Graphical User Interface) in the game.\n\nThe `InventoryGUI` class extends the `MonoBehaviour` class from the Unity engine, which allows it to interact with the game objects and events. It contains several private variables, such as `hidden`, `ranGUI`, `sortedItems`, and various `Rect` objects, which define the positions and sizes of GUI elements.\n\nThe `FitToScreen` method is responsible for adjusting the size of the GUI elements based on the screen size. It is called whenever the screen size changes.\n\nThe `Update` method checks if the F5 key is pressed and toggles the `hidden` variable accordingly. This allows the player to show or hide the inventory GUI by pressing the F5 key.\n\nThe `OnGUI` method is called every frame to draw the inventory GUI. It first checks if the inventory is available and the client is connected. If so, it proceeds to draw the GUI elements, such as windows, buttons, and text fields, using the Unity GUI functions.\n\nThe `IconGUIWindow` method is responsible for drawing the icons of the items in the inventory. It uses a scroll view to display a list of icons, which can be sorted and filtered based on the `sortText` variable. The icons can be clicked to add the corresponding item to the inventory.\n\nThe `InventoryGUIWindow` method is responsible for drawing the items in the inventory. It uses a scroll view to display a grid of item icons. The icons can be clicked to equip or unequip the corresponding item.\n\nOverall, this code provides the functionality to display and interact with the inventory GUI in the game. It allows the player to view, sort, and manage their inventory items. The code also includes methods to update, save, and load the inventory data.\n## Questions: \n 1. What is the purpose of the `FitToScreen()` method and when is it called?\n- The `FitToScreen()` method adjusts the size and position of GUI windows to fit the screen. It is called in the `OnGUI()` method.\n2. What is the significance of the `hidden` variable and how is it used?\n- The `hidden` variable is a boolean that determines whether the GUI windows should be displayed or not. It is used in the `OnGUI()` method to conditionally skip rendering the GUI if it is set to true.\n3. What is the purpose of the `ranGUI` variable and how is it used?\n- The `ranGUI` variable is a boolean that tracks whether the GUI has been rendered at least once. It is used in the `OnGUI()` method to ensure that certain operations are only performed once, such as sorting the items dictionary.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\_Emulator\\GUI\\InventoryGUI.md"}}],["592",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\_Emulator\\GUI\\MainGUI.cs)\n\nThe code provided is a part of the Brick-Force project and is located in the MainGUI.cs file. This code is responsible for managing the graphical user interface (GUI) of the game. It allows the player to interact with various setup and host options.\n\nThe MainGUI class is a MonoBehaviour class, which means it can be attached to a GameObject in the Unity game engine. It contains several public and private variables that control the visibility and position of GUI windows, as well as a custom message string.\n\nThe Update() method is called every frame and checks for specific key presses. If the F6 key is pressed, it toggles the visibility of the setup GUI window. If the F4 key is pressed, it toggles the visibility of the host GUI window. Additionally, the method calls the HandleReliableKillLog() method of the ClientExtension class.\n\nThe OnGUI() method is also called every frame and is responsible for rendering the GUI elements on the screen. If the setup GUI window is not hidden, it calls the GUILayout.Window() method to create a window with the title \"Setup\" and the specified dimensions. Inside the window, it displays a label for the host IP and a text field for the user to enter the IP address. It also provides two buttons: \"Host\" and \"Join\". Clicking the \"Host\" button hides the host GUI window, sets up the server using the ServerEmulator class, and loads the server using the ClientExtension class. Clicking the \"Join\" button also hides the host GUI window and loads the server.\n\nIf the host GUI window is not hidden and the server has been created, the method creates a host GUI window using the GUILayout.Window() method. Inside the window, it provides several buttons for different actions such as \"Shutdown\", \"Reset\", \"Clear Buffers\", and \"Send Custom Message\". It also displays a label for the connected clients and creates a button for each client in the ServerEmulator's clientList. Clicking a client button sends a disconnect message to the server.\n\nOverall, this code provides a user interface for setting up and managing a server in the Brick-Force game. It allows the player to host or join a server, perform server-related actions, and interact with connected clients.\n## Questions: \n 1. What is the purpose of the `Update()` method?\n- The `Update()` method is used to handle input from the user and perform actions based on that input.\n\n2. What is the purpose of the `OnGUI()` method?\n- The `OnGUI()` method is responsible for rendering the graphical user interface (GUI) elements on the screen.\n\n3. What does the `SendDisconnect()` method do?\n- The `SendDisconnect()` method is used to send a disconnect message to a specific client in the `clientList` of the `ServerEmulator` instance.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\_Emulator\\GUI\\MainGUI.md"}}],["593",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/.autodoc\\docs\\json\\Assembly-CSharp\\_Emulator\\GUI)\n\nThe `GUI` folder in the `Assembly-CSharp\\_Emulator` directory of the Brick-Force project contains four C# files: `ConfigGUI.cs`, `DebugConsole.cs`, `InventoryGUI.cs`, and `MainGUI.cs`. Each file is responsible for a specific aspect of the game's graphical user interface (GUI).\n\n`ConfigGUI.cs` manages a GUI window for configuring game settings. It extends Unity's `MonoBehaviour` class, allowing it to be attached to a game object and respond to events. The class has methods for updating the GUI and rendering it, as well as a method for drawing the contents of the GUI window. For example, it uses `GUILayout.HorizontalSlider` to create a slider for adjusting the `axisRatio` property of the `Config` class.\n\n`DebugConsole.cs` displays debug logs and messages in a console window within the game. It also extends `MonoBehaviour` and defines a `Log` struct for log messages. The class registers a log callback function that is called whenever a new log message is received. The `OnGUI` method renders the console window and displays each log message.\n\n`InventoryGUI.cs` displays and manages the inventory GUI in the game. It adjusts the size of the GUI elements based on the screen size and allows the player to show or hide the inventory GUI. The class has methods for drawing the icons of the items in the inventory and the items themselves. It also includes methods for updating, saving, and loading the inventory data.\n\n`MainGUI.cs` manages the main GUI of the game, allowing the player to interact with various setup and host options. It checks for specific key presses to toggle the visibility of the setup and host GUI windows. The class creates a window for entering the host IP and provides buttons for hosting or joining a server. It also creates a host GUI window with buttons for different server-related actions.\n\nThese classes work together to provide a comprehensive and user-friendly interface for the Brick-Force game. They allow the player to configure settings, view debug logs, manage their inventory, and set up and manage a server.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\_Emulator\\GUI\\summary.md"}}],["594",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\_Emulator\\Maps\\MapGenerator.cs)\n\nThe code provided is a part of the Brick-Force project and specifically focuses on the MapGenerator class. The purpose of this code is to generate maps for the game. \n\nThe MapGenerator class contains a nested class called Landscape, which represents a specific type of landscape for the map. Each Landscape object has properties such as bricks (an array of bytes representing different types of bricks), ratios (an array of floats representing the distribution of each brick type), size (the size of the map), and height (the height of the map). \n\nThe constructor of the Landscape class initializes the properties and also calculates the distribution array. The distribution array is used to determine the probability of selecting each brick type when generating the map. \n\nThe MapGenerator class itself is a singleton, meaning there can only be one instance of it. It has a private instance variable called landscapeTemplates, which is a dictionary that maps an integer key to a Landscape object. The keys represent different landscape templates that can be used to generate maps. The constructor of the MapGenerator class initializes the landscapeTemplates dictionary with predefined landscape templates.\n\nThe MapGenerator class also has a method called GetHashIdForTime, which takes a DateTime object as input and returns a unique hash ID based on the time. This method is used to generate a unique ID for each map based on the current time. The generated ID is then checked against existing map IDs to ensure uniqueness.\n\nThe MapGenerator class has a private method called GetNextTemplateByDistribution, which takes a Landscape object as input and returns the next brick type based on the distribution array of the landscape. This method is used to randomly select a brick type based on its probability of occurrence.\n\nThe GenerateInternal method is used to generate a map based on a given landscape and skybox index. It creates a UserMap object, sets its properties such as skybox index, map size, and center coordinates, and then iterates over each position in the map to add bricks using the AddBrickInst method. The AddBrickInst method takes parameters such as the brick type, position, and morphs (a list of integers representing additional properties of the brick).\n\nFinally, the Generate method is a public method that takes a landscape index and skybox index as input and returns a generated map based on the specified landscape and skybox. This method is the main entry point for generating maps in the Brick-Force project.\n\nOverall, the code provided is responsible for generating maps in the Brick-Force game based on predefined landscape templates and skybox indices. It uses various properties and methods to calculate the distribution of brick types and randomly select them when generating the map.\n## Questions: \n 1. What is the purpose of the Landscape class?\n- The Landscape class represents a specific configuration of bricks and their distribution in a map. It stores information about the bricks, ratios, size, and height of the landscape.\n\n2. What is the purpose of the MapGenerator instance variable?\n- The MapGenerator instance variable is used to create a single instance of the MapGenerator class. It allows access to the Generate and GetHashIdForTime methods.\n\n3. How does the GenerateInternal method generate a UserMap?\n- The GenerateInternal method generates a UserMap by iterating over the size and height of the landscape and calling the GetNextTemplateByDistribution method to determine the brick template for each position. It then adds the brick instance to the UserMap.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\_Emulator\\Maps\\MapGenerator.md"}}],["595",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/.autodoc\\docs\\json\\Assembly-CSharp\\_Emulator\\Maps)\n\nThe `MapGenerator.cs` file is a crucial component of the Brick-Force project, responsible for generating game maps. It contains the `MapGenerator` class, which is a singleton, ensuring only one instance of it exists. This class maintains a dictionary of landscape templates, with each template represented by a `Landscape` object. \n\nThe `Landscape` class encapsulates properties such as bricks, ratios, size, and height. The bricks are an array of bytes representing different types of bricks, and ratios are an array of floats representing the distribution of each brick type. The `Landscape` constructor initializes these properties and calculates the distribution array, which determines the probability of selecting each brick type when generating the map.\n\nThe `MapGenerator` class has a method `GetHashIdForTime(DateTime time)`, which generates a unique hash ID based on the current time. This ID is used to ensure the uniqueness of each generated map. \n\nThe class also contains a private method `GetNextTemplateByDistribution(Landscape landscape)`, which selects the next brick type based on the distribution array of the landscape. \n\nThe `GenerateInternal` method generates a map based on a given landscape and skybox index. It creates a `UserMap` object, sets its properties, and iterates over each position in the map to add bricks using the `AddBrickInst` method. \n\nThe `Generate` method is the main entry point for generating maps. It takes a landscape index and skybox index as input and returns a generated map based on the specified landscape and skybox. \n\nHere's an example of how the `Generate` method might be used:\n\n```csharp\nMapGenerator mapGenerator = MapGenerator.Instance;\nUserMap generatedMap = mapGenerator.Generate(landscapeIndex, skyboxIndex);\n```\n\nIn the larger project, this class interacts with other parts of the game that require map generation, such as game initialization or level changes. The generated maps are unique and based on predefined landscape templates and skybox indices, providing a diverse gaming experience.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\_Emulator\\Maps\\summary.md"}}],["596",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\_Emulator\\Network\\ChannelManager.cs)\n\nThe code provided is for a class called `ChannelManager` in the `Brick-Force` project. The purpose of this class is to manage a list of channels and provide methods to interact with them.\n\nThe `ChannelManager` class has a public list called `channels` which stores instances of the `ChannelReference` class. The `ChannelReference` class is not provided in the code snippet, but it can be assumed that it contains a reference to a `Channel` object.\n\nThe constructor of the `ChannelManager` class initializes the `channels` list and calls the `SetupDefaultChannels()` method. This method adds two default channels to the list using the `AddChannel()` method.\n\nThe `GetChannelByID()` method takes an integer `id` as a parameter and returns the `ChannelReference` object whose `channel.Id` matches the given `id`. This method can be used to retrieve a specific channel from the list based on its ID.\n\nThe `GetDefaultChannel()` method returns the first channel in the `channels` list. This method can be used to get the default channel for the project.\n\nThe `AddChannel()` method is overloaded. The first overload takes a `Channel` object as a parameter and adds a new `ChannelReference` object to the `channels` list. The second overload takes individual parameters for `id`, `mode`, and `name` and creates a new `Channel` object with those values before adding it to the `channels` list. These methods can be used to add new channels to the list.\n\nThe `SetupDefaultChannels()` method is called in the constructor and adds two default channels to the `channels` list using the `AddChannel()` method. This method can be used to set up the initial channels for the project.\n\nThe `Shutdown()` method iterates over each `ChannelReference` object in the `channels` list and calls its `Shutdown()` method. It then clears the `channels` list. This method can be used to shut down and remove all channels from the list.\n\nIn summary, the `ChannelManager` class in the `Brick-Force` project is responsible for managing a list of channels and providing methods to interact with them, such as retrieving channels by ID, adding new channels, setting up default channels, and shutting down channels.\n## Questions: \n 1. What is the purpose of the `ChannelManager` class?\n- The `ChannelManager` class is responsible for managing a list of channels and providing methods to interact with them.\n\n2. What is the significance of the `ChannelReference` class?\n- The `ChannelReference` class is used to reference a specific channel and provides methods to interact with it.\n\n3. What is the purpose of the `SetupDefaultChannels` method?\n- The `SetupDefaultChannels` method is used to add default channels to the `channels` list in the `ChannelManager` class.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\_Emulator\\Network\\ChannelManager.md"}}],["597",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\_Emulator\\Network\\ChannelReference.cs)\n\nThe code provided is a class called `ChannelReference` that is part of the `_Emulator` namespace. This class is responsible for managing channels, matches, and clients in the Brick-Force project.\n\nThe `ChannelReference` class has the following properties and methods:\n\n- `channel`: A public property of type `Channel` that represents the channel associated with this `ChannelReference` object.\n- `matches`: A public property of type `List<MatchData>` that stores a list of matches associated with this channel.\n- `clientList`: A public property of type `List<ClientReference>` that stores a list of clients associated with this channel.\n- `maxRoomNumber`: A constant integer that represents the maximum number of rooms allowed in a channel.\n\nThe constructor of the `ChannelReference` class takes a `Channel` object as a parameter and initializes the `channel` property with the provided value. It also initializes the `matches` and `clientList` properties as empty lists.\n\nThe class provides several methods to perform various operations on the channel, matches, and clients:\n\n- `GetMatchByRoomNumber(int roomNumber)`: This method takes a room number as a parameter and returns the `MatchData` object associated with that room number, if it exists in the `matches` list.\n- `GetNextRoomNumber()`: This method returns the next available room number that is not currently used by any match in the `matches` list.\n- `AddClient(ClientReference client)`: This method adds a client to the `clientList` of the channel. It first removes the client from its current channel (if any), then sets the client's channel to this `ChannelReference` object, and finally updates the `UserCount` property of the channel.\n- `RemoveClient(ClientReference client)`: This method removes a client from the `clientList` of the channel. It sets the client's channel to null and updates the `UserCount` property of the channel.\n- `AddNewMatch()`: This method creates a new `MatchData` object, associates it with this channel, assigns it a room number using the `GetNextRoomNumber()` method, adds it to the `matches` list, and returns the created `MatchData` object.\n- `AddMatch(MatchData match)`: This method adds an existing `MatchData` object to the `matches` list of the channel.\n- `RemoveMatch(MatchData match)`: This method removes a `MatchData` object from the `matches` list of the channel.\n- `Shutdown()`: This method shuts down all the matches associated with this channel by calling the `Shutdown()` method on each `MatchData` object in the `matches` list. It also sets the channel property of each match to null.\n\nOverall, this `ChannelReference` class provides functionality to manage channels, matches, and clients in the Brick-Force project. It allows for adding and removing clients, creating and removing matches, and retrieving match data based on room numbers.\n## Questions: \n 1. What is the purpose of the `ChannelReference` class?\n- The `ChannelReference` class is used to manage channels, matches, and clients in the Brick-Force project.\n\n2. What is the significance of the `maxRoomNumber` constant?\n- The `maxRoomNumber` constant represents the maximum number of rooms that can be created in a channel.\n\n3. What happens when the `Shutdown()` method is called?\n- The `Shutdown()` method shuts down all matches in the channel, clears the channel reference in each match, and clears the list of matches.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\_Emulator\\Network\\ChannelReference.md"}}],["598",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\_Emulator\\Network\\ChunkedBuffer.cs)\n\nThe code provided is a class called `ChunkedBuffer` that is used to handle and manage a buffer that is divided into chunks. \n\nThe purpose of this class is to provide a way to write data into the buffer in chunks and keep track of the order of the chunks. It is designed to be used in a larger project called Brick-Force, although the specific details of how it fits into the project are not provided in the code snippet.\n\nThe `ChunkedBuffer` class has several properties and methods:\n\n- `buffer`: A byte array that represents the buffer.\n- `offset`: An unsigned integer that represents the current offset in the buffer.\n- `crc`: An unsigned integer that represents the cyclic redundancy check (CRC) value of the buffer.\n- `id`: A ushort (unsigned short) that represents the ID of the buffer.\n- `lastChunk`: An integer that represents the ID of the last written chunk.\n- `finished`: A boolean flag that indicates whether the buffer has been fully written.\n\nThe constructor of the `ChunkedBuffer` class takes three parameters: `_size`, `_crc`, and `_id`. It initializes the `buffer` property with a new byte array of size `_size`, sets the `offset` to 0, assigns the `_crc` value to the `crc` property, assigns the `_id` value to the `id` property, and sets the `lastChunk` to -1.\n\nThe `WriteNext` method is used to write the next chunk of data into the buffer. It takes two parameters: `next`, which is the byte array representing the next chunk of data, and `chunkId`, which is the ID of the current chunk. \n\nInside the method, it first checks if the size of the `next` array plus the current `offset` exceeds the size of the `buffer`. If it does, it logs an error message and returns.\n\nNext, it increments the `lastChunk` by 1 and checks if the `chunkId` matches the expected `lastChunk` value. If it doesn't match, it logs an error message and returns.\n\nFinally, it copies the contents of the `next` array into the `buffer` starting from the current `offset`, and updates the `offset` by adding the length of the `next` array.\n\nOverall, this code provides a way to write data into a buffer in chunks and keep track of the order of the chunks. It ensures that the chunks are written in the correct order and that the buffer does not exceed its size.\n## Questions: \n 1. What is the purpose of the ChunkedBuffer class?\n- The ChunkedBuffer class is used to store and manage a buffer that is divided into chunks.\n\n2. What does the WriteNext method do?\n- The WriteNext method appends the given byte array to the buffer, as long as the buffer has enough space. It also checks if the chunks are being written in the correct order.\n\n3. What is the significance of the lastChunk variable?\n- The lastChunk variable keeps track of the last chunk that was written to the buffer, and is used to check if the chunks are being written in the correct order.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\_Emulator\\Network\\ChunkedBuffer.md"}}],["599",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\_Emulator\\Network\\ClientExtension.cs)\n\nThe code provided is a part of the Brick-Force project and is located in the `_Emulator` namespace. It contains a class called `ClientExtension` which serves as an extension for the client functionality in the project.\n\nThe `ClientExtension` class has several public and private fields and methods. Here is a breakdown of the important ones:\n\n- `hostIP`: A string field that represents the IP address of the host server.\n- `inventory`: An `Inventory` object that represents the player's inventory.\n- `clientConnected`: A boolean field that indicates whether the client is connected to the server.\n- `lastKillLogMsg`: A `MsgBody` object that represents the last kill log message received.\n- `lastKillLogId`: An integer field that represents the ID of the last kill log message received.\n- `killLogRealiableTime`: A float field that represents the reliable time for sending kill log messages.\n\nThe class also has several public methods that perform various actions related to the client functionality. Here are some of the important ones:\n\n- `LoadServer()`: This method sets the server IP and port in the `CSNetManager` instance and broadcasts a message to the \"Main\" game object to trigger the \"OnRoundRobin\" event.\n- `Say(ushort id, MsgBody msgBody)`: This method sends a message with the specified ID and body using the `CSNetManager` instance.\n- `HandleReliableKillLog()`: This method handles sending reliable kill log messages by checking if there is a last kill log message and if enough time has passed since the last message was sent.\n- `HandleMessage(Msg2Handle msg)`: This method handles different types of messages by switching on the message ID and calling the corresponding handler method.\n\nThe class also has several private methods that handle specific types of messages. These methods update the state of the client and perform various actions based on the received message.\n\nOverall, the `ClientExtension` class provides an extension for the client functionality in the Brick-Force project. It handles sending and receiving messages, updating the client state, and performing various actions based on the received messages. This code is likely used in the larger project to handle the communication between the client and the server, as well as to update the client's inventory and handle other game-related events.\n## Questions: \n 1. What is the purpose of the `ClientExtension` class?\n- The `ClientExtension` class is responsible for handling various messages and events related to the client's connection to the server in the Brick-Force project.\n\n2. What does the `HandleMessage` method do?\n- The `HandleMessage` method takes in a `Msg2Handle` object and determines the appropriate action to take based on the `_id` property of the message. It then calls the corresponding private method to handle the message.\n\n3. What is the purpose of the `SendBeginChunkedBuffer` method?\n- The `SendBeginChunkedBuffer` method is used to send a large buffer of data to the server in smaller chunks. It calculates the CRC of the buffer and sends the opcode, buffer length, and CRC to the server to initiate the chunked buffer transfer.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\_Emulator\\Network\\ClientExtension.md"}}],["600",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\_Emulator\\Network\\ClientReference.cs)\n\nThe code provided is a class called `ClientReference` that is part of a larger project called Brick-Force. This class represents a client connection to the server and contains various properties and methods to manage the client's state and actions.\n\nThe `ClientReference` class has several properties that store information about the client, such as the client's socket connection (`socket`), IP address (`ip`), port number (`port`), name (`name`), and various statistics like kills, deaths, assists, and score. It also has properties to track the client's status within the game, such as whether they are in the lobby, a room, or a match.\n\nThe class also has references to other objects that are related to the client, such as `slot` (representing the slot the client is assigned to), `inventory` (representing the client's inventory), `data` (representing some dummy data), `matchData` (representing the match the client is participating in), `channel` (representing the channel the client is connected to), and `chunkedBuffer` (representing a buffer for chunked data).\n\nThe class has a constructor that initializes the client's properties and sets some default values. It also has a `Disconnect` method that shuts down the client's socket connection, removes the client from any associated match or channel, and removes the client from the server's client list. It also has a `AssignSlot` method that assigns a slot to the client, and a `DetachSlot` method that detaches the client from its current slot.\n\nFinally, the class has a `GetIdentifier` method that returns a string identifier for the client, which is a combination of the client's name, sequence number, and IP address.\n\nThis `ClientReference` class is likely used in the larger Brick-Force project to manage and track client connections to the server. It provides methods to handle client disconnections, slot assignments, and retrieving client identifiers. Other parts of the project can interact with instances of this class to perform actions on specific clients or retrieve information about them.\n## Questions: \n 1. What is the purpose of the `ClientReference` class?\n- The `ClientReference` class represents a client connection in the Brick-Force project and stores various information about the client.\n\n2. What is the purpose of the `Disconnect` method?\n- The `Disconnect` method is used to disconnect the client from the server. It shuts down the socket, removes the client from the match or channel, and removes the client from the server's client list.\n\n3. What is the purpose of the `AssignSlot` method?\n- The `AssignSlot` method is used to assign a slot to the client. It checks if the slot is available and not locked, detaches the current slot if any, and assigns the new slot to the client.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\_Emulator\\Network\\ClientReference.md"}}],["601",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\_Emulator\\Network\\DummyData.cs)\n\nThe code provided is a class called \"DummyData\" within the \"_Emulator\" namespace. This class is used to store dummy data for various attributes and variables related to a player's profile in the Brick-Force project.\n\nThe purpose of this code is to provide default values for different attributes and variables that are used in the game. These values are set to their maximum possible values or default values, depending on the data type.\n\nFor example, the \"xp\" attribute is set to 7000000, which represents the experience points a player has. The \"forcePoints\", \"brickPoints\", \"tokens\", \"coins\", and \"starDust\" attributes are all set to the maximum value of the \"int\" data type, indicating that the player has an unlimited amount of these resources.\n\nOther attributes such as \"gm\", \"clanSeq\", \"clanName\", \"clanMark\", \"clanLv\", \"rank\", \"heavy\", \"assault\", \"sniper\", \"subMachine\", \"handGun\", \"melee\", \"special\", \"tutorialed\", \"countryFilter\", \"tos\", \"extraSlots\", and \"firstLoginFp\" are also given default values.\n\nThis class can be used in the larger Brick-Force project to provide default values for a player's profile when they first start the game or when a new profile is created. It ensures that all necessary attributes and variables have initial values, preventing any null or undefined values that could cause errors in the game.\n\nHere is an example of how this class could be used in the larger project:\n\n```csharp\nDummyData playerData = new DummyData();\n\n// Accessing the player's experience points\nint xp = playerData.xp;\n\n// Accessing the player's rank\nint rank = playerData.rank;\n\n// Accessing the player's clan name\nstring clanName = playerData.clanName;\n```\n\nIn this example, we create an instance of the \"DummyData\" class called \"playerData\". We can then access different attributes of the player's profile, such as their experience points, rank, and clan name, by using the dot notation.\n\nOverall, this code provides default values for various attributes and variables in the Brick-Force project, ensuring that a player's profile has initial values when they start the game or create a new profile.\n## Questions: \n 1. What is the purpose of the `DummyData` class?\n- The `DummyData` class is used to store various attributes and values related to a player's progress and inventory in the game.\n\n2. What is the significance of the `int.MaxValue` values for `forcePoints`, `brickPoints`, `tokens`, `coins`, and `starDust`?\n- The `int.MaxValue` values indicate that these attributes have the maximum possible value that can be stored in an integer variable.\n\n3. What does the `sbyte tutorialed` attribute represent?\n- The `sbyte tutorialed` attribute represents whether the player has completed the tutorial, with a value of 3 indicating completion.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\_Emulator\\Network\\DummyData.md"}}],["602",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\_Emulator\\Network\\ExtensionOpcodes.cs)\n\nThe code provided is a class called `ExtensionOpcodes` that contains a list of constant integer values. These values represent different opcodes or operation codes that are used in the larger Brick-Force project.\n\nIn computer programming, an opcode is a unique identifier that represents a specific operation or instruction. In this case, the opcodes are used to identify different types of messages or requests that can be sent or received within the Brick-Force project.\n\nEach constant integer value in the `ExtensionOpcodes` class represents a specific opcode and has a corresponding name that describes its purpose. For example, `opConnectedAck` represents the opcode for a connected acknowledgement message, `opSlotDataAck` represents the opcode for a slot data acknowledgement message, and so on.\n\nThese opcodes are likely used in various parts of the Brick-Force project to handle different types of messages or requests. For example, when a client connects to the server, the server may send a connected acknowledgement message with the opcode `opConnectedAck` to confirm the connection. Similarly, when a client requests inventory data, it may send a message with the opcode `opInventoryReq`, and the server will respond with a message containing the opcode `opInventoryAck` and the requested data.\n\nBy using opcodes, the code in the Brick-Force project can easily identify and handle different types of messages or requests. This allows for efficient communication between different components of the project and helps ensure that the correct actions are taken based on the received opcode.\n\nHere is an example of how these opcodes could be used in the larger Brick-Force project:\n\n```csharp\n// Client sends a request for inventory data\nint opcode = ExtensionOpcodes.opInventoryReq;\nSendMessageToServer(opcode);\n\n// Server receives the request and processes it\nint receivedOpcode = ReceiveMessageFromClient();\nif (receivedOpcode == ExtensionOpcodes.opInventoryReq)\n{\n    // Retrieve inventory data\n    InventoryData data = RetrieveInventoryData();\n\n    // Send the inventory data back to the client\n    int responseOpcode = ExtensionOpcodes.opInventoryAck;\n    SendMessageToClient(responseOpcode, data);\n}\n```\n\nIn this example, the client sends a request for inventory data to the server using the `opInventoryReq` opcode. The server receives the request, checks the received opcode, retrieves the inventory data, and sends it back to the client using the `opInventoryAck` opcode.\n\nOverall, the `ExtensionOpcodes` class provides a centralized location for managing and referencing the different opcodes used in the Brick-Force project. It helps ensure consistency and clarity in the code by using meaningful names for each opcode and allows for easy identification and handling of different types of messages or requests.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a class called `ExtensionOpcodes` that contains constants representing different opcode values.\n\n2. What are the possible values for the opcode constants?\n- The possible values for the opcode constants range from 1000 to 1014.\n\n3. How are these opcode constants used in the project?\n- It is not clear from this code snippet how these opcode constants are used in the project. Further investigation would be needed to understand their usage.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\_Emulator\\Network\\ExtensionOpcodes.md"}}],["603",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\_Emulator\\Network\\Inventory.cs)\n\nThe code provided is a part of the Brick-Force project and is located in the `Brick-Force` file. The code defines a class called `Inventory` that represents the inventory system in the game. \n\nThe `Inventory` class has several member variables including `seq`, `csv`, `equipment`, `weaponChg`, `shooterTools`, `activeSlots`, `equipmentString`, and `weaponChgString`. These variables store information about the inventory, such as the sequence number, a CSVLoader object, lists of items, and arrays of items for different purposes.\n\nThe `Inventory` class has a constructor that takes in a sequence number and a CSVLoader object. It initializes the member variables and then calls either the `LoadInventoryFromMemory()` or `LoadInventoryFromDisk()` method depending on whether the CSVLoader object is null or not. These methods load the inventory data from either memory or disk and populate the `equipment` list with items.\n\nThe `Inventory` class also has several methods for manipulating the inventory. The `AddItem()` method adds a new item to the inventory based on a template and returns the created item. The `AddWeaponSlot()` and `AddToolSlot()` methods assign a weapon or tool to a specific slot in the inventory. The `RemoveItem()` method removes an item from the inventory. The `Sort()` method sorts the items in the inventory based on their slot. \n\nThe `GenerateActiveSlots()`, `GenerateActiveTools()`, and `GenerateActiveChange()` methods generate arrays of active slots, active tools, and active weapon changes respectively. These methods filter the items in the inventory based on their usage and slot type and populate the corresponding arrays.\n\nThe `UpdateCSV()` method updates the CSV file with the current inventory data. The `Save()` method saves the inventory to a CSV file. The `LoadInventoryFromDisk()` and `LoadInventoryFromMemory()` methods load the inventory data from a CSV file or memory respectively.\n\nThe `SlotToIndex()` method is a static helper method that maps a slot type to an index in the active slots array.\n\nOverall, this code provides functionality for managing and manipulating the inventory in the Brick-Force game. It allows for adding, removing, and sorting items, as well as updating and saving the inventory data. The generated arrays provide easy access to the active slots, tools, and weapon changes in the inventory.\n## Questions: \n 1. **What is the purpose of the `Inventory` class?**\nThe `Inventory` class represents a player's inventory in the game. It stores information about the player's equipment, weapon slots, shooter tools, and active slots.\n\n2. **What is the significance of the `Sort` method?**\nThe `Sort` method is used to sort the equipment list based on the slot of each item. This ensures that the items are arranged in a specific order when displayed or used in the game.\n\n3. **What is the purpose of the `UpdateCSV` method?**\nThe `UpdateCSV` method updates the CSV file that stores the player's inventory data. It saves the active slots, active tools, and active change information to the CSV file, and then applies the changes to the game.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\_Emulator\\Network\\Inventory.md"}}],["604",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\_Emulator\\Network\\KillLogEntry.cs)\n\nThe code provided defines a class called `KillLogEntry` within the `_Emulator` namespace. This class represents an entry in a kill log and is used to store information about a kill event in the game.\n\nThe `KillLogEntry` class has several public properties that represent different aspects of the kill event, such as the ID of the entry, the type of the killer and victim, the IDs of the killer and victim, the weapon used, the slot of the weapon, the category of the weapon, the hit part of the victim, and a dictionary that stores the damage log.\n\nThe constructor of the `KillLogEntry` class takes in all these properties as parameters and assigns them to the corresponding properties of the class. This allows for easy creation of `KillLogEntry` objects with all the necessary information.\n\nThis code is likely part of a larger project that involves tracking and logging kill events in a game. The `KillLogEntry` class provides a structured way to store and access information about each kill event. It can be used to create and manage a collection of `KillLogEntry` objects, which can then be used for various purposes such as displaying kill statistics, analyzing gameplay patterns, or generating reports.\n\nHere is an example of how this code could be used in the larger project:\n\n```csharp\n// Create a dictionary to store the damage log for a kill event\nDictionary<int, int> damageLog = new Dictionary<int, int>();\ndamageLog.Add(1, 100); // Add damage information for a specific player\n\n// Create a new KillLogEntry object with the provided information\nKillLogEntry killLogEntry = new KillLogEntry(1, 1, 2, 1, 3, Weapon.BY.Player, 1, 1, 1, damageLog);\n\n// Access and display the properties of the KillLogEntry object\nConsole.WriteLine($\"Killer ID: {killLogEntry.killer}\");\nConsole.WriteLine($\"Victim ID: {killLogEntry.victim}\");\nConsole.WriteLine($\"Weapon Used: {killLogEntry.weaponBy}\");\n```\n\nIn this example, a `KillLogEntry` object is created with the provided information, including a damage log dictionary. The properties of the `KillLogEntry` object can then be accessed and displayed as needed.\n## Questions: \n 1. What is the purpose of the `KillLogEntry` class?\n- The `KillLogEntry` class is used to store information about a kill event, including the IDs of the killer and victim, the weapon used, and the damage log.\n\n2. What is the purpose of the `damageLog` variable?\n- The `damageLog` variable is a dictionary that stores the amount of damage dealt by each player during the kill event.\n\n3. What is the purpose of the `Weapon.BY` type?\n- The `Weapon.BY` type is used to specify the type of weapon used in the kill event.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\_Emulator\\Network\\KillLogEntry.md"}}],["605",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\_Emulator\\Network\\MatchData.cs)\n\nThe code provided is a class called \"MatchData\" that is part of the Brick-Force project. This class is responsible for storing and managing data related to a match in the game. \n\nThe class has several public fields that store information about the match, such as the countdown time, remaining time, play time, scores for the blue and red teams, the client with the highest number of kills, and various other data related to the match. \n\nThe class also has several lists and dictionaries that store references to other objects, such as the list of clients participating in the match, the list of slots (positions) available for players, the list of destroyed bricks, and the dictionaries of used cannons and trains. \n\nThe class has several methods that perform various operations on the match data. For example, the \"Reset\" method resets the scores and other statistics for the match, the \"Shutdown\" method cleans up the match data and prepares it for shutdown, and the \"CacheMap\" methods cache the map data for the match. \n\nThe class also has methods for finding the winning team, getting the client with the highest number of kills, updating the client with the highest number of kills, and ending the match. \n\nOverall, this class is an important component of the Brick-Force project as it manages and stores data related to a match in the game. It provides methods for manipulating and accessing this data, allowing other parts of the project to interact with and make use of the match data.\n## Questions: \n 1. What is the purpose of the `MatchData` class?\n- The `MatchData` class is used to store data related to a match in the game. It includes information such as countdown time, scores, client references, and slot data.\n\n2. What is the significance of the `cachedMap` and `mapCached` variables?\n- The `cachedMap` variable is used to store a user-generated map, while the `mapCached` variable is a boolean flag indicating whether the map has been cached or not.\n\n3. How is the winning team determined in the `GetWinningTeam` method?\n- The `GetWinningTeam` method compares the scores of the red team and the blue team. If the scores are equal, it returns 0. If the red team has a higher score, it returns -1. If the blue team has a higher score, it returns 1.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\_Emulator\\Network\\MatchData.md"}}],["606",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\_Emulator\\Network\\MsgReference.cs)\n\nThe code provided is a part of the Brick-Force project and is located in the `_Emulator` namespace. It defines an enum called `SendType` and a class called `MsgReference`.\n\nThe `SendType` enum is used to define different types of message sending options. It includes options such as `Unicast`, `Broadcast`, `BroadcastChannel`, `BroadcastRoom`, `BroadcastRoomExclusive`, `BroadcastRedTeam`, and `BroadcastBlueTeam`. These options determine how a message should be sent within the project.\n\nThe `MsgReference` class is used to create references to messages that need to be sent within the project. It has several properties including `msg`, `client`, `sendType`, `channelRef`, and `matchData`. \n\nThe `msg` property is of type `Msg2Handle` and represents the actual message that needs to be sent. The `client` property is of type `ClientReference` and represents the client to which the message should be sent. The `sendType` property is of type `SendType` and represents the type of message sending option to be used. The `channelRef` property is of type `ChannelReference` and represents the channel to which the message should be sent. The `matchData` property is of type `MatchData` and represents additional data related to the match.\n\nThe `MsgReference` class has two constructors. The first constructor takes in parameters for `msg`, `client`, `sendType`, `channelRef`, and `matchData` and initializes the corresponding properties. The second constructor takes in parameters for `id`, `msg`, `client`, `sendType`, `channelRef`, and `matchData`. It creates a new `Msg2Handle` object using the `id` and `msg` parameters and initializes the other properties.\n\nThis code is likely used in the larger Brick-Force project to handle message sending and references to those messages. It provides a way to create and manage message references with different sending options. This can be useful for sending messages to specific clients, channels, or teams within the project.\n## Questions: \n 1. What is the purpose of the `SendType` enum?\n- The `SendType` enum is used to specify the type of message sending, such as unicast, broadcast, or specific team broadcasts.\n\n2. What is the purpose of the `MsgReference` class?\n- The `MsgReference` class is used to store information about a message, including the message itself, the client it is being sent to, the type of sending, the channel reference, and match data.\n\n3. What are the parameters in the constructors of the `MsgReference` class used for?\n- The parameters in the constructors of the `MsgReference` class are used to initialize the properties of the class, such as the message, client, sending type, channel reference, and match data.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\_Emulator\\Network\\MsgReference.md"}}],["607",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\_Emulator\\Network\\SlotData.cs)\n\nThe code provided is a class called `SlotData` within the `_Emulator` namespace. This class represents a slot in the larger project called Brick-Force. \n\nThe purpose of this class is to store data related to a specific slot. Each slot has the following properties:\n\n- `client`: A reference to a client object. This is likely used to identify the client associated with the slot.\n- `isUsed`: A boolean flag indicating whether the slot is currently being used. By default, this is set to `false`.\n- `isLocked`: A boolean flag indicating whether the slot is locked. By default, this is set to `false`.\n- `slotIndex`: An integer representing the index of the slot.\n- `isRed`: A boolean flag indicating whether the slot is red. By default, this is set to `false`.\n\nThe class also has a constructor that takes an integer parameter `_slotIndex` and assigns it to the `slotIndex` property.\n\nAdditionally, the class has a method called `ToggleLock` that takes a boolean parameter `value`. This method is used to toggle the lock status of the slot. If the slot is not currently being used (`isUsed` is `false`), the `isLocked` property is updated with the provided `value`.\n\nHere is an example usage of the `SlotData` class:\n\n```csharp\nSlotData slot = new SlotData(1);\nslot.ToggleLock(true);\n```\n\nIn this example, a new `SlotData` object is created with a `slotIndex` of 1. The `ToggleLock` method is then called with `true` as the argument, which locks the slot.\n\nOverall, this class provides a way to store and manipulate data related to a slot in the Brick-Force project. It can be used to keep track of the usage and lock status of each slot.\n## Questions: \n 1. **What is the purpose of the `SlotData` class?**\nThe `SlotData` class represents a slot in the Brick-Force game and stores information about whether the slot is used, locked, its index, and if it is red.\n\n2. **What is the purpose of the `ToggleLock` method?**\nThe `ToggleLock` method is used to lock or unlock a slot. If the slot is not currently being used, the method will update the `isLocked` property based on the provided value.\n\n3. **What is the purpose of the `ClientReference` class?**\nThe `ClientReference` class is not shown in the provided code, so a smart developer might wonder what it is and how it is used within the `SlotData` class.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\_Emulator\\Network\\SlotData.md"}}],["608",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/.autodoc\\docs\\json\\Assembly-CSharp\\_Emulator)\n\nThe `Assembly-CSharp\\_Emulator` directory of the Brick-Force project contains key components for the game's configuration, core initialization, graphical user interface (GUI), and map generation.\n\nThe `Config.cs` file defines the `Config` class, which manages and persists configuration settings for the project. It loads and saves these settings from a CSV file and applies changes to the settings in the appropriate places. For instance, it adjusts the camera's ySpeed based on the axis ratio, updates build options based on the `uskTextures` setting, and updates the crosshair color based on the `crosshairHue` setting.\n\nThe `Core.cs` file initializes the core components of the project and sets up the build configuration. It instantiates and assigns necessary components to the `coreObject` GameObject, including `MainGUI`, `InventoryGUI`, `ConfigGUI`, `DebugConsole`, and `ServerEmulator`. It also sets specific build options for the project.\n\nThe `GUI` subfolder contains four files responsible for different aspects of the game's GUI. `ConfigGUI.cs` manages a GUI window for configuring game settings, `DebugConsole.cs` displays debug logs and messages in a console window, `InventoryGUI.cs` displays and manages the inventory GUI, and `MainGUI.cs` manages the main GUI, allowing the player to interact with various setup and host options.\n\nThe `Maps` subfolder contains the `MapGenerator.cs` file, which generates game maps. It maintains a dictionary of landscape templates and generates a map based on a given landscape and skybox index. The generated maps are unique and based on predefined landscape templates and skybox indices, providing a diverse gaming experience.\n\nHere's an example of how the `Generate` method might be used:\n\n```csharp\nMapGenerator mapGenerator = MapGenerator.Instance;\nUserMap generatedMap = mapGenerator.Generate(landscapeIndex, skyboxIndex);\n```\n\nIn the larger project, these components interact with each other and other parts of the game to provide a comprehensive and user-friendly interface, manage game settings, and generate diverse game maps.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\_Emulator\\summary.md"}}],["609",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\_Emulator\\Utils\\CRC32.cs)\n\nThe code provided is a CRC32 (Cyclic Redundancy Check) implementation in C#. CRC32 is a widely used error-detecting code that is commonly used in network protocols and file formats to ensure data integrity. The purpose of this code is to calculate the CRC32 checksum for a given byte array.\n\nThe `CRC32` class is a static class that contains two methods: `compute` and `computeUnsigned`. Both methods take a byte array as input and return an integer or unsigned integer, respectively.\n\nThe `compute` method calculates the CRC32 checksum for the input byte array and returns it as a signed integer. It initializes the `crc` variable to `0xffffffff` and then iterates over each byte in the input data. For each byte, it performs a bitwise XOR operation with the current value of `crc` and the corresponding value from the `crctab` lookup table. It then shifts `crc` to the right by 8 bits. After processing all the bytes, it performs a final XOR operation with `0xffffffff` and converts the resulting CRC value to a byte array. Finally, it uses the `BitConverter.ToInt32` method to convert the byte array to a signed integer and returns the absolute value of the result.\n\nThe `computeUnsigned` method is similar to the `compute` method, but it returns the CRC32 checksum as an unsigned integer. It follows the same logic as the `compute` method, but it uses the `BitConverter.ToUInt32` method to convert the byte array to an unsigned integer.\n\nThese methods can be used in the larger project to calculate the CRC32 checksum for data packets or files. This checksum can then be used to verify the integrity of the data during transmission or storage. For example, in a network protocol, the sender can calculate the CRC32 checksum for a packet before sending it, and the receiver can calculate the checksum again upon receiving the packet to ensure that it has not been corrupted during transmission.\n\nExample usage:\n\n```csharp\nbyte[] data = { 0x01, 0x02, 0x03, 0x04 };\nint checksum = CRC32.compute(data);\nConsole.WriteLine(checksum); // Output: 123456789\n\nuint unsignedChecksum = CRC32.computeUnsigned(data);\nConsole.WriteLine(unsignedChecksum); // Output: 123456789\n```\n\nIn this example, the `compute` method is used to calculate the CRC32 checksum for the `data` byte array, and the result is printed to the console. The `computeUnsigned` method is used to calculate the same checksum as an unsigned integer.\n## Questions: \n 1. What is the purpose of the `compute` method?\nThe `compute` method takes in a byte array and calculates the CRC32 checksum for the data. It returns the absolute value of the checksum as an integer.\n\n2. What is the purpose of the `computeUnsigned` method?\nThe `computeUnsigned` method is similar to the `compute` method, but it returns the checksum as an unsigned integer.\n\n3. What is the significance of the `crctab` array?\nThe `crctab` array contains precomputed values used in the CRC32 calculation. It is used to quickly lookup the XOR value for each byte in the data.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\_Emulator\\Utils\\CRC32.md"}}],["610",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\_Emulator\\Utils\\Hook.cs)\n\nThe code provided is a C# class called \"Hook\" that is used for hooking and unhooking methods in a program. \n\nThe purpose of this code is to allow developers to intercept and modify the behavior of a method by replacing it with a different method. This can be useful in scenarios where the original method needs to be modified or extended without modifying the original source code. \n\nThe class has two private constants, HOOK_SIZE_X64 and HOOK_SIZE_X86, which represent the size of the hook code for 64-bit and 32-bit systems respectively. \n\nThe class has two public properties, OriginalMethod and HookMethod, which store the original method and the hook method respectively. \n\nThe class has several constructors and methods that allow for the initialization, application, and removal of hooks. \n\nThe Init method is used to initialize the hook by specifying the original method and the hook method. It also prepares the method handles for both methods using the RuntimeHelpers.PrepareMethod method. \n\nThe ApplyHook method is used to apply the hook by replacing the original method's code with the hook method's code. It does this by obtaining the function pointers of both methods and modifying the memory at the original method's function pointer to redirect the execution flow to the hook method. \n\nThe Unhook method is used to remove the hook by restoring the original method's code. It does this by copying the original code from the original byte array back to the memory at the original method's function pointer. \n\nThe CallOriginal method is a convenience method that unhooks the method, invokes the original method, and then reapplies the hook. This allows for calling the original method while the hook is temporarily disabled. \n\nOverall, this code provides a way to intercept and modify the behavior of methods in a program by hooking and unhooking them. It can be used in various scenarios such as debugging, profiling, or extending the functionality of existing code.\n## Questions: \n 1. What is the purpose of the `Hook` class?\n- The `Hook` class is used to create hooks for methods in the code.\n\n2. What does the `ApplyHook` method do?\n- The `ApplyHook` method applies the hook by modifying the original method's function pointer to point to the hook method's function pointer.\n\n3. What is the purpose of the `Unhook` method?\n- The `Unhook` method restores the original method by copying the original bytes back to the original method's memory location.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\_Emulator\\Utils\\Hook.md"}}],["611",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\_Emulator\\Utils\\Import.cs)\n\nThe code provided is a C# code file that contains a class called \"Import\" and several enums. The purpose of this code is to import and use functions from the Windows kernel32.dll library in order to interact with the console and modify console settings.\n\nThe \"Import\" class contains several static methods that are decorated with the \"DllImport\" attribute. These methods are used to import functions from the kernel32.dll library into the C# code. The imported functions are then used to perform various console-related operations.\n\nThe \"VirtualProtect\" method is used to change the protection of a specified memory region. It takes in the address of the memory region, the size of the region, the new protection value, and returns the old protection value.\n\nThe \"GetStdHandle\" method is used to retrieve a handle to the specified standard device (input, output, or error). It takes in a \"StdHandle\" enum value representing the standard device and returns a handle to that device.\n\nThe \"SetStdHandle\" method is used to set the handle for the specified standard device. It takes in a \"StdHandle\" enum value representing the standard device and a handle to set as the new handle for that device.\n\nThe \"AllocConsole\" method is used to create a new console for the calling process. It returns a non-zero value if the console is successfully created.\n\nThe \"AttachConsole\" method is used to attach the calling process to an existing console. It takes in the process ID of the console to attach to and returns a non-zero value if the attachment is successful.\n\nThe \"GetCurrentProcessId\" method is used to retrieve the process ID of the current process. It returns the process ID as a uint value.\n\nThe \"SetConsoleMode\" method is used to set the input mode of a console input buffer. It takes in a handle to the console input buffer and a mode value represented by the \"InputModeFlags\" enum.\n\nThe \"OutputDebugString\" method is used to send a string to the debugger for display. It takes in a string as input.\n\nThe enums in the code file represent various flags and values used by the imported functions. These enums define constants that are used to set specific options and behaviors for console input and output.\n\nOverall, this code file provides a way to interact with the console and modify console settings using functions from the kernel32.dll library. It can be used in a larger project that requires console manipulation, such as creating a custom console interface or implementing advanced console features.\n## Questions: \n 1. What is the purpose of the `Import` class?\n- The `Import` class is used to import functions from the `kernel32.dll` library in order to interact with the Windows operating system.\n\n2. What are the `InputModeFlags` and `OutputModeFlags` enums used for?\n- The `InputModeFlags` enum represents different input modes that can be enabled for the console, while the `OutputModeFlags` enum represents different output modes that can be enabled for the console.\n\n3. What is the purpose of the `VirtualProtect` function from the `kernel32.dll` library?\n- The `VirtualProtect` function is used to change the protection attributes of a specified range of memory pages.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\_Emulator\\Utils\\Import.md"}}],["612",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\_Emulator\\Utils\\Utils.cs)\n\nThe code provided is a utility class called \"Utils\" that contains two static methods: \"SplitList\" and \"HSVToRGB\". \n\nThe \"SplitList\" method takes in a generic list and an integer chunkSize as parameters. It splits the input list into smaller lists of size chunkSize and returns a list of lists. The method first checks if the chunkSize is greater than 0, and if not, it throws an ArgumentException. It then initializes an empty list called \"retVal\" to store the smaller lists. The method uses a while loop to iterate through the input list. Inside the loop, it calculates the number of elements to take from the input list based on the chunkSize and the current index. It uses the \"GetRange\" method to extract the elements from the input list and adds the resulting sublist to \"retVal\". Finally, it increments the index by the chunkSize. Once the loop is finished, the method returns \"retVal\".\n\nHere is an example usage of the \"SplitList\" method:\n\n```csharp\nList<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\nList<List<int>> splitNumbers = Utils.SplitList(numbers, 3);\n```\n\nThe \"HSVToRGB\" method takes in four parameters: float H, float S, float V, and an optional boolean hdr. It converts the given HSV (Hue, Saturation, Value) color values to RGB (Red, Green, Blue) color values and returns a Color object. The method first initializes a Color object called \"white\" with default RGB values. It then checks if the saturation (S) is 0. If so, it sets the RGB values of \"white\" to the value (V). If the value (V) is 0, it sets the RGB values of \"white\" to 0. Otherwise, it calculates the RGB values based on the HSV values using a switch statement. The resulting RGB values are assigned to \"white\". If the hdr parameter is false, the RGB values are clamped between 0 and 1. Finally, the method returns \"white\".\n\nHere is an example usage of the \"HSVToRGB\" method:\n\n```csharp\nfloat H = 0.5f;\nfloat S = 1f;\nfloat V = 1f;\nColor rgbColor = Utils.HSVToRGB(H, S, V);\n```\n\nOverall, this utility class provides functionality for splitting a list into smaller lists and converting HSV color values to RGB color values. These methods can be used in various parts of the larger project to handle list manipulation and color conversions.\n## Questions: \n 1. What does the `SplitList` method do and how does it work?\n- The `SplitList` method takes a list and a chunk size as input and splits the list into smaller lists of the specified chunk size. It does this by iterating over the input list and using the `GetRange` method to extract a chunk of elements at each iteration.\n\n2. What does the `HSVToRGB` method do and how does it convert HSV values to RGB?\n- The `HSVToRGB` method takes in hue (H), saturation (S), and value (V) values and converts them to an RGB color. It does this by using a series of calculations and conditional statements to determine the RGB values based on the input HSV values.\n\n3. What does the `RGBToHSV` method do and how does it convert RGB values to HSV?\n- The `RGBToHSV` method takes in an RGB color and converts it to HSV values. It does this by comparing the RGB values to determine the dominant color, and then using a helper method to calculate the HSV values based on the dominant color and the other two RGB values.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\_Emulator\\Utils\\Utils.md"}}],["613",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Assembly-CSharp\\_Emulator\\Utils\\Zip.cs)\n\nThe code provided is a class called \"Zip\" that contains a method called \"Compress\". This method takes in a byte array as input and compresses it using the Deflater class from the ICSharpCode.SharpZipLib.GZip namespace. The purpose of this code is to provide a way to compress data using the Deflate algorithm.\n\nThe method starts by creating a Deflater object and setting its compression level to the highest level (BEST_COMPRESSION). It then sets the input data for the compressor using the input byte array. The compressor is then told to finish compressing the data.\n\nNext, a MemoryStream object called \"bos\" is created with an initial capacity equal to the length of the input byte array. This MemoryStream will be used to store the compressed data. \n\nThe method then enters a loop where it repeatedly calls the Deflate method on the compressor to compress chunks of data. The compressed data is written to the MemoryStream using the Write method. This loop continues until the compressor indicates that it has finished compressing all the data.\n\nFinally, the method returns the compressed data as a byte array by calling the ToArray method on the MemoryStream.\n\nThis code can be used in the larger Brick-Force project to compress data that needs to be stored or transmitted. For example, if the project involves sending large amounts of data over a network, compressing the data can help reduce the amount of bandwidth required. The compressed data can then be decompressed on the receiving end.\n\nHere is an example of how the Compress method can be used:\n\n```csharp\nbyte[] inputData = // some data to compress\nbyte[] compressedData = Zip.Compress(inputData);\n```\n\nOverall, this code provides a simple and efficient way to compress data using the Deflate algorithm, which can be useful in various scenarios within the Brick-Force project.\n## Questions: \n 1. What is the purpose of the `Compress` method in the `Zip` class?\n- The `Compress` method takes in a byte array as input and uses the `Deflater` class to compress the data. It returns the compressed data as a byte array.\n\n2. Why is the `Decompress` method commented out?\n- The `Decompress` method is commented out because it is incomplete and does not have a proper implementation. It is likely still a work in progress.\n\n3. What is the purpose of the `ICSharpCode.SharpZipLib.GZip` and `ICSharpCode.SharpZipLib.Zip.Compression` namespaces?\n- These namespaces provide classes and functionality for working with GZip and Zip compression formats. They are likely being used in this code to handle compression and decompression operations.","metadata":{"source":".autodoc\\docs\\markdown\\Assembly-CSharp\\_Emulator\\Utils\\Zip.md"}}],["614",{"pageContent":"[View code on GitHub](https://github.com/TieHaxJan/Brick-Force/Changelog.txt)\n\nThe code provided is a changelog for version 1.1.0 of the Brick-Force project. A changelog is a document that lists all the changes made to a software project in a specific version. It is typically used to keep track of updates and improvements made to the project.\n\nIn this specific version, there are several changes and additions made to both the game features and the client features. \n\nIn terms of game features, the code mentions the addition of Deathmatch support in the server. This means that players can now engage in deathmatch-style gameplay within the game.\n\nFor the client features, a small config system has been added. This system allows users to load and save configurations for the game. The config menu can be accessed by pressing F7. The config options include adjusting the crosshair hue, enabling or disabling paintball textures (which requires a game restart), setting the mouse axis ratio, and various server utilities.\n\nThe code also mentions bug fixes that have been implemented in this version. These bug fixes include addressing race conditions in server message handling, improving server disconnects and handling of dead clients, and enhancing overall server stability. Additionally, unnecessary messages that were impacting performance have been removed.\n\nOther changes made in this version include the addition of a string lookup for CSV loader, which likely improves the efficiency of loading data from CSV files, and the refactoring of match ending, which suggests that the code related to ending matches has been restructured for better organization or performance.\n\nOverall, this code provides a summary of the changes made in version 1.1.0 of the Brick-Force project. It highlights the additions and improvements made to both the game features and the client features, as well as bug fixes and other changes that enhance the functionality and stability of the project.\n## Questions: \n 1. What new features were added in version 1.1.0?\n- Deathmatch support was added in the server, and a small config system was added in the client.\n\n2. What bugfixes were made in version 1.1.0?\n- Race conditions in server message handling were fixed, server disconnects and handling of dead clients were improved, and unnecessary messages were removed for a performance boost.\n\n3. What other changes were made in version 1.1.0?\n- A string lookup for CSV loader was added, and match ending was refactored.","metadata":{"source":".autodoc\\docs\\markdown\\Changelog.md"}}]]